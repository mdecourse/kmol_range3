<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20201108101132.2"><vh>import cpp files</vh></v>
<v t="leo.20201108102637.1"><vh>KMOLab Range3 Study Note</vh></v>
<v t="leo.20201108101517.1"><vh>imported files</vh>
<v t="leo.20201108101517.2"><vh>@path ./</vh>
<v t="leo.20201108101517.3"><vh>@path Range</vh>
<v t="leo.20201108101517.10"><vh>@path src</vh>
<v t="leo.20201108101517.11"><vh>@clean action.cpp</vh>
<v t="leo.20201108101517.12"><vh>void Action::enable (action.cpp)</vh></v>
<v t="leo.20201108101517.13"><vh>void Action::disable (action.cpp)</vh></v>
<v t="leo.20201108101517.14"><vh>void Action::onSessionNew (action.cpp)</vh>
<v t="leo.20201108101517.15"><vh>int response (action.cpp)</vh></v>
</v>
<v t="leo.20201108101517.16"><vh>void Action::onSessionOpen (action.cpp)</vh></v>
<v t="leo.20201108101517.17"><vh>void Action::onSessionSave (action.cpp)</vh></v>
<v t="leo.20201108101517.18"><vh>void Action::onSessionSaveAs (action.cpp)</vh></v>
<v t="leo.20201108101517.19"><vh>void Action::onSessionClose (action.cpp)</vh>
<v t="leo.20201108101517.20"><vh>int response (action.cpp)</vh></v>
</v>
<v t="leo.20201108101517.21"><vh>void Action::onModelNew (action.cpp)</vh></v>
<v t="leo.20201108101517.22"><vh>void Action::onModelOpen (action.cpp)</vh></v>
<v t="leo.20201108101517.23"><vh>void Action::onModelSave (action.cpp)</vh></v>
<v t="leo.20201108101517.24"><vh>void Action::onModelSaveAs (action.cpp)</vh></v>
<v t="leo.20201108101517.25"><vh>void Action::onModelExportMsh (action.cpp)</vh></v>
<v t="leo.20201108101517.26"><vh>void Action::onModelExportRaw (action.cpp)</vh></v>
<v t="leo.20201108101517.27"><vh>void Action::onModelExportStlAscii (action.cpp)</vh></v>
<v t="leo.20201108101517.28"><vh>void Action::onModelExportStlBinary (action.cpp)</vh></v>
<v t="leo.20201108101517.29"><vh>void Action::onModelClose (action.cpp)</vh>
<v t="leo.20201108101517.30"><vh>int response (action.cpp)</vh></v>
</v>
<v t="leo.20201108101517.31"><vh>void Action::onModelReloadResults (action.cpp)</vh></v>
<v t="leo.20201108101517.32"><vh>void Action::onModelRename (action.cpp)</vh></v>
<v t="leo.20201108101517.33"><vh>void Action::onModelDropResults (action.cpp)</vh></v>
<v t="leo.20201108101517.34"><vh>void Action::onMaterialNew (action.cpp)</vh></v>
<v t="leo.20201108101517.35"><vh>void Action::onMaterialImport (action.cpp)</vh>
<v t="leo.20201108101517.36"><vh>int response (action.cpp)</vh></v>
</v>
<v t="leo.20201108101517.37"><vh>void Action::onMaterialDelete (action.cpp)</vh>
<v t="leo.20201108101517.38"><vh>int response (action.cpp)</vh></v>
</v>
<v t="leo.20201108101517.39"><vh>void Action::onGeometryUndo (action.cpp)</vh></v>
<v t="leo.20201108101517.40"><vh>void Action::onGeometryRedo (action.cpp)</vh></v>
<v t="leo.20201108101517.41"><vh>void Action::onGeometryDrawPoint (action.cpp)</vh></v>
<v t="leo.20201108101517.42"><vh>void Action::onGeometryDrawLine (action.cpp)</vh></v>
<v t="leo.20201108101517.43"><vh>void Action::onGeometryDrawTriangle (action.cpp)</vh></v>
<v t="leo.20201108101517.44"><vh>void Action::onGeometryDrawQuadrilateral (action.cpp)</vh></v>
<v t="leo.20201108101517.45"><vh>void Action::onGeometryDrawCircle (action.cpp)</vh></v>
<v t="leo.20201108101517.46"><vh>void Action::onGeometryDrawEllipse (action.cpp)</vh></v>
<v t="leo.20201108101517.47"><vh>void Action::onGeometryDrawTetrahedron (action.cpp)</vh></v>
<v t="leo.20201108101517.48"><vh>void Action::onGeometryDrawHexahedron (action.cpp)</vh></v>
<v t="leo.20201108101517.49"><vh>void Action::onGeometryDrawCylinder (action.cpp)</vh></v>
<v t="leo.20201108101517.50"><vh>void Action::onGeometryDrawSphere (action.cpp)</vh></v>
<v t="leo.20201108101517.51"><vh>void Action::onGeometryDrawRaw (action.cpp)</vh></v>
<v t="leo.20201108101517.52"><vh>void Action::onGeometryCreateElement (action.cpp)</vh></v>
<v t="leo.20201108101517.53"><vh>void Action::onGeometryFindSliverElements (action.cpp)</vh></v>
<v t="leo.20201108101517.54"><vh>void Action::onGeometryFixSliverElements (action.cpp)</vh></v>
<v t="leo.20201108101517.55"><vh>void Action::onGeometryFindIntersectedElements (action.cpp)</vh></v>
<v t="leo.20201108101517.56"><vh>void Action::onGeometryBreakIntersectedElements (action.cpp)</vh></v>
<v t="leo.20201108101517.57"><vh>void Action::onGeometryBoolUnion (action.cpp)</vh></v>
<v t="leo.20201108101517.58"><vh>void Action::onGeometryBoolDifference (action.cpp)</vh></v>
<v t="leo.20201108101517.59"><vh>void Action::onGeometryBoolIntersection (action.cpp)</vh></v>
<v t="leo.20201108101517.60"><vh>void Action::onGeometryMergeNearNodes (action.cpp)</vh></v>
<v t="leo.20201108101517.61"><vh>void Action::onGeometryMoveNode (action.cpp)</vh></v>
<v t="leo.20201108101517.62"><vh>void Action::onGeometryRemoveNode (action.cpp)</vh></v>
<v t="leo.20201108101517.63"><vh>void Action::onGeometryRemoveNodeAndCloseHole (action.cpp)</vh></v>
<v t="leo.20201108101517.64"><vh>void Action::onGeometryRemoveElement (action.cpp)</vh></v>
<v t="leo.20201108101517.65"><vh>void Action::onGeometryLineGenerateFromEdges (action.cpp)</vh></v>
<v t="leo.20201108101517.66"><vh>void Action::onGeometrySurfaceMark (action.cpp)</vh></v>
<v t="leo.20201108101517.67"><vh>void Action::onGeometrySurfaceSwapElementNormal (action.cpp)</vh></v>
<v t="leo.20201108101517.68"><vh>void Action::onGeometrySurfaceSwapNormals (action.cpp)</vh></v>
<v t="leo.20201108101517.69"><vh>void Action::onGeometrySurfaceSyncNormals (action.cpp)</vh></v>
<v t="leo.20201108101517.70"><vh>void Action::onGeometrySurfaceCloseHole (action.cpp)</vh></v>
<v t="leo.20201108101517.71"><vh>void Action::onGeometrySurfaceCoarsen (action.cpp)</vh></v>
<v t="leo.20201108101517.72"><vh>void Action::onGeometryVectorFieldCreate (action.cpp)</vh></v>
<v t="leo.20201108101517.73"><vh>void Action::onGeometryVectorFieldEdit (action.cpp)</vh></v>
<v t="leo.20201108101517.74"><vh>void Action::onGeometryScalarFieldCreate (action.cpp)</vh></v>
<v t="leo.20201108101517.75"><vh>void Action::onGeometryScalarFieldEdit (action.cpp)</vh></v>
<v t="leo.20201108101517.76"><vh>void Action::onGeometryStreamLineCreate (action.cpp)</vh></v>
<v t="leo.20201108101517.77"><vh>void Action::onGeometryStreamLineEdit (action.cpp)</vh></v>
<v t="leo.20201108101517.78"><vh>void Action::onGeometryCutCreate (action.cpp)</vh></v>
<v t="leo.20201108101517.79"><vh>void Action::onGeometryCutEdit (action.cpp)</vh></v>
<v t="leo.20201108101517.80"><vh>void Action::onGeometryIsoCreate (action.cpp)</vh></v>
<v t="leo.20201108101517.81"><vh>void Action::onGeometryIsoEdit (action.cpp)</vh></v>
<v t="leo.20201108101517.82"><vh>void Action::onGeometryEntityMerge (action.cpp)</vh></v>
<v t="leo.20201108101517.83"><vh>void Action::onGeometryEntityRemove (action.cpp)</vh></v>
<v t="leo.20201108101517.84"><vh>void Action::onGeometryGenerateTetrahedra (action.cpp)</vh></v>
<v t="leo.20201108101517.85"><vh>void Action::onGeometryTransform (action.cpp)</vh></v>
<v t="leo.20201108101517.86"><vh>void Action::onGeometryDevExportSliverElements (action.cpp)</vh></v>
<v t="leo.20201108101517.87"><vh>void Action::onGeometryDevExportIntersectedElements (action.cpp)</vh></v>
<v t="leo.20201108101517.88"><vh>void Action::onGeometryDevPurgeUnusedNodes (action.cpp)</vh></v>
<v t="leo.20201108101517.89"><vh>void Action::onGeometryDevPurgeUnusedElements (action.cpp)</vh></v>
<v t="leo.20201108101517.90"><vh>void Action::onGeometryDevRemoveDuplicateNodes (action.cpp)</vh></v>
<v t="leo.20201108101517.91"><vh>void Action::onGeometryDevRemoveDuplicateElements (action.cpp)</vh></v>
<v t="leo.20201108101517.92"><vh>void Action::onGeometryDevPointInsideSurface (action.cpp)</vh></v>
<v t="leo.20201108101517.93"><vh>void Action::onGeometryDevTetrahedralizeeSurface (action.cpp)</vh></v>
<v t="leo.20201108101517.94"><vh>void Action::onGeometryDevConsolidate (action.cpp)</vh></v>
<v t="leo.20201108101517.95"><vh>void Action::onProblemTaskFlow (action.cpp)</vh></v>
<v t="leo.20201108101517.96"><vh>void Action::onProblemSolverSetup (action.cpp)</vh></v>
<v t="leo.20201108101517.97"><vh>void Action::onProblemDefineMonitoringPoints (action.cpp)</vh></v>
<v t="leo.20201108101517.98"><vh>void Action::onProblemReset (action.cpp)</vh></v>
<v t="leo.20201108101517.99"><vh>void Action::onSolverStart (action.cpp)</vh></v>
<v t="leo.20201108101517.100"><vh>void Action::onSolverStop (action.cpp)</vh></v>
<v t="leo.20201108101517.101"><vh>void Action::onSolverKill (action.cpp)</vh></v>
<v t="leo.20201108101517.102"><vh>void Action::onReportModelStatistics (action.cpp)</vh></v>
<v t="leo.20201108101517.103"><vh>void Action::onReportSolverLog (action.cpp)</vh></v>
<v t="leo.20201108101517.104"><vh>void Action::onReportConvergenceGraph (action.cpp)</vh></v>
<v t="leo.20201108101517.105"><vh>void Action::onReportMonitoringPointGraph (action.cpp)</vh></v>
<v t="leo.20201108101517.106"><vh>void Action::onReportCreateReport (action.cpp)</vh></v>
<v t="leo.20201108101517.107"><vh>void Action::onHelp (action.cpp)</vh></v>
<v t="leo.20201108101517.108"><vh>void Action::onQuit (action.cpp)</vh></v>
<v t="leo.20201108101517.109"><vh>void Action::onApplicationSettings (action.cpp)</vh></v>
<v t="leo.20201108101517.110"><vh>void Action::onUpdate (action.cpp)</vh></v>
<v t="leo.20201108101517.111"><vh>void Action::onAbout (action.cpp)</vh></v>
<v t="leo.20201108101517.112"><vh>void Action::onAboutQt (action.cpp)</vh></v>
<v t="leo.20201108101517.113"><vh>void Action::onLicense (action.cpp)</vh></v>
<v t="leo.20201108101517.114"><vh>void Action::onReleaseNotes (action.cpp)</vh></v>
</v>
<v t="leo.20201108101517.115"><vh>@clean action_definition.cpp</vh>
<v t="leo.20201108101517.116"><vh>const QString (action_definition.cpp)</vh></v>
<v t="leo.20201108101517.117"><vh>const QString (action_definition.cpp)</vh></v>
<v t="leo.20201108101517.118"><vh>const QString (action_definition.cpp)</vh></v>
<v t="leo.20201108101517.119"><vh>void ActionDefinition::setShortcut (action_definition.cpp)</vh></v>
<v t="leo.20201108101517.120"><vh>const QString (action_definition.cpp)</vh></v>
<v t="leo.20201108101517.121"><vh>void ActionDefinition::generateActionDescList (action_definition.cpp)</vh></v>
</v>
<v t="leo.20201108101517.122"><vh>@clean action_definition_item.cpp</vh>
<v t="leo.20201108101517.123"><vh>void ActionDefinitionItem::_init (action_definition_item.cpp)</vh></v>
<v t="leo.20201108101517.124"><vh>const QString (action_definition_item.cpp)</vh></v>
</v>
<v t="leo.20201108101517.125"><vh>@clean action_list.cpp</vh>
<v t="leo.20201108101517.126"><vh>void ActionList::processAvailability (action_list.cpp)</vh></v>
<v t="leo.20201108101517.127"><vh>void ActionList::enable (action_list.cpp)</vh></v>
<v t="leo.20201108101517.128"><vh>void ActionList::disable (action_list.cpp)</vh></v>
<v t="leo.20201108101517.129"><vh>void ActionList::setDisabled (action_list.cpp)</vh></v>
<v t="leo.20201108101517.130"><vh>void ActionList::changeShortcut (action_list.cpp)</vh></v>
</v>
<v t="leo.20201108101517.131"><vh>@clean application.cpp</vh>
<v t="leo.20201108101517.132"><vh>void Application::applyStyle (application.cpp)</vh></v>
<v t="leo.20201108101517.133"><vh>void Application::onStarted (application.cpp)</vh></v>
<v t="leo.20201108101517.134"><vh>void Application::onAboutToQuit (application.cpp)</vh></v>
<v t="leo.20201108101517.135"><vh>void Application::onStyleChanged (application.cpp)</vh></v>
<v t="leo.20201108101517.136"><vh>void Application::onAvailableSoftware (application.cpp)</vh></v>
<v t="leo.20201108101517.137"><vh>void Application::onSignedIn (application.cpp)</vh></v>
<v t="leo.20201108101517.138"><vh>void Application::onSignedOut (application.cpp)</vh></v>
</v>
<v t="leo.20201108101517.139"><vh>@clean application_settings.cpp</vh>
<v t="leo.20201108101517.140"><vh>const ActionDefinition (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.141"><vh>const QString (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.142"><vh>void ApplicationSettings::setSolverPath (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.143"><vh>const QString (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.144"><vh>void ApplicationSettings::setHelpDir (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.145"><vh>void ApplicationSettings::setNThreads (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.146"><vh>void ApplicationSettings::setNHistoryRecords (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.147"><vh>const QString (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.148"><vh>void ApplicationSettings::setStyle (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.149"><vh>int ApplicationSettings::getToolbarIconSize (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.150"><vh>void ApplicationSettings::setToolbarIconSize (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.151"><vh>bool ApplicationSettings::getSendUsageInfo (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.152"><vh>void ApplicationSettings::setSendUsageInfo (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.153"><vh>bool ApplicationSettings::getRangeApiAllowed (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.154"><vh>void ApplicationSettings::setRangeApiAllowed (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.155"><vh>const QString (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.156"><vh>void ApplicationSettings::setRangeApiServer (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.157"><vh>const QString (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.158"><vh>void ApplicationSettings::setRangeAccount (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.159"><vh>const QString (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.160"><vh>void ApplicationSettings::setRangePassword (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.161"><vh>int ApplicationSettings::getDefaultToolbarIconSize (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.162"><vh>bool ApplicationSettings::getDefaultSendUsageInfo (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.163"><vh>bool ApplicationSettings::getDefaultRangeApiAllowed (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.164"><vh>const QString (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.165"><vh>const QString (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.166"><vh>const QString (application_settings.cpp)</vh></v>
<v t="leo.20201108101517.167"><vh>void ApplicationSettings::onShortcutChanged (application_settings.cpp)</vh></v>
</v>
<v t="leo.20201108101517.168"><vh>@clean application_settings_dialog.cpp</vh>
<v t="leo.20201108101517.169"><vh>int ApplicationSettingsDialog::exec (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.170"><vh>void ApplicationSettingsDialog::onSolverPathChanged (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.171"><vh>void ApplicationSettingsDialog::onHelpDirChanged (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.172"><vh>void ApplicationSettingsDialog::onNThreadsChanged (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.173"><vh>void ApplicationSettingsDialog::onNHistoryRecordsChanged (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.174"><vh>void ApplicationSettingsDialog::onStyleChanged (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.175"><vh>void ApplicationSettingsDialog::onToolbarIconSizeChanged (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.176"><vh>void ApplicationSettingsDialog::onKeyboardShortcutChanged (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.177"><vh>void ApplicationSettingsDialog::onRangeApiAllowedToggled (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.178"><vh>void ApplicationSettingsDialog::onSendUsageInfoAllowedToggled (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.179"><vh>void ApplicationSettingsDialog::onRangeApiServerChanged (application_settings_dialog.cpp)</vh></v>
<v t="leo.20201108101517.180"><vh>void ApplicationSettingsDialog::onDefaultClicked (application_settings_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101517.181"><vh>@clean bc_manager_tree.cpp</vh>
<v t="leo.20201108101517.182"><vh>typedef enum (bc_manager_tree.cpp)</vh></v>
<v t="leo.20201108101517.183"><vh>void BCManagerTree::populate (bc_manager_tree.cpp)</vh></v>
<v t="leo.20201108101517.184"><vh>void BCManagerTree::onModelSelectionChanged (bc_manager_tree.cpp)</vh></v>
<v t="leo.20201108101517.185"><vh>void BCManagerTree::onProblemChanged (bc_manager_tree.cpp)</vh></v>
<v t="leo.20201108101517.186"><vh>bool BCManagerTree::resolveConflicts (bc_manager_tree.cpp)</vh>
<v t="leo.20201108101517.187"><vh>int response (bc_manager_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101517.188"><vh>void BCManagerTree::onItemChanged (bc_manager_tree.cpp)</vh></v>
<v t="leo.20201108101517.189"><vh>void BCManagerTree::onItemSelectionChanged (bc_manager_tree.cpp)</vh></v>
<v t="leo.20201108101517.190"><vh>void BCManagerTree::onBcSelected (bc_manager_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101517.191"><vh>@clean bc_tree.cpp</vh>
<v t="leo.20201108101518.1"><vh>typedef enum (bc_tree.cpp)</vh></v>
<v t="leo.20201108101518.2"><vh>void BCTree::populate (bc_tree.cpp)</vh></v>
<v t="leo.20201108101518.3"><vh>void BCTree::updateSelectedEntities (bc_tree.cpp)</vh></v>
<v t="leo.20201108101518.4"><vh>void BCTree::drawLocalRotationBegin (bc_tree.cpp)</vh></v>
<v t="leo.20201108101518.5"><vh>void BCTree::drawLocalRotationEnd (bc_tree.cpp)</vh></v>
<v t="leo.20201108101518.6"><vh>void BCTree::onBcSelected (bc_tree.cpp)</vh></v>
<v t="leo.20201108101518.7"><vh>void BCTree::onBcValueChanged (bc_tree.cpp)</vh></v>
<v t="leo.20201108101518.8"><vh>void BCTree::onButtonValueClicked (bc_tree.cpp)</vh></v>
<v t="leo.20201108101518.9"><vh>void BCTree::onDirectionChanged (bc_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101518.10"><vh>@clean bool_difference_dialog.cpp</vh>
<v t="leo.20201108101518.11"><vh>int BoolDifferenceDialog::exec (bool_difference_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101518.12"><vh>@clean bool_intersection_dialog.cpp</vh>
<v t="leo.20201108101518.13"><vh>int BoolIntersectionDialog::exec (bool_intersection_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101518.14"><vh>@clean bool_union_dialog.cpp</vh>
<v t="leo.20201108101518.15"><vh>int BoolUnionDialog::exec (bool_union_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101518.16"><vh>@clean break_intersected_elements_dialog.cpp</vh>
<v t="leo.20201108101518.17"><vh>int BreakIntersectedElementsDialog::exec (break_intersected_elements_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101518.18"><vh>@clean central_tab_widget.cpp</vh>
<v t="leo.20201108101518.19"><vh>void CentralTabWidget::setTabTitle (central_tab_widget.cpp)</vh></v>
<v t="leo.20201108101518.20"><vh>void CentralTabWidget::onInfoPrinted (central_tab_widget.cpp)</vh></v>
<v t="leo.20201108101518.21"><vh>void CentralTabWidget::onNoticePrinted (central_tab_widget.cpp)</vh></v>
<v t="leo.20201108101518.22"><vh>void CentralTabWidget::onWarningPrinted (central_tab_widget.cpp)</vh></v>
<v t="leo.20201108101518.23"><vh>void CentralTabWidget::onErrorPrinted (central_tab_widget.cpp)</vh></v>
<v t="leo.20201108101518.24"><vh>void CentralTabWidget::onProcessReadyStandardOutput (central_tab_widget.cpp)</vh></v>
<v t="leo.20201108101518.25"><vh>void CentralTabWidget::onProcessReadyStandardError (central_tab_widget.cpp)</vh></v>
<v t="leo.20201108101518.26"><vh>void CentralTabWidget::onCurrentChanged (central_tab_widget.cpp)</vh></v>
<v t="leo.20201108101518.27"><vh>void CentralTabWidget::onPickLostChanged (central_tab_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101518.28"><vh>@clean clipping_plane_widget.cpp</vh>
<v t="leo.20201108101518.29"><vh>void ClippingPlaneWidget::onStateChanged (clipping_plane_widget.cpp)</vh></v>
<v t="leo.20201108101518.30"><vh>void ClippingPlaneWidget::onValueChanged (clipping_plane_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101518.31"><vh>@clean coarsen_surface_dialog.cpp</vh>
<v t="leo.20201108101518.32"><vh>int CoarsenSurfaceDialog::exec (coarsen_surface_dialog.cpp)</vh></v>
<v t="leo.20201108101518.33"><vh>void CoarsenSurfaceDialog::findGeometryLimits (coarsen_surface_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101518.34"><vh>@clean color.cpp</vh>
<v t="leo.20201108101518.35"><vh>void Color::randomize (color.cpp)</vh></v>
</v>
<v t="leo.20201108101518.36"><vh>@clean color_combo_box.cpp</vh>
<v t="leo.20201108101518.37"><vh>void ColorComboBox::setColor (color_combo_box.cpp)</vh></v>
<v t="leo.20201108101518.38"><vh>void ColorComboBox::setColorName (color_combo_box.cpp)</vh></v>
<v t="leo.20201108101518.39"><vh>void ColorComboBox::addColor (color_combo_box.cpp)</vh></v>
<v t="leo.20201108101518.40"><vh>void ColorComboBox::addColor (color_combo_box.cpp)</vh></v>
<v t="leo.20201108101518.41"><vh>void ColorComboBox::onCurrentIndexChanged (color_combo_box.cpp)</vh></v>
</v>
<v t="leo.20201108101518.42"><vh>@clean color_scale.cpp</vh>
<v t="leo.20201108101518.43"><vh>const QString (color_scale.cpp)</vh></v>
<v t="leo.20201108101518.44"><vh>void ColorScale::setName (color_scale.cpp)</vh></v>
<v t="leo.20201108101518.45"><vh>bool ColorScale::validate (color_scale.cpp)</vh></v>
</v>
<v t="leo.20201108101518.46"><vh>@clean color_scale_combo_box.cpp</vh>
<v t="leo.20201108101518.47"><vh>void ColorScaleComboBox::setColorScaleName (color_scale_combo_box.cpp)</vh></v>
</v>
<v t="leo.20201108101518.48"><vh>@clean component_edit_dialog.cpp</vh>
<v t="leo.20201108101518.49"><vh>int ComponentEditDialog::exec (component_edit_dialog.cpp)</vh></v>
<v t="leo.20201108101518.50"><vh>void ComponentEditDialog::onSpinNValuesChanged (component_edit_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101518.51"><vh>@clean component_edit_table.cpp</vh>
<v t="leo.20201108101518.52"><vh>void ComponentEditTable::populate (component_edit_table.cpp)</vh></v>
</v>
<v t="leo.20201108101518.53"><vh>@clean convergence_graph_dialog.cpp</vh></v>
<v t="leo.20201108101518.54"><vh>@clean convergence_graph_object.cpp</vh>
<v t="leo.20201108101518.55"><vh>const QString (convergence_graph_object.cpp)</vh></v>
<v t="leo.20201108101518.56"><vh>void ConvergenceGraphObject::setSourceFileName (convergence_graph_object.cpp)</vh></v>
<v t="leo.20201108101518.57"><vh>void ConvergenceGraphObject::setDataColumn (convergence_graph_object.cpp)</vh></v>
<v t="leo.20201108101518.58"><vh>bool ConvergenceGraphObject::isSourceSet (convergence_graph_object.cpp)</vh></v>
<v t="leo.20201108101518.59"><vh>void ConvergenceGraphObject::clearSourceFile (convergence_graph_object.cpp)</vh></v>
<v t="leo.20201108101518.60"><vh>void ConvergenceGraphObject::readSource (convergence_graph_object.cpp)</vh></v>
</v>
<v t="leo.20201108101518.61"><vh>@clean convergence_graph_widget.cpp</vh>
<v t="leo.20201108101518.62"><vh>void ConvergenceGraphWidget::onCurrentIndexChanged (convergence_graph_widget.cpp)</vh></v>
<v t="leo.20201108101518.63"><vh>void ConvergenceGraphWidget::onClearButtonClicked (convergence_graph_widget.cpp)</vh>
<v t="leo.20201108101518.64"><vh>int response (convergence_graph_widget.cpp)</vh></v>
</v>
</v>
<v t="leo.20201108101518.65"><vh>@clean crash_report_dialog.cpp</vh>
<v t="leo.20201108101518.66"><vh>int CrashReportDialog::exec (crash_report_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101518.67"><vh>@clean cut_dialog.cpp</vh>
<v t="leo.20201108101518.68"><vh>void CutDialog::onAccept (cut_dialog.cpp)</vh></v>
<v t="leo.20201108101518.69"><vh>void CutDialog::onReject (cut_dialog.cpp)</vh></v>
<v t="leo.20201108101518.70"><vh>void CutDialog::onPositionChanged (cut_dialog.cpp)</vh></v>
<v t="leo.20201108101518.71"><vh>void CutDialog::onDirectionChanged (cut_dialog.cpp)</vh></v>
<v t="leo.20201108101518.72"><vh>void CutDialog::onModelTreeSelectionChanged (cut_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101518.73"><vh>@clean direction_widget.cpp</vh>
<v t="leo.20201108101518.74"><vh>void DirectionWidget::showButtons (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.75"><vh>void DirectionWidget::hideButtons (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.76"><vh>void DirectionWidget::setDirection (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.77"><vh>void DirectionWidget::normalize (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.78"><vh>void DirectionWidget::findSliderPositions (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.79"><vh>void DirectionWidget::onXSliderValueChanged (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.80"><vh>void DirectionWidget::onYSliderValueChanged (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.81"><vh>void DirectionWidget::onZSliderValueChanged (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.82"><vh>void DirectionWidget::onXSpinValueChanged (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.83"><vh>void DirectionWidget::onYSpinValueChanged (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.84"><vh>void DirectionWidget::onZSpinValueChanged (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.85"><vh>void DirectionWidget::onOkButtonClicked (direction_widget.cpp)</vh></v>
<v t="leo.20201108101518.86"><vh>void DirectionWidget::onCancelButtonClicked (direction_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101518.87"><vh>@clean document_generator.cpp</vh>
<v t="leo.20201108101518.88"><vh>void DocumentGenerator::setEnableHeaderCounters (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.89"><vh>void DocumentGenerator::setFontSizeScale (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.90"><vh>void DocumentGenerator::addExportType (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.91"><vh>void DocumentGenerator::run (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.92"><vh>void DocumentGenerator::generate (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.93"><vh>void DocumentGenerator::generateHeader (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.94"><vh>void DocumentGenerator::generateFooter (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.95"><vh>void DocumentGenerator::exportToPlainText (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.96"><vh>void DocumentGenerator::exportToHTML (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.97"><vh>void DocumentGenerator::exportToODF (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.98"><vh>void DocumentGenerator::exportToPDF (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.99"><vh>void DocumentGenerator::insertH1 (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.100"><vh>void DocumentGenerator::insertH2 (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.101"><vh>void DocumentGenerator::insertH3 (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.102"><vh>void DocumentGenerator::insertH4 (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.103"><vh>void DocumentGenerator::insertH5 (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.104"><vh>void DocumentGenerator::insertText (document_generator.cpp)</vh></v>
<v t="leo.20201108101518.105"><vh>void DocumentGenerator::insertBold (document_generator.cpp)</vh></v>
</v>
<v t="leo.20201108101518.106"><vh>@clean document_tree.cpp</vh>
<v t="leo.20201108101518.107"><vh>typedef enum (document_tree.cpp)</vh></v>
<v t="leo.20201108101518.108"><vh>void DocumentTree::addDocument (document_tree.cpp)</vh></v>
<v t="leo.20201108101518.109"><vh>void DocumentTree::populate (document_tree.cpp)</vh></v>
<v t="leo.20201108101518.110"><vh>void DocumentTree::updateDocuments (document_tree.cpp)</vh></v>
<v t="leo.20201108101518.111"><vh>void DocumentTree::onModelAdded (document_tree.cpp)</vh></v>
<v t="leo.20201108101518.112"><vh>void DocumentTree::onModelChanged (document_tree.cpp)</vh></v>
<v t="leo.20201108101518.113"><vh>void DocumentTree::onModelRemoved (document_tree.cpp)</vh></v>
<v t="leo.20201108101518.114"><vh>void DocumentTree::onItemDoubleClicked (document_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101519.1"><vh>@clean document_widget.cpp</vh>
<v t="leo.20201108101519.2"><vh>void DocumentWidget::addListItem (document_widget.cpp)</vh></v>
<v t="leo.20201108101519.3"><vh>void DocumentWidget::addListItem (document_widget.cpp)</vh></v>
<v t="leo.20201108101519.4"><vh>void DocumentWidget::loadFile (document_widget.cpp)</vh></v>
<v t="leo.20201108101519.5"><vh>void DocumentWidget::onListSelectionChanged (document_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101519.6"><vh>@clean download_manager.cpp</vh>
<v t="leo.20201108101519.7"><vh>void DownloadManager::startNextDownload (download_manager.cpp)</vh></v>
<v t="leo.20201108101519.8"><vh>void DownloadManager::downloadProgress (download_manager.cpp)</vh></v>
<v t="leo.20201108101519.9"><vh>void DownloadManager::downloadFinished (download_manager.cpp)</vh></v>
<v t="leo.20201108101519.10"><vh>void DownloadManager::downloadReadyRead (download_manager.cpp)</vh></v>
</v>
<v t="leo.20201108101519.11"><vh>@clean draw_engine.cpp</vh>
<v t="leo.20201108101519.12"><vh>void DrawEngine::start (draw_engine.cpp)</vh></v>
<v t="leo.20201108101519.13"><vh>void DrawEngine::stop (draw_engine.cpp)</vh></v>
<v t="leo.20201108101519.14"><vh>void DrawEngine::processObjects (draw_engine.cpp)</vh></v>
<v t="leo.20201108101519.15"><vh>void DrawEngine::addObject (draw_engine.cpp)</vh></v>
<v t="leo.20201108101519.16"><vh>void DrawEngine::removeObject (draw_engine.cpp)</vh></v>
<v t="leo.20201108101519.17"><vh>const DrawEngineObject (draw_engine.cpp)</vh></v>
<v t="leo.20201108101519.18"><vh>void DrawEngine::setObjectChanged (draw_engine.cpp)</vh></v>
</v>
<v t="leo.20201108101519.19"><vh>@clean draw_engine_circle.cpp</vh></v>
<v t="leo.20201108101519.20"><vh>@clean draw_engine_cylinder.cpp</vh></v>
<v t="leo.20201108101519.21"><vh>@clean draw_engine_ellipse.cpp</vh></v>
<v t="leo.20201108101519.22"><vh>@clean draw_engine_hexahedron.cpp</vh></v>
<v t="leo.20201108101519.23"><vh>@clean draw_engine_input.cpp</vh>
<v t="leo.20201108101519.24"><vh>void DrawEngineInput::_init (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.25"><vh>bool DrawEngineInput::setValue (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.26"><vh>bool DrawEngineInput::setValue (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.27"><vh>bool DrawEngineInput::setValue (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.28"><vh>bool DrawEngineInput::setValue (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.29"><vh>bool DrawEngineInput::setValue (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.30"><vh>bool DrawEngineInput::setValue (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.31"><vh>bool DrawEngineInput::setValue (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.32"><vh>bool DrawEngineInput::toBool (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.33"><vh>int DrawEngineInput::toInt (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.34"><vh>const QString (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.35"><vh>const QString (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.36"><vh>const QString (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.37"><vh>bool DrawEngineInput::isValid (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.38"><vh>bool DrawEngineInput::isValid (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.39"><vh>bool DrawEngineInput::isValid (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.40"><vh>bool DrawEngineInput::isValid (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.41"><vh>bool DrawEngineInput::isValid (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.42"><vh>bool DrawEngineInput::isValid (draw_engine_input.cpp)</vh></v>
<v t="leo.20201108101519.43"><vh>bool DrawEngineInput::isValid (draw_engine_input.cpp)</vh></v>
</v>
<v t="leo.20201108101519.44"><vh>@clean draw_engine_line.cpp</vh></v>
<v t="leo.20201108101519.45"><vh>@clean draw_engine_object.cpp</vh>
<v t="leo.20201108101519.46"><vh>const QString (draw_engine_object.cpp)</vh></v>
<v t="leo.20201108101519.47"><vh>const DrawEngineInput (draw_engine_object.cpp)</vh></v>
<v t="leo.20201108101519.48"><vh>void DrawEngineObject::updateModel (draw_engine_object.cpp)</vh></v>
<v t="leo.20201108101519.49"><vh>const Model (draw_engine_object.cpp)</vh></v>
<v t="leo.20201108101519.50"><vh>void DrawEngineObject::glDraw (draw_engine_object.cpp)</vh></v>
</v>
<v t="leo.20201108101519.51"><vh>@clean draw_engine_point.cpp</vh></v>
<v t="leo.20201108101519.52"><vh>@clean draw_engine_quadrilateral.cpp</vh></v>
<v t="leo.20201108101519.53"><vh>@clean draw_engine_raw.cpp</vh></v>
<v t="leo.20201108101519.54"><vh>@clean draw_engine_sphere.cpp</vh></v>
<v t="leo.20201108101519.55"><vh>@clean draw_engine_tetrahedron.cpp</vh></v>
<v t="leo.20201108101519.56"><vh>@clean draw_engine_triangle.cpp</vh></v>
<v t="leo.20201108101519.57"><vh>@clean draw_input_tree.cpp</vh>
<v t="leo.20201108101519.58"><vh>typedef enum (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.59"><vh>void DrawInputTree::setRequestedItemVectorValue (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.60"><vh>void DrawInputTree::setRequestedItemLocalDirectionValue (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.61"><vh>void DrawInputTree::setRequestedItemTextValue (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.62"><vh>void DrawInputTree::releaseRequestedItem (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.63"><vh>void DrawInputTree::populate (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.64"><vh>void DrawInputTree::setItemVectorValue (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.65"><vh>void DrawInputTree::setItemLocalDirectionValue (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.66"><vh>void DrawInputTree::setItemTextValue (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.67"><vh>void DrawInputTree::onDrawObjectAdded (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.68"><vh>void DrawInputTree::onDrawObjectRemoved (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.69"><vh>void DrawInputTree::onDrawObjectsRemoved (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.70"><vh>void DrawInputTree::onItemDoubleClicked (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.71"><vh>void DrawInputTree::onItemChanged (draw_input_tree.cpp)</vh></v>
<v t="leo.20201108101519.72"><vh>void DrawInputTree::onItemSelectionChanged (draw_input_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101519.73"><vh>@clean draw_input_widget.cpp</vh>
<v t="leo.20201108101519.74"><vh>void DrawInputWidget::onPositionRequest (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.75"><vh>void DrawInputWidget::onPositionWidgetChanged (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.76"><vh>void DrawInputWidget::onPositionWidgetClosed (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.77"><vh>void DrawInputWidget::onLocalDirectionRequest (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.78"><vh>void DrawInputWidget::onLocalDirectionWidgetChanged (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.79"><vh>void DrawInputWidget::onLocalDirectionWidgetClosed (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.80"><vh>void DrawInputWidget::onTextRequest (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.81"><vh>void DrawInputWidget::onTextWidgetChanged (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.82"><vh>void DrawInputWidget::onTextWidgetClosed (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.83"><vh>void DrawInputWidget::onSelectionChanged (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.84"><vh>void DrawInputWidget::onInputParameterChanged (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.85"><vh>void DrawInputWidget::onRemoveClicked (draw_input_widget.cpp)</vh></v>
<v t="leo.20201108101519.86"><vh>void DrawInputWidget::onOkClicked (draw_input_widget.cpp)</vh>
<v t="leo.20201108101519.87"><vh>int response (draw_input_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101519.88"><vh>void DrawInputWidget::onCancelClicked (draw_input_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101519.89"><vh>@clean drop_results_dialog.cpp</vh>
<v t="leo.20201108101519.90"><vh>int DropResultsDialog::exec (drop_results_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101519.91"><vh>@clean ec_manager_tree.cpp</vh>
<v t="leo.20201108101519.92"><vh>typedef enum (ec_manager_tree.cpp)</vh></v>
<v t="leo.20201108101519.93"><vh>void ECManagerTree::populate (ec_manager_tree.cpp)</vh></v>
<v t="leo.20201108101520.1"><vh>void ECManagerTree::onModelSelectionChanged (ec_manager_tree.cpp)</vh></v>
<v t="leo.20201108101520.2"><vh>void ECManagerTree::onProblemChanged (ec_manager_tree.cpp)</vh></v>
<v t="leo.20201108101520.3"><vh>void ECManagerTree::onItemChanged (ec_manager_tree.cpp)</vh></v>
<v t="leo.20201108101520.4"><vh>void ECManagerTree::onItemSelectionChanged (ec_manager_tree.cpp)</vh></v>
<v t="leo.20201108101520.5"><vh>void ECManagerTree::onEcSelected (ec_manager_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101520.6"><vh>@clean ec_tree.cpp</vh>
<v t="leo.20201108101520.7"><vh>typedef enum (ec_tree.cpp)</vh></v>
<v t="leo.20201108101520.8"><vh>void ECTree::populate (ec_tree.cpp)</vh></v>
<v t="leo.20201108101520.9"><vh>void ECTree::updateSelectedEntities (ec_tree.cpp)</vh></v>
<v t="leo.20201108101520.10"><vh>void ECTree::onEcSelected (ec_tree.cpp)</vh></v>
<v t="leo.20201108101520.11"><vh>void ECTree::onEcValueChanged (ec_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101520.12"><vh>@clean file_chooser_button.cpp</vh>
<v t="leo.20201108101520.13"><vh>void FileChooserButton::setFileName (file_chooser_button.cpp)</vh></v>
<v t="leo.20201108101520.14"><vh>void FileChooserButton::setFilter (file_chooser_button.cpp)</vh></v>
<v t="leo.20201108101520.15"><vh>void FileChooserButton::setShowLabel (file_chooser_button.cpp)</vh></v>
<v t="leo.20201108101520.16"><vh>void FileChooserButton::onPushButtonClicked (file_chooser_button.cpp)</vh></v>
</v>
<v t="leo.20201108101520.17"><vh>@clean file_updater.cpp</vh>
<v t="leo.20201108101520.18"><vh>void FileUpdater::addFile (file_updater.cpp)</vh></v>
<v t="leo.20201108101520.19"><vh>void FileUpdater::run (file_updater.cpp)</vh></v>
</v>
<v t="leo.20201108101520.20"><vh>@clean find_sliver_elements_dialog.cpp</vh>
<v t="leo.20201108101520.21"><vh>int FindSliverElementsDialog::exec (find_sliver_elements_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101520.22"><vh>@clean first_run_dialog.cpp</vh>
<v t="leo.20201108101520.23"><vh>void FirstRunDialog::onSendUsageInfoToggled (first_run_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101520.24"><vh>@clean fix_sliver_elements_dialog.cpp</vh>
<v t="leo.20201108101520.25"><vh>int FixSliverElementsDialog::exec (fix_sliver_elements_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101520.26"><vh>@clean geometry_rotate_widget.cpp</vh>
<v t="leo.20201108101520.27"><vh>void GeometryRotateWidget::resetAngles (geometry_rotate_widget.cpp)</vh></v>
<v t="leo.20201108101520.28"><vh>void GeometryRotateWidget::onAngleValueChanged (geometry_rotate_widget.cpp)</vh></v>
<v t="leo.20201108101520.29"><vh>void GeometryRotateWidget::onPositionChanged (geometry_rotate_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101520.30"><vh>@clean geometry_scale_widget.cpp</vh>
<v t="leo.20201108101520.31"><vh>void GeometryScaleWidget::onSameScaleToggled (geometry_scale_widget.cpp)</vh></v>
<v t="leo.20201108101520.32"><vh>void GeometryScaleWidget::onDifferentScaleToggled (geometry_scale_widget.cpp)</vh></v>
<v t="leo.20201108101520.33"><vh>void GeometryScaleWidget::resetSameScale (geometry_scale_widget.cpp)</vh></v>
<v t="leo.20201108101520.34"><vh>void GeometryScaleWidget::resetDifferentScale (geometry_scale_widget.cpp)</vh></v>
<v t="leo.20201108101520.35"><vh>void GeometryScaleWidget::onScaleValueChanged (geometry_scale_widget.cpp)</vh></v>
<v t="leo.20201108101520.36"><vh>void GeometryScaleWidget::onPositionChanged (geometry_scale_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101520.37"><vh>@clean geometry_transform_input.cpp</vh>
<v t="leo.20201108101520.38"><vh>void GeometryTransformInput::_init (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.39"><vh>const RR3Vector (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.40"><vh>void GeometryTransformInput::setTranslation (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.41"><vh>const RR3Vector (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.42"><vh>void GeometryTransformInput::setRotation (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.43"><vh>const RR3Vector (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.44"><vh>void GeometryTransformInput::setRotationCenter (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.45"><vh>const RR3Vector (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.46"><vh>void GeometryTransformInput::setScale (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.47"><vh>const RR3Vector (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.48"><vh>void GeometryTransformInput::setScaleCenter (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.49"><vh>void GeometryTransformInput::setApplyTo (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.50"><vh>bool GeometryTransformInput::getIncludeSharedNodes (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.51"><vh>void GeometryTransformInput::setIncludeSharedNodes (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.52"><vh>bool GeometryTransformInput::getSplitSharedNodes (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.53"><vh>void GeometryTransformInput::setSplitSharedNodes (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.54"><vh>bool GeometryTransformInput::getSweepSharedNodes (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.55"><vh>void GeometryTransformInput::setSweepSharedNodes (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.56"><vh>void GeometryTransformInput::setNSweepSteps (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.57"><vh>bool GeometryTransformInput::isTranslateActive (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.58"><vh>bool GeometryTransformInput::isRotateActive (geometry_transform_input.cpp)</vh></v>
<v t="leo.20201108101520.59"><vh>bool GeometryTransformInput::isScaleActive (geometry_transform_input.cpp)</vh></v>
</v>
<v t="leo.20201108101520.60"><vh>@clean geometry_transform_widget.cpp</vh>
<v t="leo.20201108101520.61"><vh>void GeometryTransformWidget::enableOkButton (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.62"><vh>void GeometryTransformWidget::onModelSelectionChanged (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.63"><vh>void GeometryTransformWidget::onModelVisibilityChanged (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.64"><vh>void GeometryTransformWidget::onPickListChanged (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.65"><vh>void GeometryTransformWidget::onScaleChanged (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.66"><vh>void GeometryTransformWidget::onRotationChanged (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.67"><vh>void GeometryTransformWidget::onTranslationChanged (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.68"><vh>void GeometryTransformWidget::onApplyToAllClicked (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.69"><vh>void GeometryTransformWidget::onApplyToSelectedClicked (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.70"><vh>void GeometryTransformWidget::onApplyToPickedClicked (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.71"><vh>void GeometryTransformWidget::onApplyToVisibleClicked (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.72"><vh>void GeometryTransformWidget::onIncludeSharedNodesClicked (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.73"><vh>void GeometryTransformWidget::onSplitSharedNodesClicked (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.74"><vh>void GeometryTransformWidget::onSweepSharedNodesClicked (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.75"><vh>void GeometryTransformWidget::onSweepNStepsSpinChanged (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.76"><vh>void GeometryTransformWidget::onCancelClicked (geometry_transform_widget.cpp)</vh></v>
<v t="leo.20201108101520.77"><vh>void GeometryTransformWidget::onOkClicked (geometry_transform_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101520.78"><vh>@clean geometry_translate_widget.cpp</vh>
<v t="leo.20201108101520.79"><vh>void GeometryTranslateWidget::setOrigin (geometry_translate_widget.cpp)</vh></v>
<v t="leo.20201108101520.80"><vh>void GeometryTranslateWidget::setCenter (geometry_translate_widget.cpp)</vh></v>
<v t="leo.20201108101520.81"><vh>void GeometryTranslateWidget::resetDistances (geometry_translate_widget.cpp)</vh></v>
<v t="leo.20201108101520.82"><vh>void GeometryTranslateWidget::onDistanceValueChanged (geometry_translate_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101520.83"><vh>@clean gl_acion_event.cpp</vh>
<v t="leo.20201108101520.84"><vh>typedef struct (gl_acion_event.cpp)</vh></v>
<v t="leo.20201108101520.85"><vh>static std::vector (gl_acion_event.cpp)</vh></v>
<v t="leo.20201108101520.86"><vh>bool GLActionEvent::getChanged (gl_acion_event.cpp)</vh></v>
<v t="leo.20201108101520.87"><vh>void GLActionEvent::setKeyEvent (gl_acion_event.cpp)</vh></v>
<v t="leo.20201108101520.88"><vh>void GLActionEvent::setMouseEvent (gl_acion_event.cpp)</vh></v>
<v t="leo.20201108101520.89"><vh>void GLActionEvent::setScrollPhase (gl_acion_event.cpp)</vh></v>
<v t="leo.20201108101520.90"><vh>void GLActionEvent::clear (gl_acion_event.cpp)</vh></v>
</v>
<v t="leo.20201108101520.91"><vh>@clean gl_arrow.cpp</vh>
<v t="leo.20201108101520.92"><vh>void GLArrow::_init (gl_arrow.cpp)</vh></v>
<v t="leo.20201108101520.93"><vh>void GLArrow::initialize (gl_arrow.cpp)</vh></v>
<v t="leo.20201108101520.94"><vh>void GLArrow::finalize (gl_arrow.cpp)</vh></v>
<v t="leo.20201108101520.95"><vh>void GLArrow::draw (gl_arrow.cpp)</vh></v>
<v t="leo.20201108101520.96"><vh>void GLArrow::drawShaft (gl_arrow.cpp)</vh></v>
<v t="leo.20201108101520.97"><vh>void GLArrow::drawHead (gl_arrow.cpp)</vh></v>
</v>
<v t="leo.20201108101520.98"><vh>@clean gl_axis.cpp</vh>
<v t="leo.20201108101520.99"><vh>void GLAxis::_init (gl_axis.cpp)</vh></v>
<v t="leo.20201108101520.100"><vh>void GLAxis::setType (gl_axis.cpp)</vh></v>
<v t="leo.20201108101520.101"><vh>float GLAxis::getSize (gl_axis.cpp)</vh></v>
<v t="leo.20201108101520.102"><vh>void GLAxis::setSize (gl_axis.cpp)</vh></v>
<v t="leo.20201108101520.103"><vh>void GLAxis::initialize (gl_axis.cpp)</vh></v>
<v t="leo.20201108101520.104"><vh>void GLAxis::finalize (gl_axis.cpp)</vh></v>
<v t="leo.20201108101520.105"><vh>void GLAxis::draw (gl_axis.cpp)</vh></v>
</v>
<v t="leo.20201108101520.106"><vh>@clean gl_cut_plane.cpp</vh>
<v t="leo.20201108101520.107"><vh>void GLCutPlane::_init (gl_cut_plane.cpp)</vh></v>
<v t="leo.20201108101520.108"><vh>float GLCutPlane::getSize (gl_cut_plane.cpp)</vh></v>
<v t="leo.20201108101520.109"><vh>void GLCutPlane::setSize (gl_cut_plane.cpp)</vh></v>
<v t="leo.20201108101520.110"><vh>void GLCutPlane::initialize (gl_cut_plane.cpp)</vh></v>
<v t="leo.20201108101520.111"><vh>void GLCutPlane::finalize (gl_cut_plane.cpp)</vh></v>
<v t="leo.20201108101520.112"><vh>void GLCutPlane::draw (gl_cut_plane.cpp)</vh></v>
</v>
<v t="leo.20201108101520.113"><vh>@clean gl_dimension.cpp</vh>
<v t="leo.20201108101520.114"><vh>void GLDimension::_init (gl_dimension.cpp)</vh></v>
<v t="leo.20201108101520.115"><vh>void GLDimension::initialize (gl_dimension.cpp)</vh></v>
<v t="leo.20201108101520.116"><vh>void GLDimension::finalize (gl_dimension.cpp)</vh></v>
<v t="leo.20201108101520.117"><vh>void GLDimension::draw (gl_dimension.cpp)</vh></v>
</v>
<v t="leo.20201108101520.118"><vh>@clean gl_display_properties.cpp</vh>
<v t="leo.20201108101520.119"><vh>void GLDisplayProperties::_init (gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101520.120"><vh>const QString (gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101520.121"><vh>void GLDisplayProperties::setFileName (gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101520.122"><vh>void GLDisplayProperties::load (gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101520.123"><vh>void GLDisplayProperties::store (gl_display_properties.cpp)</vh></v>
</v>
<v t="leo.20201108101520.124"><vh>@clean gl_display_properties_dialog.cpp</vh>
<v t="leo.20201108101520.125"><vh>typedef enum (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101520.126"><vh>int GLDisplayPropertiesDialog::exec (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101520.127"><vh>void GLDisplayPropertiesDialog::populate (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101521.1"><vh>void GLDisplayPropertiesDialog::onShowModelEdgesClicked (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101521.2"><vh>void GLDisplayPropertiesDialog::onShowModelDimensionsClicked (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101521.3"><vh>void GLDisplayPropertiesDialog::onShowModelErrorsClicked (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101521.4"><vh>void GLDisplayPropertiesDialog::onShowGlobalAxisClicked (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101521.5"><vh>void GLDisplayPropertiesDialog::onShowLocalAxisClicked (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101521.6"><vh>void GLDisplayPropertiesDialog::onBgColorChanged (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101521.7"><vh>void GLDisplayPropertiesDialog::onBgGradientStateChanged (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101521.8"><vh>void GLDisplayPropertiesDialog::onLightChanged (gl_display_properties_dialog.cpp)</vh></v>
<v t="leo.20201108101521.9"><vh>void GLDisplayPropertiesDialog::onDefaultClicked (gl_display_properties_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101521.10"><vh>@clean gl_element.cpp</vh>
<v t="leo.20201108101521.11"><vh>void GLElement::_init (gl_element.cpp)</vh></v>
<v t="leo.20201108101521.12"><vh>void GLElement::setPointVolume (gl_element.cpp)</vh></v>
<v t="leo.20201108101521.13"><vh>void GLElement::setLineCrossArea (gl_element.cpp)</vh></v>
<v t="leo.20201108101521.14"><vh>void GLElement::setSurfaceThickness (gl_element.cpp)</vh></v>
<v t="leo.20201108101521.15"><vh>void GLElement::draw (gl_element.cpp)</vh></v>
<v t="leo.20201108101521.16"><vh>void GLElement::drawPoint (gl_element.cpp)</vh></v>
<v t="leo.20201108101521.17"><vh>void GLElement::drawLine (gl_element.cpp)</vh></v>
<v t="leo.20201108101521.18"><vh>void GLElement::drawTriangle (gl_element.cpp)</vh></v>
<v t="leo.20201108101521.19"><vh>void GLElement::drawQuadrilateral (gl_element.cpp)</vh></v>
<v t="leo.20201108101521.20"><vh>void GLElement::drawTetrahedra (gl_element.cpp)</vh></v>
</v>
<v t="leo.20201108101521.21"><vh>@clean gl_element_base.cpp</vh>
<v t="leo.20201108101521.22"><vh>void GLElementBase::_init (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.23"><vh>const REntityGroupData (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.24"><vh>const QColor (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.25"><vh>const Model (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.26"><vh>void GLElementBase::setModelPtr (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.27"><vh>void GLElementBase::setElementID (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.28"><vh>void GLElementBase::setScalarVariable (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.29"><vh>void GLElementBase::setDisplacementVariable (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.30"><vh>void GLElementBase::setNodePointSize (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.31"><vh>void GLElementBase::setEdgeLineWidth (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.32"><vh>void GLElementBase::initialize (gl_element_base.cpp)</vh></v>
<v t="leo.20201108101521.33"><vh>void GLElementBase::finalize (gl_element_base.cpp)</vh></v>
</v>
<v t="leo.20201108101521.34"><vh>@clean gl_element_group.cpp</vh>
<v t="leo.20201108101521.35"><vh>void GLElementGroup::_init (gl_element_group.cpp)</vh></v>
<v t="leo.20201108101521.36"><vh>void GLElementGroup::setPointVolume (gl_element_group.cpp)</vh></v>
<v t="leo.20201108101521.37"><vh>void GLElementGroup::setLineCrossArea (gl_element_group.cpp)</vh></v>
<v t="leo.20201108101521.38"><vh>void GLElementGroup::setSurfaceThickness (gl_element_group.cpp)</vh></v>
<v t="leo.20201108101521.39"><vh>void GLElementGroup::initialize (gl_element_group.cpp)</vh></v>
<v t="leo.20201108101521.40"><vh>void GLElementGroup::finalize (gl_element_group.cpp)</vh></v>
<v t="leo.20201108101521.41"><vh>void GLElementGroup::draw (gl_element_group.cpp)</vh></v>
</v>
<v t="leo.20201108101521.42"><vh>@clean gl_entity.cpp</vh>
<v t="leo.20201108101521.43"><vh>void GLEntity::_init (gl_entity.cpp)</vh></v>
<v t="leo.20201108101521.44"><vh>const SessionEntityID (gl_entity.cpp)</vh></v>
<v t="leo.20201108101521.45"><vh>void GLEntity::initialize (gl_entity.cpp)</vh></v>
<v t="leo.20201108101521.46"><vh>void GLEntity::finalize (gl_entity.cpp)</vh></v>
<v t="leo.20201108101521.47"><vh>void GLEntity::draw (gl_entity.cpp)</vh></v>
</v>
<v t="leo.20201108101521.48"><vh>@clean gl_entity_list.cpp</vh>
<v t="leo.20201108101521.49"><vh>void GLEntityList::_init (gl_entity_list.cpp)</vh></v>
</v>
<v t="leo.20201108101521.50"><vh>@clean gl_functions.cpp</vh>
<v t="leo.20201108101521.51"><vh>void GLFunctions::printError (gl_functions.cpp)</vh></v>
<v t="leo.20201108101521.52"><vh>void GLFunctions::begin (gl_functions.cpp)</vh></v>
<v t="leo.20201108101521.53"><vh>void GLFunctions::end (gl_functions.cpp)</vh></v>
</v>
<v t="leo.20201108101521.54"><vh>@clean gl_interpolated_element.cpp</vh>
<v t="leo.20201108101521.55"><vh>void GLInterpolatedElement::_init (gl_interpolated_element.cpp)</vh></v>
<v t="leo.20201108101521.56"><vh>const Model (gl_interpolated_element.cpp)</vh></v>
<v t="leo.20201108101521.57"><vh>void GLInterpolatedElement::draw (gl_interpolated_element.cpp)</vh></v>
<v t="leo.20201108101521.58"><vh>void GLInterpolatedElement::drawNormal (gl_interpolated_element.cpp)</vh></v>
</v>
<v t="leo.20201108101521.59"><vh>@clean gl_interpolated_entity.cpp</vh>
<v t="leo.20201108101521.60"><vh>void GLInterpolatedEntity::_init (gl_interpolated_entity.cpp)</vh></v>
<v t="leo.20201108101521.61"><vh>void GLInterpolatedEntity::initialize (gl_interpolated_entity.cpp)</vh></v>
<v t="leo.20201108101521.62"><vh>void GLInterpolatedEntity::finalize (gl_interpolated_entity.cpp)</vh></v>
<v t="leo.20201108101521.63"><vh>void GLInterpolatedEntity::draw (gl_interpolated_entity.cpp)</vh></v>
</v>
<v t="leo.20201108101521.64"><vh>@clean gl_line.cpp</vh>
<v t="leo.20201108101521.65"><vh>void GLLine::_init (gl_line.cpp)</vh></v>
<v t="leo.20201108101521.66"><vh>void GLLine::initialize (gl_line.cpp)</vh></v>
<v t="leo.20201108101521.67"><vh>void GLLine::finalize (gl_line.cpp)</vh></v>
<v t="leo.20201108101521.68"><vh>void GLLine::draw (gl_line.cpp)</vh></v>
</v>
<v t="leo.20201108101521.69"><vh>@clean gl_list.cpp</vh>
<v t="leo.20201108101521.70"><vh>void GLList::_init (gl_list.cpp)</vh></v>
<v t="leo.20201108101521.71"><vh>void GLList::setNLists (gl_list.cpp)</vh></v>
<v t="leo.20201108101521.72"><vh>bool GLList::getListValid (gl_list.cpp)</vh></v>
<v t="leo.20201108101521.73"><vh>void GLList::setListInvalid (gl_list.cpp)</vh></v>
<v t="leo.20201108101521.74"><vh>bool GLList::getValid (gl_list.cpp)</vh></v>
<v t="leo.20201108101521.75"><vh>void GLList::newList (gl_list.cpp)</vh></v>
<v t="leo.20201108101521.76"><vh>void GLList::endList (gl_list.cpp)</vh></v>
<v t="leo.20201108101521.77"><vh>void GLList::callList (gl_list.cpp)</vh></v>
<v t="leo.20201108101521.78"><vh>void GLList::callLists (gl_list.cpp)</vh></v>
</v>
<v t="leo.20201108101521.79"><vh>@clean gl_model_list.cpp</vh>
<v t="leo.20201108101521.80"><vh>void GLModelList::_init (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.81"><vh>void GLModelList::clear (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.82"><vh>void GLModelList::setNGlPointLists (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.83"><vh>const GLEntityList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.84"><vh>void GLModelList::setGlPointList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.85"><vh>void GLModelList::setNGlLineLists (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.86"><vh>const GLEntityList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.87"><vh>void GLModelList::setGlLineList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.88"><vh>void GLModelList::setNGlSurfaceLists (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.89"><vh>const GLEntityList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.90"><vh>void GLModelList::setGlSurfaceList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.91"><vh>void GLModelList::setNGlVolumeLists (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.92"><vh>const GLEntityList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.93"><vh>void GLModelList::setGlVolumeList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.94"><vh>void GLModelList::setNGlVectorFieldLists (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.95"><vh>const GLEntityList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.96"><vh>void GLModelList::setGlVectorFieldList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.97"><vh>void GLModelList::setNGlScalarFieldLists (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.98"><vh>const GLEntityList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.99"><vh>void GLModelList::setGlScalarFieldList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.100"><vh>void GLModelList::setNGlStreamLineLists (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.101"><vh>const GLEntityList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.102"><vh>void GLModelList::setGlStreamLineList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.103"><vh>void GLModelList::setNGlCutLists (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.104"><vh>const GLEntityList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.105"><vh>void GLModelList::setGlCutList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.106"><vh>void GLModelList::setNGlIsoLists (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.107"><vh>const GLEntityList (gl_model_list.cpp)</vh></v>
<v t="leo.20201108101521.108"><vh>void GLModelList::setGlIsoList (gl_model_list.cpp)</vh></v>
</v>
<v t="leo.20201108101521.109"><vh>@clean gl_node.cpp</vh>
<v t="leo.20201108101521.110"><vh>void GLNode::_init (gl_node.cpp)</vh></v>
<v t="leo.20201108101521.111"><vh>void GLNode::initialize (gl_node.cpp)</vh></v>
<v t="leo.20201108101521.112"><vh>void GLNode::finalize (gl_node.cpp)</vh></v>
<v t="leo.20201108101521.113"><vh>void GLNode::draw (gl_node.cpp)</vh></v>
</v>
<v t="leo.20201108101521.114"><vh>@clean gl_object.cpp</vh>
<v t="leo.20201108101521.115"><vh>void GLObject::_init (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.116"><vh>void GLObject::setParentModel (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.117"><vh>bool GLObject::getApplyEnvironmentSettings (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.118"><vh>void GLObject::setApplyEnvironmentSettings (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.119"><vh>bool GLObject::getUseGlList (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.120"><vh>void GLObject::setUseGlList (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.121"><vh>bool GLObject::getUseGlCullFace (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.122"><vh>void GLObject::setUseGlCullFace (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.123"><vh>void GLObject::paint (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.124"><vh>void GLObject::glNormalVector (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.125"><vh>void GLObject::glVertexVector (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.126"><vh>void GLObject::glVertexNode (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.127"><vh>void GLObject::initialize (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.128"><vh>void GLObject::finalize (gl_object.cpp)</vh></v>
<v t="leo.20201108101521.129"><vh>void GLObject::draw (gl_object.cpp)</vh></v>
</v>
<v t="leo.20201108101521.130"><vh>@clean gl_point.cpp</vh>
<v t="leo.20201108101521.131"><vh>void GLPoint::_init (gl_point.cpp)</vh></v>
<v t="leo.20201108101521.132"><vh>void GLPoint::initialize (gl_point.cpp)</vh></v>
<v t="leo.20201108101521.133"><vh>void GLPoint::finalize (gl_point.cpp)</vh></v>
<v t="leo.20201108101521.134"><vh>void GLPoint::draw (gl_point.cpp)</vh></v>
</v>
<v t="leo.20201108101521.135"><vh>@clean gl_rotation_sphere.cpp</vh>
<v t="leo.20201108101521.136"><vh>void GLRotationSphere::_init (gl_rotation_sphere.cpp)</vh></v>
<v t="leo.20201108101521.137"><vh>void GLRotationSphere::initialize (gl_rotation_sphere.cpp)</vh></v>
<v t="leo.20201108101521.138"><vh>void GLRotationSphere::finalize (gl_rotation_sphere.cpp)</vh></v>
<v t="leo.20201108101521.139"><vh>void GLRotationSphere::draw (gl_rotation_sphere.cpp)</vh></v>
</v>
<v t="leo.20201108101521.140"><vh>@clean gl_scalar_field.cpp</vh>
<v t="leo.20201108101521.141"><vh>class ScalarFieldItem</vh>
<v t="leo.20201108101521.142"><vh>ScalarFieldItem.double scalarRate</vh></v>
</v>
<v t="leo.20201108101521.143"><vh>void GLScalarField::_init (gl_scalar_field.cpp)</vh></v>
<v t="leo.20201108101521.144"><vh>const SessionEntityID (gl_scalar_field.cpp)</vh></v>
<v t="leo.20201108101521.145"><vh>void GLScalarField::initialize (gl_scalar_field.cpp)</vh></v>
<v t="leo.20201108101521.146"><vh>void GLScalarField::finalize (gl_scalar_field.cpp)</vh></v>
<v t="leo.20201108101521.147"><vh>void GLScalarField::draw (gl_scalar_field.cpp)</vh></v>
</v>
<v t="leo.20201108101521.148"><vh>@clean gl_simplex.cpp</vh>
<v t="leo.20201108101521.149"><vh>void GLSimplex::_init (gl_simplex.cpp)</vh></v>
<v t="leo.20201108101521.150"><vh>void GLSimplex::setEdgeNodes (gl_simplex.cpp)</vh></v>
<v t="leo.20201108101521.151"><vh>void GLSimplex::setNodeTextureCoordinates (gl_simplex.cpp)</vh></v>
<v t="leo.20201108101521.152"><vh>void GLSimplex::setNodeIds (gl_simplex.cpp)</vh></v>
<v t="leo.20201108101521.153"><vh>void GLSimplex::setId (gl_simplex.cpp)</vh></v>
<v t="leo.20201108101521.154"><vh>void GLSimplex::setColor (gl_simplex.cpp)</vh></v>
<v t="leo.20201108101521.155"><vh>void GLSimplex::setDrawType (gl_simplex.cpp)</vh></v>
</v>
<v t="leo.20201108101521.156"><vh>@clean gl_simplex_point.cpp</vh>
<v t="leo.20201108101521.157"><vh>void GLSimplexPoint::_init (gl_simplex_point.cpp)</vh></v>
<v t="leo.20201108101521.158"><vh>void GLSimplexPoint::initialize (gl_simplex_point.cpp)</vh></v>
<v t="leo.20201108101521.159"><vh>void GLSimplexPoint::finalize (gl_simplex_point.cpp)</vh></v>
<v t="leo.20201108101521.160"><vh>void GLSimplexPoint::draw (gl_simplex_point.cpp)</vh></v>
<v t="leo.20201108101521.161"><vh>void GLSimplexPoint::drawNormal (gl_simplex_point.cpp)</vh></v>
<v t="leo.20201108101521.162"><vh>void GLSimplexPoint::drawWired (gl_simplex_point.cpp)</vh></v>
<v t="leo.20201108101521.163"><vh>void GLSimplexPoint::drawNodes (gl_simplex_point.cpp)</vh></v>
</v>
<v t="leo.20201108101521.164"><vh>@clean gl_simplex_polygon.cpp</vh>
<v t="leo.20201108101522.1"><vh>void GLSimplexPolygon::_init (gl_simplex_polygon.cpp)</vh></v>
<v t="leo.20201108101522.2"><vh>void GLSimplexPolygon::initialize (gl_simplex_polygon.cpp)</vh></v>
<v t="leo.20201108101522.3"><vh>void GLSimplexPolygon::finalize (gl_simplex_polygon.cpp)</vh></v>
<v t="leo.20201108101522.4"><vh>void GLSimplexPolygon::draw (gl_simplex_polygon.cpp)</vh></v>
<v t="leo.20201108101522.5"><vh>void GLSimplexPolygon::drawNormal (gl_simplex_polygon.cpp)</vh></v>
<v t="leo.20201108101522.6"><vh>void GLSimplexPolygon::drawWired (gl_simplex_polygon.cpp)</vh></v>
<v t="leo.20201108101522.7"><vh>void GLSimplexPolygon::drawNodes (gl_simplex_polygon.cpp)</vh></v>
</v>
<v t="leo.20201108101522.8"><vh>@clean gl_simplex_segment.cpp</vh>
<v t="leo.20201108101522.9"><vh>void GLSimplexSegment::_init (gl_simplex_segment.cpp)</vh></v>
<v t="leo.20201108101522.10"><vh>void GLSimplexSegment::initialize (gl_simplex_segment.cpp)</vh></v>
<v t="leo.20201108101522.11"><vh>void GLSimplexSegment::finalize (gl_simplex_segment.cpp)</vh></v>
<v t="leo.20201108101522.12"><vh>void GLSimplexSegment::draw (gl_simplex_segment.cpp)</vh></v>
<v t="leo.20201108101522.13"><vh>void GLSimplexSegment::drawNormal (gl_simplex_segment.cpp)</vh></v>
<v t="leo.20201108101522.14"><vh>void GLSimplexSegment::drawWired (gl_simplex_segment.cpp)</vh></v>
<v t="leo.20201108101522.15"><vh>void GLSimplexSegment::drawNodes (gl_simplex_segment.cpp)</vh></v>
</v>
<v t="leo.20201108101522.16"><vh>@clean gl_simplex_tetrahedra.cpp</vh>
<v t="leo.20201108101522.17"><vh>void GLSimplexTetrahedra::_init (gl_simplex_tetrahedra.cpp)</vh></v>
<v t="leo.20201108101522.18"><vh>void GLSimplexTetrahedra::initialize (gl_simplex_tetrahedra.cpp)</vh></v>
<v t="leo.20201108101522.19"><vh>void GLSimplexTetrahedra::finalize (gl_simplex_tetrahedra.cpp)</vh></v>
<v t="leo.20201108101522.20"><vh>void GLSimplexTetrahedra::draw (gl_simplex_tetrahedra.cpp)</vh></v>
<v t="leo.20201108101522.21"><vh>void GLSimplexTetrahedra::drawNormal (gl_simplex_tetrahedra.cpp)</vh></v>
<v t="leo.20201108101522.22"><vh>void GLSimplexTetrahedra::drawWired (gl_simplex_tetrahedra.cpp)</vh></v>
<v t="leo.20201108101522.23"><vh>void GLSimplexTetrahedra::drawNodes (gl_simplex_tetrahedra.cpp)</vh></v>
</v>
<v t="leo.20201108101522.24"><vh>@clean gl_texture.cpp</vh>
<v t="leo.20201108101522.25"><vh>void GLTexture::load (gl_texture.cpp)</vh></v>
<v t="leo.20201108101522.26"><vh>void GLTexture::unload (gl_texture.cpp)</vh></v>
</v>
<v t="leo.20201108101522.27"><vh>@clean gl_text_renderer.cpp</vh>
<v t="leo.20201108101522.28"><vh>void GLTextRenderer::_init (gl_text_renderer.cpp)</vh></v>
<v t="leo.20201108101522.29"><vh>void GLTextRenderer::add (gl_text_renderer.cpp)</vh></v>
<v t="leo.20201108101522.30"><vh>void GLTextRenderer::clear (gl_text_renderer.cpp)</vh></v>
<v t="leo.20201108101522.31"><vh>void GLTextRenderer::render (gl_text_renderer.cpp)</vh></v>
</v>
<v t="leo.20201108101522.32"><vh>@clean gl_text_renderer_item.cpp</vh>
<v t="leo.20201108101522.33"><vh>void GLTextRendererItem::_init (gl_text_renderer_item.cpp)</vh></v>
</v>
<v t="leo.20201108101522.34"><vh>@clean gl_vector_field.cpp</vh>
<v t="leo.20201108101522.35"><vh>class VectorFieldItem</vh>
<v t="leo.20201108101522.36"><vh>VectorFieldItem.const RR3Vector</vh></v>
</v>
<v t="leo.20201108101522.37"><vh>void GLVectorField::_init (gl_vector_field.cpp)</vh></v>
<v t="leo.20201108101522.38"><vh>const SessionEntityID (gl_vector_field.cpp)</vh></v>
<v t="leo.20201108101522.39"><vh>void GLVectorField::initialize (gl_vector_field.cpp)</vh></v>
<v t="leo.20201108101522.40"><vh>void GLVectorField::finalize (gl_vector_field.cpp)</vh></v>
<v t="leo.20201108101522.41"><vh>void GLVectorField::draw (gl_vector_field.cpp)</vh></v>
</v>
<v t="leo.20201108101522.42"><vh>@clean gl_widget.cpp</vh>
<v t="leo.20201108101522.43"><vh>void GLWidget::setModelID (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.44"><vh>void GLWidget::initializeGL (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.45"><vh>void GLWidget::resizeGL (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.46"><vh>void GLWidget::paintGL (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.47"><vh>void GLWidget::drawBackgroundGradient (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.48"><vh>void GLWidget::drawModel (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.49"><vh>void GLWidget::drawValueRanges (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.50"><vh>void GLWidget::drawValueRange (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.51"><vh>void GLWidget::drawMessageBox (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.52"><vh>void GLWidget::drawInfoBox (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.53"><vh>void GLWidget::applyTransformations (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.54"><vh>void GLWidget::processActionEvent (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.55"><vh>void GLWidget::mousePressEvent (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.56"><vh>void GLWidget::mouseReleaseEvent (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.57"><vh>void GLWidget::mouseMoveEvent (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.58"><vh>void GLWidget::enterEvent (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.59"><vh>void GLWidget::leaveEvent (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.60"><vh>void GLWidget::wheelEvent (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.61"><vh>void GLWidget::keyPressEvent (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.62"><vh>void GLWidget::keyReleaseEvent (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.63"><vh>void GLWidget::calculateModelScale (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.64"><vh>void GLWidget::calculatePickRay (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.65"><vh>void GLWidget::convertModelToScreen (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.66"><vh>void GLWidget::convertScreenToModel (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.67"><vh>void GLWidget::showLight (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.68"><vh>void GLWidget::transformPoint (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.69"><vh>void GLWidget::resetView (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.70"><vh>void GLWidget::setClippingPlane (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.71"><vh>void GLWidget::onEntityVisibilityChanged (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.72"><vh>void GLWidget::onDisplayPropertiesChanged (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.73"><vh>void GLWidget::onVariableDataChanged (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.74"><vh>void GLWidget::onVariableDataChanged (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.75"><vh>void GLWidget::onModelChanged (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.76"><vh>void GLWidget::onResultsChanged (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.77"><vh>void GLWidget::onBeginDrawStreamLinePosition (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.78"><vh>void GLWidget::onEndDrawStreamLinePosition (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.79"><vh>void GLWidget::onBeginDrawScaleOrigin (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.80"><vh>void GLWidget::onEndDrawScaleOrigin (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.81"><vh>void GLWidget::onBeginDrawRotationOrigin (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.82"><vh>void GLWidget::onEndDrawRotationOrigin (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.83"><vh>void GLWidget::onBeginDrawLocalDirections (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.84"><vh>void GLWidget::onEndDrawLocalDirections (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.85"><vh>void GLWidget::onBeginDrawCutPlane (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.86"><vh>void GLWidget::onEndDrawCutPlane (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.87"><vh>void GLWidget::onBeginDrawMoveNodes (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.88"><vh>void GLWidget::onEndDrawMoveNodes (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.89"><vh>void GLWidget::onDrawObjectAdded (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.90"><vh>void GLWidget::onDrawObjectRemoved (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.91"><vh>void GLWidget::onDrawObjectChanged (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.92"><vh>const GLModelList (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.93"><vh>const GLActionEvent (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.94"><vh>const GLDisplayProperties (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.95"><vh>bool GLWidget::getUseGLVoidModelList (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.96"><vh>void GLWidget::setUseGLVoidModelList (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.97"><vh>bool GLWidget::getUseGlCullFace (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.98"><vh>void GLWidget::setUseGlCullFace (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.99"><vh>void GLWidget::takeScreenShot (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.100"><vh>void GLWidget::qglColor (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.101"><vh>void GLWidget::qglClearColor (gl_widget.cpp)</vh></v>
<v t="leo.20201108101522.102"><vh>void GLWidget::renderText (gl_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101522.103"><vh>@clean graph_data.cpp</vh>
<v t="leo.20201108101522.104"><vh>void GraphData::_init (graph_data.cpp)</vh></v>
<v t="leo.20201108101522.105"><vh>void GraphData::setTypeMask (graph_data.cpp)</vh></v>
<v t="leo.20201108101522.106"><vh>const QString (graph_data.cpp)</vh></v>
<v t="leo.20201108101522.107"><vh>void GraphData::setTitle (graph_data.cpp)</vh></v>
<v t="leo.20201108101522.108"><vh>const QString (graph_data.cpp)</vh></v>
<v t="leo.20201108101522.109"><vh>void GraphData::setXLabel (graph_data.cpp)</vh></v>
<v t="leo.20201108101522.110"><vh>const QString (graph_data.cpp)</vh></v>
<v t="leo.20201108101522.111"><vh>void GraphData::setYLabel (graph_data.cpp)</vh></v>
<v t="leo.20201108101522.112"><vh>void GraphData::setLimits (graph_data.cpp)</vh></v>
</v>
<v t="leo.20201108101522.113"><vh>@clean graph_dialog.cpp</vh></v>
<v t="leo.20201108101522.114"><vh>@clean graph_object.cpp</vh>
<v t="leo.20201108101522.115"><vh>const GraphData (graph_object.cpp)</vh></v>
<v t="leo.20201108101522.116"><vh>void GraphObject::setData (graph_object.cpp)</vh></v>
<v t="leo.20201108101522.117"><vh>void GraphObject::setDataChanged (graph_object.cpp)</vh></v>
<v t="leo.20201108101522.118"><vh>void GraphObject::setSourceReadInterval (graph_object.cpp)</vh></v>
<v t="leo.20201108101522.119"><vh>void GraphObject::readSource (graph_object.cpp)</vh></v>
<v t="leo.20201108101522.120"><vh>void GraphObject::loadData (graph_object.cpp)</vh></v>
</v>
<v t="leo.20201108101522.121"><vh>@clean graph_widget.cpp</vh>
<v t="leo.20201108101522.122"><vh>void GraphWidget::setShowPointer (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.123"><vh>void GraphWidget::setPaintGraphLimits (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.124"><vh>void GraphWidget::setPaintX0 (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.125"><vh>void GraphWidget::setPaintY0 (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.126"><vh>void GraphWidget::paintEvent (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.127"><vh>void GraphWidget::mousePressEvent (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.128"><vh>void GraphWidget::mouseMoveEvent (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.129"><vh>void GraphWidget::enterEvent (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.130"><vh>void GraphWidget::leaveEvent (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.131"><vh>void GraphWidget::paintSetup (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.132"><vh>void GraphWidget::paintPoints (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.133"><vh>void GraphWidget::paintLines (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.134"><vh>void GraphWidget::paintBars (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.135"><vh>void GraphWidget::paintTitle (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.136"><vh>void GraphWidget::paintPointer (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.137"><vh>void GraphWidget::paintLimits (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.138"><vh>void GraphWidget::paintXLine (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.139"><vh>void GraphWidget::paintYLine (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.140"><vh>void GraphWidget::paintXLabel (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.141"><vh>void GraphWidget::paintYLabel (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.142"><vh>void GraphWidget::paintXAxis (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.143"><vh>void GraphWidget::paintYAxis (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.144"><vh>void GraphWidget::paintPosition (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.145"><vh>void GraphWidget::updateLimits (graph_widget.cpp)</vh></v>
<v t="leo.20201108101522.146"><vh>void GraphWidget::onGraphDataChanged (graph_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101522.147"><vh>@clean help_actions_widget.cpp</vh></v>
<v t="leo.20201108101522.148"><vh>@clean help_center_dialog.cpp</vh></v>
<v t="leo.20201108101523.1"><vh>@clean help_general_widget.cpp</vh></v>
<v t="leo.20201108101523.2"><vh>@clean help_tips_widget.cpp</vh></v>
<v t="leo.20201108101523.3"><vh>@clean help_tutorial_widget.cpp</vh></v>
<v t="leo.20201108101523.4"><vh>@clean http_request_input.cpp</vh>
<v t="leo.20201108101523.5"><vh>void HttpRequestInput::_init (http_request_input.cpp)</vh></v>
<v t="leo.20201108101523.6"><vh>const QString (http_request_input.cpp)</vh></v>
<v t="leo.20201108101523.7"><vh>void HttpRequestInput::setUrlStr (http_request_input.cpp)</vh></v>
<v t="leo.20201108101523.8"><vh>const QString (http_request_input.cpp)</vh></v>
<v t="leo.20201108101523.9"><vh>void HttpRequestInput::setVariableLayout (http_request_input.cpp)</vh></v>
<v t="leo.20201108101523.10"><vh>const QMap (http_request_input.cpp)</vh></v>
<v t="leo.20201108101523.11"><vh>const QList (http_request_input.cpp)</vh></v>
<v t="leo.20201108101523.12"><vh>void HttpRequestInput::addVariable (http_request_input.cpp)</vh></v>
<v t="leo.20201108101523.13"><vh>void HttpRequestInput::addFile (http_request_input.cpp)</vh></v>
</v>
<v t="leo.20201108101523.14"><vh>@clean http_request_worker.cpp</vh>
<v t="leo.20201108101523.15"><vh>const QByteArray (http_request_worker.cpp)</vh></v>
<v t="leo.20201108101523.16"><vh>const QString (http_request_worker.cpp)</vh></v>
<v t="leo.20201108101523.17"><vh>void HttpRequestWorker::execute (http_request_worker.cpp)</vh></v>
<v t="leo.20201108101523.18"><vh>void HttpRequestWorker::onManagerAuthenticationRequired (http_request_worker.cpp)</vh></v>
<v t="leo.20201108101523.19"><vh>void HttpRequestWorker::onManagerEncrypted (http_request_worker.cpp)</vh></v>
<v t="leo.20201108101523.20"><vh>void HttpRequestWorker::onManagerFinished (http_request_worker.cpp)</vh></v>
<v t="leo.20201108101523.21"><vh>void HttpRequestWorker::onManagerNetworkAccessibleChanged (http_request_worker.cpp)</vh></v>
<v t="leo.20201108101523.22"><vh>void HttpRequestWorker::onManagerPreSharedKeyAuthenticationRequired (http_request_worker.cpp)</vh></v>
<v t="leo.20201108101523.23"><vh>void HttpRequestWorker::onManagerProxyAuthenticationRequired (http_request_worker.cpp)</vh></v>
<v t="leo.20201108101523.24"><vh>void HttpRequestWorker::onSslErrors (http_request_worker.cpp)</vh></v>
</v>
<v t="leo.20201108101523.25"><vh>@clean ic_manager_tree.cpp</vh>
<v t="leo.20201108101523.26"><vh>typedef enum (ic_manager_tree.cpp)</vh></v>
<v t="leo.20201108101523.27"><vh>void ICManagerTree::populate (ic_manager_tree.cpp)</vh></v>
<v t="leo.20201108101523.28"><vh>void ICManagerTree::onModelSelectionChanged (ic_manager_tree.cpp)</vh></v>
<v t="leo.20201108101523.29"><vh>void ICManagerTree::onProblemChanged (ic_manager_tree.cpp)</vh></v>
<v t="leo.20201108101523.30"><vh>void ICManagerTree::onItemChanged (ic_manager_tree.cpp)</vh></v>
<v t="leo.20201108101523.31"><vh>void ICManagerTree::onItemSelectionChanged (ic_manager_tree.cpp)</vh></v>
<v t="leo.20201108101523.32"><vh>void ICManagerTree::onIcSelected (ic_manager_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101523.33"><vh>@clean ic_tree.cpp</vh>
<v t="leo.20201108101523.34"><vh>typedef enum (ic_tree.cpp)</vh></v>
<v t="leo.20201108101523.35"><vh>void ICTree::populate (ic_tree.cpp)</vh></v>
<v t="leo.20201108101523.36"><vh>void ICTree::updateSelectedEntities (ic_tree.cpp)</vh></v>
<v t="leo.20201108101523.37"><vh>void ICTree::onIcSelected (ic_tree.cpp)</vh></v>
<v t="leo.20201108101523.38"><vh>void ICTree::onIcValueChanged (ic_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101523.39"><vh>@clean iso_dialog.cpp</vh>
<v t="leo.20201108101523.40"><vh>int IsoDialog::exec (iso_dialog.cpp)</vh></v>
<v t="leo.20201108101523.41"><vh>void IsoDialog::createDialog (iso_dialog.cpp)</vh></v>
<v t="leo.20201108101523.42"><vh>void IsoDialog::onVariableTreeSelectionChanged (iso_dialog.cpp)</vh></v>
<v t="leo.20201108101523.43"><vh>void IsoDialog::onModelTreeSelectionChanged (iso_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101523.44"><vh>@clean job.cpp</vh>
<v t="leo.20201108101523.45"><vh>bool Job::isFinished (job.cpp)</vh></v>
<v t="leo.20201108101523.46"><vh>bool Job::getAutoDelete (job.cpp)</vh></v>
<v t="leo.20201108101523.47"><vh>void Job::setAutoDelete (job.cpp)</vh></v>
<v t="leo.20201108101523.48"><vh>void Job::setBlocking (job.cpp)</vh></v>
<v t="leo.20201108101523.49"><vh>void Job::exec (job.cpp)</vh></v>
<v t="leo.20201108101523.50"><vh>void Job::process (job.cpp)</vh></v>
<v t="leo.20201108101523.51"><vh>void Job::run (job.cpp)</vh></v>
</v>
<v t="leo.20201108101523.52"><vh>@clean job_manager.cpp</vh>
<v t="leo.20201108101523.53"><vh>void JobManager::submit (job_manager.cpp)</vh></v>
<v t="leo.20201108101523.54"><vh>void JobManager::onJobBlocking (job_manager.cpp)</vh></v>
<v t="leo.20201108101523.55"><vh>void JobManager::onJobStarted (job_manager.cpp)</vh></v>
<v t="leo.20201108101523.56"><vh>void JobManager::onJobFinished (job_manager.cpp)</vh></v>
<v t="leo.20201108101523.57"><vh>void JobManager::processWaitingJobs (job_manager.cpp)</vh></v>
<v t="leo.20201108101523.58"><vh>void JobManager::processFinishedJobs (job_manager.cpp)</vh></v>
<v t="leo.20201108101523.59"><vh>void JobManager::startJob (job_manager.cpp)</vh></v>
</v>
<v t="leo.20201108101523.60"><vh>@clean keyboard_shortcuts_edit.cpp</vh>
<v t="leo.20201108101523.61"><vh>void KeyboardShortcutsEdit::resetToDefault (keyboard_shortcuts_edit.cpp)</vh></v>
<v t="leo.20201108101523.62"><vh>void KeyboardShortcutsEdit::populateTree (keyboard_shortcuts_edit.cpp)</vh></v>
<v t="leo.20201108101523.63"><vh>void KeyboardShortcutsEdit::onSelectionChanged (keyboard_shortcuts_edit.cpp)</vh></v>
<v t="leo.20201108101523.64"><vh>void KeyboardShortcutsEdit::onResetAllClicked (keyboard_shortcuts_edit.cpp)</vh></v>
<v t="leo.20201108101523.65"><vh>void KeyboardShortcutsEdit::onShortcutChanged (keyboard_shortcuts_edit.cpp)</vh>
<v t="leo.20201108101523.66"><vh>int response (keyboard_shortcuts_edit.cpp)</vh></v>
</v>
</v>
<v t="leo.20201108101523.67"><vh>@clean light_properties_widget.cpp</vh>
<v t="leo.20201108101523.68"><vh>const RGLLight (light_properties_widget.cpp)</vh></v>
<v t="leo.20201108101523.69"><vh>void LightPropertiesWidget::lightToggled (light_properties_widget.cpp)</vh></v>
<v t="leo.20201108101523.70"><vh>void LightPropertiesWidget::ambientColorChanged (light_properties_widget.cpp)</vh></v>
<v t="leo.20201108101523.71"><vh>void LightPropertiesWidget::diffuseColorChanged (light_properties_widget.cpp)</vh></v>
<v t="leo.20201108101523.72"><vh>void LightPropertiesWidget::specularColorChanged (light_properties_widget.cpp)</vh></v>
<v t="leo.20201108101523.73"><vh>void LightPropertiesWidget::positionChanged (light_properties_widget.cpp)</vh></v>
<v t="leo.20201108101523.74"><vh>void LightPropertiesWidget::directionChanged (light_properties_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101523.75"><vh>@clean local_direction_widget.cpp</vh>
<v t="leo.20201108101523.76"><vh>void LocalDirectionWidget::setLocalDirection (local_direction_widget.cpp)</vh></v>
<v t="leo.20201108101523.77"><vh>void LocalDirectionWidget::showEvent (local_direction_widget.cpp)</vh></v>
<v t="leo.20201108101523.78"><vh>void LocalDirectionWidget::onPositionChanged (local_direction_widget.cpp)</vh></v>
<v t="leo.20201108101523.79"><vh>void LocalDirectionWidget::onDirectionChanged (local_direction_widget.cpp)</vh></v>
<v t="leo.20201108101523.80"><vh>void LocalDirectionWidget::onCancelButtonClicked (local_direction_widget.cpp)</vh></v>
<v t="leo.20201108101523.81"><vh>void LocalDirectionWidget::onOkButtonClicked (local_direction_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101523.82"><vh>@clean locker.cpp</vh>
<v t="leo.20201108101523.83"><vh>void Locker::initialize (locker.cpp)</vh></v>
<v t="leo.20201108101523.84"><vh>void lockHandler (locker.cpp)</vh></v>
</v>
<v t="leo.20201108101523.85"><vh>@clean logger.cpp</vh>
<v t="leo.20201108101523.86"><vh>void Logger::initialize (logger.cpp)</vh></v>
<v t="leo.20201108101523.87"><vh>void Logger::halt (logger.cpp)</vh></v>
<v t="leo.20201108101523.88"><vh>void Logger::unhalt (logger.cpp)</vh></v>
<v t="leo.20201108101523.89"><vh>void Logger::logHandler (logger.cpp)</vh></v>
</v>
<v t="leo.20201108101523.90"><vh>@clean log_browser.cpp</vh>
<v t="leo.20201108101523.91"><vh>void LogBrowser::clearLog (log_browser.cpp)</vh></v>
<v t="leo.20201108101523.92"><vh>void LogBrowser::onFileChanged (log_browser.cpp)</vh></v>
</v>
<v t="leo.20201108101523.93"><vh>@clean log_browser_dialog.cpp</vh>
<v t="leo.20201108101523.94"><vh>int LogBrowserDialog::exec (log_browser_dialog.cpp)</vh></v>
<v t="leo.20201108101523.95"><vh>void LogBrowserDialog::onClearButtonClicked (log_browser_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101523.96"><vh>@clean main.cpp</vh>
<v t="leo.20201108101523.97"><vh>int main (main.cpp)</vh></v>
</v>
<v t="leo.20201108101524.1"><vh>@clean main_settings.cpp</vh>
<v t="leo.20201108101524.2"><vh>const QString (main_settings.cpp)</vh></v>
<v t="leo.20201108101524.3"><vh>void MainSettings::setDirApplicationPath (main_settings.cpp)</vh></v>
<v t="leo.20201108101524.4"><vh>const ApplicationSettings (main_settings.cpp)</vh></v>
<v t="leo.20201108101524.5"><vh>const RVersion (main_settings.cpp)</vh></v>
</v>
<v t="leo.20201108101524.6"><vh>@clean main_window.cpp</vh>
<v t="leo.20201108101524.7"><vh>void MainWindow::showTransformGeometryWidget (main_window.cpp)</vh></v>
<v t="leo.20201108101524.8"><vh>void MainWindow::hideTransformGeometryWidget (main_window.cpp)</vh></v>
<v t="leo.20201108101524.9"><vh>void MainWindow::showDrawWidget (main_window.cpp)</vh></v>
<v t="leo.20201108101524.10"><vh>void MainWindow::hideDrawWidget (main_window.cpp)</vh></v>
<v t="leo.20201108101524.11"><vh>void MainWindow::progressAutoHideEnable (main_window.cpp)</vh></v>
<v t="leo.20201108101524.12"><vh>void MainWindow::progressAutoHideDisable (main_window.cpp)</vh></v>
<v t="leo.20201108101524.13"><vh>void MainWindow::showCustomDockWidget (main_window.cpp)</vh></v>
<v t="leo.20201108101524.14"><vh>void MainWindow::hideCustomDockWidget (main_window.cpp)</vh></v>
<v t="leo.20201108101524.15"><vh>void MainWindow::createMenus (main_window.cpp)</vh></v>
<v t="leo.20201108101524.16"><vh>void MainWindow::createToolBars (main_window.cpp)</vh></v>
<v t="leo.20201108101524.17"><vh>void MainWindow::createStatusBar (main_window.cpp)</vh></v>
<v t="leo.20201108101524.18"><vh>void MainWindow::createDownloadBar (main_window.cpp)</vh></v>
<v t="leo.20201108101524.19"><vh>void MainWindow::createCentralWidget (main_window.cpp)</vh></v>
<v t="leo.20201108101524.20"><vh>void MainWindow::createModelDock (main_window.cpp)</vh></v>
<v t="leo.20201108101524.21"><vh>void MainWindow::createProblemDock (main_window.cpp)</vh></v>
<v t="leo.20201108101524.22"><vh>void MainWindow::createDocumentDock (main_window.cpp)</vh></v>
<v t="leo.20201108101524.23"><vh>void MainWindow::createRecordsDock (main_window.cpp)</vh></v>
<v t="leo.20201108101524.24"><vh>void MainWindow::createBcDock (main_window.cpp)</vh></v>
<v t="leo.20201108101524.25"><vh>void MainWindow::createIcDock (main_window.cpp)</vh></v>
<v t="leo.20201108101524.26"><vh>void MainWindow::createEcDock (main_window.cpp)</vh></v>
<v t="leo.20201108101524.27"><vh>void MainWindow::createMaterialDock (main_window.cpp)</vh></v>
<v t="leo.20201108101524.28"><vh>void MainWindow::createResultsDock (main_window.cpp)</vh></v>
<v t="leo.20201108101524.29"><vh>void MainWindow::readSettings (main_window.cpp)</vh></v>
<v t="leo.20201108101524.30"><vh>void MainWindow::writeSettings (main_window.cpp)</vh></v>
<v t="leo.20201108101524.31"><vh>void MainWindow::closeEvent (main_window.cpp)</vh></v>
<v t="leo.20201108101524.32"><vh>void MainWindow::progressBar (main_window.cpp)</vh></v>
<v t="leo.20201108101524.33"><vh>void MainWindow::progressBarInitialize (main_window.cpp)</vh></v>
<v t="leo.20201108101524.34"><vh>void MainWindow::progressBarFinalize (main_window.cpp)</vh></v>
<v t="leo.20201108101524.35"><vh>void MainWindow::setEnabled (main_window.cpp)</vh></v>
<v t="leo.20201108101524.36"><vh>void MainWindow::enable (main_window.cpp)</vh></v>
<v t="leo.20201108101524.37"><vh>void MainWindow::disable (main_window.cpp)</vh></v>
<v t="leo.20201108101524.38"><vh>void MainWindow::onMainProgress (main_window.cpp)</vh></v>
<v t="leo.20201108101524.39"><vh>void MainWindow::onMainProgressInitialize (main_window.cpp)</vh></v>
<v t="leo.20201108101524.40"><vh>void MainWindow::onMainProgressFinalize (main_window.cpp)</vh></v>
<v t="leo.20201108101524.41"><vh>void MainWindow::onDownloadProgress (main_window.cpp)</vh></v>
<v t="leo.20201108101524.42"><vh>void MainWindow::onDownloadProgressInitialize (main_window.cpp)</vh></v>
<v t="leo.20201108101524.43"><vh>void MainWindow::onDownloadProgressFinalize (main_window.cpp)</vh></v>
<v t="leo.20201108101524.44"><vh>void MainWindow::onDrawObjectAdded (main_window.cpp)</vh></v>
<v t="leo.20201108101524.45"><vh>void MainWindow::onDrawObjectRemoved (main_window.cpp)</vh></v>
<v t="leo.20201108101524.46"><vh>void MainWindow::onJobBlocking (main_window.cpp)</vh></v>
<v t="leo.20201108101524.47"><vh>void MainWindow::onJobStarted (main_window.cpp)</vh></v>
<v t="leo.20201108101524.48"><vh>void MainWindow::onJobEnded (main_window.cpp)</vh></v>
<v t="leo.20201108101524.49"><vh>void MainWindow::onModelAdded (main_window.cpp)</vh></v>
<v t="leo.20201108101524.50"><vh>void MainWindow::onModelRemoved (main_window.cpp)</vh></v>
<v t="leo.20201108101524.51"><vh>void MainWindow::onModelChanged (main_window.cpp)</vh></v>
<v t="leo.20201108101524.52"><vh>void MainWindow::onProblemChanged (main_window.cpp)</vh></v>
<v t="leo.20201108101524.53"><vh>void MainWindow::onResultsChanged (main_window.cpp)</vh></v>
<v t="leo.20201108101524.54"><vh>void MainWindow::onEntityVisibilityChanged (main_window.cpp)</vh></v>
<v t="leo.20201108101524.55"><vh>void MainWindow::onGeometryTransformFinalize (main_window.cpp)</vh></v>
<v t="leo.20201108101524.56"><vh>void MainWindow::onNHistoryRecordsChanged (main_window.cpp)</vh></v>
<v t="leo.20201108101524.57"><vh>void MainWindow::onToolbarIconSizeChanged (main_window.cpp)</vh></v>
</v>
<v t="leo.20201108101524.58"><vh>@clean mark_entity_dialog.cpp</vh>
<v t="leo.20201108101524.59"><vh>int MarkEntityDialog::exec (mark_entity_dialog.cpp)</vh></v>
<v t="leo.20201108101524.60"><vh>bool MarkEntityDialog::autoMarkEntities (mark_entity_dialog.cpp)</vh></v>
<v t="leo.20201108101524.61"><vh>bool MarkEntityDialog::markEntities (mark_entity_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101524.62"><vh>@clean material_list.cpp</vh>
<v t="leo.20201108101524.63"><vh>void MaterialList::initialize (material_list.cpp)</vh></v>
<v t="leo.20201108101524.64"><vh>void MaterialList::addMaterial (material_list.cpp)</vh></v>
<v t="leo.20201108101524.65"><vh>void MaterialList::add (material_list.cpp)</vh></v>
<v t="leo.20201108101524.66"><vh>int MaterialList::remove (material_list.cpp)</vh></v>
<v t="leo.20201108101524.67"><vh>bool MaterialList::rename (material_list.cpp)</vh></v>
<v t="leo.20201108101524.68"><vh>void MaterialList::selectMaterial (material_list.cpp)</vh></v>
<v t="leo.20201108101524.69"><vh>const QString (material_list.cpp)</vh></v>
<v t="leo.20201108101524.70"><vh>void MaterialList::signalMaterialChanged (material_list.cpp)</vh></v>
<v t="leo.20201108101524.71"><vh>void MaterialList::readStore (material_list.cpp)</vh></v>
</v>
<v t="leo.20201108101524.72"><vh>@clean material_manager_tree.cpp</vh>
<v t="leo.20201108101524.73"><vh>typedef enum (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.74"><vh>void MaterialManagerTree::populate (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.75"><vh>void MaterialManagerTree::updateCheckStates (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.76"><vh>void MaterialManagerTree::updateProblemTypeMask (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.77"><vh>void MaterialManagerTree::setItemValid (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.78"><vh>void MaterialManagerTree::addMaterial (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.79"><vh>void MaterialManagerTree::onModelSelectionChanged (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.80"><vh>void MaterialManagerTree::onModelAdded (material_manager_tree.cpp)</vh>
<v t="leo.20201108101524.81"><vh>int response (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.82"><vh>int response (material_manager_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101524.83"><vh>void MaterialManagerTree::onProblemChanged (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.84"><vh>void MaterialManagerTree::onMaterialAdded (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.85"><vh>void MaterialManagerTree::onMaterialRemoved (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.86"><vh>void MaterialManagerTree::onMaterialRenamed (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.87"><vh>void MaterialManagerTree::onMaterialChanged (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.88"><vh>void MaterialManagerTree::onItemChanged (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.89"><vh>void MaterialManagerTree::onItemDoubleClicked (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.90"><vh>void MaterialManagerTree::onItemSelectionChanged (material_manager_tree.cpp)</vh></v>
<v t="leo.20201108101524.91"><vh>void MaterialManagerTree::onMaterialSelected (material_manager_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101524.92"><vh>@clean material_property_add_dialog.cpp</vh>
<v t="leo.20201108101524.93"><vh>int MaterialPropertyAddDialog::exec (material_property_add_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101524.94"><vh>@clean material_property_edit_dialog.cpp</vh>
<v t="leo.20201108101524.95"><vh>int MaterialPropertyEditDialog::exec (material_property_edit_dialog.cpp)</vh></v>
<v t="leo.20201108101524.96"><vh>void MaterialPropertyEditDialog::onTableSizeChanged (material_property_edit_dialog.cpp)</vh></v>
<v t="leo.20201108101524.97"><vh>void MaterialPropertyEditDialog::onSpinNValuesChanged (material_property_edit_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101524.98"><vh>@clean material_property_edit_table.cpp</vh>
<v t="leo.20201108101524.99"><vh>void MaterialPropertyEditTable::populate (material_property_edit_table.cpp)</vh></v>
</v>
<v t="leo.20201108101524.100"><vh>@clean material_property_line_edit.cpp</vh>
<v t="leo.20201108101524.101"><vh>void MaterialPropertyLineEdit::onValueChaged (material_property_line_edit.cpp)</vh></v>
</v>
<v t="leo.20201108101524.102"><vh>@clean material_tree.cpp</vh>
<v t="leo.20201108101524.103"><vh>typedef enum (material_tree.cpp)</vh></v>
<v t="leo.20201108101524.104"><vh>void MaterialTree::populate (material_tree.cpp)</vh></v>
<v t="leo.20201108101524.105"><vh>void MaterialTree::onMaterialSelected (material_tree.cpp)</vh></v>
<v t="leo.20201108101524.106"><vh>void MaterialTree::onCurrentItemChanged (material_tree.cpp)</vh></v>
<v t="leo.20201108101524.107"><vh>void MaterialTree::onValueChanged (material_tree.cpp)</vh></v>
<v t="leo.20201108101524.108"><vh>void MaterialTree::onButtonValueClicked (material_tree.cpp)</vh></v>
<v t="leo.20201108101524.109"><vh>void MaterialTree::onPropertyAdd (material_tree.cpp)</vh></v>
<v t="leo.20201108101524.110"><vh>void MaterialTree::onPropertyDelete (material_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101524.111"><vh>@clean material_updater.cpp</vh>
<v t="leo.20201108101524.112"><vh>void MaterialUpdater::addMaterial (material_updater.cpp)</vh></v>
<v t="leo.20201108101524.113"><vh>void MaterialUpdater::run (material_updater.cpp)</vh></v>
</v>
<v t="leo.20201108101524.114"><vh>@clean matrix_solver_config_dialog.cpp</vh>
<v t="leo.20201108101524.115"><vh>int MatrixSolverConfigDialog::exec (matrix_solver_config_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101524.116"><vh>@clean merge_entity_dialog.cpp</vh>
<v t="leo.20201108101524.117"><vh>int MergeEntityDialog::exec (merge_entity_dialog.cpp)</vh></v>
<v t="leo.20201108101524.118"><vh>bool MergeEntityDialog::entitiesSelected (merge_entity_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101524.119"><vh>@clean merge_near_nodes_dialog.cpp</vh>
<v t="leo.20201108101524.120"><vh>int MergeNearNodesDialog::exec (merge_near_nodes_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101524.121"><vh>@clean mesh_generator.cpp</vh>
<v t="leo.20201108101524.122"><vh>void MeshGenerator::run (mesh_generator.cpp)</vh></v>
</v>
<v t="leo.20201108101525.1"><vh>@clean mesh_generator_dialog.cpp</vh>
<v t="leo.20201108101525.2"><vh>int MeshGeneratorDialog::exec (mesh_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101525.3"><vh>void MeshGeneratorDialog::updateMeshInput (mesh_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101525.4"><vh>void MeshGeneratorDialog::onSurfaceIntegrityStateChanged (mesh_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101525.5"><vh>void MeshGeneratorDialog::onQualityMeshGroupBoxClicked (mesh_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101525.6"><vh>void MeshGeneratorDialog::onVolumeConstraintValueChanged (mesh_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101525.7"><vh>void MeshGeneratorDialog::onMeshSizeFunctionMinValueChanged (mesh_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101525.8"><vh>void MeshGeneratorDialog::onMeshSizeFunctionMaxValueChanged (mesh_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101525.9"><vh>void MeshGeneratorDialog::onReconstructStateChanged (mesh_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101525.10"><vh>void MeshGeneratorDialog::onKeepResultsStateChanged (mesh_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101525.11"><vh>void MeshGeneratorDialog::onTetgenParamsGroupBoxClicked (mesh_generator_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101525.12"><vh>@clean mesh_setup_widget.cpp</vh>
<v t="leo.20201108101525.13"><vh>const std::vector (mesh_setup_widget.cpp)</vh></v>
<v t="leo.20201108101525.14"><vh>void MeshSetupWidget::onVariableListItemChanged (mesh_setup_widget.cpp)</vh></v>
<v t="leo.20201108101525.15"><vh>void MeshSetupWidget::onMinEdgeLengthChanged (mesh_setup_widget.cpp)</vh></v>
<v t="leo.20201108101525.16"><vh>void MeshSetupWidget::onMaxEdgeLengthChanged (mesh_setup_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101525.17"><vh>@clean modal_setup_widget.cpp</vh>
<v t="leo.20201108101525.18"><vh>void ModalSetupWidget::onModalMethodChanged (modal_setup_widget.cpp)</vh></v>
<v t="leo.20201108101525.19"><vh>void ModalSetupWidget::onNIterationsChanged (modal_setup_widget.cpp)</vh></v>
<v t="leo.20201108101525.20"><vh>void ModalSetupWidget::onNModesExtractChanged (modal_setup_widget.cpp)</vh></v>
<v t="leo.20201108101525.21"><vh>void ModalSetupWidget::onConvergenceValueChanged (modal_setup_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101525.22"><vh>@clean model.cpp</vh>
<v t="leo.20201108101525.23"><vh>void Model::_init (model.cpp)</vh></v>
<v t="leo.20201108101525.24"><vh>const QString (model.cpp)</vh></v>
<v t="leo.20201108101525.25"><vh>void Model::insertModel (model.cpp)</vh></v>
<v t="leo.20201108101525.26"><vh>const QString (model.cpp)</vh></v>
<v t="leo.20201108101525.27"><vh>void Model::setFileName (model.cpp)</vh></v>
<v t="leo.20201108101525.28"><vh>const RMeshInput (model.cpp)</vh></v>
<v t="leo.20201108101525.29"><vh>void Model::setMeshInput (model.cpp)</vh></v>
<v t="leo.20201108101525.30"><vh>void Model::initializeMeshInput (model.cpp)</vh></v>
<v t="leo.20201108101525.31"><vh>const RViewFactorMatrix (model.cpp)</vh></v>
<v t="leo.20201108101525.32"><vh>bool Model::canColorByPatch (model.cpp)</vh></v>
<v t="leo.20201108101525.33"><vh>bool Model::canColorByViewFactor (model.cpp)</vh></v>
<v t="leo.20201108101525.34"><vh>const QList (model.cpp)</vh></v>
<v t="leo.20201108101525.35"><vh>void Model::generatePatchColors (model.cpp)</vh></v>
<v t="leo.20201108101525.36"><vh>void Model::generateLineFromSurfaceEdges (model.cpp)</vh></v>
<v t="leo.20201108101525.37"><vh>const REntityGroupData (model.cpp)</vh></v>
<v t="leo.20201108101525.38"><vh>void Model::autoMarkSurfaces (model.cpp)</vh></v>
<v t="leo.20201108101525.39"><vh>void Model::markSurface (model.cpp)</vh></v>
<v t="leo.20201108101525.40"><vh>void Model::closeSurfaceHole (model.cpp)</vh></v>
<v t="leo.20201108101525.41"><vh>void Model::transformGeometry (model.cpp)</vh></v>
<v t="leo.20201108101525.42"><vh>void Model::updateSliverElements (model.cpp)</vh></v>
<v t="leo.20201108101525.43"><vh>void Model::updateIntersectedElements (model.cpp)</vh></v>
<v t="leo.20201108101525.44"><vh>bool Model::exportSliverElements (model.cpp)</vh></v>
<v t="leo.20201108101525.45"><vh>bool Model::exportIntersectedElements (model.cpp)</vh></v>
<v t="leo.20201108101525.46"><vh>bool Model::boolDifference (model.cpp)</vh></v>
<v t="leo.20201108101525.47"><vh>bool Model::boolIntersection (model.cpp)</vh></v>
<v t="leo.20201108101525.48"><vh>bool Model::boolUnion (model.cpp)</vh></v>
<v t="leo.20201108101525.49"><vh>bool Model::isSliver (model.cpp)</vh></v>
<v t="leo.20201108101525.50"><vh>bool Model::isIntersected (model.cpp)</vh></v>
<v t="leo.20201108101525.51"><vh>bool Model::isSelected (model.cpp)</vh></v>
<v t="leo.20201108101525.52"><vh>bool Model::isSelected (model.cpp)</vh></v>
<v t="leo.20201108101525.53"><vh>bool Model::getSelected (model.cpp)</vh></v>
<v t="leo.20201108101525.54"><vh>bool Model::getSelected (model.cpp)</vh></v>
<v t="leo.20201108101525.55"><vh>void Model::setSelected (model.cpp)</vh></v>
<v t="leo.20201108101525.56"><vh>void Model::setSelected (model.cpp)</vh></v>
<v t="leo.20201108101525.57"><vh>bool Model::isVisible (model.cpp)</vh></v>
<v t="leo.20201108101525.58"><vh>bool Model::isVisible (model.cpp)</vh></v>
<v t="leo.20201108101525.59"><vh>bool Model::getVisible (model.cpp)</vh></v>
<v t="leo.20201108101525.60"><vh>void Model::setVisible (model.cpp)</vh></v>
<v t="leo.20201108101525.61"><vh>bool Model::getDrawWire (model.cpp)</vh></v>
<v t="leo.20201108101525.62"><vh>void Model::setDrawWire (model.cpp)</vh></v>
<v t="leo.20201108101525.63"><vh>bool Model::getDrawEdges (model.cpp)</vh></v>
<v t="leo.20201108101525.64"><vh>void Model::setDrawEdges (model.cpp)</vh></v>
<v t="leo.20201108101525.65"><vh>bool Model::getDrawNodes (model.cpp)</vh></v>
<v t="leo.20201108101525.66"><vh>void Model::setDrawNodes (model.cpp)</vh></v>
<v t="leo.20201108101525.67"><vh>bool Model::getDrawElementNumbers (model.cpp)</vh></v>
<v t="leo.20201108101525.68"><vh>void Model::setDrawElementNumbers (model.cpp)</vh></v>
<v t="leo.20201108101525.69"><vh>bool Model::getDrawNodeNumbers (model.cpp)</vh></v>
<v t="leo.20201108101525.70"><vh>void Model::setDrawNodeNumbers (model.cpp)</vh></v>
<v t="leo.20201108101525.71"><vh>bool Model::getDrawArrowHeads (model.cpp)</vh></v>
<v t="leo.20201108101525.72"><vh>void Model::setDrawArrowHeads (model.cpp)</vh></v>
<v t="leo.20201108101525.73"><vh>bool Model::getDrawEqualArrowLengths (model.cpp)</vh></v>
<v t="leo.20201108101525.74"><vh>void Model::setDrawEqualArrowLengths (model.cpp)</vh></v>
<v t="leo.20201108101525.75"><vh>bool Model::getDrawArrowFrom (model.cpp)</vh></v>
<v t="leo.20201108101525.76"><vh>void Model::setDrawArrowFrom (model.cpp)</vh></v>
<v t="leo.20201108101525.77"><vh>bool Model::getColorByPatch (model.cpp)</vh></v>
<v t="leo.20201108101525.78"><vh>void Model::setColorByPatch (model.cpp)</vh></v>
<v t="leo.20201108101525.79"><vh>bool Model::getColorByViewFactor (model.cpp)</vh></v>
<v t="leo.20201108101525.80"><vh>void Model::setColorByViewFactor (model.cpp)</vh></v>
<v t="leo.20201108101525.81"><vh>void Model::setColor (model.cpp)</vh></v>
<v t="leo.20201108101525.82"><vh>void Model::glDrawLock (model.cpp)</vh></v>
<v t="leo.20201108101525.83"><vh>bool Model::glDrawTrylock (model.cpp)</vh></v>
<v t="leo.20201108101525.84"><vh>void Model::glDrawUnlock (model.cpp)</vh></v>
<v t="leo.20201108101525.85"><vh>void Model::glDraw (model.cpp)</vh></v>
<v t="leo.20201108101525.86"><vh>void Model::glDraw (model.cpp)</vh></v>
<v t="leo.20201108101525.87"><vh>const RInterpolatedElement (model.cpp)</vh></v>
<v t="leo.20201108101525.88"><vh>const RInterpolatedElement (model.cpp)</vh></v>
<v t="leo.20201108101525.89"><vh>bool Model::nodeIsOnEdge (model.cpp)</vh></v>
<v t="leo.20201108101525.90"><vh>bool Model::elementIsOnEdge (model.cpp)</vh></v>
<v t="leo.20201108101525.91"><vh>bool Model::findPickedElement (model.cpp)</vh></v>
<v t="leo.20201108101525.92"><vh>bool Model::findPickedNode (model.cpp)</vh></v>
<v t="leo.20201108101525.93"><vh>bool Model::findPickedHoleElement (model.cpp)</vh></v>
<v t="leo.20201108101525.94"><vh>void Model::update (model.cpp)</vh></v>
<v t="leo.20201108101525.95"><vh>void Model::read (model.cpp)</vh></v>
<v t="leo.20201108101525.96"><vh>void Model::write (model.cpp)</vh></v>
<v t="leo.20201108101525.97"><vh>void Model::loadViewFactorMatrix (model.cpp)</vh></v>
<v t="leo.20201108101525.98"><vh>void Model::unloadViewFactorMatrix (model.cpp)</vh></v>
<v t="leo.20201108101525.99"><vh>void Model::consolidate (model.cpp)</vh></v>
<v t="leo.20201108101525.100"><vh>void Model::undo (model.cpp)</vh></v>
<v t="leo.20201108101525.101"><vh>void Model::redo (model.cpp)</vh></v>
<v t="leo.20201108101525.102"><vh>void Model::storeCurentVersion (model.cpp)</vh></v>
<v t="leo.20201108101525.103"><vh>void Model::updateHistoryStackSize (model.cpp)</vh></v>
<v t="leo.20201108101525.104"><vh>void Model::clearEdgeNodes (model.cpp)</vh></v>
<v t="leo.20201108101525.105"><vh>void Model::createSweepEdgeElements (model.cpp)</vh></v>
</v>
<v t="leo.20201108101525.106"><vh>@clean model_action.cpp</vh>
<v t="leo.20201108101525.107"><vh>void ModelAction::addAction (model_action.cpp)</vh></v>
<v t="leo.20201108101525.108"><vh>void ModelAction::run (model_action.cpp)</vh></v>
<v t="leo.20201108101525.109"><vh>void ModelAction::executeAction (model_action.cpp)</vh></v>
<v t="leo.20201108101525.110"><vh>void ModelAction::autoMarkSurfaces (model_action.cpp)</vh></v>
<v t="leo.20201108101525.111"><vh>void ModelAction::markSurfaces (model_action.cpp)</vh></v>
<v t="leo.20201108101525.112"><vh>void ModelAction::closeSurfaceHole (model_action.cpp)</vh></v>
<v t="leo.20201108101525.113"><vh>void ModelAction::mergeNearNodes (model_action.cpp)</vh></v>
<v t="leo.20201108101525.114"><vh>void ModelAction::mergeEntities (model_action.cpp)</vh></v>
<v t="leo.20201108101525.115"><vh>void ModelAction::removeEntities (model_action.cpp)</vh></v>
<v t="leo.20201108101525.116"><vh>void ModelAction::createElement (model_action.cpp)</vh></v>
<v t="leo.20201108101525.117"><vh>void ModelAction::removeNodes (model_action.cpp)</vh></v>
<v t="leo.20201108101525.118"><vh>void ModelAction::purgeUnusedNodes (model_action.cpp)</vh></v>
<v t="leo.20201108101525.119"><vh>void ModelAction::purgeUnusedElements (model_action.cpp)</vh></v>
<v t="leo.20201108101525.120"><vh>void ModelAction::removeDuplicateNodes (model_action.cpp)</vh></v>
<v t="leo.20201108101525.121"><vh>void ModelAction::removeDuplicateElements (model_action.cpp)</vh></v>
<v t="leo.20201108101525.122"><vh>void ModelAction::removeElements (model_action.cpp)</vh></v>
<v t="leo.20201108101525.123"><vh>void ModelAction::generateLineFromEdges (model_action.cpp)</vh></v>
<v t="leo.20201108101525.124"><vh>void ModelAction::findSliverElements (model_action.cpp)</vh></v>
<v t="leo.20201108101525.125"><vh>void ModelAction::fixSliverElements (model_action.cpp)</vh></v>
<v t="leo.20201108101525.126"><vh>void ModelAction::exportSliverElements (model_action.cpp)</vh></v>
<v t="leo.20201108101525.127"><vh>void ModelAction::findIntersectedElements (model_action.cpp)</vh></v>
<v t="leo.20201108101525.128"><vh>void ModelAction::breakIntersectedElements (model_action.cpp)</vh></v>
<v t="leo.20201108101525.129"><vh>void ModelAction::exportIntersectedElements (model_action.cpp)</vh></v>
<v t="leo.20201108101525.130"><vh>void ModelAction::boolDifference (model_action.cpp)</vh></v>
<v t="leo.20201108101525.131"><vh>void ModelAction::boolIntersection (model_action.cpp)</vh></v>
<v t="leo.20201108101525.132"><vh>void ModelAction::boolUnion (model_action.cpp)</vh></v>
<v t="leo.20201108101525.133"><vh>void ModelAction::checkPointInsideSurface (model_action.cpp)</vh></v>
<v t="leo.20201108101525.134"><vh>void ModelAction::generatePatches (model_action.cpp)</vh></v>
<v t="leo.20201108101525.135"><vh>void ModelAction::calculateViewFactors (model_action.cpp)</vh></v>
<v t="leo.20201108101525.136"><vh>void ModelAction::swapSurfaceElementNormal (model_action.cpp)</vh></v>
<v t="leo.20201108101525.137"><vh>void ModelAction::swapSurfaceNormals (model_action.cpp)</vh></v>
<v t="leo.20201108101525.138"><vh>void ModelAction::syncSurfaceNormals (model_action.cpp)</vh></v>
<v t="leo.20201108101525.139"><vh>void ModelAction::coarsenSurface (model_action.cpp)</vh></v>
<v t="leo.20201108101525.140"><vh>void ModelAction::tetrahedralizeSurface (model_action.cpp)</vh></v>
<v t="leo.20201108101525.141"><vh>void ModelAction::consolidate (model_action.cpp)</vh></v>
<v t="leo.20201108101525.142"><vh>void ModelAction::geometryTransform (model_action.cpp)</vh></v>
<v t="leo.20201108101525.143"><vh>void ModelAction::applyVariableOnNode (model_action.cpp)</vh></v>
<v t="leo.20201108101525.144"><vh>void ModelAction::removeVariable (model_action.cpp)</vh></v>
</v>
<v t="leo.20201108101525.145"><vh>@clean model_action_input.cpp</vh>
<v t="leo.20201108101525.146"><vh>void ModelActionInput::_init (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.147"><vh>bool ModelActionInput::operator (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.148"><vh>bool ModelActionInput::getCloseHole (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.149"><vh>const QList (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.150"><vh>const QList (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.151"><vh>const QList (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.152"><vh>const RR3Vector (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.153"><vh>const GeometryTransformInput (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.154"><vh>void ModelActionInput::setAutoMarkSurfaces (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.155"><vh>void ModelActionInput::setMarkSurfaces (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.156"><vh>void ModelActionInput::setCloseSurfaceHole (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.157"><vh>void ModelActionInput::setMergeNearNodes (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.158"><vh>void ModelActionInput::setMergeEntities (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.159"><vh>void ModelActionInput::setRemoveEntities (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.160"><vh>void ModelActionInput::setCreateElement (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.161"><vh>void ModelActionInput::setRemoveNodes (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.162"><vh>void ModelActionInput::setPurgeUnusedNodes (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.163"><vh>void ModelActionInput::setPurgeUnusedElements (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.164"><vh>void ModelActionInput::setRemoveDuplicateNodes (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.165"><vh>void ModelActionInput::setRemoveDuplicateElements (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.166"><vh>void ModelActionInput::setRemoveElements (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.167"><vh>void ModelActionInput::setGenerateLinesFromEdges (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.168"><vh>void ModelActionInput::setFindSliverElements (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.169"><vh>void ModelActionInput::setFixSliverElements (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.170"><vh>void ModelActionInput::setFindIntersectedElements (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.171"><vh>void ModelActionInput::setBreakIntersectedElements (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.172"><vh>void ModelActionInput::setExportSliverElements (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.173"><vh>void ModelActionInput::setExportIntersectedElements (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.174"><vh>void ModelActionInput::setBoolDifference (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.175"><vh>void ModelActionInput::setBoolIntersection (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.176"><vh>void ModelActionInput::setBoolUnion (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.177"><vh>void ModelActionInput::setCheckPointInsideSurface (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.178"><vh>void ModelActionInput::setGeneratePatches (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.179"><vh>void ModelActionInput::setCalculateViewFactors (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.180"><vh>void ModelActionInput::setSwapSurfaceElementNormal (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.181"><vh>void ModelActionInput::setSwapSurfaceNormals (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.182"><vh>void ModelActionInput::setSyncSurfaceNormals (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.183"><vh>void ModelActionInput::setCoarsenSurface (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.184"><vh>void ModelActionInput::setTetrahedralizeSurface (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.185"><vh>void ModelActionInput::setConsolidate (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.186"><vh>void ModelActionInput::setGeometryTransform (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.187"><vh>void ModelActionInput::setApplyVariableOnNode (model_action_input.cpp)</vh></v>
<v t="leo.20201108101525.188"><vh>void ModelActionInput::setRemoveVariable (model_action_input.cpp)</vh></v>
</v>
<v t="leo.20201108101525.189"><vh>@clean model_entity_display_properties_tree.cpp</vh>
<v t="leo.20201108101525.190"><vh>typedef enum (model_entity_display_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.191"><vh>typedef enum (model_entity_display_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.192"><vh>void ModelEntityDisplayPropertiesTree::populate (model_entity_display_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.193"><vh>void ModelEntityDisplayPropertiesTree::onModelSelectionChanged (model_entity_display_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.194"><vh>void ModelEntityDisplayPropertiesTree::onModelChanged (model_entity_display_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.195"><vh>void ModelEntityDisplayPropertiesTree::onProblemChanged (model_entity_display_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.196"><vh>void ModelEntityDisplayPropertiesTree::onItemChanged (model_entity_display_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.197"><vh>void ModelEntityDisplayPropertiesTree::onColorChanged (model_entity_display_properties_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101525.198"><vh>@clean model_entity_geometric_properties_tree.cpp</vh>
<v t="leo.20201108101525.199"><vh>typedef enum (model_entity_geometric_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.200"><vh>typedef enum (model_entity_geometric_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.201"><vh>void ModelEntityGeometricPropertiesTree::populate (model_entity_geometric_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.202"><vh>void ModelEntityGeometricPropertiesTree::onModelSelectionChanged (model_entity_geometric_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.203"><vh>void ModelEntityGeometricPropertiesTree::onItemChanged (model_entity_geometric_properties_tree.cpp)</vh></v>
<v t="leo.20201108101525.204"><vh>void ModelEntityGeometricPropertiesTree::onItemDoubleClicked (model_entity_geometric_properties_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101525.205"><vh>@clean model_io.cpp</vh>
<v t="leo.20201108101525.206"><vh>const QString (model_io.cpp)</vh></v>
<v t="leo.20201108101525.207"><vh>void ModelIO::save (model_io.cpp)</vh></v>
<v t="leo.20201108101525.208"><vh>void ModelIO::open (model_io.cpp)</vh></v>
<v t="leo.20201108101525.209"><vh>void ModelIO::update (model_io.cpp)</vh></v>
<v t="leo.20201108101525.210"><vh>void ModelIO::exportMsh (model_io.cpp)</vh></v>
<v t="leo.20201108101525.211"><vh>void ModelIO::importMsh (model_io.cpp)</vh></v>
<v t="leo.20201108101525.212"><vh>void ModelIO::exportRaw (model_io.cpp)</vh></v>
<v t="leo.20201108101525.213"><vh>void ModelIO::importRaw (model_io.cpp)</vh></v>
<v t="leo.20201108101525.214"><vh>void ModelIO::exportStl (model_io.cpp)</vh></v>
<v t="leo.20201108101525.215"><vh>void ModelIO::importStl (model_io.cpp)</vh></v>
<v t="leo.20201108101525.216"><vh>void ModelIO::run (model_io.cpp)</vh></v>
</v>
<v t="leo.20201108101525.217"><vh>@clean model_records_selector.cpp</vh>
<v t="leo.20201108101525.218"><vh>void ModelRecordsSelector::createAnimation (model_records_selector.cpp)</vh></v>
<v t="leo.20201108101525.219"><vh>void ModelRecordsSelector::onRecordMarked (model_records_selector.cpp)</vh></v>
<v t="leo.20201108101526.1"><vh>void ModelRecordsSelector::onRecordFinished (model_records_selector.cpp)</vh></v>
<v t="leo.20201108101526.2"><vh>void ModelRecordsSelector::onUpdateJobFinished (model_records_selector.cpp)</vh></v>
<v t="leo.20201108101526.3"><vh>void ModelRecordsSelector::playToggle (model_records_selector.cpp)</vh></v>
<v t="leo.20201108101526.4"><vh>void ModelRecordsSelector::loadNextRecord (model_records_selector.cpp)</vh></v>
<v t="leo.20201108101526.5"><vh>void ModelRecordsSelector::onRecordVideo (model_records_selector.cpp)</vh></v>
</v>
<v t="leo.20201108101526.6"><vh>@clean model_records_tree.cpp</vh>
<v t="leo.20201108101526.7"><vh>class ModelRecordsTreeRecordID</vh>
<v t="leo.20201108101526.8"><vh>ModelRecordsTreeRecordID.bool operator</vh></v>
</v>
<v t="leo.20201108101526.9"><vh>bool ModelRecordsTree::isFirst (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.10"><vh>bool ModelRecordsTree::isLast (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.11"><vh>void ModelRecordsTree::markCurrent (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.12"><vh>void ModelRecordsTree::markPrevious (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.13"><vh>void ModelRecordsTree::markNext (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.14"><vh>void ModelRecordsTree::markFirst (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.15"><vh>void ModelRecordsTree::markLast (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.16"><vh>void ModelRecordsTree::populate (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.17"><vh>void ModelRecordsTree::onModelSelectionChanged (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.18"><vh>void ModelRecordsTree::onModelChanged (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.19"><vh>void ModelRecordsTree::onItemChanged (model_records_tree.cpp)</vh></v>
<v t="leo.20201108101526.20"><vh>void ModelRecordsTree::onItemActivated (model_records_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101526.21"><vh>@clean model_statistics_dialog.cpp</vh>
<v t="leo.20201108101526.22"><vh>int ModelStatisticsDialog::exec (model_statistics_dialog.cpp)</vh></v>
<v t="leo.20201108101526.23"><vh>void ModelStatisticsDialog::produceStatistics (model_statistics_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101526.24"><vh>@clean model_tree.cpp</vh>
<v t="leo.20201108101526.25"><vh>typedef enum (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.26"><vh>typedef enum (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.27"><vh>static REntityGroupType (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.28"><vh>void ModelTree::setIgnoreSignals (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.29"><vh>void ModelTree::populate (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.30"><vh>void ModelTree::insertModel (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.31"><vh>void ModelTree::removeModel (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.32"><vh>void ModelTree::onModelAdded (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.33"><vh>void ModelTree::onModelRemoved (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.34"><vh>void ModelTree::onModelChanged (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.35"><vh>void ModelTree::onSelectionChanged (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.36"><vh>void ModelTree::onItemChanged (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.37"><vh>void ModelTree::onEntitySelectionChanged (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.38"><vh>void ModelTree::onEntityVisibilityChanged (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.39"><vh>void ModelTree::selectSelected (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.40"><vh>void ModelTree::expandSelected (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.41"><vh>void ModelTree::checkVisible (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.42"><vh>void ModelTree::onDataChanged (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.43"><vh>void ModelTree::onItemExpanded (model_tree.cpp)</vh></v>
<v t="leo.20201108101526.44"><vh>void ModelTree::onItemDoubleClicked (model_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101526.45"><vh>@clean model_tree_simple.cpp</vh>
<v t="leo.20201108101526.46"><vh>typedef enum (model_tree_simple.cpp)</vh></v>
<v t="leo.20201108101526.47"><vh>typedef enum (model_tree_simple.cpp)</vh></v>
<v t="leo.20201108101526.48"><vh>static REntityGroupType (model_tree_simple.cpp)</vh></v>
<v t="leo.20201108101526.49"><vh>void ModelTreeSimple::selectEntity (model_tree_simple.cpp)</vh></v>
<v t="leo.20201108101526.50"><vh>void ModelTreeSimple::addModel (model_tree_simple.cpp)</vh></v>
<v t="leo.20201108101526.51"><vh>void ModelTreeSimple::onSelectionChanged (model_tree_simple.cpp)</vh></v>
</v>
<v t="leo.20201108101526.52"><vh>@clean monitoring_points_dialog.cpp</vh>
<v t="leo.20201108101526.53"><vh>int MonitoringPointsDialog::exec (monitoring_points_dialog.cpp)</vh></v>
<v t="leo.20201108101526.54"><vh>void MonitoringPointsDialog::addMonitoringPoint (monitoring_points_dialog.cpp)</vh></v>
<v t="leo.20201108101526.55"><vh>void MonitoringPointsDialog::onItemSelectionChanged (monitoring_points_dialog.cpp)</vh></v>
<v t="leo.20201108101526.56"><vh>void MonitoringPointsDialog::onAddClicked (monitoring_points_dialog.cpp)</vh></v>
<v t="leo.20201108101526.57"><vh>void MonitoringPointsDialog::onRemoveClicked (monitoring_points_dialog.cpp)</vh></v>
<v t="leo.20201108101526.58"><vh>void MonitoringPointsDialog::onUsePickedClicked (monitoring_points_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101526.59"><vh>@clean monitoring_point_graph_dialog.cpp</vh>
<v t="leo.20201108101526.60"><vh>int MonitoringPointGraphDialog::exec (monitoring_point_graph_dialog.cpp)</vh></v>
<v t="leo.20201108101526.61"><vh>void MonitoringPointGraphDialog::readDataFromFile (monitoring_point_graph_dialog.cpp)</vh></v>
<v t="leo.20201108101526.62"><vh>void MonitoringPointGraphDialog::populateValuesTree (monitoring_point_graph_dialog.cpp)</vh></v>
<v t="leo.20201108101526.63"><vh>void MonitoringPointGraphDialog::displayInGraph (monitoring_point_graph_dialog.cpp)</vh></v>
<v t="leo.20201108101526.64"><vh>void MonitoringPointGraphDialog::onCurrentIndexChanged (monitoring_point_graph_dialog.cpp)</vh></v>
<v t="leo.20201108101526.65"><vh>void MonitoringPointGraphDialog::onDisplayInGraphClicked (monitoring_point_graph_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101526.66"><vh>@clean move_node_dialog.cpp</vh>
<v t="leo.20201108101526.67"><vh>int MoveNodeDialog::exec (move_node_dialog.cpp)</vh></v>
<v t="leo.20201108101526.68"><vh>void MoveNodeDialog::onPositionChanged (move_node_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101526.69"><vh>@clean new_model_dialog.cpp</vh>
<v t="leo.20201108101526.70"><vh>int NewModelDialog::exec (new_model_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101526.71"><vh>@clean pick_details_tree.cpp</vh>
<v t="leo.20201108101526.72"><vh>typedef enum (pick_details_tree.cpp)</vh></v>
<v t="leo.20201108101526.73"><vh>void PickDetailsTree::populate (pick_details_tree.cpp)</vh></v>
<v t="leo.20201108101526.74"><vh>void PickDetailsTree::onPickListChanged (pick_details_tree.cpp)</vh></v>
<v t="leo.20201108101526.75"><vh>void PickDetailsTree::onItemExpanded (pick_details_tree.cpp)</vh></v>
<v t="leo.20201108101526.76"><vh>void PickDetailsTree::resizeColumnsToContent (pick_details_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101526.77"><vh>@clean pick_item.cpp</vh>
<v t="leo.20201108101526.78"><vh>void PickItem::_init (pick_item.cpp)</vh></v>
<v t="leo.20201108101526.79"><vh>const SessionEntityID (pick_item.cpp)</vh></v>
<v t="leo.20201108101526.80"><vh>bool PickItem::operator (pick_item.cpp)</vh></v>
</v>
<v t="leo.20201108101526.81"><vh>@clean pick_list.cpp</vh>
<v t="leo.20201108101526.82"><vh>bool PickList::getMultipleSelection (pick_list.cpp)</vh></v>
<v t="leo.20201108101526.83"><vh>void PickList::setMultipleSelection (pick_list.cpp)</vh></v>
<v t="leo.20201108101526.84"><vh>const QVector (pick_list.cpp)</vh></v>
<v t="leo.20201108101526.85"><vh>bool PickList::isEmpty (pick_list.cpp)</vh></v>
<v t="leo.20201108101526.86"><vh>bool PickList::isEmpty (pick_list.cpp)</vh></v>
<v t="leo.20201108101526.87"><vh>bool PickList::registerItem (pick_list.cpp)</vh></v>
<v t="leo.20201108101526.88"><vh>void PickList::addItem (pick_list.cpp)</vh></v>
<v t="leo.20201108101526.89"><vh>void PickList::removeItem (pick_list.cpp)</vh></v>
<v t="leo.20201108101526.90"><vh>void PickList::removeItems (pick_list.cpp)</vh></v>
<v t="leo.20201108101526.91"><vh>bool PickList::hasItem (pick_list.cpp)</vh></v>
<v t="leo.20201108101526.92"><vh>void PickList::clear (pick_list.cpp)</vh></v>
</v>
<v t="leo.20201108101526.93"><vh>@clean pick_value.cpp</vh>
<v t="leo.20201108101526.94"><vh>void PickValue::_init (pick_value.cpp)</vh></v>
<v t="leo.20201108101526.95"><vh>const RR3Vector (pick_value.cpp)</vh></v>
<v t="leo.20201108101526.96"><vh>void PickValue::setPosition (pick_value.cpp)</vh></v>
<v t="leo.20201108101526.97"><vh>const RRVector (pick_value.cpp)</vh></v>
<v t="leo.20201108101526.98"><vh>void PickValue::setValues (pick_value.cpp)</vh></v>
</v>
<v t="leo.20201108101526.99"><vh>@clean point_inside_surface_dialog.cpp</vh>
<v t="leo.20201108101526.100"><vh>int PointInsideSurfaceDialog::exec (point_inside_surface_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101527.1"><vh>@clean position_widget.cpp</vh>
<v t="leo.20201108101527.2"><vh>void PositionWidget::showSliders (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.3"><vh>void PositionWidget::hideSliders (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.4"><vh>void PositionWidget::showPickButton (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.5"><vh>void PositionWidget::hidePickButton (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.6"><vh>void PositionWidget::showButtons (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.7"><vh>void PositionWidget::hideButtons (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.8"><vh>void PositionWidget::setXRange (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.9"><vh>void PositionWidget::setYRange (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.10"><vh>void PositionWidget::setZRange (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.11"><vh>void PositionWidget::setPosition (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.12"><vh>void PositionWidget::setSlidersPosition (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.13"><vh>void PositionWidget::findSliderPositions (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.14"><vh>void PositionWidget::onXSliderValueChanged (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.15"><vh>void PositionWidget::onYSliderValueChanged (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.16"><vh>void PositionWidget::onZSliderValueChanged (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.17"><vh>void PositionWidget::onXLineEditValueChanged (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.18"><vh>void PositionWidget::onYLineEditValueChanged (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.19"><vh>void PositionWidget::onZLineEditValueChanged (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.20"><vh>void PositionWidget::onPickButtonClicked (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.21"><vh>void PositionWidget::onOkButtonClicked (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.22"><vh>void PositionWidget::onCancelButtonClicked (position_widget.cpp)</vh></v>
<v t="leo.20201108101527.23"><vh>void PositionWidget::onPickListChanged (position_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101527.24"><vh>@clean problem_selector_dialog.cpp</vh>
<v t="leo.20201108101527.25"><vh>void ProblemSelectorDialog::onProblemTreeChanged (problem_selector_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101527.26"><vh>@clean problem_selector_tree.cpp</vh>
<v t="leo.20201108101527.27"><vh>typedef enum (problem_selector_tree.cpp)</vh></v>
<v t="leo.20201108101527.28"><vh>bool ProblemSelectorTree::checkProblemIsChecked (problem_selector_tree.cpp)</vh></v>
<v t="leo.20201108101527.29"><vh>void ProblemSelectorTree::checkCheckedTreeWidgetItem (problem_selector_tree.cpp)</vh></v>
<v t="leo.20201108101527.30"><vh>void ProblemSelectorTree::checkUncheckedTreeWidgetItem (problem_selector_tree.cpp)</vh></v>
<v t="leo.20201108101527.31"><vh>void ProblemSelectorTree::onTreeWidgetItemChanged (problem_selector_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101527.32"><vh>@clean problem_task_dialog.cpp</vh>
<v t="leo.20201108101527.33"><vh>int ProblemTaskDialog::exec (problem_task_dialog.cpp)</vh></v>
<v t="leo.20201108101527.34"><vh>void ProblemTaskDialog::closeEvent (problem_task_dialog.cpp)</vh></v>
<v t="leo.20201108101527.35"><vh>void ProblemTaskDialog::keyPressEvent (problem_task_dialog.cpp)</vh></v>
<v t="leo.20201108101527.36"><vh>void ProblemTaskDialog::onProblemTaskTreeChanged (problem_task_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101527.37"><vh>@clean problem_task_tree.cpp</vh>
<v t="leo.20201108101527.38"><vh>void ProblemTaskTree::addTaskItemToWidget (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.39"><vh>void ProblemTaskTree::removeItem (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.40"><vh>void ProblemTaskTree::addWidgetItemToTree (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.41"><vh>void ProblemTaskTree::onItemSelectionChanged (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.42"><vh>void ProblemTaskTree::onItemChanged (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.43"><vh>void ProblemTaskTree::onItemDoubleClicked (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.44"><vh>void ProblemTaskTree::onUpButtonClicked (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.45"><vh>void ProblemTaskTree::onDownButtonClicked (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.46"><vh>void ProblemTaskTree::onIndentButtonClicked (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.47"><vh>void ProblemTaskTree::onUnindentButtonClicked (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.48"><vh>void ProblemTaskTree::onDeleteButtonClicked (problem_task_tree.cpp)</vh></v>
<v t="leo.20201108101527.49"><vh>void ProblemTaskTree::onAddProblemButtonClicked (problem_task_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101527.50"><vh>@clean problem_tree.cpp</vh>
<v t="leo.20201108101527.51"><vh>typedef enum (problem_tree.cpp)</vh></v>
<v t="leo.20201108101527.52"><vh>void ProblemTree::populate (problem_tree.cpp)</vh></v>
<v t="leo.20201108101527.53"><vh>void ProblemTree::onModelChanged (problem_tree.cpp)</vh></v>
<v t="leo.20201108101527.54"><vh>void ProblemTree::onProblemChanged (problem_tree.cpp)</vh></v>
<v t="leo.20201108101527.55"><vh>void ProblemTree::onModelSelectionChanged (problem_tree.cpp)</vh></v>
<v t="leo.20201108101527.56"><vh>void ProblemTree::onTimeSolverChanged (problem_tree.cpp)</vh></v>
<v t="leo.20201108101527.57"><vh>void ProblemTree::onModalSetupChanged (problem_tree.cpp)</vh></v>
<v t="leo.20201108101527.58"><vh>void ProblemTree::onRadiationSetupChanged (problem_tree.cpp)</vh></v>
<v t="leo.20201108101527.59"><vh>void ProblemTree::onMeshSetupChanged (problem_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101527.60"><vh>@clean progress.cpp</vh>
<v t="leo.20201108101527.61"><vh>void progressInitializeHandler (progress.cpp)</vh></v>
<v t="leo.20201108101527.62"><vh>void Progress::print (progress.cpp)</vh></v>
<v t="leo.20201108101527.63"><vh>void Progress::emitProgressInitialize (progress.cpp)</vh></v>
<v t="leo.20201108101527.64"><vh>void Progress::emitProgressFinalize (progress.cpp)</vh></v>
<v t="leo.20201108101527.65"><vh>void progressPrintHandler (progress.cpp)</vh></v>
<v t="leo.20201108101527.66"><vh>void progressInitializeHandler (progress.cpp)</vh></v>
<v t="leo.20201108101527.67"><vh>void progressFinalizeHandler (progress.cpp)</vh></v>
</v>
<v t="leo.20201108101527.68"><vh>@clean progress_bar.cpp</vh>
<v t="leo.20201108101527.69"><vh>void ProgressBar::startPulse (progress_bar.cpp)</vh></v>
<v t="leo.20201108101527.70"><vh>void ProgressBar::stopPulse (progress_bar.cpp)</vh></v>
<v t="leo.20201108101527.71"><vh>void ProgressBar::setValue (progress_bar.cpp)</vh></v>
<v t="leo.20201108101527.72"><vh>void ProgressBar::setMessage (progress_bar.cpp)</vh></v>
<v t="leo.20201108101527.73"><vh>void ProgressBar::setAutoHide (progress_bar.cpp)</vh></v>
<v t="leo.20201108101527.74"><vh>void ProgressBar::hide (progress_bar.cpp)</vh></v>
<v t="leo.20201108101527.75"><vh>void ProgressBar::pulse (progress_bar.cpp)</vh></v>
</v>
<v t="leo.20201108101527.76"><vh>@clean push_button.cpp</vh>
<v t="leo.20201108101527.77"><vh>void PushButton::onClicked (push_button.cpp)</vh></v>
</v>
<v t="leo.20201108101527.78"><vh>@clean quit_dialog.cpp</vh></v>
<v t="leo.20201108101527.79"><vh>@clean radiation_setup_widget.cpp</vh>
<v t="leo.20201108101527.80"><vh>void RadiationSetupWidget::onResolutionChanged (radiation_setup_widget.cpp)</vh></v>
<v t="leo.20201108101527.81"><vh>void RadiationSetupWidget::onCustomViewFactorFileToggled (radiation_setup_widget.cpp)</vh></v>
<v t="leo.20201108101527.82"><vh>void RadiationSetupWidget::onViewFactorFileChanged (radiation_setup_widget.cpp)</vh></v>
<v t="leo.20201108101527.83"><vh>void RadiationSetupWidget::regeneratePatches (radiation_setup_widget.cpp)</vh></v>
<v t="leo.20201108101527.84"><vh>void RadiationSetupWidget::recalculateViewFactors (radiation_setup_widget.cpp)</vh></v>
<v t="leo.20201108101527.85"><vh>void RadiationSetupWidget::clearViewFactorMatrix (radiation_setup_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101527.86"><vh>@clean remove_entity_dialog.cpp</vh>
<v t="leo.20201108101527.87"><vh>int RemoveEntityDialog::exec (remove_entity_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101527.88"><vh>@clean rename_model_dialog.cpp</vh>
<v t="leo.20201108101527.89"><vh>int RenameModelDialog::exec (rename_model_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101528.1"><vh>@clean report_dialog.cpp</vh>
<v t="leo.20201108101528.2"><vh>int ReportDialog::exec (report_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101528.3"><vh>@clean report_generator.cpp</vh>
<v t="leo.20201108101528.4"><vh>void ReportGenerator::generateTitle (report_generator.cpp)</vh></v>
<v t="leo.20201108101528.5"><vh>void ReportGenerator::generateBody (report_generator.cpp)</vh></v>
<v t="leo.20201108101528.6"><vh>void ReportGenerator::generateModelChapter (report_generator.cpp)</vh></v>
<v t="leo.20201108101528.7"><vh>void ReportGenerator::generateProblemChapter (report_generator.cpp)</vh></v>
<v t="leo.20201108101528.8"><vh>void ReportGenerator::generateResultsChapter (report_generator.cpp)</vh></v>
</v>
<v t="leo.20201108101528.9"><vh>@clean results_variable_selector.cpp</vh>
<v t="leo.20201108101528.10"><vh>void ResultsVariableSelector::populate (results_variable_selector.cpp)</vh></v>
<v t="leo.20201108101528.11"><vh>void ResultsVariableSelector::onResultsChanged (results_variable_selector.cpp)</vh></v>
</v>
<v t="leo.20201108101528.12"><vh>@clean results_variable_tree.cpp</vh>
<v t="leo.20201108101528.13"><vh>typedef enum (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.14"><vh>void ResultsVariableTree::populate (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.15"><vh>void ResultsVariableTree::processApplyAsStates (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.16"><vh>void ResultsVariableTree::onResultsVariableSelected (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.17"><vh>void ResultsVariableTree::onApplyAsScalarStateChanged (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.18"><vh>void ResultsVariableTree::onApplyAsDisplacementStateChanged (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.19"><vh>void ResultsVariableTree::onApplyOnNodeClicked (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.20"><vh>void ResultsVariableTree::onRemoveVariableClicked (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.21"><vh>void ResultsVariableTree::onColorScaleChanged (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.22"><vh>void ResultsVariableTree::onRangeMinValueChanged (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.23"><vh>void ResultsVariableTree::onRangeMaxValueChanged (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.24"><vh>void ResultsVariableTree::onRangeDisplayStateChanged (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.25"><vh>void ResultsVariableTree::onRangeAutofillClicked (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.26"><vh>void ResultsVariableTree::onRangeGraphClicked (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.27"><vh>void ResultsVariableTree::onVariableScaleChanged (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.28"><vh>void ResultsVariableTree::onVariableDataChanged (results_variable_tree.cpp)</vh></v>
<v t="leo.20201108101528.29"><vh>void ResultsVariableTree::onVariableDataChanged (results_variable_tree.cpp)</vh></v>
</v>
<v t="leo.20201108101528.30"><vh>@clean rra_request_input.cpp</vh></v>
<v t="leo.20201108101528.31"><vh>@clean rra_request_worker.cpp</vh>
<v t="leo.20201108101528.32"><vh>void RRARequestWorker::availableSoftware (rra_request_worker.cpp)</vh></v>
<v t="leo.20201108101528.33"><vh>void RRARequestWorker::logIn (rra_request_worker.cpp)</vh></v>
<v t="leo.20201108101528.34"><vh>void RRARequestWorker::logOut (rra_request_worker.cpp)</vh></v>
<v t="leo.20201108101528.35"><vh>void RRARequestWorker::sendUsageInfo (rra_request_worker.cpp)</vh></v>
<v t="leo.20201108101528.36"><vh>void RRARequestWorker::sendCrashReport (rra_request_worker.cpp)</vh></v>
<v t="leo.20201108101528.37"><vh>void RRARequestWorker::onHttpRequestFinished (rra_request_worker.cpp)</vh></v>
<v t="leo.20201108101528.38"><vh>bool RRARequestWorker::processJSon (rra_request_worker.cpp)</vh></v>
</v>
<v t="leo.20201108101528.39"><vh>@clean rra_session.cpp</vh>
<v t="leo.20201108101528.40"><vh>void RRASession::start (rra_session.cpp)</vh></v>
<v t="leo.20201108101528.41"><vh>void RRASession::stop (rra_session.cpp)</vh></v>
<v t="leo.20201108101528.42"><vh>const RVersion (rra_session.cpp)</vh></v>
<v t="leo.20201108101528.43"><vh>const QString (rra_session.cpp)</vh></v>
<v t="leo.20201108101528.44"><vh>void RRASession::submitCrashReport (rra_session.cpp)</vh></v>
<v t="leo.20201108101528.45"><vh>void RRASession::submitNextRequest (rra_session.cpp)</vh></v>
<v t="leo.20201108101528.46"><vh>void RRASession::onRraAvailableSoftware (rra_session.cpp)</vh></v>
<v t="leo.20201108101528.47"><vh>void RRASession::onRraLoginStatus (rra_session.cpp)</vh></v>
<v t="leo.20201108101528.48"><vh>void RRASession::onRraFailed (rra_session.cpp)</vh></v>
</v>
<v t="leo.20201108101528.49"><vh>@clean scalar_field_dialog.cpp</vh>
<v t="leo.20201108101528.50"><vh>int ScalarFieldDialog::exec (scalar_field_dialog.cpp)</vh></v>
<v t="leo.20201108101528.51"><vh>void ScalarFieldDialog::createDialog (scalar_field_dialog.cpp)</vh></v>
<v t="leo.20201108101528.52"><vh>void ScalarFieldDialog::onVariableTreeSelectionChanged (scalar_field_dialog.cpp)</vh></v>
<v t="leo.20201108101528.53"><vh>void ScalarFieldDialog::onModelTreeSelectionChanged (scalar_field_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101528.54"><vh>@clean session.cpp</vh>
<v t="leo.20201108101528.55"><vh>const QString (session.cpp)</vh></v>
<v t="leo.20201108101528.56"><vh>void Session::lock (session.cpp)</vh></v>
<v t="leo.20201108101528.57"><vh>bool Session::trylock (session.cpp)</vh></v>
<v t="leo.20201108101528.58"><vh>void Session::unlock (session.cpp)</vh></v>
<v t="leo.20201108101528.59"><vh>const QString (session.cpp)</vh></v>
<v t="leo.20201108101528.60"><vh>const Model (session.cpp)</vh></v>
<v t="leo.20201108101528.61"><vh>const Model (session.cpp)</vh></v>
<v t="leo.20201108101528.62"><vh>void Session::addModel (session.cpp)</vh></v>
<v t="leo.20201108101528.63"><vh>void Session::setModel (session.cpp)</vh></v>
<v t="leo.20201108101528.64"><vh>void Session::removeModel (session.cpp)</vh></v>
<v t="leo.20201108101528.65"><vh>void Session::setModelSelected (session.cpp)</vh></v>
<v t="leo.20201108101528.66"><vh>void Session::setEntitySelected (session.cpp)</vh></v>
<v t="leo.20201108101528.67"><vh>void Session::setEntityVisible (session.cpp)</vh></v>
<v t="leo.20201108101528.68"><vh>void Session::setModelVisible (session.cpp)</vh></v>
<v t="leo.20201108101528.69"><vh>bool Session::isModelSelected (session.cpp)</vh></v>
<v t="leo.20201108101528.70"><vh>void Session::setModelSelectionChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.71"><vh>void Session::setDisplayPropertiesChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.72"><vh>void Session::setModelChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.73"><vh>void Session::setModelRenamed (session.cpp)</vh></v>
<v t="leo.20201108101528.74"><vh>void Session::setProblemChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.75"><vh>void Session::setProblemSelectionChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.76"><vh>void Session::setResultsChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.77"><vh>void Session::setBoundaryConditionChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.78"><vh>void Session::setInitialConditionChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.79"><vh>void Session::setEnvironmentConditionChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.80"><vh>void Session::setMaterialChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.81"><vh>void Session::setVariableDataChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.82"><vh>void Session::setVariableDataChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.83"><vh>const PickList (session.cpp)</vh></v>
<v t="leo.20201108101528.84"><vh>void Session::setBeginDrawStreamLinePosition (session.cpp)</vh></v>
<v t="leo.20201108101528.85"><vh>void Session::setEndDrawStreamLinePosition (session.cpp)</vh></v>
<v t="leo.20201108101528.86"><vh>void Session::setBeginDrawScaleOrigin (session.cpp)</vh></v>
<v t="leo.20201108101528.87"><vh>void Session::setEndDrawScaleOrigin (session.cpp)</vh></v>
<v t="leo.20201108101528.88"><vh>void Session::setBeginDrawRotationOrigin (session.cpp)</vh></v>
<v t="leo.20201108101528.89"><vh>void Session::setEndDrawRotationOrigin (session.cpp)</vh></v>
<v t="leo.20201108101528.90"><vh>void Session::setBeginDrawLocalDirections (session.cpp)</vh></v>
<v t="leo.20201108101528.91"><vh>void Session::setEndDrawLocalDirections (session.cpp)</vh></v>
<v t="leo.20201108101528.92"><vh>void Session::setBeginDrawCutPlane (session.cpp)</vh></v>
<v t="leo.20201108101528.93"><vh>void Session::setEndDrawCutPlane (session.cpp)</vh></v>
<v t="leo.20201108101528.94"><vh>void Session::setBeginDrawMoveNodes (session.cpp)</vh></v>
<v t="leo.20201108101528.95"><vh>void Session::setEndDrawMoveNodes (session.cpp)</vh></v>
<v t="leo.20201108101528.96"><vh>void Session::setTakeScreenShot (session.cpp)</vh></v>
<v t="leo.20201108101528.97"><vh>void Session::readModels (session.cpp)</vh></v>
<v t="leo.20201108101528.98"><vh>void Session::read (session.cpp)</vh></v>
<v t="leo.20201108101528.99"><vh>void Session::write (session.cpp)</vh></v>
<v t="leo.20201108101528.100"><vh>void Session::clear (session.cpp)</vh></v>
<v t="leo.20201108101528.101"><vh>void Session::storeCurentModelVersion (session.cpp)</vh></v>
<v t="leo.20201108101528.102"><vh>bool Session::isUndoAvailable (session.cpp)</vh></v>
<v t="leo.20201108101528.103"><vh>bool Session::isRedoAvailable (session.cpp)</vh></v>
<v t="leo.20201108101528.104"><vh>bool Session::selectedModelsHasEntities (session.cpp)</vh></v>
<v t="leo.20201108101528.105"><vh>bool Session::selectedModelsHasEntitySelected (session.cpp)</vh></v>
<v t="leo.20201108101528.106"><vh>void Session::onPickListChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.107"><vh>void Session::onModelAdded (session.cpp)</vh></v>
<v t="leo.20201108101528.108"><vh>void Session::onModelChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.109"><vh>void Session::onNHistoryRecordsChanged (session.cpp)</vh></v>
<v t="leo.20201108101528.110"><vh>void Session::onSoftwareUpdateFileSaved (session.cpp)</vh></v>
</v>
<v t="leo.20201108101528.111"><vh>@clean session_entity_id.cpp</vh>
<v t="leo.20201108101528.112"><vh>void SessionEntityID::_init (session_entity_id.cpp)</vh></v>
<v t="leo.20201108101528.113"><vh>bool SessionEntityID::operator (session_entity_id.cpp)</vh></v>
<v t="leo.20201108101528.114"><vh>bool SessionEntityID::operator (session_entity_id.cpp)</vh></v>
<v t="leo.20201108101528.115"><vh>bool SessionEntityID::operator (session_entity_id.cpp)</vh></v>
<v t="leo.20201108101528.116"><vh>void SessionEntityID::setMid (session_entity_id.cpp)</vh></v>
<v t="leo.20201108101528.117"><vh>void SessionEntityID::setType (session_entity_id.cpp)</vh></v>
<v t="leo.20201108101528.118"><vh>void SessionEntityID::setEid (session_entity_id.cpp)</vh></v>
</v>
<v t="leo.20201108101528.119"><vh>@clean session_node_id.cpp</vh>
<v t="leo.20201108101528.120"><vh>void SessionNodeID::_init (session_node_id.cpp)</vh></v>
<v t="leo.20201108101528.121"><vh>bool SessionNodeID::operator (session_node_id.cpp)</vh></v>
<v t="leo.20201108101528.122"><vh>bool SessionNodeID::operator (session_node_id.cpp)</vh></v>
<v t="leo.20201108101528.123"><vh>bool SessionNodeID::operator (session_node_id.cpp)</vh></v>
<v t="leo.20201108101528.124"><vh>void SessionNodeID::setMid (session_node_id.cpp)</vh></v>
<v t="leo.20201108101528.125"><vh>void SessionNodeID::setNid (session_node_id.cpp)</vh></v>
</v>
<v t="leo.20201108101528.126"><vh>@clean shortcut_line_edit.cpp</vh>
<v t="leo.20201108101528.127"><vh>void ShortcutLineEdit::keyPressEvent (shortcut_line_edit.cpp)</vh></v>
<v t="leo.20201108101528.128"><vh>void ShortcutLineEdit::onTextChanged (shortcut_line_edit.cpp)</vh></v>
</v>
<v t="leo.20201108101528.129"><vh>@clean solver_manager.cpp</vh>
<v t="leo.20201108101528.130"><vh>const QString (solver_manager.cpp)</vh></v>
<v t="leo.20201108101528.131"><vh>void SolverManager::submit (solver_manager.cpp)</vh></v>
<v t="leo.20201108101528.132"><vh>bool SolverManager::isSolverQueued (solver_manager.cpp)</vh></v>
<v t="leo.20201108101528.133"><vh>void SolverManager::stopRunningTasks (solver_manager.cpp)</vh></v>
<v t="leo.20201108101528.134"><vh>void SolverManager::killRunningTasks (solver_manager.cpp)</vh></v>
<v t="leo.20201108101528.135"><vh>const QString (solver_manager.cpp)</vh></v>
<v t="leo.20201108101528.136"><vh>void SolverManager::stopServer (solver_manager.cpp)</vh></v>
<v t="leo.20201108101528.137"><vh>void SolverManager::onReadyReadStandardOutput (solver_manager.cpp)</vh></v>
<v t="leo.20201108101528.138"><vh>void SolverManager::onReadyReadStandardError (solver_manager.cpp)</vh></v>
<v t="leo.20201108101528.139"><vh>void SolverManager::onSolverTaskNewConnection (solver_manager.cpp)</vh></v>
</v>
<v t="leo.20201108101529.1"><vh>@clean solver_process.cpp</vh></v>
<v t="leo.20201108101529.2"><vh>@clean solver_setup_checker.cpp</vh>
<v t="leo.20201108101529.3"><vh>void SolverSetupChecker::_init (solver_setup_checker.cpp)</vh></v>
<v t="leo.20201108101529.4"><vh>void SolverSetupChecker::perform (solver_setup_checker.cpp)</vh></v>
<v t="leo.20201108101529.5"><vh>void SolverSetupChecker::checkElements (solver_setup_checker.cpp)</vh></v>
<v t="leo.20201108101529.6"><vh>void SolverSetupChecker::checkMaterials (solver_setup_checker.cpp)</vh></v>
<v t="leo.20201108101529.7"><vh>void SolverSetupChecker::checkBoundaryConditions (solver_setup_checker.cpp)</vh></v>
</v>
<v t="leo.20201108101529.8"><vh>@clean solver_start_dialog.cpp</vh>
<v t="leo.20201108101529.9"><vh>int SolverStartDialog::exec (solver_start_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101529.10"><vh>@clean solver_task.cpp</vh>
<v t="leo.20201108101529.11"><vh>const SolverTaskID (solver_task.cpp)</vh></v>
<v t="leo.20201108101529.12"><vh>const QString (solver_task.cpp)</vh></v>
<v t="leo.20201108101529.13"><vh>void SolverTask::kill (solver_task.cpp)</vh></v>
<v t="leo.20201108101529.14"><vh>const QString (solver_task.cpp)</vh></v>
<v t="leo.20201108101529.15"><vh>void SolverTask::run (solver_task.cpp)</vh></v>
<v t="leo.20201108101529.16"><vh>void SolverTask::onProcessReadyReadStandardOutput (solver_task.cpp)</vh></v>
<v t="leo.20201108101529.17"><vh>void SolverTask::onProcessReadyReadStandardError (solver_task.cpp)</vh></v>
</v>
<v t="leo.20201108101529.18"><vh>@clean solver_task_id.cpp</vh>
<v t="leo.20201108101529.19"><vh>void SolverTaskID::_init (solver_task_id.cpp)</vh></v>
<v t="leo.20201108101529.20"><vh>bool SolverTaskID::operator (solver_task_id.cpp)</vh></v>
<v t="leo.20201108101529.21"><vh>void SolverTaskID::generate (solver_task_id.cpp)</vh></v>
<v t="leo.20201108101529.22"><vh>bool SolverTaskID::isValid (solver_task_id.cpp)</vh></v>
<v t="leo.20201108101529.23"><vh>const QString (solver_task_id.cpp)</vh></v>
</v>
<v t="leo.20201108101529.24"><vh>@clean stream_line_dialog.cpp</vh>
<v t="leo.20201108101529.25"><vh>int StreamLineDialog::exec (stream_line_dialog.cpp)</vh></v>
<v t="leo.20201108101529.26"><vh>void StreamLineDialog::createDialog (stream_line_dialog.cpp)</vh></v>
<v t="leo.20201108101529.27"><vh>void StreamLineDialog::onPositionChanged (stream_line_dialog.cpp)</vh></v>
<v t="leo.20201108101529.28"><vh>void StreamLineDialog::onVariableListSelectionChanged (stream_line_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101529.29"><vh>@clean sub_window.cpp</vh>
<v t="leo.20201108101529.30"><vh>void SubWindow::createSubWindow (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.31"><vh>void SubWindow::setModelID (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.32"><vh>void SubWindow::closeEvent (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.33"><vh>void SubWindow::onResetO (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.34"><vh>void SubWindow::onResetX (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.35"><vh>void SubWindow::onResetY (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.36"><vh>void SubWindow::onResetZ (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.37"><vh>void SubWindow::onScreenshot (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.38"><vh>void SubWindow::onSessionScreenshot (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.39"><vh>void SubWindow::onShowModelEdgesToggled (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.40"><vh>void SubWindow::onShowErrorsToggled (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.41"><vh>void SubWindow::onBackSideColorChanged (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.42"><vh>void SubWindow::onPreferences (sub_window.cpp)</vh></v>
<v t="leo.20201108101529.43"><vh>void SubWindow::onToolbarIconSizeChanged (sub_window.cpp)</vh></v>
</v>
<v t="leo.20201108101529.44"><vh>@clean sub_window_manager.cpp</vh>
<v t="leo.20201108101529.45"><vh>bool SubWindowManager::windowCreate (sub_window_manager.cpp)</vh></v>
<v t="leo.20201108101529.46"><vh>bool SubWindowManager::windowClose (sub_window_manager.cpp)</vh></v>
<v t="leo.20201108101529.47"><vh>bool SubWindowManager::windowExists (sub_window_manager.cpp)</vh></v>
<v t="leo.20201108101529.48"><vh>void SubWindowManager::onModelAdded (sub_window_manager.cpp)</vh></v>
<v t="leo.20201108101529.49"><vh>void SubWindowManager::onModelRemoved (sub_window_manager.cpp)</vh></v>
<v t="leo.20201108101529.50"><vh>void SubWindowManager::onModelChanged (sub_window_manager.cpp)</vh></v>
<v t="leo.20201108101529.51"><vh>void SubWindowManager::onWindowClosed (sub_window_manager.cpp)</vh></v>
</v>
<v t="leo.20201108101529.52"><vh>@clean text_browser.cpp</vh>
<v t="leo.20201108101529.53"><vh>void TextBrowser::resizeEvent (text_browser.cpp)</vh></v>
</v>
<v t="leo.20201108101529.54"><vh>@clean text_browser_dialog.cpp</vh>
<v t="leo.20201108101529.55"><vh>const QString (text_browser_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101529.56"><vh>@clean text_edit_widget.cpp</vh>
<v t="leo.20201108101529.57"><vh>void TextEditWidget::setText (text_edit_widget.cpp)</vh></v>
<v t="leo.20201108101529.58"><vh>void TextEditWidget::onTextEditChanged (text_edit_widget.cpp)</vh></v>
<v t="leo.20201108101529.59"><vh>void TextEditWidget::onCancelButtonClicked (text_edit_widget.cpp)</vh></v>
<v t="leo.20201108101529.60"><vh>void TextEditWidget::onOkButtonClicked (text_edit_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101529.61"><vh>@clean time_solver_setup_widget.cpp</vh>
<v t="leo.20201108101529.62"><vh>void TimeSolverSetupWidget::onTimeSolverEnabledChanged (time_solver_setup_widget.cpp)</vh></v>
<v t="leo.20201108101529.63"><vh>void TimeSolverSetupWidget::onTimeApproximationChanged (time_solver_setup_widget.cpp)</vh></v>
<v t="leo.20201108101529.64"><vh>void TimeSolverSetupWidget::onStartTimeChanged (time_solver_setup_widget.cpp)</vh></v>
<v t="leo.20201108101529.65"><vh>void TimeSolverSetupWidget::onTimeStepSizeChanged (time_solver_setup_widget.cpp)</vh></v>
<v t="leo.20201108101529.66"><vh>void TimeSolverSetupWidget::onNTimeStepsChanged (time_solver_setup_widget.cpp)</vh></v>
<v t="leo.20201108101529.67"><vh>void TimeSolverSetupWidget::onOutputFrequencyChanged (time_solver_setup_widget.cpp)</vh></v>
</v>
<v t="leo.20201108101529.68"><vh>@clean update_dialog.cpp</vh>
<v t="leo.20201108101529.69"><vh>int UpdateDialog::exec (update_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101529.70"><vh>@clean usage_info.cpp</vh></v>
<v t="leo.20201108101529.71"><vh>@clean value_line_edit.cpp</vh>
<v t="leo.20201108101529.72"><vh>void ValueLineEdit::setDoubleValidator (value_line_edit.cpp)</vh></v>
<v t="leo.20201108101529.73"><vh>void ValueLineEdit::setIntValidator (value_line_edit.cpp)</vh></v>
<v t="leo.20201108101529.74"><vh>void ValueLineEdit::setRange (value_line_edit.cpp)</vh></v>
<v t="leo.20201108101529.75"><vh>void ValueLineEdit::setRange (value_line_edit.cpp)</vh></v>
<v t="leo.20201108101529.76"><vh>void ValueLineEdit::setValue (value_line_edit.cpp)</vh></v>
<v t="leo.20201108101529.77"><vh>void ValueLineEdit::setValue (value_line_edit.cpp)</vh></v>
<v t="leo.20201108101529.78"><vh>void ValueLineEdit::setValue (value_line_edit.cpp)</vh></v>
<v t="leo.20201108101529.79"><vh>void ValueLineEdit::createTimer (value_line_edit.cpp)</vh></v>
<v t="leo.20201108101529.80"><vh>void ValueLineEdit::paintBackground (value_line_edit.cpp)</vh></v>
<v t="leo.20201108101529.81"><vh>void ValueLineEdit::onTextChaged (value_line_edit.cpp)</vh></v>
<v t="leo.20201108101529.82"><vh>void ValueLineEdit::onTimeout (value_line_edit.cpp)</vh></v>
</v>
<v t="leo.20201108101530.1"><vh>@clean value_scale.cpp</vh>
<v t="leo.20201108101530.2"><vh>void ValueScale::setValue (value_scale.cpp)</vh></v>
<v t="leo.20201108101530.3"><vh>void ValueScale::onScaleEditChanged (value_scale.cpp)</vh></v>
<v t="leo.20201108101530.4"><vh>void ValueScale::onExpandButtonClicked (value_scale.cpp)</vh></v>
<v t="leo.20201108101530.5"><vh>void ValueScale::onMantisSliderChanged (value_scale.cpp)</vh></v>
<v t="leo.20201108101530.6"><vh>void ValueScale::onMantisEditChanged (value_scale.cpp)</vh></v>
<v t="leo.20201108101530.7"><vh>void ValueScale::onExponentSpinBoxChanged (value_scale.cpp)</vh></v>
</v>
<v t="leo.20201108101530.8"><vh>@clean value_set_generator_dialog.cpp</vh>
<v t="leo.20201108101530.9"><vh>typedef enum (value_set_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101530.10"><vh>class ValueSetGeneratorStaticValues</vh>
<v t="leo.20201108101530.11"><vh>ValueSetGeneratorStaticValues.void initialize</vh></v>
</v>
<v t="leo.20201108101530.12"><vh>double funcFindValue (value_set_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101530.13"><vh>static QString (value_set_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101530.14"><vh>int ValueSetGeneratorDialog::exec (value_set_generator_dialog.cpp)</vh></v>
<v t="leo.20201108101530.15"><vh>void ValueSetGeneratorDialog::onFuncComboCurrentIndexChanged (value_set_generator_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101530.16"><vh>@clean value_table.cpp</vh>
<v t="leo.20201108101530.17"><vh>typedef enum (value_table.cpp)</vh></v>
<v t="leo.20201108101530.18"><vh>void ValueTable::setDataType (value_table.cpp)</vh></v>
<v t="leo.20201108101530.19"><vh>void ValueTable::setKeyHeader (value_table.cpp)</vh></v>
<v t="leo.20201108101530.20"><vh>void ValueTable::setValueHeader (value_table.cpp)</vh></v>
<v t="leo.20201108101530.21"><vh>void ValueTable::addValue (value_table.cpp)</vh></v>
<v t="leo.20201108101530.22"><vh>void ValueTable::removeValue (value_table.cpp)</vh></v>
<v t="leo.20201108101530.23"><vh>void ValueTable::onItemChanged (value_table.cpp)</vh></v>
<v t="leo.20201108101530.24"><vh>void ValueTable::onInsertValue (value_table.cpp)</vh></v>
<v t="leo.20201108101530.25"><vh>void ValueTable::onDeleteValue (value_table.cpp)</vh></v>
<v t="leo.20201108101530.26"><vh>void ValueTable::onImportFromFile (value_table.cpp)</vh></v>
<v t="leo.20201108101530.27"><vh>void ValueTable::onViewGraph (value_table.cpp)</vh></v>
<v t="leo.20201108101530.28"><vh>void ValueTable::onFillValues (value_table.cpp)</vh></v>
</v>
<v t="leo.20201108101530.29"><vh>@clean variable_selector.cpp</vh>
<v t="leo.20201108101530.30"><vh>bool VariableSelector::setCurrentVariableType (variable_selector.cpp)</vh></v>
<v t="leo.20201108101530.31"><vh>void VariableSelector::populate (variable_selector.cpp)</vh></v>
<v t="leo.20201108101530.32"><vh>void VariableSelector::onCurrentIndexChanged (variable_selector.cpp)</vh></v>
</v>
<v t="leo.20201108101530.33"><vh>@clean variable_value_edit.cpp</vh>
<v t="leo.20201108101530.34"><vh>void VariableValueEdit::setValue (variable_value_edit.cpp)</vh></v>
<v t="leo.20201108101530.35"><vh>void VariableValueEdit::onValueChaged (variable_value_edit.cpp)</vh></v>
<v t="leo.20201108101530.36"><vh>void VariableValueEdit::onStateChaged (variable_value_edit.cpp)</vh></v>
</v>
<v t="leo.20201108101530.37"><vh>@clean vector_field_dialog.cpp</vh>
<v t="leo.20201108101530.38"><vh>int VectorFieldDialog::exec (vector_field_dialog.cpp)</vh></v>
<v t="leo.20201108101530.39"><vh>void VectorFieldDialog::createDialog (vector_field_dialog.cpp)</vh></v>
<v t="leo.20201108101530.40"><vh>void VectorFieldDialog::onVariableTreeSelectionChanged (vector_field_dialog.cpp)</vh></v>
<v t="leo.20201108101530.41"><vh>void VectorFieldDialog::onModelTreeSelectionChanged (vector_field_dialog.cpp)</vh></v>
</v>
<v t="leo.20201108101530.42"><vh>@clean video_output.cpp</vh>
<v t="leo.20201108101530.43"><vh>bool VideoOutput::openMediaFile (video_output.cpp)</vh></v>
<v t="leo.20201108101530.44"><vh>bool VideoOutput::closeMediaFile (video_output.cpp)</vh></v>
<v t="leo.20201108101530.45"><vh>void VideoOutput::setStreamRate (video_output.cpp)</vh></v>
<v t="leo.20201108101530.46"><vh>void VideoOutput::setResolution (video_output.cpp)</vh></v>
<v t="leo.20201108101530.47"><vh>bool VideoOutput::newFrame (video_output.cpp)</vh></v>
<v t="leo.20201108101530.48"><vh>bool VideoOutput::openVideo (video_output.cpp)</vh></v>
<v t="leo.20201108101530.49"><vh>bool VideoOutput::writeVideoFrame (video_output.cpp)</vh></v>
<v t="leo.20201108101530.50"><vh>void VideoOutput::closeVideo (video_output.cpp)</vh></v>
</v>
<v t="leo.20201108101530.51"><vh>@clean video_settings.cpp</vh>
<v t="leo.20201108101530.52"><vh>void VideoSettings::_init (video_settings.cpp)</vh></v>
<v t="leo.20201108101530.53"><vh>int VideoSettings::getWidth (video_settings.cpp)</vh></v>
<v t="leo.20201108101530.54"><vh>void VideoSettings::setWidth (video_settings.cpp)</vh></v>
<v t="leo.20201108101530.55"><vh>int VideoSettings::getHeight (video_settings.cpp)</vh></v>
<v t="leo.20201108101530.56"><vh>void VideoSettings::setHeight (video_settings.cpp)</vh></v>
<v t="leo.20201108101530.57"><vh>int VideoSettings::getFps (video_settings.cpp)</vh></v>
<v t="leo.20201108101530.58"><vh>void VideoSettings::setFps (video_settings.cpp)</vh></v>
<v t="leo.20201108101530.59"><vh>int VideoSettings::getFpp (video_settings.cpp)</vh></v>
<v t="leo.20201108101530.60"><vh>void VideoSettings::setFpp (video_settings.cpp)</vh></v>
<v t="leo.20201108101530.61"><vh>void VideoSettings::setFormat (video_settings.cpp)</vh></v>
</v>
<v t="leo.20201108101530.62"><vh>@clean video_settings_dialog.cpp</vh>
<v t="leo.20201108101530.63"><vh>int VideoSettingsDialog::exec (video_settings_dialog.cpp)</vh></v>
</v>
</v>
</v>
<v t="leo.20201108101530.64"><vh>@path RangeBase</vh>
<v t="leo.20201108101530.66"><vh>@path src</vh>
<v t="leo.20201108101530.67"><vh>@clean rbl_application_state.cpp</vh>
<v t="leo.20201108101530.68"><vh>void RApplicationState::_init (rbl_application_state.cpp)</vh></v>
<v t="leo.20201108101530.69"><vh>void RApplicationState::setStateType (rbl_application_state.cpp)</vh></v>
</v>
<v t="leo.20201108101530.70"><vh>@clean rbl_arguments_parser.cpp</vh>
<v t="leo.20201108101530.71"><vh>void RArgumentsParser::_init (rbl_arguments_parser.cpp)</vh></v>
<v t="leo.20201108101530.72"><vh>bool RArgumentsParser::isSet (rbl_arguments_parser.cpp)</vh></v>
<v t="leo.20201108101530.73"><vh>bool RArgumentsParser::isValid (rbl_arguments_parser.cpp)</vh></v>
<v t="leo.20201108101530.74"><vh>const QStringList (rbl_arguments_parser.cpp)</vh></v>
<v t="leo.20201108101530.75"><vh>void RArgumentsParser::printHelp (rbl_arguments_parser.cpp)</vh></v>
<v t="leo.20201108101530.76"><vh>void RArgumentsParser::printVersion (rbl_arguments_parser.cpp)</vh></v>
<v t="leo.20201108101530.77"><vh>void RArgumentsParser::printHeader (rbl_arguments_parser.cpp)</vh></v>
<v t="leo.20201108101530.78"><vh>void RArgumentsParser::printFooter (rbl_arguments_parser.cpp)</vh></v>
<v t="leo.20201108101530.79"><vh>void RArgumentsParser::processArgumentList (rbl_arguments_parser.cpp)</vh></v>
<v t="leo.20201108101530.80"><vh>bool RArgumentsParser::processArgument (rbl_arguments_parser.cpp)</vh></v>
</v>
<v t="leo.20201108101531.1"><vh>@clean rbl_argument_option.cpp</vh>
<v t="leo.20201108101531.2"><vh>void RArgumentOption::_init (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.3"><vh>const QString (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.4"><vh>void RArgumentOption::setFlag (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.5"><vh>void RArgumentOption::setType (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.6"><vh>const QVariant (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.7"><vh>void RArgumentOption::setValue (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.8"><vh>const QString (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.9"><vh>void RArgumentOption::setDescription (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.10"><vh>bool RArgumentOption::getMandatory (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.11"><vh>void RArgumentOption::setMandatory (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.12"><vh>bool RArgumentOption::getExclusive (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.13"><vh>void RArgumentOption::setExclusive (rbl_argument_option.cpp)</vh></v>
<v t="leo.20201108101531.14"><vh>bool RArgumentOption::isOption (rbl_argument_option.cpp)</vh></v>
</v>
<v t="leo.20201108101531.15"><vh>@clean rbl_book.cpp</vh>
<v t="leo.20201108101531.16"><vh>void RBook::_init (rbl_book.cpp)</vh></v>
<v t="leo.20201108101531.17"><vh>void RBook::resize (rbl_book.cpp)</vh></v>
<v t="leo.20201108101531.18"><vh>void RBook::initialize (rbl_book.cpp)</vh></v>
<v t="leo.20201108101531.19"><vh>bool RBook::getValue (rbl_book.cpp)</vh></v>
<v t="leo.20201108101531.20"><vh>void RBook::setValue (rbl_book.cpp)</vh></v>
<v t="leo.20201108101531.21"><vh>void RBook::enable (rbl_book.cpp)</vh></v>
<v t="leo.20201108101531.22"><vh>void RBook::disable (rbl_book.cpp)</vh></v>
<v t="leo.20201108101531.23"><vh>void RBook::print (rbl_book.cpp)</vh></v>
</v>
<v t="leo.20201108101531.24"><vh>@clean rbl_bvector.cpp</vh>
<v t="leo.20201108101531.25"><vh>void RBVector::_init (rbl_bvector.cpp)</vh></v>
<v t="leo.20201108101531.26"><vh>void RBVector::fill (rbl_bvector.cpp)</vh></v>
<v t="leo.20201108101531.27"><vh>void RBVector::print (rbl_bvector.cpp)</vh></v>
</v>
<v t="leo.20201108101531.28"><vh>@clean rbl_error.cpp</vh>
<v t="leo.20201108101531.29"><vh>const QString (rbl_error.cpp)</vh></v>
<v t="leo.20201108101531.30"><vh>void RError::_init (rbl_error.cpp)</vh></v>
<v t="leo.20201108101531.31"><vh>void RError::setType (rbl_error.cpp)</vh></v>
<v t="leo.20201108101531.32"><vh>void RError::setMessage (rbl_error.cpp)</vh></v>
<v t="leo.20201108101531.33"><vh>const QString (rbl_error.cpp)</vh></v>
</v>
<v t="leo.20201108101531.34"><vh>@clean rbl_gl_light.cpp</vh>
<v t="leo.20201108101531.35"><vh>void RGLLight::_init (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.36"><vh>bool RGLLight::getEnabled (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.37"><vh>void RGLLight::setEnabled (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.38"><vh>const QColor (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.39"><vh>void RGLLight::setAmbient (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.40"><vh>const QColor (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.41"><vh>void RGLLight::setDiffuse (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.42"><vh>const QColor (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.43"><vh>void RGLLight::setSpecular (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.44"><vh>const RR3Vector (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.45"><vh>void RGLLight::setDirection (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.46"><vh>const RR3Vector (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.47"><vh>void RGLLight::setPosition (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.48"><vh>int RGLLight::getLightNumber (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.49"><vh>void RGLLight::setLightNumber (rbl_gl_light.cpp)</vh></v>
<v t="leo.20201108101531.50"><vh>void RGLLight::setDefault (rbl_gl_light.cpp)</vh></v>
</v>
<v t="leo.20201108101531.51"><vh>@clean rbl_imatrix.cpp</vh>
<v t="leo.20201108101531.52"><vh>int nColumns (rbl_imatrix.cpp)</vh></v>
<v t="leo.20201108101531.53"><vh>void RIMatrix::_init (rbl_imatrix.cpp)</vh></v>
<v t="leo.20201108101531.54"><vh>int RIMatrix::getNRows (rbl_imatrix.cpp)</vh></v>
<v t="leo.20201108101531.55"><vh>int RIMatrix::getNColumns (rbl_imatrix.cpp)</vh></v>
<v t="leo.20201108101531.56"><vh>void RIMatrix::resize (rbl_imatrix.cpp)</vh></v>
<v t="leo.20201108101531.57"><vh>int RIMatrix::getValue (rbl_imatrix.cpp)</vh></v>
<v t="leo.20201108101531.58"><vh>void RIMatrix::setValue (rbl_imatrix.cpp)</vh></v>
<v t="leo.20201108101531.59"><vh>void RIMatrix::transpose (rbl_imatrix.cpp)</vh></v>
<v t="leo.20201108101531.60"><vh>const RIVector (rbl_imatrix.cpp)</vh></v>
<v t="leo.20201108101531.61"><vh>void RIMatrix::clear (rbl_imatrix.cpp)</vh></v>
</v>
<v t="leo.20201108101531.62"><vh>@clean rbl_ivector.cpp</vh>
<v t="leo.20201108101531.63"><vh>void RIVector::_init (rbl_ivector.cpp)</vh></v>
<v t="leo.20201108101531.64"><vh>int &amp; RIVector::operator [] (unsigned int n) (rbl_ivector.cpp)</vh></v>
<v t="leo.20201108101531.65"><vh>const int &amp; RIVector::operator [] (unsigned int n) const (rbl_ivector.cpp)</vh></v>
<v t="leo.20201108101531.66"><vh>void RIVector::fill (rbl_ivector.cpp)</vh></v>
<v t="leo.20201108101531.67"><vh>void RIVector::print (rbl_ivector.cpp)</vh></v>
</v>
<v t="leo.20201108101531.68"><vh>@clean rbl_limit_box.cpp</vh>
<v t="leo.20201108101531.69"><vh>void RLimitBox::_init (rbl_limit_box.cpp)</vh></v>
<v t="leo.20201108101531.70"><vh>void RLimitBox::setLimits (rbl_limit_box.cpp)</vh></v>
<v t="leo.20201108101531.71"><vh>void RLimitBox::scale (rbl_limit_box.cpp)</vh></v>
<v t="leo.20201108101531.72"><vh>void RLimitBox::print (rbl_limit_box.cpp)</vh></v>
<v t="leo.20201108101531.73"><vh>bool RLimitBox::areIntersecting (rbl_limit_box.cpp)</vh></v>
<v t="leo.20201108101531.74"><vh>void RLimitBox::fixLimits (rbl_limit_box.cpp)</vh></v>
</v>
<v t="leo.20201108101531.75"><vh>@clean rbl_local_direction.cpp</vh>
<v t="leo.20201108101531.76"><vh>void RLocalDirection::_init (rbl_local_direction.cpp)</vh></v>
<v t="leo.20201108101531.77"><vh>const RR3Vector (rbl_local_direction.cpp)</vh></v>
<v t="leo.20201108101531.78"><vh>const RR3Vector (rbl_local_direction.cpp)</vh></v>
</v>
<v t="leo.20201108101531.79"><vh>@clean rbl_locker.cpp</vh>
<v t="leo.20201108101531.80"><vh>void RLocker::_init (rbl_locker.cpp)</vh></v>
<v t="leo.20201108101531.81"><vh>void RLocker::setLockHandler (rbl_locker.cpp)</vh></v>
<v t="leo.20201108101531.82"><vh>void RLocker::setLock (rbl_locker.cpp)</vh></v>
<v t="leo.20201108101531.83"><vh>void RLocker::lock (rbl_locker.cpp)</vh></v>
<v t="leo.20201108101531.84"><vh>void RLocker::unlock (rbl_locker.cpp)</vh></v>
</v>
<v t="leo.20201108101531.85"><vh>@clean rbl_logger.cpp</vh>
<v t="leo.20201108101531.86"><vh>void RLogger::_init (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.87"><vh>void RLogger::setLevel (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.88"><vh>bool RLogger::getHalted (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.89"><vh>void RLogger::setHalted (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.90"><vh>bool RLogger::getPrintTimeEnabled (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.91"><vh>void RLogger::setPrintTimeEnabled (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.92"><vh>bool RLogger::getAddNewLine (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.93"><vh>void RLogger::setAddNewLine (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.94"><vh>const QString (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.95"><vh>void RLogger::setFile (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.96"><vh>void RLogger::setLogHandler (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.97"><vh>int RLogger::getIndentLevel (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.98"><vh>void RLogger::setIndentLevel (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.99"><vh>void RLogger::increaseIndent (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.100"><vh>void RLogger::decreaseIndent (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.101"><vh>void RLogger::printToFile (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.102"><vh>void RLogger::insertLabel (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.103"><vh>void RLogger::print (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.104"><vh>void RLogger::print (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.105"><vh>void RLogger::print (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.106"><vh>void RLogger::print (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.107"><vh>void RLogger::flush (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.108"><vh>void RLogger::purge (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.109"><vh>int RLogger::trace (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.110"><vh>int RLogger::debug (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.111"><vh>int RLogger::info (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.112"><vh>int RLogger::notice (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.113"><vh>int RLogger::warning (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.114"><vh>int RLogger::error (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.115"><vh>void RLogger::timestamp (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.116"><vh>void RLogger::indent (rbl_logger.cpp)</vh></v>
<v t="leo.20201108101531.117"><vh>void RLogger::unindent (rbl_logger.cpp)</vh></v>
</v>
<v t="leo.20201108101531.118"><vh>@clean rbl_message.cpp</vh>
<v t="leo.20201108101531.119"><vh>void RMessage::_init (rbl_message.cpp)</vh></v>
<v t="leo.20201108101531.120"><vh>void RMessage::setType (rbl_message.cpp)</vh></v>
<v t="leo.20201108101531.121"><vh>void RMessage::setAtimeToNow (rbl_message.cpp)</vh></v>
</v>
<v t="leo.20201108101531.122"><vh>@clean rbl_plane.cpp</vh>
<v t="leo.20201108101531.123"><vh>void RPlane::_init (rbl_plane.cpp)</vh></v>
<v t="leo.20201108101531.124"><vh>const RR3Vector (rbl_plane.cpp)</vh></v>
<v t="leo.20201108101531.125"><vh>void RPlane::setPosition (rbl_plane.cpp)</vh></v>
<v t="leo.20201108101531.126"><vh>const RR3Vector (rbl_plane.cpp)</vh></v>
<v t="leo.20201108101531.127"><vh>void RPlane::setNormal (rbl_plane.cpp)</vh></v>
<v t="leo.20201108101531.128"><vh>void RPlane::findRotationMatrix (rbl_plane.cpp)</vh></v>
<v t="leo.20201108101531.129"><vh>void RPlane::findPoints (rbl_plane.cpp)</vh></v>
<v t="leo.20201108101531.130"><vh>bool RPlane::findLineIntersection (rbl_plane.cpp)</vh>
<v t="leo.20201108101531.131"><vh>double n (rbl_plane.cpp)</vh></v>
</v>
<v t="leo.20201108101531.132"><vh>bool RPlane::findSegmentIntersection (rbl_plane.cpp)</vh></v>
</v>
<v t="leo.20201108101532.1"><vh>@clean rbl_progress.cpp</vh>
<v t="leo.20201108101532.2"><vh>void RProgress::_init (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.3"><vh>bool RProgress::getPrintToLog (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.4"><vh>void RProgress::setPrintToLog (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.5"><vh>void RProgress::setProgressPrintHandler (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.6"><vh>void RProgress::setProgressInitializeHandler (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.7"><vh>void RProgress::setProgressFinalizeHandler (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.8"><vh>void RProgress::initialize (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.9"><vh>void RProgress::finalize (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.10"><vh>void RProgress::print (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.11"><vh>void RProgressInitialize (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.12"><vh>void RProgressFinalize (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.13"><vh>void RProgressPrint (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.14"><vh>void RProgressPrint (rbl_progress.cpp)</vh></v>
<v t="leo.20201108101532.15"><vh>void RProgressPrintToLog (rbl_progress.cpp)</vh></v>
</v>
<v t="leo.20201108101532.16"><vh>@clean rbl_r3vector.cpp</vh>
<v t="leo.20201108101532.17"><vh>void RR3Vector::_init (rbl_r3vector.cpp)</vh></v>
<v t="leo.20201108101532.18"><vh>void RR3Vector::findRotationMatrix (rbl_r3vector.cpp)</vh></v>
<v t="leo.20201108101532.19"><vh>void RR3Vector::clear (rbl_r3vector.cpp)</vh></v>
<v t="leo.20201108101532.20"><vh>void RR3Vector::cross (rbl_r3vector.cpp)</vh></v>
<v t="leo.20201108101532.21"><vh>bool RR3Vector::areParallel (rbl_r3vector.cpp)</vh></v>
</v>
<v t="leo.20201108101532.22"><vh>@clean rbl_rmatrix.cpp</vh>
<v t="leo.20201108101532.23"><vh>double value (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.24"><vh>void RRMatrix::_init (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.25"><vh>void RRMatrix::resize (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.26"><vh>void RRMatrix::setIdentity (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.27"><vh>void RRMatrix::fill (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.28"><vh>void RRMatrix::setValue (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.29"><vh>bool RRMatrix::isSquare (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.30"><vh>void RRMatrix::transpose (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.31"><vh>void RRMatrix::transpose (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.32"><vh>void RRMatrix::invert (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.33"><vh>void RRMatrix::decomposeToLU (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.34"><vh>const RRVector (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.35"><vh>void RRMatrix::operator (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.36"><vh>bool RRMatrix::operator (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.37"><vh>bool RRMatrix::operator (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.38"><vh>void RRMatrix::setBlock (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.39"><vh>void RRMatrix::print (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.40"><vh>void RRMatrix::clear (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.41"><vh>void RRMatrix::solveLU (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.42"><vh>void RRMatrix::mlt (rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101532.43"><vh>void RRMatrix::mlt (rbl_rmatrix.cpp)</vh></v>
</v>
<v t="leo.20201108101532.44"><vh>@clean rbl_rvector.cpp</vh>
<v t="leo.20201108101532.45"><vh>void RRVector::fill (rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101532.46"><vh>void RRVector::append (rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101532.47"><vh>void RRVector::_init (rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101532.48"><vh>const double &amp; RRVector::operator [](uint n) const (rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101532.49"><vh>void RRVector::operator (rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101532.50"><vh>bool RRVector::operator (rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101532.51"><vh>bool RRVector::operator (rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101532.52"><vh>void RRVector::scale (rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101532.53"><vh>void RRVector::print (rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101532.54"><vh>void RRVector::add (rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101532.55"><vh>void RRVector::subtract (rbl_rvector.cpp)</vh></v>
</v>
<v t="leo.20201108101532.56"><vh>@clean rbl_statistics.cpp</vh>
<v t="leo.20201108101532.57"><vh>void RStatistics::_init (rbl_statistics.cpp)</vh></v>
<v t="leo.20201108101532.58"><vh>void RStatistics::print (rbl_statistics.cpp)</vh></v>
<v t="leo.20201108101532.59"><vh>void RStatistics::calculate (rbl_statistics.cpp)</vh></v>
</v>
<v t="leo.20201108101532.60"><vh>@clean rbl_stop_watch.cpp</vh>
<v t="leo.20201108101532.61"><vh>void RStopWatch::_init (rbl_stop_watch.cpp)</vh></v>
<v t="leo.20201108101532.62"><vh>void RStopWatch::reset (rbl_stop_watch.cpp)</vh></v>
<v t="leo.20201108101532.63"><vh>void RStopWatch::pause (rbl_stop_watch.cpp)</vh></v>
<v t="leo.20201108101532.64"><vh>void RStopWatch::resume (rbl_stop_watch.cpp)</vh></v>
<v t="leo.20201108101532.65"><vh>void RStopWatch::addElapsedTime (rbl_stop_watch.cpp)</vh></v>
</v>
<v t="leo.20201108101532.66"><vh>@clean rbl_utils.cpp</vh>
<v t="leo.20201108101532.67"><vh>float storeFloat (rbl_utils.cpp)</vh></v>
<v t="leo.20201108101532.68"><vh>double storeDouble (rbl_utils.cpp)</vh></v>
<v t="leo.20201108101532.69"><vh>float RConstants::findMachineFloatEpsilon (rbl_utils.cpp)</vh></v>
</v>
<v t="leo.20201108101532.70"><vh>@clean rbl_uvector.cpp</vh>
<v t="leo.20201108101532.71"><vh>void RUVector::_init (rbl_uvector.cpp)</vh></v>
<v t="leo.20201108101532.72"><vh>unsigned int &amp; RUVector::operator [] (unsigned int n) (rbl_uvector.cpp)</vh></v>
<v t="leo.20201108101532.73"><vh>const unsigned int &amp; RUVector::operator [] (unsigned int n) const (rbl_uvector.cpp)</vh></v>
<v t="leo.20201108101532.74"><vh>void RUVector::fill (rbl_uvector.cpp)</vh></v>
<v t="leo.20201108101532.75"><vh>void RUVector::print (rbl_uvector.cpp)</vh></v>
</v>
<v t="leo.20201108101532.76"><vh>@clean rbl_value.cpp</vh></v>
<v t="leo.20201108101532.77"><vh>@clean rbl_value_table.cpp</vh>
<v t="leo.20201108101532.78"><vh>void RValueTable::_init (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.79"><vh>const QString (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.80"><vh>void RValueTable::setKeyName (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.81"><vh>const QString (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.82"><vh>void RValueTable::setKeyUnits (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.83"><vh>const QString (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.84"><vh>void RValueTable::setValueName (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.85"><vh>const QString (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.86"><vh>void RValueTable::setValueUnits (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.87"><vh>int RValueTable::size (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.88"><vh>void RValueTable::add (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.89"><vh>void RValueTable::remove (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.90"><vh>void RValueTable::remove (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.91"><vh>bool RValueTable::operator (rbl_value_table.cpp)</vh></v>
<v t="leo.20201108101532.92"><vh>bool RValueTable::operator (rbl_value_table.cpp)</vh></v>
</v>
<v t="leo.20201108101532.93"><vh>@clean rbl_value_vector.cpp</vh>
<v t="leo.20201108101532.94"><vh>void RValueVector::_init (rbl_value_vector.cpp)</vh></v>
<v t="leo.20201108101532.95"><vh>const QString (rbl_value_vector.cpp)</vh></v>
<v t="leo.20201108101532.96"><vh>void RValueVector::setName (rbl_value_vector.cpp)</vh></v>
<v t="leo.20201108101532.97"><vh>const QString (rbl_value_vector.cpp)</vh></v>
<v t="leo.20201108101532.98"><vh>void RValueVector::setUnits (rbl_value_vector.cpp)</vh></v>
<v t="leo.20201108101532.99"><vh>int RValueVector::size (rbl_value_vector.cpp)</vh></v>
<v t="leo.20201108101532.100"><vh>void RValueVector::resize (rbl_value_vector.cpp)</vh></v>
<v t="leo.20201108101532.101"><vh>void RValueVector::add (rbl_value_vector.cpp)</vh></v>
<v t="leo.20201108101532.102"><vh>void RValueVector::remove (rbl_value_vector.cpp)</vh></v>
<v t="leo.20201108101532.103"><vh>void RValueVector::remove (rbl_value_vector.cpp)</vh></v>
<v t="leo.20201108101532.104"><vh>void RValueVector::fill (rbl_value_vector.cpp)</vh></v>
</v>
<v t="leo.20201108101532.105"><vh>@clean rbl_version.cpp</vh>
<v t="leo.20201108101532.106"><vh>void RVersion::_init (rbl_version.cpp)</vh></v>
<v t="leo.20201108101532.107"><vh>bool RVersion::operator (rbl_version.cpp)</vh></v>
<v t="leo.20201108101532.108"><vh>bool RVersion::operator (rbl_version.cpp)</vh></v>
<v t="leo.20201108101532.109"><vh>bool RVersion::operator (rbl_version.cpp)</vh></v>
<v t="leo.20201108101532.110"><vh>bool RVersion::operator (rbl_version.cpp)</vh></v>
<v t="leo.20201108101532.111"><vh>bool RVersion::operator (rbl_version.cpp)</vh></v>
<v t="leo.20201108101532.112"><vh>bool RVersion::operator (rbl_version.cpp)</vh></v>
<v t="leo.20201108101532.113"><vh>int RVersion::getMajor (rbl_version.cpp)</vh></v>
<v t="leo.20201108101532.114"><vh>int RVersion::getMinor (rbl_version.cpp)</vh></v>
<v t="leo.20201108101532.115"><vh>int RVersion::getRelease (rbl_version.cpp)</vh></v>
</v>
</v>
</v>
<v t="leo.20201108101533.1"><vh>@path RangeModel</vh>
<v t="leo.20201108101533.3"><vh>@path src</vh>
<v t="leo.20201108101533.4"><vh>@clean rml_boundary_condition.cpp</vh>
<v t="leo.20201108101533.5"><vh>typedef struct (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.6"><vh>const RBoundaryConditionDesc (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.7"><vh>void RBoundaryCondition::_init (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.8"><vh>void RBoundaryCondition::setType (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.9"><vh>void RBoundaryCondition::setTypeSafe (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.10"><vh>bool RBoundaryCondition::getHasLocalDirection (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.11"><vh>const RR3Vector (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.12"><vh>void RBoundaryCondition::setLocalDirection (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.13"><vh>const QString (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.14"><vh>bool RBoundaryCondition::getOptional (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.15"><vh>bool RBoundaryCondition::getExplicit (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.16"><vh>bool RBoundaryCondition::getApplyOnPoint (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.17"><vh>bool RBoundaryCondition::getApplyOnLine (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.18"><vh>bool RBoundaryCondition::getApplyOnSurface (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.19"><vh>bool RBoundaryCondition::getApplyOnVolume (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.20"><vh>bool RBoundaryCondition::getHasLocalDirection (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.21"><vh>bool RBoundaryCondition::getHasExplicit (rml_boundary_condition.cpp)</vh></v>
<v t="leo.20201108101533.22"><vh>void operator (rml_boundary_condition.cpp)</vh></v>
</v>
<v t="leo.20201108101533.23"><vh>@clean rml_condition.cpp</vh>
<v t="leo.20201108101533.24"><vh>void RCondition::_init (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.25"><vh>const QString (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.26"><vh>void RCondition::setName (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.27"><vh>bool RCondition::getApplyOnPoint (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.28"><vh>void RCondition::setApplyOnPoint (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.29"><vh>bool RCondition::getApplyOnLine (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.30"><vh>void RCondition::setApplyOnLine (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.31"><vh>bool RCondition::getApplyOnSurface (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.32"><vh>void RCondition::setApplyOnSurface (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.33"><vh>bool RCondition::getApplyOnVolume (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.34"><vh>void RCondition::setApplyOnVolume (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.35"><vh>void RCondition::setProblemTypeMask (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.36"><vh>bool RCondition::checkProblemTypeMask (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.37"><vh>int RCondition::size (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.38"><vh>bool RCondition::addComponent (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.39"><vh>const RConditionComponent (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.40"><vh>void RCondition::removeComponent (rml_condition.cpp)</vh></v>
<v t="leo.20201108101533.41"><vh>int RCondition::findComponentPosition (rml_condition.cpp)</vh></v>
</v>
<v t="leo.20201108101533.42"><vh>@clean rml_condition_component.cpp</vh>
<v t="leo.20201108101533.43"><vh>void RConditionComponent::_init (rml_condition_component.cpp)</vh></v>
<v t="leo.20201108101533.44"><vh>void RConditionComponent::setType (rml_condition_component.cpp)</vh></v>
<v t="leo.20201108101533.45"><vh>const QString (rml_condition_component.cpp)</vh></v>
<v t="leo.20201108101533.46"><vh>void RConditionComponent::setName (rml_condition_component.cpp)</vh></v>
<v t="leo.20201108101533.47"><vh>const QString (rml_condition_component.cpp)</vh></v>
<v t="leo.20201108101533.48"><vh>void RConditionComponent::setUnits (rml_condition_component.cpp)</vh></v>
</v>
<v t="leo.20201108101533.49"><vh>@clean rml_cut.cpp</vh>
<v t="leo.20201108101533.50"><vh>void RCut::_init (rml_cut.cpp)</vh></v>
<v t="leo.20201108101533.51"><vh>const RPlane (rml_cut.cpp)</vh></v>
<v t="leo.20201108101533.52"><vh>void RCut::setPlane (rml_cut.cpp)</vh></v>
<v t="leo.20201108101533.53"><vh>const std::vector (rml_cut.cpp)</vh></v>
<v t="leo.20201108101533.54"><vh>bool RCut::addElementGroupID (rml_cut.cpp)</vh></v>
<v t="leo.20201108101533.55"><vh>bool RCut::removeElementGroupID (rml_cut.cpp)</vh></v>
<v t="leo.20201108101533.56"><vh>void RCut::clearElementGroupIDs (rml_cut.cpp)</vh></v>
</v>
<v t="leo.20201108101533.57"><vh>@clean rml_eigen_value_solver_conf.cpp</vh>
<v t="leo.20201108101533.58"><vh>typedef struct (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.59"><vh>static REigenValueSolverDesc (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.60"><vh>void REigenValueSolverConf::_init (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.61"><vh>void REigenValueSolverConf::setMethod (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.62"><vh>int REigenValueSolverConf::getNIterations (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.63"><vh>void REigenValueSolverConf::setNIterations (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.64"><vh>int REigenValueSolverConf::getNEigenValues (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.65"><vh>void REigenValueSolverConf::setNEigenValues (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.66"><vh>void REigenValueSolverConf::setSolverCvgValue (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.67"><vh>int REigenValueSolverConf::getOutputFrequency (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.68"><vh>void REigenValueSolverConf::setOutputFrequency (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.69"><vh>const QString (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.70"><vh>void REigenValueSolverConf::setOutputFileName (rml_eigen_value_solver_conf.cpp)</vh></v>
<v t="leo.20201108101533.71"><vh>const QString (rml_eigen_value_solver_conf.cpp)</vh></v>
</v>
<v t="leo.20201108101533.72"><vh>@clean rml_element.cpp</vh>
<v t="leo.20201108101533.73"><vh>typedef struct (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.74"><vh>const RElementDesc (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.75"><vh>void RElement::_init (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.76"><vh>bool RElement::operator (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.77"><vh>bool RElement::operator (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.78"><vh>void RElement::setType (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.79"><vh>int RElement::size (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.80"><vh>int RElement::getNodeId (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.81"><vh>void RElement::setNodeId (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.82"><vh>void RElement::swapNodeIds (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.83"><vh>bool RElement::hasNodeId (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.84"><vh>bool RElement::hasDuplicateNodes (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.85"><vh>bool RElement::swapNormal (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.86"><vh>bool RElement::findNormal (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.87"><vh>void RElement::findCenter (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.88"><vh>bool RElement::findShortestEdge (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.89"><vh>bool RElement::findLength (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.90"><vh>bool RElement::findArea (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.91"><vh>bool RElement::findVolume (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.92"><vh>bool RElement::findPickDistance (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.93"><vh>bool RElement::isInside (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.94"><vh>bool RElement::isInside (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.95"><vh>const RNode (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.96"><vh>int RElement::findIntersectedSide (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.97"><vh>bool RElement::isNeighbor (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.98"><vh>int RElement::findEdgePositionForNeighborElement (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.99"><vh>bool RElement::isNeighborNormalSync (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.100"><vh>bool RElement::nodeIsOnEdge (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.101"><vh>bool RElement::mergeNodes (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.102"><vh>void RElement::breakWithNodes (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.103"><vh>void RElement::breakWithNode (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.104"><vh>void RElement::findLimitBox (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.105"><vh>void RElement::findScalarNodeValues (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.106"><vh>void RElement::findDisplacementNodeValues (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.107"><vh>void RElement::print (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.108"><vh>void RElement::print (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.109"><vh>const QString (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.110"><vh>int RElement::getNNodes (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.111"><vh>int RElement::getNNeighbors (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.112"><vh>int RElement::getNIntegrationPoints (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.113"><vh>const RElementShapeFunction (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.114"><vh>const RRMatrix (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.115"><vh>const RRVector (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.116"><vh>bool RElement::hasConstantDerivative (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.117"><vh>bool RElement::findIntersectionPoints (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.118"><vh>bool RElement::isInsideBoundingBox (rml_element.cpp)</vh></v>
<v t="leo.20201108101533.119"><vh>bool RElement::testPlaneIntersect (rml_element.cpp)</vh></v>
</v>
<v t="leo.20201108101533.120"><vh>@clean rml_element_group.cpp</vh>
<v t="leo.20201108101533.121"><vh>void RElementGroup::_init (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.122"><vh>void RElementGroup::add (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.123"><vh>int RElementGroup::get (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.124"><vh>void RElementGroup::remove (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.125"><vh>void RElementGroup::set (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.126"><vh>bool RElementGroup::findPosition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.127"><vh>int RElementGroup::size (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.128"><vh>void RElementGroup::resize (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.129"><vh>void RElementGroup::addBoundaryCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.130"><vh>bool RElementGroup::hasBoundaryCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.131"><vh>const RBoundaryCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.132"><vh>const RBoundaryCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.133"><vh>void RElementGroup::removeBoundaryCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.134"><vh>void RElementGroup::removeBoundaryCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.135"><vh>void RElementGroup::removeAllBoundaryConditions (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.136"><vh>void RElementGroup::addEnvironmentCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.137"><vh>bool RElementGroup::hasEnvironmentCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.138"><vh>const REnvironmentCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.139"><vh>const REnvironmentCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.140"><vh>void RElementGroup::removeEnvironmentCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.141"><vh>void RElementGroup::removeEnvironmentCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.142"><vh>void RElementGroup::removeAllEnvironmentConditions (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.143"><vh>void RElementGroup::addInitialCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.144"><vh>bool RElementGroup::hasInitialCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.145"><vh>const RInitialCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.146"><vh>const RInitialCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.147"><vh>void RElementGroup::removeInitialCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.148"><vh>void RElementGroup::removeInitialCondition (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.149"><vh>void RElementGroup::removeAllInitialConditions (rml_element_group.cpp)</vh></v>
<v t="leo.20201108101533.150"><vh>void RElementGroup::setDefaultEnvironmentConditions (rml_element_group.cpp)</vh></v>
</v>
<v t="leo.20201108101533.151"><vh>@clean rml_element_shape_derivation.cpp</vh>
<v t="leo.20201108101533.152"><vh>void RElementShapeDerivation::_init (rml_element_shape_derivation.cpp)</vh></v>
<v t="leo.20201108101533.153"><vh>const RRMatrix (rml_element_shape_derivation.cpp)</vh></v>
<v t="leo.20201108101533.154"><vh>void RElementShapeDerivation::generateFluid (rml_element_shape_derivation.cpp)</vh></v>
</v>
<v t="leo.20201108101534.1"><vh>@clean rml_element_shape_function.cpp</vh>
<v t="leo.20201108101534.2"><vh>void RElementShapeFunction::_init (rml_element_shape_function.cpp)</vh></v>
<v t="leo.20201108101534.3"><vh>int RElementShapeFunction::getNNodes (rml_element_shape_function.cpp)</vh></v>
<v t="leo.20201108101534.4"><vh>const RRVector (rml_element_shape_function.cpp)</vh></v>
<v t="leo.20201108101534.5"><vh>const RRMatrix (rml_element_shape_function.cpp)</vh></v>
<v t="leo.20201108101534.6"><vh>const double &amp;RElementShapeFunction::getW(void) const (rml_element_shape_function.cpp)</vh></v>
</v>
<v t="leo.20201108101534.7"><vh>@clean rml_entity_group.cpp</vh>
<v t="leo.20201108101534.8"><vh>void REntityGroup::_init (rml_entity_group.cpp)</vh></v>
<v t="leo.20201108101534.9"><vh>const QString (rml_entity_group.cpp)</vh></v>
<v t="leo.20201108101534.10"><vh>void REntityGroup::setName (rml_entity_group.cpp)</vh></v>
<v t="leo.20201108101534.11"><vh>const QString (rml_entity_group.cpp)</vh></v>
<v t="leo.20201108101534.12"><vh>bool REntityGroup::typeIsElementGroup (rml_entity_group.cpp)</vh></v>
<v t="leo.20201108101534.13"><vh>bool REntityGroup::typeIsInterpolatedElementGroup (rml_entity_group.cpp)</vh></v>
</v>
<v t="leo.20201108101534.14"><vh>@clean rml_entity_group_data.cpp</vh>
<v t="leo.20201108101534.15"><vh>typedef struct (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.16"><vh>const REntityGroupVariableDisplayDesc (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.17"><vh>void REntityGroupData::_init (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.18"><vh>bool REntityGroupData::getSelected (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.19"><vh>void REntityGroupData::setSelected (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.20"><vh>bool REntityGroupData::getVisible (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.21"><vh>void REntityGroupData::setVisible (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.22"><vh>void REntityGroupData::getColor (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.23"><vh>void REntityGroupData::setColor (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.24"><vh>bool REntityGroupData::getDrawWire (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.25"><vh>void REntityGroupData::setDrawWire (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.26"><vh>bool REntityGroupData::getDrawEdges (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.27"><vh>void REntityGroupData::setDrawEdges (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.28"><vh>bool REntityGroupData::getDrawNodes (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.29"><vh>void REntityGroupData::setDrawNodes (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.30"><vh>bool REntityGroupData::getDrawElementNumbers (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.31"><vh>void REntityGroupData::setDrawElementNumbers (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.32"><vh>bool REntityGroupData::getDrawNodeNumbers (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.33"><vh>void REntityGroupData::setDrawNodeNumbers (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.34"><vh>bool REntityGroupData::getDrawArrowHeads (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.35"><vh>void REntityGroupData::setDrawArrowHeads (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.36"><vh>bool REntityGroupData::getDrawEqualArrowLength (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.37"><vh>void REntityGroupData::setDrawEqualArrowLength (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.38"><vh>bool REntityGroupData::getDrawArrowFrom (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.39"><vh>void REntityGroupData::setDrawArrowFrom (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.40"><vh>bool REntityGroupData::getColorByPatch (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.41"><vh>void REntityGroupData::setColorByPatch (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.42"><vh>bool REntityGroupData::getColorByViewFactor (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.43"><vh>void REntityGroupData::setColorByViewFactor (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.44"><vh>const std::map (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.45"><vh>void REntityGroupData::setVariableData (rml_entity_group_data.cpp)</vh></v>
<v t="leo.20201108101534.46"><vh>const QString (rml_entity_group_data.cpp)</vh></v>
</v>
<v t="leo.20201108101534.47"><vh>@clean rml_environment_condition.cpp</vh>
<v t="leo.20201108101534.48"><vh>typedef struct (rml_environment_condition.cpp)</vh></v>
<v t="leo.20201108101534.49"><vh>const REnvironmentConditionDesc (rml_environment_condition.cpp)</vh></v>
<v t="leo.20201108101534.50"><vh>void REnvironmentCondition::_init (rml_environment_condition.cpp)</vh></v>
<v t="leo.20201108101534.51"><vh>void REnvironmentCondition::setType (rml_environment_condition.cpp)</vh></v>
<v t="leo.20201108101534.52"><vh>void REnvironmentCondition::setTypeSafe (rml_environment_condition.cpp)</vh></v>
<v t="leo.20201108101534.53"><vh>const QString (rml_environment_condition.cpp)</vh></v>
<v t="leo.20201108101534.54"><vh>void operator (rml_environment_condition.cpp)</vh></v>
</v>
<v t="leo.20201108101534.55"><vh>@clean rml_file.cpp</vh>
<v t="leo.20201108101534.56"><vh>void RFile::_init (rml_file.cpp)</vh></v>
<v t="leo.20201108101534.57"><vh>const RVersion (rml_file.cpp)</vh></v>
<v t="leo.20201108101534.58"><vh>void RFile::setVersion (rml_file.cpp)</vh></v>
</v>
<v t="leo.20201108101534.59"><vh>@clean rml_file_header.cpp</vh>
<v t="leo.20201108101534.60"><vh>void RFileHeader::_init (rml_file_header.cpp)</vh></v>
<v t="leo.20201108101534.61"><vh>const QString (rml_file_header.cpp)</vh></v>
<v t="leo.20201108101534.62"><vh>const RVersion (rml_file_header.cpp)</vh></v>
<v t="leo.20201108101534.63"><vh>void RFileHeader::setVersion (rml_file_header.cpp)</vh></v>
<v t="leo.20201108101534.64"><vh>void RFileHeader::setType (rml_file_header.cpp)</vh></v>
<v t="leo.20201108101534.65"><vh>const QString (rml_file_header.cpp)</vh></v>
<v t="leo.20201108101534.66"><vh>void RFileHeader::setInformation (rml_file_header.cpp)</vh></v>
</v>
<v t="leo.20201108101534.67"><vh>@clean rml_file_io.cpp</vh>
<v t="leo.20201108101534.68"><vh>void RFileIO::writeNewLineAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.69"><vh>void RFileIO::writeNewLineAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.70"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.71"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.72"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.73"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.74"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.75"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.76"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.77"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.78"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.79"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.80"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.81"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.82"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.83"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.84"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.85"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.86"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.87"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.88"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.89"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.90"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.91"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.92"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.93"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.94"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.95"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.96"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.97"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.98"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.99"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.100"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.101"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.102"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.103"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.104"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.105"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.106"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.107"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.108"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.109"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.110"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.111"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.112"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.113"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.114"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.115"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.116"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.117"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.118"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.119"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.120"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.121"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.122"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.123"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.124"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.125"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.126"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.127"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.128"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.129"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.130"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.131"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.132"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.133"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.134"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.135"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.136"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.137"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.138"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.139"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.140"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.141"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.142"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.143"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.144"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.145"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.146"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.147"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.148"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.149"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.150"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.151"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.152"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.153"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.154"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.155"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.156"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.157"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.158"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.159"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.160"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.161"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.162"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.163"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.164"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.165"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.166"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.167"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.168"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.169"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.170"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.171"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.172"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.173"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.174"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.175"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.176"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.177"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.178"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.179"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.180"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.181"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.182"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.183"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.184"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.185"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.186"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.187"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.188"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.189"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.190"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.191"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.192"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.193"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.194"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.195"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.196"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.197"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.198"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.199"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.200"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.201"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.202"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.203"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.204"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.205"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.206"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.207"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.208"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.209"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.210"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.211"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.212"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.213"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.214"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.215"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.216"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.217"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.218"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.219"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.220"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.221"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.222"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.223"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.224"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.225"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.226"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.227"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.228"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.229"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.230"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.231"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.232"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.233"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.234"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.235"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.236"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.237"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.238"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.239"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.240"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.241"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.242"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.243"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.244"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.245"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.246"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.247"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.248"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.249"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.250"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.251"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.252"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.253"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.254"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.255"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.256"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.257"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.258"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.259"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.260"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.261"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.262"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.263"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.264"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.265"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.266"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.267"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.268"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.269"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.270"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.271"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.272"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.273"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.274"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.275"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.276"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.277"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.278"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.279"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.280"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.281"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.282"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.283"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.284"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.285"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.286"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.287"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.288"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.289"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.290"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.291"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.292"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.293"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.294"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.295"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.296"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.297"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.298"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.299"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.300"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.301"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.302"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.303"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.304"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.305"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.306"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.307"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.308"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.309"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.310"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.311"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.312"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.313"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.314"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.315"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.316"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.317"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.318"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.319"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.320"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.321"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.322"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.323"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.324"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.325"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.326"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.327"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.328"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.329"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.330"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.331"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.332"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.333"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.334"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.335"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.336"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.337"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.338"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.339"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.340"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.341"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.342"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.343"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.344"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.345"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.346"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.347"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.348"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.349"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.350"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.351"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.352"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.353"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.354"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.355"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.356"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.357"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.358"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.359"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.360"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.361"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.362"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.363"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.364"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.365"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.366"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.367"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.368"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.369"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.370"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.371"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.372"><vh>void RFileIO::readAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.373"><vh>void RFileIO::readBinary (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.374"><vh>void RFileIO::writeAscii (rml_file_io.cpp)</vh></v>
<v t="leo.20201108101534.375"><vh>void RFileIO::writeBinary (rml_file_io.cpp)</vh></v>
</v>
<v t="leo.20201108101534.376"><vh>@clean rml_file_manager.cpp</vh>
<v t="leo.20201108101534.377"><vh>void RFileManager::remove (rml_file_manager.cpp)</vh></v>
<v t="leo.20201108101534.378"><vh>void RFileManager::rename (rml_file_manager.cpp)</vh></v>
<v t="leo.20201108101534.379"><vh>int RFileManager::listDirectory (rml_file_manager.cpp)</vh></v>
<v t="leo.20201108101534.380"><vh>bool RFileManager::fileExists (rml_file_manager.cpp)</vh></v>
<v t="leo.20201108101534.381"><vh>void RFileManager::writeLink (rml_file_manager.cpp)</vh></v>
</v>
<v t="leo.20201108101534.382"><vh>@clean rml_gl_display_properties.cpp</vh>
<v t="leo.20201108101534.383"><vh>int lightNums (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.384"><vh>void RGLDisplayProperties::_init (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.385"><vh>bool RGLDisplayProperties::getDrawGlobalAxis (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.386"><vh>void RGLDisplayProperties::setDrawGlobalAxis (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.387"><vh>bool RGLDisplayProperties::getDrawLocalAxis (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.388"><vh>void RGLDisplayProperties::setDrawLocalAxis (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.389"><vh>bool RGLDisplayProperties::getShowModelEdges (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.390"><vh>void RGLDisplayProperties::setShowModelEdges (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.391"><vh>bool RGLDisplayProperties::getShowModelDimensions (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.392"><vh>void RGLDisplayProperties::setShowModelDimensions (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.393"><vh>bool RGLDisplayProperties::getShowErrors (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.394"><vh>void RGLDisplayProperties::setShowErrors (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.395"><vh>const QColor (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.396"><vh>void RGLDisplayProperties::setBgColor (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.397"><vh>bool RGLDisplayProperties::getBgGradient (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.398"><vh>void RGLDisplayProperties::setBgGradient (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.399"><vh>void RGLDisplayProperties::setNLights (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.400"><vh>const RGLLight (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.401"><vh>void RGLDisplayProperties::setLight (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.402"><vh>void RGLDisplayProperties::read (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.403"><vh>void RGLDisplayProperties::write (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.404"><vh>void RGLDisplayProperties::writeAscii (rml_gl_display_properties.cpp)</vh></v>
<v t="leo.20201108101534.405"><vh>void RGLDisplayProperties::writeBinary (rml_gl_display_properties.cpp)</vh></v>
</v>
<v t="leo.20201108101535.1"><vh>@clean rml_initial_condition.cpp</vh>
<v t="leo.20201108101535.2"><vh>typedef struct (rml_initial_condition.cpp)</vh></v>
<v t="leo.20201108101535.3"><vh>const RInitialConditionDesc (rml_initial_condition.cpp)</vh></v>
<v t="leo.20201108101535.4"><vh>void RInitialCondition::_init (rml_initial_condition.cpp)</vh></v>
<v t="leo.20201108101535.5"><vh>void RInitialCondition::setType (rml_initial_condition.cpp)</vh></v>
<v t="leo.20201108101535.6"><vh>void RInitialCondition::setTypeSafe (rml_initial_condition.cpp)</vh></v>
<v t="leo.20201108101535.7"><vh>const QString (rml_initial_condition.cpp)</vh></v>
<v t="leo.20201108101535.8"><vh>void operator (rml_initial_condition.cpp)</vh></v>
</v>
<v t="leo.20201108101535.9"><vh>@clean rml_interpolated_element.cpp</vh>
<v t="leo.20201108101535.10"><vh>void RInterpolatedElement::_init (rml_interpolated_element.cpp)</vh></v>
<v t="leo.20201108101535.11"><vh>void RInterpolatedElement::sortNodes (rml_interpolated_element.cpp)</vh></v>
<v t="leo.20201108101535.12"><vh>void RInterpolatedElement::removeDuplicateNodes (rml_interpolated_element.cpp)</vh></v>
<v t="leo.20201108101535.13"><vh>void RInterpolatedElement::findCenter (rml_interpolated_element.cpp)</vh></v>
<v t="leo.20201108101535.14"><vh>bool RInterpolatedElement::findNormal (rml_interpolated_element.cpp)</vh></v>
<v t="leo.20201108101535.15"><vh>bool RInterpolatedElement::findPickDistance (rml_interpolated_element.cpp)</vh></v>
<v t="leo.20201108101535.16"><vh>void RInterpolatedElement::findScalarNodeValues (rml_interpolated_element.cpp)</vh></v>
<v t="leo.20201108101535.17"><vh>void RInterpolatedElement::findDisplacementNodeValues (rml_interpolated_element.cpp)</vh></v>
</v>
<v t="leo.20201108101535.18"><vh>@clean rml_interpolated_entity.cpp</vh>
<v t="leo.20201108101535.19"><vh>void RInterpolatedEntity::_init (rml_interpolated_entity.cpp)</vh></v>
</v>
<v t="leo.20201108101535.20"><vh>@clean rml_interpolated_node.cpp</vh>
<v t="leo.20201108101535.21"><vh>void RInterpolatedNode::_init (rml_interpolated_node.cpp)</vh></v>
<v t="leo.20201108101535.22"><vh>int RInterpolatedNode::getElementID (rml_interpolated_node.cpp)</vh></v>
<v t="leo.20201108101535.23"><vh>void RInterpolatedNode::setElementID (rml_interpolated_node.cpp)</vh></v>
</v>
<v t="leo.20201108101535.24"><vh>@clean rml_iso.cpp</vh>
<v t="leo.20201108101535.25"><vh>void RIso::_init (rml_iso.cpp)</vh></v>
<v t="leo.20201108101535.26"><vh>void RIso::setVariableType (rml_iso.cpp)</vh></v>
<v t="leo.20201108101535.27"><vh>void RIso::setVariableValue (rml_iso.cpp)</vh></v>
<v t="leo.20201108101535.28"><vh>const std::vector (rml_iso.cpp)</vh></v>
<v t="leo.20201108101535.29"><vh>bool RIso::addElementGroupID (rml_iso.cpp)</vh></v>
<v t="leo.20201108101535.30"><vh>bool RIso::removeElementGroupID (rml_iso.cpp)</vh></v>
<v t="leo.20201108101535.31"><vh>void RIso::clearElementGroupIDs (rml_iso.cpp)</vh></v>
</v>
<v t="leo.20201108101535.32"><vh>@clean rml_line.cpp</vh>
<v t="leo.20201108101535.33"><vh>void RLine::_init (rml_line.cpp)</vh></v>
<v t="leo.20201108101535.34"><vh>void RLine::setCrossArea (rml_line.cpp)</vh></v>
</v>
<v t="leo.20201108101535.35"><vh>@clean rml_material.cpp</vh>
<v t="leo.20201108101535.36"><vh>void RMaterial::_init (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.37"><vh>bool RMaterial::propertiesEqual (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.38"><vh>int RMaterial::getID (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.39"><vh>void RMaterial::setID (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.40"><vh>const QString (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.41"><vh>void RMaterial::setName (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.42"><vh>void RMaterial::setState (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.43"><vh>int RMaterial::size (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.44"><vh>bool RMaterial::add (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.45"><vh>const RMaterialProperty (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.46"><vh>void RMaterial::remove (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.47"><vh>void RMaterial::clear (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.48"><vh>int RMaterial::findPosition (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.49"><vh>bool RMaterial::hasProperties (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.50"><vh>void RMaterial::read (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.51"><vh>void RMaterial::write (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.52"><vh>void RMaterial::import (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.53"><vh>bool RMaterial::validForProblemType (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.54"><vh>void RMaterial::readAscii (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.55"><vh>void RMaterial::readBinary (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.56"><vh>void RMaterial::writeAscii (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.57"><vh>void RMaterial::writeBinary (rml_material.cpp)</vh></v>
<v t="leo.20201108101535.58"><vh>bool propertyTypeCompareFunc (rml_material.cpp)</vh></v>
</v>
<v t="leo.20201108101535.59"><vh>@clean rml_material_list.cpp</vh>
<v t="leo.20201108101535.60"><vh>void RMaterialList::_init (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.61"><vh>int RMaterialList::size (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.62"><vh>const QString (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.63"><vh>void RMaterialList::setStorePath (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.64"><vh>void RMaterialList::add (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.65"><vh>int RMaterialList::remove (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.66"><vh>bool RMaterialList::rename (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.67"><vh>bool RMaterialList::find (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.68"><vh>bool RMaterialList::containName (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.69"><vh>bool RMaterialList::validateID (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.70"><vh>int RMaterialList::findAvailableID (rml_material_list.cpp)</vh></v>
<v t="leo.20201108101535.71"><vh>void RMaterialList::readStore (rml_material_list.cpp)</vh></v>
</v>
<v t="leo.20201108101535.72"><vh>@clean rml_material_property.cpp</vh>
<v t="leo.20201108101535.73"><vh>typedef struct (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.74"><vh>const RMaterialPropertyDesc (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.75"><vh>void RMaterialProperty::_init (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.76"><vh>bool RMaterialProperty::operator (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.77"><vh>bool RMaterialProperty::operator (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.78"><vh>void RMaterialProperty::setType (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.79"><vh>const QString (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.80"><vh>void RMaterialProperty::setName (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.81"><vh>const QString (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.82"><vh>void RMaterialProperty::setUnits (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.83"><vh>const QString (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.84"><vh>const QString (rml_material_property.cpp)</vh></v>
<v t="leo.20201108101535.85"><vh>void operator (rml_material_property.cpp)</vh></v>
</v>
<v t="leo.20201108101535.86"><vh>@clean rml_matrix_solver_conf.cpp</vh>
<v t="leo.20201108101535.87"><vh>typedef struct (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.88"><vh>static RMatrixSolverDesc (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.89"><vh>void RMatrixSolverConf::_init (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.90"><vh>void RMatrixSolverConf::setType (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.91"><vh>int RMatrixSolverConf::getNInnerIterations (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.92"><vh>void RMatrixSolverConf::setNInnerIterations (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.93"><vh>int RMatrixSolverConf::getNOuterIterations (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.94"><vh>void RMatrixSolverConf::setNOuterIterations (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.95"><vh>void RMatrixSolverConf::setSolverCvgValue (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.96"><vh>int RMatrixSolverConf::getOutputFrequency (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.97"><vh>void RMatrixSolverConf::setOutputFrequency (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.98"><vh>const QString (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.99"><vh>void RMatrixSolverConf::setOutputFileName (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.100"><vh>const QString (rml_matrix_solver_conf.cpp)</vh></v>
<v t="leo.20201108101535.101"><vh>const QString (rml_matrix_solver_conf.cpp)</vh></v>
</v>
<v t="leo.20201108101535.102"><vh>@clean rml_mesh_generator.cpp</vh>
<v t="leo.20201108101535.103"><vh>void RMeshGenerator::generate (rml_mesh_generator.cpp)</vh></v>
<v t="leo.20201108101535.104"><vh>void RMeshGenerator::generate (rml_mesh_generator.cpp)</vh></v>
</v>
<v t="leo.20201108101535.105"><vh>@clean rml_mesh_input.cpp</vh>
<v t="leo.20201108101535.106"><vh>void RMeshInput::_init (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.107"><vh>bool RMeshInput::getVerbose (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.108"><vh>void RMeshInput::setVerbose (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.109"><vh>bool RMeshInput::getVolumeMesh (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.110"><vh>void RMeshInput::setVolumeMesh (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.111"><vh>bool RMeshInput::getQualityMesh (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.112"><vh>void RMeshInput::setQualityMesh (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.113"><vh>bool RMeshInput::getOutputEdges (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.114"><vh>void RMeshInput::setOutputEdges (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.115"><vh>bool RMeshInput::getReconstruct (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.116"><vh>void RMeshInput::setReconstruct (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.117"><vh>bool RMeshInput::getUseSizeFunction (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.118"><vh>void RMeshInput::setUseSizeFunction (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.119"><vh>const RRVector (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.120"><vh>void RMeshInput::setSizeFunctionValues (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.121"><vh>void RMeshInput::setRadiusEdgeRatio (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.122"><vh>void RMeshInput::setVolumeConstraint (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.123"><vh>void RMeshInput::setTolerance (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.124"><vh>bool RMeshInput::getSurfaceIntegrityCheck (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.125"><vh>void RMeshInput::setSurfaceIntegrityCheck (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.126"><vh>bool RMeshInput::getKeepResults (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.127"><vh>void RMeshInput::setKeepResults (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.128"><vh>bool RMeshInput::getUseTetGenInputParams (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.129"><vh>void RMeshInput::setUseTetGenInputParams (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.130"><vh>const QString (rml_mesh_input.cpp)</vh></v>
<v t="leo.20201108101535.131"><vh>void RMeshInput::setTetGenInputParams (rml_mesh_input.cpp)</vh></v>
</v>
<v t="leo.20201108101536.1"><vh>@clean rml_mesh_setup.cpp</vh>
<v t="leo.20201108101536.2"><vh>void RMeshSetup::_init (rml_mesh_setup.cpp)</vh></v>
<v t="leo.20201108101536.3"><vh>const QSet (rml_mesh_setup.cpp)</vh></v>
<v t="leo.20201108101536.4"><vh>void RMeshSetup::setVariables (rml_mesh_setup.cpp)</vh></v>
<v t="leo.20201108101536.5"><vh>void RMeshSetup::setMinEdgeLength (rml_mesh_setup.cpp)</vh></v>
<v t="leo.20201108101536.6"><vh>void RMeshSetup::setMaxEdgeLength (rml_mesh_setup.cpp)</vh></v>
</v>
<v t="leo.20201108101536.7"><vh>@clean rml_modal_setup.cpp</vh>
<v t="leo.20201108101536.8"><vh>static QString (rml_modal_setup.cpp)</vh></v>
<v t="leo.20201108101536.9"><vh>void RModalSetup::_init (rml_modal_setup.cpp)</vh></v>
<v t="leo.20201108101536.10"><vh>void RModalSetup::setMethod (rml_modal_setup.cpp)</vh></v>
<v t="leo.20201108101536.11"><vh>void RModalSetup::setNIterations (rml_modal_setup.cpp)</vh></v>
<v t="leo.20201108101536.12"><vh>void RModalSetup::setNModesToExtract (rml_modal_setup.cpp)</vh></v>
<v t="leo.20201108101536.13"><vh>void RModalSetup::setConvergenceValue (rml_modal_setup.cpp)</vh></v>
<v t="leo.20201108101536.14"><vh>void RModalSetup::setMode (rml_modal_setup.cpp)</vh></v>
<v t="leo.20201108101536.15"><vh>void RModalSetup::setFrequency (rml_modal_setup.cpp)</vh></v>
<v t="leo.20201108101536.16"><vh>const QString (rml_modal_setup.cpp)</vh></v>
</v>
<v t="leo.20201108101536.17"><vh>@clean rml_model.cpp</vh>
<v t="leo.20201108101536.18"><vh>void RModel::_init (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.19"><vh>const QString (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.20"><vh>void RModel::update (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.21"><vh>void RModel::read (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.22"><vh>void RModel::exportTo (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.23"><vh>void RModel::exportTo (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.24"><vh>void RModel::exportTo (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.25"><vh>void RModel::setName (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.26"><vh>void RModel::setDescription (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.27"><vh>void RModel::addElementToGroup (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.28"><vh>void RModel::setProblemTaskTree (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.29"><vh>void RModel::removeVariable (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.30"><vh>void RModel::removeAllVariables (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.31"><vh>void RModel::setNNodes (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.32"><vh>const RNode (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.33"><vh>const RNode (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.34"><vh>const std::vector (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.35"><vh>void RModel::addNode (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.36"><vh>void RModel::addNode (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.37"><vh>void RModel::setNode (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.38"><vh>void RModel::removeNode (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.39"><vh>void RModel::removeNodes (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.40"><vh>void RModel::mergeNodes (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.41"><vh>void RModel::findNodeLimits (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.42"><vh>void RModel::findNodeCenter (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.43"><vh>bool RModel::isNodeUsed (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.44"><vh>void RModel::setNElements (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.45"><vh>const RElement (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.46"><vh>const RElement (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.47"><vh>const std::vector (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.48"><vh>void RModel::addElement (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.49"><vh>void RModel::setElement (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.50"><vh>void RModel::removeElement (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.51"><vh>void RModel::removeElements (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.52"><vh>const RInterpolatedElement (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.53"><vh>const RElementGroup (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.54"><vh>const REntityGroup (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.55"><vh>bool RModel::getEntityID (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.56"><vh>void RModel::mergeEntities (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.57"><vh>void RModel::removeEntities (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.58"><vh>void RModel::setNPoints (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.59"><vh>const RPoint (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.60"><vh>const RPoint (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.61"><vh>void RModel::addPoint (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.62"><vh>void RModel::setPoint (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.63"><vh>void RModel::removePoint (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.64"><vh>void RModel::setNLines (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.65"><vh>const RLine (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.66"><vh>const RLine (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.67"><vh>void RModel::addLine (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.68"><vh>void RModel::setLine (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.69"><vh>void RModel::removeLine (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.70"><vh>void RModel::setNSurfaces (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.71"><vh>const RSurface (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.72"><vh>const RSurface (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.73"><vh>void RModel::addSurface (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.74"><vh>void RModel::setSurface (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.75"><vh>void RModel::removeSurface (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.76"><vh>bool RModel::checkIfSurfaceIsClosed (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.77"><vh>bool RModel::checkIfSurfacesAreClosed (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.78"><vh>void RModel::syncSurfaceNormals (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.79"><vh>void RModel::setNVolumes (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.80"><vh>const RVolume (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.81"><vh>const RVolume (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.82"><vh>void RModel::addVolume (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.83"><vh>void RModel::setVolume (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.84"><vh>void RModel::removeVolume (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.85"><vh>void RModel::setNVectorFields (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.86"><vh>const RVectorField (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.87"><vh>const RVectorField (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.88"><vh>void RModel::addVectorField (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.89"><vh>void RModel::setVectorField (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.90"><vh>void RModel::removeVectorField (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.91"><vh>void RModel::setNScalarFields (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.92"><vh>const RScalarField (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.93"><vh>const RScalarField (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.94"><vh>void RModel::addScalarField (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.95"><vh>void RModel::setScalarField (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.96"><vh>void RModel::removeScalarField (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.97"><vh>void RModel::setNStreamLines (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.98"><vh>const RStreamLine (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.99"><vh>const RStreamLine (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.100"><vh>void RModel::addStreamLine (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.101"><vh>void RModel::setStreamLine (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.102"><vh>void RModel::removeStreamLine (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.103"><vh>void RModel::setNCuts (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.104"><vh>const RCut (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.105"><vh>const RCut (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.106"><vh>void RModel::addCut (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.107"><vh>void RModel::setCut (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.108"><vh>void RModel::removeCut (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.109"><vh>void RModel::setNIsos (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.110"><vh>const RIso (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.111"><vh>const RIso (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.112"><vh>void RModel::addIso (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.113"><vh>void RModel::setIso (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.114"><vh>void RModel::removeIso (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.115"><vh>const RVariable (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.116"><vh>void RModel::rotateGeometry (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.117"><vh>void RModel::scaleGeometry (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.118"><vh>void RModel::scaleGeometry (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.119"><vh>void RModel::translateGeometry (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.120"><vh>void RModel::createCut (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.121"><vh>void RModel::createIso (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.122"><vh>void RModel::createStreamLine (rml_model.cpp)</vh>
<v t="leo.20201108101536.123"><vh>int ersectedSide (rml_model.cpp)</vh></v>
</v>
<v t="leo.20201108101536.124"><vh>void RModel::createDependentEntities (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.125"><vh>const std::vector (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.126"><vh>void RModel::setSurfaceNeighbors (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.127"><vh>void RModel::setVolumeNeighbors (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.128"><vh>void RModel::clearSurfaceNeighbors (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.129"><vh>void RModel::clearVolumeNeighbors (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.130"><vh>bool RModel::boolDifference (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.131"><vh>bool RModel::boolIntersection (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.132"><vh>bool RModel::boolUnion (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.133"><vh>void RModel::generatePatchSurface (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.134"><vh>void RModel::generatePatchInputVector (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.135"><vh>void RModel::findPatchCenter (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.136"><vh>void RModel::findPatchNormal (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.137"><vh>void RModel::findPatchArea (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.138"><vh>void RModel::generateViewFactorMatrixHeader (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.139"><vh>void RModel::convertElementToNodeVector (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.140"><vh>void RModel::convertNodeToElementVector (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.141"><vh>void RModel::clearBoundaryConditions (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.142"><vh>void RModel::clearInitialConditions (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.143"><vh>void RModel::clearEnvironmentConditions (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.144"><vh>void RModel::clearEntityVariableData (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.145"><vh>void RModel::clearEntityVariableData (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.146"><vh>void RModel::writeLink (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.147"><vh>void RModel::writeAscii (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.148"><vh>void RModel::writeBinary (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.149"><vh>void RModel::markSurfaceNeighbors (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.150"><vh>void RModel::addEntityGroupIdReference (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.151"><vh>void RModel::removeEntityGroupIdReference (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.152"><vh>void RModel::updateEntityGroupIdReferences (rml_model.cpp)</vh></v>
<v t="leo.20201108101536.153"><vh>void RModel::generateElementDistanceVector (rml_model.cpp)</vh></v>
</v>
<v t="leo.20201108101536.154"><vh>@clean rml_model_data.cpp</vh>
<v t="leo.20201108101536.155"><vh>void RModelData::_init (rml_model_data.cpp)</vh></v>
<v t="leo.20201108101536.156"><vh>bool RModelData::getSelected (rml_model_data.cpp)</vh></v>
<v t="leo.20201108101536.157"><vh>void RModelData::setSelected (rml_model_data.cpp)</vh></v>
</v>
<v t="leo.20201108101536.158"><vh>@clean rml_model_msh.cpp</vh>
<v t="leo.20201108101536.159"><vh>void RModelMsh::_init (rml_model_msh.cpp)</vh></v>
<v t="leo.20201108101536.160"><vh>void RModelMsh::clear (rml_model_msh.cpp)</vh></v>
<v t="leo.20201108101536.161"><vh>void RModelMsh::read (rml_model_msh.cpp)</vh></v>
<v t="leo.20201108101536.162"><vh>void RModelMsh::write (rml_model_msh.cpp)</vh></v>
<v t="leo.20201108101536.163"><vh>void RModelMsh::readAscii (rml_model_msh.cpp)</vh></v>
<v t="leo.20201108101536.164"><vh>void RModelMsh::readBinary (rml_model_msh.cpp)</vh>
<v t="leo.20201108101536.165"><vh>int npst (rml_model_msh.cpp)</vh></v>
</v>
<v t="leo.20201108101536.166"><vh>void RModelMsh::writeAscii (rml_model_msh.cpp)</vh></v>
<v t="leo.20201108101536.167"><vh>void RModelMsh::writeBinary (rml_model_msh.cpp)</vh>
<v t="leo.20201108101536.168"><vh>int npst (rml_model_msh.cpp)</vh></v>
</v>
</v>
<v t="leo.20201108101537.1"><vh>@clean rml_model_raw.cpp</vh>
<v t="leo.20201108101537.2"><vh>void RModelRaw::_init (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.3"><vh>int RModelRaw::getNNodes (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.4"><vh>const RNode (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.5"><vh>int RModelRaw::getNElements (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.6"><vh>const RElement (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.7"><vh>void RModelRaw::addPoint (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.8"><vh>void RModelRaw::addSegment (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.9"><vh>void RModelRaw::addTriangle (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.10"><vh>void RModelRaw::addQuadrilateral (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.11"><vh>int RModelRaw::findNearNode (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.12"><vh>int RModelRaw::mergeNearNodes (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.13"><vh>void RModelRaw::clear (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.14"><vh>void RModelRaw::read (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.15"><vh>void RModelRaw::write (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.16"><vh>void RModelRaw::readTextStream (rml_model_raw.cpp)</vh></v>
<v t="leo.20201108101537.17"><vh>bool RModelRaw::getNormal (rml_model_raw.cpp)</vh></v>
</v>
<v t="leo.20201108101537.18"><vh>@clean rml_model_stl.cpp</vh>
<v t="leo.20201108101537.19"><vh>void RModelStl::_init (rml_model_stl.cpp)</vh></v>
<v t="leo.20201108101537.20"><vh>void RModelStl::setName (rml_model_stl.cpp)</vh></v>
<v t="leo.20201108101537.21"><vh>void RModelStl::setDescription (rml_model_stl.cpp)</vh></v>
<v t="leo.20201108101537.22"><vh>void RModelStl::clear (rml_model_stl.cpp)</vh></v>
<v t="leo.20201108101537.23"><vh>void RModelStl::read (rml_model_stl.cpp)</vh></v>
<v t="leo.20201108101537.24"><vh>void RModelStl::write (rml_model_stl.cpp)</vh></v>
<v t="leo.20201108101537.25"><vh>void RModelStl::readBinary (rml_model_stl.cpp)</vh></v>
<v t="leo.20201108101537.26"><vh>void RModelStl::writeBinary (rml_model_stl.cpp)</vh></v>
<v t="leo.20201108101537.27"><vh>void RModelStl::readAscii (rml_model_stl.cpp)</vh></v>
<v t="leo.20201108101537.28"><vh>void RModelStl::writeAscii (rml_model_stl.cpp)</vh></v>
<v t="leo.20201108101537.29"><vh>bool RModelStl::checkIfBinary (rml_model_stl.cpp)</vh></v>
</v>
<v t="leo.20201108101537.30"><vh>@clean rml_monitoring_point.cpp</vh>
<v t="leo.20201108101537.31"><vh>void RMonitoringPoint::_init (rml_monitoring_point.cpp)</vh></v>
<v t="leo.20201108101537.32"><vh>bool RMonitoringPoint::operator (rml_monitoring_point.cpp)</vh></v>
<v t="leo.20201108101537.33"><vh>bool RMonitoringPoint::operator (rml_monitoring_point.cpp)</vh></v>
<v t="leo.20201108101537.34"><vh>void RMonitoringPoint::setVariableType (rml_monitoring_point.cpp)</vh></v>
<v t="leo.20201108101537.35"><vh>const RR3Vector (rml_monitoring_point.cpp)</vh></v>
<v t="leo.20201108101537.36"><vh>void RMonitoringPoint::setPosition (rml_monitoring_point.cpp)</vh></v>
<v t="leo.20201108101537.37"><vh>const QString (rml_monitoring_point.cpp)</vh></v>
<v t="leo.20201108101537.38"><vh>void RMonitoringPoint::setOutputFileName (rml_monitoring_point.cpp)</vh></v>
<v t="leo.20201108101537.39"><vh>void RMonitoringPoint::writeValueVectorToFile (rml_monitoring_point.cpp)</vh></v>
<v t="leo.20201108101537.40"><vh>void RMonitoringPoint::readRecordFromFile (rml_monitoring_point.cpp)</vh></v>
</v>
<v t="leo.20201108101537.41"><vh>@clean rml_monitoring_point_manager.cpp</vh>
<v t="leo.20201108101537.42"><vh>void RMonitoringPointManager::_init (rml_monitoring_point_manager.cpp)</vh></v>
<v t="leo.20201108101537.43"><vh>void RMonitoringPointManager::setOutputFileName (rml_monitoring_point_manager.cpp)</vh></v>
</v>
<v t="leo.20201108101537.44"><vh>@clean rml_node.cpp</vh>
<v t="leo.20201108101537.45"><vh>double y (rml_node.cpp)</vh></v>
<v t="leo.20201108101537.46"><vh>void RNode::_init (rml_node.cpp)</vh></v>
<v t="leo.20201108101537.47"><vh>void RNode::transform (rml_node.cpp)</vh></v>
<v t="leo.20201108101537.48"><vh>void RNode::translate (rml_node.cpp)</vh></v>
<v t="leo.20201108101537.49"><vh>void RNode::scale (rml_node.cpp)</vh></v>
<v t="leo.20201108101537.50"><vh>void RNode::scale (rml_node.cpp)</vh></v>
<v t="leo.20201108101537.51"><vh>bool RNode::operator (rml_node.cpp)</vh></v>
<v t="leo.20201108101537.52"><vh>bool RNode::operator (rml_node.cpp)</vh></v>
<v t="leo.20201108101537.53"><vh>bool RNode::operator (rml_node.cpp)</vh></v>
<v t="leo.20201108101537.54"><vh>void RNode::toVector (rml_node.cpp)</vh></v>
<v t="leo.20201108101537.55"><vh>void RNode::print (rml_node.cpp)</vh></v>
</v>
<v t="leo.20201108101537.56"><vh>@clean rml_patch.cpp</vh>
<v t="leo.20201108101537.57"><vh>void RPatch::_init (rml_patch.cpp)</vh></v>
<v t="leo.20201108101537.58"><vh>const RUVector (rml_patch.cpp)</vh></v>
<v t="leo.20201108101537.59"><vh>bool RPatch::addElementID (rml_patch.cpp)</vh></v>
<v t="leo.20201108101537.60"><vh>bool RPatch::removeElementID (rml_patch.cpp)</vh></v>
<v t="leo.20201108101537.61"><vh>bool RPatch::hasElementID (rml_patch.cpp)</vh></v>
</v>
<v t="leo.20201108101537.62"><vh>@clean rml_patch_book.cpp</vh>
<v t="leo.20201108101537.63"><vh>void RPatchBook::_init (rml_patch_book.cpp)</vh></v>
<v t="leo.20201108101537.64"><vh>const RPatch (rml_patch_book.cpp)</vh></v>
<v t="leo.20201108101537.65"><vh>void RPatchBook::clear (rml_patch_book.cpp)</vh></v>
<v t="leo.20201108101537.66"><vh>void RPatchBook::registerElementID (rml_patch_book.cpp)</vh></v>
</v>
<v t="leo.20201108101537.67"><vh>@clean rml_patch_input.cpp</vh>
<v t="leo.20201108101537.68"><vh>void RPatchInput::_init (rml_patch_input.cpp)</vh></v>
<v t="leo.20201108101537.69"><vh>bool RPatchInput::operator (rml_patch_input.cpp)</vh></v>
<v t="leo.20201108101537.70"><vh>bool RPatchInput::operator (rml_patch_input.cpp)</vh></v>
<v t="leo.20201108101537.71"><vh>void RPatchInput::setPatchArea (rml_patch_input.cpp)</vh></v>
<v t="leo.20201108101537.72"><vh>int RPatchInput::getPatchSize (rml_patch_input.cpp)</vh></v>
<v t="leo.20201108101537.73"><vh>void RPatchInput::setPatchSize (rml_patch_input.cpp)</vh></v>
<v t="leo.20201108101537.74"><vh>void RPatchInput::setSeparationAngle (rml_patch_input.cpp)</vh></v>
<v t="leo.20201108101537.75"><vh>bool RPatchInput::getEmitter (rml_patch_input.cpp)</vh></v>
<v t="leo.20201108101537.76"><vh>void RPatchInput::setEmitter (rml_patch_input.cpp)</vh></v>
<v t="leo.20201108101537.77"><vh>bool RPatchInput::getReceiver (rml_patch_input.cpp)</vh></v>
<v t="leo.20201108101537.78"><vh>void RPatchInput::setReceiver (rml_patch_input.cpp)</vh></v>
</v>
<v t="leo.20201108101537.79"><vh>@clean rml_point.cpp</vh>
<v t="leo.20201108101537.80"><vh>void RPoint::_init (rml_point.cpp)</vh></v>
<v t="leo.20201108101537.81"><vh>void RPoint::setVolume (rml_point.cpp)</vh></v>
</v>
<v t="leo.20201108101537.82"><vh>@clean rml_polygon.cpp</vh>
<v t="leo.20201108101537.83"><vh>void RPolygon::_init (rml_polygon.cpp)</vh></v>
<v t="leo.20201108101537.84"><vh>void RPolygon::setNodes (rml_polygon.cpp)</vh></v>
<v t="leo.20201108101537.85"><vh>void RPolygon::removeNode (rml_polygon.cpp)</vh></v>
<v t="leo.20201108101537.86"><vh>bool nodeAngleItemCompare (rml_polygon.cpp)</vh></v>
<v t="leo.20201108101537.87"><vh>void RPolygon::computeNormal (rml_polygon.cpp)</vh></v>
</v>
<v t="leo.20201108101537.88"><vh>@clean rml_problem.cpp</vh>
<v t="leo.20201108101537.89"><vh>typedef struct (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.90"><vh>const RProblemDesc (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.91"><vh>void RProblem::_init (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.92"><vh>const RProblemTaskItem (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.93"><vh>void RProblem::setProblemTaskTree (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.94"><vh>const RTimeSolver (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.95"><vh>void RProblem::setTimeSolver (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.96"><vh>const RMonitoringPointManager (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.97"><vh>void RProblem::setMonitoringPointManager (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.98"><vh>const RProblemSetup (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.99"><vh>void RProblem::setProblemSetup (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.100"><vh>bool RProblem::getTimeSolverEnabled (rml_problem.cpp)</vh></v>
<v t="leo.20201108101537.101"><vh>void RProblem::sortTypesByDependency (rml_problem.cpp)</vh></v>
</v>
<v t="leo.20201108101538.1"><vh>@clean rml_problem_setup.cpp</vh>
<v t="leo.20201108101538.2"><vh>void RProblemSetup::_init (rml_problem_setup.cpp)</vh></v>
<v t="leo.20201108101538.3"><vh>bool RProblemSetup::getRestart (rml_problem_setup.cpp)</vh></v>
<v t="leo.20201108101538.4"><vh>void RProblemSetup::setRestart (rml_problem_setup.cpp)</vh></v>
<v t="leo.20201108101538.5"><vh>const RRadiationSetup (rml_problem_setup.cpp)</vh></v>
<v t="leo.20201108101538.6"><vh>void RProblemSetup::setRadiationSetup (rml_problem_setup.cpp)</vh></v>
<v t="leo.20201108101538.7"><vh>const RModalSetup (rml_problem_setup.cpp)</vh></v>
<v t="leo.20201108101538.8"><vh>void RProblemSetup::setModalSetup (rml_problem_setup.cpp)</vh></v>
<v t="leo.20201108101538.9"><vh>const RMeshSetup (rml_problem_setup.cpp)</vh></v>
<v t="leo.20201108101538.10"><vh>void RProblemSetup::setMeshSetup (rml_problem_setup.cpp)</vh></v>
</v>
<v t="leo.20201108101538.11"><vh>@clean rml_problem_task_item.cpp</vh>
<v t="leo.20201108101538.12"><vh>void RProblemTaskItem::_init (rml_problem_task_item.cpp)</vh></v>
<v t="leo.20201108101538.13"><vh>void RProblemTaskItem::setProblemType (rml_problem_task_item.cpp)</vh></v>
<v t="leo.20201108101538.14"><vh>int RProblemTaskItem::getNIterations (rml_problem_task_item.cpp)</vh></v>
<v t="leo.20201108101538.15"><vh>void RProblemTaskItem::setNIterations (rml_problem_task_item.cpp)</vh></v>
<v t="leo.20201108101538.16"><vh>int RProblemTaskItem::getNChildren (rml_problem_task_item.cpp)</vh></v>
<v t="leo.20201108101538.17"><vh>const RProblemTaskItem (rml_problem_task_item.cpp)</vh></v>
<v t="leo.20201108101538.18"><vh>void RProblemTaskItem::addChild (rml_problem_task_item.cpp)</vh></v>
<v t="leo.20201108101538.19"><vh>void RProblemTaskItem::insertChild (rml_problem_task_item.cpp)</vh></v>
<v t="leo.20201108101538.20"><vh>void RProblemTaskItem::removeChild (rml_problem_task_item.cpp)</vh></v>
<v t="leo.20201108101538.21"><vh>void RProblemTaskItem::print (rml_problem_task_item.cpp)</vh></v>
</v>
<v t="leo.20201108101538.22"><vh>@clean rml_radiation_setup.cpp</vh>
<v t="leo.20201108101538.23"><vh>void RRadiationSetup::_init (rml_radiation_setup.cpp)</vh></v>
<v t="leo.20201108101538.24"><vh>void RRadiationSetup::setResolution (rml_radiation_setup.cpp)</vh></v>
<v t="leo.20201108101538.25"><vh>const QString (rml_radiation_setup.cpp)</vh></v>
<v t="leo.20201108101538.26"><vh>void RRadiationSetup::setViewFactorMatrixFile (rml_radiation_setup.cpp)</vh></v>
</v>
<v t="leo.20201108101538.27"><vh>@clean rml_results.cpp</vh>
<v t="leo.20201108101538.28"><vh>void RResults::_init (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.29"><vh>void RResults::clearResults (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.30"><vh>int RResults::getNVariables (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.31"><vh>void RResults::setNVariables (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.32"><vh>const RVariable (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.33"><vh>int RResults::findVariable (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.34"><vh>int RResults::addVariable (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.35"><vh>void RResults::setVariable (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.36"><vh>void RResults::removeVariable (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.37"><vh>void RResults::removeAllVariables (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.38"><vh>int RResults::getNNodes (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.39"><vh>void RResults::setNNodes (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.40"><vh>void RResults::addNode (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.41"><vh>void RResults::removeNode (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.42"><vh>int RResults::getNElements (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.43"><vh>void RResults::setNElements (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.44"><vh>void RResults::addElement (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.45"><vh>void RResults::removeElement (rml_results.cpp)</vh></v>
<v t="leo.20201108101538.46"><vh>void RResults::removeElements (rml_results.cpp)</vh></v>
</v>
<v t="leo.20201108101538.47"><vh>@clean rml_save_file.cpp</vh>
<v t="leo.20201108101538.48"><vh>void RSaveFile::_init (rml_save_file.cpp)</vh></v>
<v t="leo.20201108101538.49"><vh>const RVersion (rml_save_file.cpp)</vh></v>
<v t="leo.20201108101538.50"><vh>void RSaveFile::setVersion (rml_save_file.cpp)</vh></v>
</v>
<v t="leo.20201108101538.51"><vh>@clean rml_scalar_field.cpp</vh>
<v t="leo.20201108101538.52"><vh>void RScalarField::_init (rml_scalar_field.cpp)</vh></v>
<v t="leo.20201108101538.53"><vh>void RScalarField::setMaxPointSize (rml_scalar_field.cpp)</vh></v>
</v>
<v t="leo.20201108101538.54"><vh>@clean rml_segment.cpp</vh>
<v t="leo.20201108101538.55"><vh>void RSegment::_init (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.56"><vh>bool RSegment::operator (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.57"><vh>void RSegment::setNodeIDs (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.58"><vh>bool RSegment::hasNodeID (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.59"><vh>void RSegment::setNodes (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.60"><vh>void RSegment::findRotationMatrix (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.61"><vh>bool RSegment::findLineIntersection (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.62"><vh>bool RSegment::findPointIntersection (rml_segment.cpp)</vh>
<v t="leo.20201108101538.63"><vh>int ersectionFound (rml_segment.cpp)</vh></v>
</v>
<v t="leo.20201108101538.64"><vh>bool RSegment::findSegmentIntersection (rml_segment.cpp)</vh>
<v t="leo.20201108101538.65"><vh>bool isNode1 (rml_segment.cpp)</vh></v>
</v>
<v t="leo.20201108101538.66"><vh>bool RSegment::findSegmentIntersection (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.67"><vh>bool RSegment::isPointInside (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.68"><vh>void RSegment::findDirection (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.69"><vh>void RSegment::findPerpendicularVectors (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.70"><vh>void RSegment::print (rml_segment.cpp)</vh></v>
<v t="leo.20201108101538.71"><vh>bool RSegment::findLineLineIntersection (rml_segment.cpp)</vh></v>
</v>
<v t="leo.20201108101538.72"><vh>@clean rml_shape_generator.cpp</vh>
<v t="leo.20201108101538.73"><vh>void RShapeGenerator::_init (rml_shape_generator.cpp)</vh></v>
</v>
<v t="leo.20201108101538.74"><vh>@clean rml_sparse_matrix.cpp</vh>
<v t="leo.20201108101538.75"><vh>void RSparseMatrix::_init (rml_sparse_matrix.cpp)</vh></v>
<v t="leo.20201108101538.76"><vh>const RSparseVector (rml_sparse_matrix.cpp)</vh></v>
<v t="leo.20201108101538.77"><vh>void RSparseMatrix::addMatrix (rml_sparse_matrix.cpp)</vh></v>
<v t="leo.20201108101538.78"><vh>void RSparseMatrix::setNRows (rml_sparse_matrix.cpp)</vh></v>
<v t="leo.20201108101538.79"><vh>void RSparseMatrix::reserveNColumns (rml_sparse_matrix.cpp)</vh></v>
<v t="leo.20201108101538.80"><vh>void RSparseMatrix::addValue (rml_sparse_matrix.cpp)</vh></v>
<v t="leo.20201108101538.81"><vh>void RSparseMatrix::clear (rml_sparse_matrix.cpp)</vh></v>
<v t="leo.20201108101538.82"><vh>bool RSparseMatrix::findColumnPosition (rml_sparse_matrix.cpp)</vh></v>
<v t="leo.20201108101538.83"><vh>void RSparseMatrix::print (rml_sparse_matrix.cpp)</vh></v>
<v t="leo.20201108101538.84"><vh>void RSparseMatrix::mlt (rml_sparse_matrix.cpp)</vh></v>
</v>
<v t="leo.20201108101538.85"><vh>@clean rml_stream_line.cpp</vh>
<v t="leo.20201108101538.86"><vh>void RStreamLine::_init (rml_stream_line.cpp)</vh></v>
<v t="leo.20201108101538.87"><vh>void RStreamLine::setVariableType (rml_stream_line.cpp)</vh></v>
<v t="leo.20201108101538.88"><vh>const RR3Vector (rml_stream_line.cpp)</vh></v>
<v t="leo.20201108101538.89"><vh>void RStreamLine::setPosition (rml_stream_line.cpp)</vh></v>
</v>
<v t="leo.20201108101538.90"><vh>@clean rml_surface.cpp</vh>
<v t="leo.20201108101538.91"><vh>void RSurface::_init (rml_surface.cpp)</vh></v>
<v t="leo.20201108101538.92"><vh>void RSurface::setThickness (rml_surface.cpp)</vh></v>
<v t="leo.20201108101538.93"><vh>bool RSurface::pointInside (rml_surface.cpp)</vh></v>
<v t="leo.20201108101538.94"><vh>void RSurface::tetrahedralize (rml_surface.cpp)</vh></v>
<v t="leo.20201108101538.95"><vh>void RSurface::findAverageNormal (rml_surface.cpp)</vh></v>
</v>
<v t="leo.20201108101539.1"><vh>@clean rml_tetgen.cpp</vh>
<v t="leo.20201108101539.2"><vh>void RTetGen::importModel (rml_tetgen.cpp)</vh></v>
<v t="leo.20201108101539.3"><vh>void RTetGen::exportMesh (rml_tetgen.cpp)</vh></v>
</v>
<v t="leo.20201108101539.4"><vh>@clean rml_tetrahedron.cpp</vh>
<v t="leo.20201108101539.5"><vh>void RTetrahedron::_init (rml_tetrahedron.cpp)</vh></v>
<v t="leo.20201108101539.6"><vh>void RTetrahedron::setNodes (rml_tetrahedron.cpp)</vh></v>
</v>
<v t="leo.20201108101539.7"><vh>@clean rml_time_solver.cpp</vh>
<v t="leo.20201108101539.8"><vh>static QString (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.9"><vh>void RTimeSolver::_init (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.10"><vh>void RTimeSolver::sort (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.11"><vh>bool RTimeSolver::getEnabled (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.12"><vh>void RTimeSolver::setEnabled (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.13"><vh>void RTimeSolver::setTimeMarchApproximation (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.14"><vh>const std::vector (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.15"><vh>void RTimeSolver::setTimes (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.16"><vh>void RTimeSolver::addTimes (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.17"><vh>int RTimeSolver::getInputNTimeSteps (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.18"><vh>void RTimeSolver::setInputNTimeSteps (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.19"><vh>void RTimeSolver::setInputStartTime (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.20"><vh>void RTimeSolver::setInputTimeStepSize (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.21"><vh>int RTimeSolver::getCurrentTimeStep (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.22"><vh>void RTimeSolver::setCurrentTimeStep (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.23"><vh>int RTimeSolver::getOutputFrequency (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.24"><vh>void RTimeSolver::setOutputFrequency (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.25"><vh>int RTimeSolver::setNextTimeStep (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.26"><vh>void RTimeSolver::setComputedTime (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.27"><vh>int RTimeSolver::getNTimeSteps (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.28"><vh>bool RTimeSolver::hasTime (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.29"><vh>void RTimeSolver::harmonizeTimesWithInput (rml_time_solver.cpp)</vh></v>
<v t="leo.20201108101539.30"><vh>const QString (rml_time_solver.cpp)</vh></v>
</v>
<v t="leo.20201108101539.31"><vh>@clean rml_triangle.cpp</vh>
<v t="leo.20201108101539.32"><vh>void RTriangle::_init (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.33"><vh>void RTriangle::setNodeIDs (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.34"><vh>bool RTriangle::hasNodeID (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.35"><vh>void RTriangle::setNodes (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.36"><vh>void RTriangle::findRotationMatrix (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.37"><vh>bool RTriangle::findLineIntersection (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.38"><vh>bool RTriangle::findSegmentIntersection (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.39"><vh>bool RTriangle::findPointIntersection (rml_triangle.cpp)</vh>
<v t="leo.20201108101539.40"><vh>int ersectionFound (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.41"><vh>int ersectionFound (rml_triangle.cpp)</vh></v>
</v>
<v t="leo.20201108101539.42"><vh>bool RTriangle::findSegmentIntersection (rml_triangle.cpp)</vh>
<v t="leo.20201108101539.43"><vh>bool isNode1 (rml_triangle.cpp)</vh></v>
</v>
<v t="leo.20201108101539.44"><vh>bool RTriangle::findTriangleIntersection (rml_triangle.cpp)</vh>
<v t="leo.20201108101539.45"><vh>bool isNode1 (rml_triangle.cpp)</vh></v>
</v>
<v t="leo.20201108101539.46"><vh>bool RTriangle::isPointInside (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.47"><vh>void RTriangle::findCenter (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.48"><vh>void RTriangle::computeNormal (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.49"><vh>bool RTriangle::findParallelSegmentIntersection (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.50"><vh>bool RTriangle::findSkewedSegmentIntersection (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.51"><vh>bool RTriangle::findParallelTriangleIntersection (rml_triangle.cpp)</vh></v>
<v t="leo.20201108101539.52"><vh>bool RTriangle::findSkewedTriangleIntersection (rml_triangle.cpp)</vh></v>
</v>
<v t="leo.20201108101539.53"><vh>@clean rml_triangulate.cpp</vh>
<v t="leo.20201108101539.54"><vh>typedef struct (rml_triangulate.cpp)</vh></v>
<v t="leo.20201108101539.55"><vh>typedef struct (rml_triangulate.cpp)</vh></v>
<v t="leo.20201108101539.56"><vh>typedef struct (rml_triangulate.cpp)</vh></v>
<v t="leo.20201108101539.57"><vh>bool CircumCircle (rml_triangulate.cpp)</vh></v>
<v t="leo.20201108101539.58"><vh>static std::vector (rml_triangulate.cpp)</vh>
<v t="leo.20201108101539.59"><vh>bool inside (rml_triangulate.cpp)</vh></v>
</v>
<v t="leo.20201108101539.60"><vh>bool CircumCircle (rml_triangulate.cpp)</vh></v>
</v>
<v t="leo.20201108101539.61"><vh>@clean rml_variable.cpp</vh>
<v t="leo.20201108101539.62"><vh>typedef struct (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.63"><vh>const RVariableDesc (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.64"><vh>void RVariable::_init (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.65"><vh>void RVariable::setType (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.66"><vh>void RVariable::setApplyType (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.67"><vh>const QString (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.68"><vh>void RVariable::setName (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.69"><vh>const QString (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.70"><vh>void RVariable::setUnits (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.71"><vh>int RVariable::getNVectors (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.72"><vh>int RVariable::getNValues (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.73"><vh>void RVariable::clearValues (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.74"><vh>void RVariable::resize (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.75"><vh>int valpos (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.76"><vh>void RVariable::setValue (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.77"><vh>void RVariable::addValue (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.78"><vh>void RVariable::removeValue (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.79"><vh>void RVariable::removeValues (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.80"><vh>const RVariableData (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.81"><vh>void RVariable::setVariableData (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.82"><vh>const RValueVector (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.83"><vh>const QString (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.84"><vh>const QString (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.85"><vh>const QString (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.86"><vh>const QString (rml_variable.cpp)</vh></v>
<v t="leo.20201108101539.87"><vh>bool RVariable::checkVectorTypes (rml_variable.cpp)</vh></v>
</v>
<v t="leo.20201108101539.88"><vh>@clean rml_variable_data.cpp</vh>
<v t="leo.20201108101539.89"><vh>void RVariableData::_init (rml_variable_data.cpp)</vh></v>
<v t="leo.20201108101539.90"><vh>void RVariableData::setMinMaxDisplayValue (rml_variable_data.cpp)</vh></v>
<v t="leo.20201108101539.91"><vh>bool RVariableData::getDisplayValueRange (rml_variable_data.cpp)</vh></v>
<v t="leo.20201108101539.92"><vh>void RVariableData::setDisplayValueRange (rml_variable_data.cpp)</vh></v>
<v t="leo.20201108101539.93"><vh>const QString (rml_variable_data.cpp)</vh></v>
<v t="leo.20201108101539.94"><vh>void RVariableData::setValueRangeName (rml_variable_data.cpp)</vh></v>
<v t="leo.20201108101539.95"><vh>void RVariableData::setScale (rml_variable_data.cpp)</vh></v>
</v>
<v t="leo.20201108101539.96"><vh>@clean rml_vector_field.cpp</vh>
<v t="leo.20201108101539.97"><vh>void RVectorField::_init (rml_vector_field.cpp)</vh></v>
<v t="leo.20201108101539.98"><vh>void RVectorField::setVariableType (rml_vector_field.cpp)</vh></v>
<v t="leo.20201108101539.99"><vh>bool RVectorField::getType3D (rml_vector_field.cpp)</vh></v>
<v t="leo.20201108101539.100"><vh>void RVectorField::setType3D (rml_vector_field.cpp)</vh></v>
<v t="leo.20201108101539.101"><vh>const std::vector (rml_vector_field.cpp)</vh></v>
<v t="leo.20201108101539.102"><vh>bool RVectorField::addElementGroupID (rml_vector_field.cpp)</vh></v>
<v t="leo.20201108101539.103"><vh>bool RVectorField::removeElementGroupID (rml_vector_field.cpp)</vh></v>
<v t="leo.20201108101539.104"><vh>void RVectorField::clearElementGroupIDs (rml_vector_field.cpp)</vh></v>
</v>
<v t="leo.20201108101539.105"><vh>@clean rml_view_factor_matrix.cpp</vh>
<v t="leo.20201108101539.106"><vh>void RViewFactorMatrix::_init (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.107"><vh>const RViewFactorMatrixHeader (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.108"><vh>void RViewFactorMatrix::setHeader (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.109"><vh>const RPatchBook (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.110"><vh>void RViewFactorMatrix::resize (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.111"><vh>const RViewFactorRow (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.112"><vh>void RViewFactorMatrix::clear (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.113"><vh>void RViewFactorMatrix::read (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.114"><vh>void RViewFactorMatrix::write (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.115"><vh>void RViewFactorMatrix::readHeader (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.116"><vh>void RViewFactorMatrix::writeLink (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.117"><vh>void RViewFactorMatrix::writeAscii (rml_view_factor_matrix.cpp)</vh></v>
<v t="leo.20201108101539.118"><vh>void RViewFactorMatrix::writeBinary (rml_view_factor_matrix.cpp)</vh></v>
</v>
<v t="leo.20201108101539.119"><vh>@clean rml_view_factor_matrix_header.cpp</vh>
<v t="leo.20201108101539.120"><vh>void RViewFactorMatrixHeader::_init (rml_view_factor_matrix_header.cpp)</vh></v>
<v t="leo.20201108101539.121"><vh>bool RViewFactorMatrixHeader::operator (rml_view_factor_matrix_header.cpp)</vh></v>
<v t="leo.20201108101539.122"><vh>bool RViewFactorMatrixHeader::operator (rml_view_factor_matrix_header.cpp)</vh></v>
<v t="leo.20201108101539.123"><vh>const std::vector (rml_view_factor_matrix_header.cpp)</vh></v>
<v t="leo.20201108101539.124"><vh>int RViewFactorMatrixHeader::getHemicubeResolution (rml_view_factor_matrix_header.cpp)</vh></v>
<v t="leo.20201108101539.125"><vh>void RViewFactorMatrixHeader::setHemicubeResolution (rml_view_factor_matrix_header.cpp)</vh></v>
<v t="leo.20201108101539.126"><vh>int RViewFactorMatrixHeader::getNElements (rml_view_factor_matrix_header.cpp)</vh></v>
<v t="leo.20201108101539.127"><vh>void RViewFactorMatrixHeader::setNElements (rml_view_factor_matrix_header.cpp)</vh></v>
<v t="leo.20201108101539.128"><vh>void RViewFactorMatrixHeader::clear (rml_view_factor_matrix_header.cpp)</vh></v>
</v>
<v t="leo.20201108101540.1"><vh>@clean rml_view_factor_row.cpp</vh>
<v t="leo.20201108101540.2"><vh>void RViewFactorRow::_init (rml_view_factor_row.cpp)</vh></v>
<v t="leo.20201108101540.3"><vh>const RSparseVector (rml_view_factor_row.cpp)</vh></v>
</v>
<v t="leo.20201108101540.4"><vh>@clean rml_volume.cpp</vh>
<v t="leo.20201108101540.5"><vh>void RVolume::_init (rml_volume.cpp)</vh></v>
</v>
</v>
</v>
<v t="leo.20201108101540.6"><vh>@path RangeSolver</vh>
<v t="leo.20201108101540.7"><vh>@path src</vh>
<v t="leo.20201108101540.8"><vh>@clean application.cpp</vh>
<v t="leo.20201108101540.9"><vh>void Application::onStarted (application.cpp)</vh></v>
</v>
<v t="leo.20201108101540.10"><vh>@clean command_processor.cpp</vh>
<v t="leo.20201108101540.11"><vh>void CommandProcessor::start (command_processor.cpp)</vh></v>
<v t="leo.20201108101540.12"><vh>void CommandProcessor::stop (command_processor.cpp)</vh></v>
<v t="leo.20201108101540.13"><vh>void CommandProcessor::readSocket (command_processor.cpp)</vh></v>
</v>
<v t="leo.20201108101540.14"><vh>@clean main.cpp</vh>
<v t="leo.20201108101540.15"><vh>int main (main.cpp)</vh></v>
</v>
<v t="leo.20201108101540.16"><vh>@clean main_task.cpp</vh>
<v t="leo.20201108101540.17"><vh>void MainTask::run (main_task.cpp)</vh></v>
</v>
<v t="leo.20201108101540.18"><vh>@clean solver_input.cpp</vh>
<v t="leo.20201108101540.19"><vh>void SolverInput::_init (solver_input.cpp)</vh></v>
<v t="leo.20201108101540.20"><vh>void SolverInput::setConvergenceFileName (solver_input.cpp)</vh></v>
<v t="leo.20201108101540.21"><vh>void SolverInput::setMonitoringFileName (solver_input.cpp)</vh></v>
<v t="leo.20201108101540.22"><vh>void SolverInput::setNThreads (solver_input.cpp)</vh></v>
<v t="leo.20201108101540.23"><vh>void SolverInput::setRestart (solver_input.cpp)</vh></v>
</v>
<v t="leo.20201108101540.24"><vh>@clean solver_task.cpp</vh>
<v t="leo.20201108101540.25"><vh>void SolverTask::run (solver_task.cpp)</vh></v>
</v>
</v>
</v>
<v t="leo.20201108101540.26"><vh>@path RangeSolverLib</vh>
<v t="leo.20201108101541.1"><vh>@path src</vh>
<v t="leo.20201108101541.2"><vh>@clean rconvection.cpp</vh>
<v t="leo.20201108101541.3"><vh>typedef struct (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.4"><vh>static RConvectionDesc (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.5"><vh>void RConvection::_init (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.6"><vh>void RConvection::setType (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.7"><vh>void RConvection::setMaterial (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.8"><vh>void RConvection::setMaterial (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.9"><vh>void RConvection::setDiameter (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.10"><vh>void RConvection::setVelocity (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.11"><vh>void RConvection::setGravity (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.12"><vh>void RConvection::setSurfTemp (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.13"><vh>void RConvection::setFluidTemp (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.14"><vh>const QString (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.15"><vh>bool RConvection::isNatural (rconvection.cpp)</vh></v>
<v t="leo.20201108101541.16"><vh>bool RConvection::isForced (rconvection.cpp)</vh></v>
</v>
<v t="leo.20201108101541.17"><vh>@clean reigenvaluesolver.cpp</vh>
<v t="leo.20201108101541.18"><vh>void REigenValueSolver::_init (reigenvaluesolver.cpp)</vh></v>
<v t="leo.20201108101541.19"><vh>void REigenValueSolver::solve (reigenvaluesolver.cpp)</vh></v>
<v t="leo.20201108101541.20"><vh>void REigenValueSolver::solveLanczos (reigenvaluesolver.cpp)</vh></v>
<v t="leo.20201108101541.21"><vh>void REigenValueSolver::solveArnoldi (reigenvaluesolver.cpp)</vh></v>
<v t="leo.20201108101541.22"><vh>void REigenValueSolver::solveRayleigh (reigenvaluesolver.cpp)</vh></v>
<v t="leo.20201108101541.23"><vh>void REigenValueSolver::qlDecomposition (reigenvaluesolver.cpp)</vh></v>
<v t="leo.20201108101541.24"><vh>void REigenValueSolver::qrDecomposition (reigenvaluesolver.cpp)</vh></v>
</v>
<v t="leo.20201108101541.25"><vh>@clean rhemicube.cpp</vh>
<v t="leo.20201108101541.26"><vh>class RHemicubeTriangle</vh></v>
<v t="leo.20201108101541.27"><vh>class RHemicubeTriangleComp</vh>
<v t="leo.20201108101541.28"><vh>RHemicubeTriangleComp.bool operator</vh></v>
</v>
<v t="leo.20201108101541.29"><vh>void RHemiCube::_init (rhemicube.cpp)</vh></v>
<v t="leo.20201108101541.30"><vh>void RHemiCube::rayTraceTriangle (rhemicube.cpp)</vh></v>
<v t="leo.20201108101541.31"><vh>void RHemiCube::calculateViewFactors (rhemicube.cpp)</vh></v>
<v t="leo.20201108101541.32"><vh>void RHemiCube::generate (rhemicube.cpp)</vh></v>
</v>
<v t="leo.20201108101541.33"><vh>@clean rhemicubepixel.cpp</vh>
<v t="leo.20201108101541.34"><vh>void RHemiCubePixel::_init (rhemicubepixel.cpp)</vh></v>
<v t="leo.20201108101541.35"><vh>const RR3Vector (rhemicubepixel.cpp)</vh></v>
<v t="leo.20201108101541.36"><vh>void RHemiCubePixel::setPosition (rhemicubepixel.cpp)</vh></v>
<v t="leo.20201108101541.37"><vh>void RHemiCubePixel::setColor (rhemicubepixel.cpp)</vh></v>
<v t="leo.20201108101541.38"><vh>void RHemiCubePixel::setDepth (rhemicubepixel.cpp)</vh></v>
<v t="leo.20201108101541.39"><vh>void RHemiCubePixel::setWeight (rhemicubepixel.cpp)</vh></v>
</v>
<v t="leo.20201108101541.40"><vh>@clean rhemicubesector.cpp</vh>
<v t="leo.20201108101541.41"><vh>void RHemiCubeSector::_init (rhemicubesector.cpp)</vh></v>
<v t="leo.20201108101541.42"><vh>const RR3Vector (rhemicubesector.cpp)</vh></v>
<v t="leo.20201108101541.43"><vh>const RHemiCubePixel (rhemicubesector.cpp)</vh></v>
<v t="leo.20201108101541.44"><vh>void RHemiCubeSector::rayTraceTriangle (rhemicubesector.cpp)</vh></v>
<v t="leo.20201108101541.45"><vh>bool RHemiCubeSector::testVisibility (rhemicubesector.cpp)</vh></v>
<v t="leo.20201108101541.46"><vh>void RHemiCubeSector::generate (rhemicubesector.cpp)</vh></v>
</v>
<v t="leo.20201108101541.47"><vh>@clean riterationinfo.cpp</vh>
<v t="leo.20201108101541.48"><vh>void RIterationInfo::_init (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.49"><vh>void RIterationInfo::setNIterations (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.50"><vh>void RIterationInfo::setOutputFrequency (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.51"><vh>void RIterationInfo::setConvergenceValue (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.52"><vh>void RIterationInfo::setIteration (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.53"><vh>void RIterationInfo::setError (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.54"><vh>void RIterationInfo::setEquationScale (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.55"><vh>void RIterationInfo::setOutputFileName (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.56"><vh>bool RIterationInfo::hasConverged (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.57"><vh>void RIterationInfo::printHeader (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.58"><vh>void RIterationInfo::printFooter (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.59"><vh>void RIterationInfo::printIteration (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.60"><vh>void RIterationInfo::writeToFile (riterationinfo.cpp)</vh></v>
<v t="leo.20201108101541.61"><vh>void RIterationInfo::writeToFile (riterationinfo.cpp)</vh></v>
</v>
<v t="leo.20201108101541.62"><vh>@clean riterationinfovalue.cpp</vh>
<v t="leo.20201108101541.63"><vh>void RIterationInfoValue::_init (riterationinfovalue.cpp)</vh></v>
<v t="leo.20201108101541.64"><vh>const QString (riterationinfovalue.cpp)</vh></v>
</v>
<v t="leo.20201108101541.65"><vh>@clean rlocalrotation.cpp</vh>
<v t="leo.20201108101541.66"><vh>void RLocalRotation::_init (rlocalrotation.cpp)</vh></v>
<v t="leo.20201108101541.67"><vh>bool RLocalRotation::isActive (rlocalrotation.cpp)</vh></v>
<v t="leo.20201108101541.68"><vh>void RLocalRotation::activate (rlocalrotation.cpp)</vh></v>
<v t="leo.20201108101541.69"><vh>void RLocalRotation::deactivate (rlocalrotation.cpp)</vh></v>
<v t="leo.20201108101541.70"><vh>void RLocalRotation::rotateResultsVector (rlocalrotation.cpp)</vh></v>
</v>
<v t="leo.20201108101541.71"><vh>@clean rmatrixmanager.cpp</vh></v>
<v t="leo.20201108101541.72"><vh>@clean rmatrixpreconditioner.cpp</vh>
<v t="leo.20201108101541.73"><vh>void RMatrixPreconditioner::_init (rmatrixpreconditioner.cpp)</vh></v>
<v t="leo.20201108101541.74"><vh>void RMatrixPreconditioner::compute (rmatrixpreconditioner.cpp)</vh></v>
<v t="leo.20201108101541.75"><vh>void RMatrixPreconditioner::constructJacobi (rmatrixpreconditioner.cpp)</vh></v>
<v t="leo.20201108101541.76"><vh>void RMatrixPreconditioner::constructBlockJacobi (rmatrixpreconditioner.cpp)</vh></v>
<v t="leo.20201108101541.77"><vh>void RMatrixPreconditioner::computeJacobi (rmatrixpreconditioner.cpp)</vh></v>
<v t="leo.20201108101541.78"><vh>void RMatrixPreconditioner::computeBlockJacobi (rmatrixpreconditioner.cpp)</vh></v>
</v>
<v t="leo.20201108101541.79"><vh>@clean rmatrixsolver.cpp</vh>
<v t="leo.20201108101541.80"><vh>void RMatrixSolver::_init (rmatrixsolver.cpp)</vh></v>
<v t="leo.20201108101541.81"><vh>void RMatrixSolver::solve (rmatrixsolver.cpp)</vh></v>
<v t="leo.20201108101541.82"><vh>void RMatrixSolver::disableConvergenceLogFile (rmatrixsolver.cpp)</vh></v>
<v t="leo.20201108101541.83"><vh>void RMatrixSolver::solveCG (rmatrixsolver.cpp)</vh></v>
<v t="leo.20201108101541.84"><vh>void RMatrixSolver::solveGMRES (rmatrixsolver.cpp)</vh>
<v t="leo.20201108101542.1"><vh>double g (rmatrixsolver.cpp)</vh></v>
</v>
</v>
<v t="leo.20201108101542.2"><vh>@clean rscales.cpp</vh>
<v t="leo.20201108101542.3"><vh>void RScales::_init (rscales.cpp)</vh></v>
<v t="leo.20201108101542.4"><vh>void RScales::downscale (rscales.cpp)</vh></v>
<v t="leo.20201108101542.5"><vh>void RScales::upscale (rscales.cpp)</vh></v>
<v t="leo.20201108101542.6"><vh>void RScales::print (rscales.cpp)</vh></v>
<v t="leo.20201108101542.7"><vh>void RScales::convert (rscales.cpp)</vh></v>
</v>
<v t="leo.20201108101542.8"><vh>@clean rsolver.cpp</vh>
<v t="leo.20201108101542.9"><vh>void RSolver::_init (rsolver.cpp)</vh></v>
<v t="leo.20201108101542.10"><vh>void RSolver::run (rsolver.cpp)</vh></v>
<v t="leo.20201108101542.11"><vh>void RSolver::runSingle (rsolver.cpp)</vh></v>
<v t="leo.20201108101542.12"><vh>bool RSolver::runProblemTask (rsolver.cpp)</vh></v>
</v>
<v t="leo.20201108101542.13"><vh>@clean rsolveracoustic.cpp</vh>
<v t="leo.20201108101542.14"><vh>void RSolverAcoustic::_init (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.15"><vh>bool RSolverAcoustic::hasConverged (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.16"><vh>void RSolverAcoustic::updateScales (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.17"><vh>void RSolverAcoustic::recover (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.18"><vh>void RSolverAcoustic::prepare (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.19"><vh>void RSolverAcoustic::solve (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.20"><vh>void RSolverAcoustic::process (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.21"><vh>void RSolverAcoustic::processAbsorbingBoundary (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.22"><vh>void RSolverAcoustic::processAcousticPressure (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.23"><vh>void RSolverAcoustic::processAcousticParticleVelocity (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.24"><vh>void RSolverAcoustic::store (rsolveracoustic.cpp)</vh>
<v t="leo.20201108101542.25"><vh>double u (rsolveracoustic.cpp)</vh></v>
</v>
<v t="leo.20201108101542.26"><vh>void RSolverAcoustic::statistics (rsolveracoustic.cpp)</vh></v>
<v t="leo.20201108101542.27"><vh>void RSolverAcoustic::assemblyMatrix (rsolveracoustic.cpp)</vh></v>
</v>
<v t="leo.20201108101542.28"><vh>@clean rsolverelectrostatics.cpp</vh>
<v t="leo.20201108101542.29"><vh>void RSolverElectrostatics::_init (rsolverelectrostatics.cpp)</vh></v>
<v t="leo.20201108101542.30"><vh>bool RSolverElectrostatics::hasConverged (rsolverelectrostatics.cpp)</vh></v>
<v t="leo.20201108101542.31"><vh>void RSolverElectrostatics::updateScales (rsolverelectrostatics.cpp)</vh></v>
<v t="leo.20201108101542.32"><vh>void RSolverElectrostatics::recover (rsolverelectrostatics.cpp)</vh></v>
<v t="leo.20201108101542.33"><vh>void RSolverElectrostatics::prepare (rsolverelectrostatics.cpp)</vh></v>
<v t="leo.20201108101542.34"><vh>void RSolverElectrostatics::solve (rsolverelectrostatics.cpp)</vh></v>
<v t="leo.20201108101542.35"><vh>void RSolverElectrostatics::process (rsolverelectrostatics.cpp)</vh></v>
<v t="leo.20201108101542.36"><vh>void RSolverElectrostatics::store (rsolverelectrostatics.cpp)</vh></v>
<v t="leo.20201108101542.37"><vh>void RSolverElectrostatics::statistics (rsolverelectrostatics.cpp)</vh></v>
<v t="leo.20201108101542.38"><vh>void RSolverElectrostatics::assemblyMatrix (rsolverelectrostatics.cpp)</vh></v>
</v>
<v t="leo.20201108101542.39"><vh>@clean rsolverfluid.cpp</vh>
<v t="leo.20201108101542.40"><vh>class FluidMatrixContainer</vh>
<v t="leo.20201108101542.41"><vh>FluidMatrixContainer.void resize</vh></v>
<v t="leo.20201108101542.42"><vh>FluidMatrixContainer.void clear</vh></v>
</v>
<v t="leo.20201108101542.43"><vh>void RSolverFluid::_init (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.44"><vh>bool RSolverFluid::hasConverged (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.45"><vh>void RSolverFluid::updateScales (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.46"><vh>void RSolverFluid::recover (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.47"><vh>void RSolverFluid::prepare (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.48"><vh>void RSolverFluid::solve (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.49"><vh>void RSolverFluid::process (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.50"><vh>void RSolverFluid::store (rsolverfluid.cpp)</vh>
<v t="leo.20201108101542.51"><vh>double u (rsolverfluid.cpp)</vh></v>
</v>
<v t="leo.20201108101542.52"><vh>void RSolverFluid::statistics (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.53"><vh>void RSolverFluid::findInputVectors (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.54"><vh>void RSolverFluid::generateNodeBook (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.55"><vh>void RSolverFluid::computeFreePressureNodeHeight (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.56"><vh>void RSolverFluid::computeShapeDerivatives (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.57"><vh>void RSolverFluid::clearShapeDerivatives (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.58"><vh>void RSolverFluid::computeElement (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.59"><vh>void RSolverFluid::computeElementGeneral (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.60"><vh>void RSolverFluid::computeElementConstantDerivative (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.61"><vh>void RSolverFluid::computeElementScales (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.62"><vh>void RSolverFluid::computeElementFreePressure (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.63"><vh>void RSolverFluid::assemblyMatrix (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.64"><vh>void RSolverFluid::assemblyMatrix (rsolverfluid.cpp)</vh></v>
<v t="leo.20201108101542.65"><vh>void RSolverFluid::applyLocalRotations (rsolverfluid.cpp)</vh></v>
</v>
<v t="leo.20201108101542.66"><vh>@clean rsolverfluidheat.cpp</vh>
<v t="leo.20201108101542.67"><vh>class FluidHeatMatrixContainer</vh>
<v t="leo.20201108101542.68"><vh>FluidHeatMatrixContainer.void resize</vh></v>
<v t="leo.20201108101542.69"><vh>FluidHeatMatrixContainer.void clear</vh></v>
</v>
<v t="leo.20201108101542.70"><vh>void RSolverFluidHeat::_init (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.71"><vh>bool RSolverFluidHeat::hasConverged (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.72"><vh>void RSolverFluidHeat::generateNodeHeatVector (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.73"><vh>void RSolverFluidHeat::updateScales (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.74"><vh>void RSolverFluidHeat::recover (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.75"><vh>void RSolverFluidHeat::prepare (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.76"><vh>void RSolverFluidHeat::solve (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.77"><vh>void RSolverFluidHeat::process (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.78"><vh>void RSolverFluidHeat::store (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.79"><vh>void RSolverFluidHeat::statistics (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.80"><vh>void RSolverFluidHeat::computeShapeDerivatives (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.81"><vh>void RSolverFluidHeat::clearShapeDerivatives (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.82"><vh>void RSolverFluidHeat::computeElement (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.83"><vh>void RSolverFluidHeat::computeElementGeneral (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.84"><vh>void RSolverFluidHeat::computeElementConstantDerivative (rsolverfluidheat.cpp)</vh></v>
<v t="leo.20201108101542.85"><vh>void RSolverFluidHeat::assemblyMatrix (rsolverfluidheat.cpp)</vh></v>
</v>
<v t="leo.20201108101542.86"><vh>@clean rsolverfluidparticle.cpp</vh>
<v t="leo.20201108101542.87"><vh>class FluidParticleMatrixContainer</vh>
<v t="leo.20201108101542.88"><vh>FluidParticleMatrixContainer.void resize</vh></v>
<v t="leo.20201108101542.89"><vh>FluidParticleMatrixContainer.void clear</vh></v>
</v>
<v t="leo.20201108101542.90"><vh>void RSolverFluidParticle::_init (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.1"><vh>bool RSolverFluidParticle::hasConverged (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.2"><vh>void RSolverFluidParticle::generateNodeRateVector (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.3"><vh>void RSolverFluidParticle::updateScales (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.4"><vh>void RSolverFluidParticle::recover (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.5"><vh>void RSolverFluidParticle::prepare (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.6"><vh>void RSolverFluidParticle::solve (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.7"><vh>void RSolverFluidParticle::process (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.8"><vh>void RSolverFluidParticle::store (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.9"><vh>void RSolverFluidParticle::statistics (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.10"><vh>void RSolverFluidParticle::computeShapeDerivatives (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.11"><vh>void RSolverFluidParticle::clearShapeDerivatives (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.12"><vh>void RSolverFluidParticle::computeElement (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.13"><vh>void RSolverFluidParticle::computeElementGeneral (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.14"><vh>void RSolverFluidParticle::computeElementConstantDerivative (rsolverfluidparticle.cpp)</vh></v>
<v t="leo.20201108101543.15"><vh>void RSolverFluidParticle::assemblyMatrix (rsolverfluidparticle.cpp)</vh></v>
</v>
<v t="leo.20201108101543.16"><vh>@clean rsolvergeneric.cpp</vh>
<v t="leo.20201108101543.17"><vh>void RSolverGeneric::_init (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.18"><vh>void RSolverGeneric::run (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.19"><vh>bool RSolverGeneric::getMeshChanged (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.20"><vh>void RSolverGeneric::setMeshChanged (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.21"><vh>void RSolverGeneric::updateOldRecords (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.22"><vh>void RSolverGeneric::updateLocalRotations (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.23"><vh>void RSolverGeneric::clearSharedData (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.24"><vh>void RSolverGeneric::storeSharedData (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.25"><vh>void RSolverGeneric::recoverSharedData (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.26"><vh>void RSolverGeneric::writeResults (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.27"><vh>void RSolverGeneric::applyDisplacement (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.28"><vh>void RSolverGeneric::removeDisplacement (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.29"><vh>void RSolverGeneric::generateNodeBook (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.30"><vh>void RSolverGeneric::generateMaterialVecor (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.31"><vh>void RSolverGeneric::generateVariableVector (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.32"><vh>void RSolverGeneric::recoverVariable (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.33"><vh>void RSolverGeneric::syncShared (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.34"><vh>void RSolverGeneric::findComputableElements (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.35"><vh>void RSolverGeneric::findIncludableElements (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.36"><vh>void RSolverGeneric::findInwardElements (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.37"><vh>void RSolverGeneric::processMonitoringPoints (rsolvergeneric.cpp)</vh></v>
<v t="leo.20201108101543.38"><vh>void RSolverGeneric::printStats (rsolvergeneric.cpp)</vh></v>
</v>
<v t="leo.20201108101543.39"><vh>@clean rsolverheat.cpp</vh>
<v t="leo.20201108101543.40"><vh>void RSolverHeat::_init (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.41"><vh>bool RSolverHeat::hasConverged (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.42"><vh>void RSolverHeat::updateScales (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.43"><vh>void RSolverHeat::recover (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.44"><vh>void RSolverHeat::prepare (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.45"><vh>void RSolverHeat::solve (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.46"><vh>void RSolverHeat::process (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.47"><vh>void RSolverHeat::store (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.48"><vh>void RSolverHeat::statistics (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.49"><vh>void RSolverHeat::assemblyMatrix (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.50"><vh>bool RSolverHeat::getSimpleConvection (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.51"><vh>bool RSolverHeat::getForcedConvection (rsolverheat.cpp)</vh></v>
<v t="leo.20201108101543.52"><vh>bool RSolverHeat::getNaturalConvection (rsolverheat.cpp)</vh></v>
</v>
<v t="leo.20201108101543.53"><vh>@clean rsolvermagnetostatics.cpp</vh>
<v t="leo.20201108101543.54"><vh>void RSolverMagnetostatics::_init (rsolvermagnetostatics.cpp)</vh></v>
<v t="leo.20201108101543.55"><vh>bool RSolverMagnetostatics::hasConverged (rsolvermagnetostatics.cpp)</vh></v>
<v t="leo.20201108101543.56"><vh>void RSolverMagnetostatics::updateScales (rsolvermagnetostatics.cpp)</vh></v>
<v t="leo.20201108101543.57"><vh>void RSolverMagnetostatics::recover (rsolvermagnetostatics.cpp)</vh></v>
<v t="leo.20201108101543.58"><vh>void RSolverMagnetostatics::prepare (rsolvermagnetostatics.cpp)</vh></v>
<v t="leo.20201108101543.59"><vh>void RSolverMagnetostatics::solve (rsolvermagnetostatics.cpp)</vh></v>
<v t="leo.20201108101543.60"><vh>void RSolverMagnetostatics::process (rsolvermagnetostatics.cpp)</vh></v>
<v t="leo.20201108101543.61"><vh>void RSolverMagnetostatics::store (rsolvermagnetostatics.cpp)</vh>
<v t="leo.20201108101543.62"><vh>double u (rsolvermagnetostatics.cpp)</vh></v>
</v>
<v t="leo.20201108101543.63"><vh>void RSolverMagnetostatics::statistics (rsolvermagnetostatics.cpp)</vh></v>
<v t="leo.20201108101543.64"><vh>void RSolverMagnetostatics::assemblyMatrix (rsolvermagnetostatics.cpp)</vh></v>
</v>
<v t="leo.20201108101543.65"><vh>@clean rsolvermesh.cpp</vh>
<v t="leo.20201108101543.66"><vh>void RSolverMesh::_init (rsolvermesh.cpp)</vh></v>
<v t="leo.20201108101543.67"><vh>bool RSolverMesh::hasConverged (rsolvermesh.cpp)</vh></v>
<v t="leo.20201108101543.68"><vh>void RSolverMesh::updateScales (rsolvermesh.cpp)</vh></v>
<v t="leo.20201108101543.69"><vh>void RSolverMesh::recover (rsolvermesh.cpp)</vh></v>
<v t="leo.20201108101543.70"><vh>void RSolverMesh::prepare (rsolvermesh.cpp)</vh></v>
<v t="leo.20201108101543.71"><vh>void RSolverMesh::solve (rsolvermesh.cpp)</vh></v>
<v t="leo.20201108101543.72"><vh>void RSolverMesh::process (rsolvermesh.cpp)</vh></v>
<v t="leo.20201108101543.73"><vh>void RSolverMesh::store (rsolvermesh.cpp)</vh></v>
<v t="leo.20201108101543.74"><vh>void RSolverMesh::statistics (rsolvermesh.cpp)</vh></v>
</v>
<v t="leo.20201108101543.75"><vh>@clean rsolverradiativeheat.cpp</vh>
<v t="leo.20201108101543.76"><vh>void RSolverRadiativeHeat::_init (rsolverradiativeheat.cpp)</vh></v>
<v t="leo.20201108101543.77"><vh>bool RSolverRadiativeHeat::hasConverged (rsolverradiativeheat.cpp)</vh></v>
<v t="leo.20201108101543.78"><vh>void RSolverRadiativeHeat::updateScales (rsolverradiativeheat.cpp)</vh></v>
<v t="leo.20201108101543.79"><vh>void RSolverRadiativeHeat::recover (rsolverradiativeheat.cpp)</vh></v>
<v t="leo.20201108101543.80"><vh>void RSolverRadiativeHeat::prepareViewFactors (rsolverradiativeheat.cpp)</vh></v>
<v t="leo.20201108101543.81"><vh>void RSolverRadiativeHeat::prepare (rsolverradiativeheat.cpp)</vh></v>
<v t="leo.20201108101543.82"><vh>void RSolverRadiativeHeat::solve (rsolverradiativeheat.cpp)</vh></v>
<v t="leo.20201108101543.83"><vh>void RSolverRadiativeHeat::process (rsolverradiativeheat.cpp)</vh></v>
<v t="leo.20201108101543.84"><vh>void RSolverRadiativeHeat::store (rsolverradiativeheat.cpp)</vh></v>
<v t="leo.20201108101543.85"><vh>void RSolverRadiativeHeat::statistics (rsolverradiativeheat.cpp)</vh></v>
<v t="leo.20201108101543.86"><vh>bool RSolverRadiativeHeat::checkViewFactorHeader (rsolverradiativeheat.cpp)</vh></v>
</v>
<v t="leo.20201108101543.87"><vh>@clean rsolvershareddata.cpp</vh>
<v t="leo.20201108101543.88"><vh>void RSolverSharedData::_init (rsolvershareddata.cpp)</vh></v>
<v t="leo.20201108101543.89"><vh>bool RSolverSharedData::hasData (rsolvershareddata.cpp)</vh></v>
<v t="leo.20201108101543.90"><vh>void RSolverSharedData::addData (rsolvershareddata.cpp)</vh></v>
<v t="leo.20201108101543.91"><vh>void RSolverSharedData::clearData (rsolvershareddata.cpp)</vh></v>
</v>
<v t="leo.20201108101543.92"><vh>@clean rsolverstress.cpp</vh>
<v t="leo.20201108101543.93"><vh>void RSolverStress::_init (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.94"><vh>bool RSolverStress::hasConverged (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.95"><vh>void RSolverStress::updateScales (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.96"><vh>void RSolverStress::recover (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.97"><vh>void RSolverStress::prepare (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.98"><vh>void RSolverStress::solve (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.99"><vh>void RSolverStress::solveStressStrain (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.100"><vh>void RSolverStress::solveEigenValue (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.101"><vh>void RSolverStress::setDisplacement (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.102"><vh>void RSolverStress::process (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.103"><vh>void RSolverStress::store (rsolverstress.cpp)</vh>
<v t="leo.20201108101543.104"><vh>double u (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.105"><vh>double f (rsolverstress.cpp)</vh></v>
</v>
<v t="leo.20201108101543.106"><vh>void RSolverStress::statistics (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.107"><vh>void RSolverStress::generateNodeBook (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.108"><vh>void RSolverStress::assemblyMatrix (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.109"><vh>void RSolverStress::applyLocalRotations (rsolverstress.cpp)</vh></v>
<v t="leo.20201108101543.110"><vh>void RSolverStress::applyLocalRotations (rsolverstress.cpp)</vh></v>
</v>
<v t="leo.20201108101544.1"><vh>@clean rsolverwave.cpp</vh>
<v t="leo.20201108101544.2"><vh>void RSolverWave::_init (rsolverwave.cpp)</vh></v>
<v t="leo.20201108101544.3"><vh>bool RSolverWave::hasConverged (rsolverwave.cpp)</vh></v>
<v t="leo.20201108101544.4"><vh>void RSolverWave::updateScales (rsolverwave.cpp)</vh></v>
<v t="leo.20201108101544.5"><vh>void RSolverWave::recover (rsolverwave.cpp)</vh></v>
<v t="leo.20201108101544.6"><vh>void RSolverWave::prepare (rsolverwave.cpp)</vh></v>
<v t="leo.20201108101544.7"><vh>void RSolverWave::solve (rsolverwave.cpp)</vh></v>
<v t="leo.20201108101544.8"><vh>void RSolverWave::process (rsolverwave.cpp)</vh></v>
<v t="leo.20201108101544.9"><vh>void RSolverWave::store (rsolverwave.cpp)</vh></v>
<v t="leo.20201108101544.10"><vh>void RSolverWave::statistics (rsolverwave.cpp)</vh></v>
</v>
</v>
</v>
<v t="leo.20201108101544.11"><vh>@path RangeTests</vh>
<v t="leo.20201108101544.12"><vh>@clean tst_main.cpp</vh>
<v t="leo.20201108101544.13"><vh>int main (tst_main.cpp)</vh></v>
</v>
<v t="leo.20201108101544.14"><vh>@path TestRangeBase</vh>
<v t="leo.20201108101544.15"><vh>@clean tst_rbl_r3vector.cpp</vh>
<v t="leo.20201108101544.16"><vh>void tst_RR3Vector::getOpposite (tst_rbl_r3vector.cpp)</vh></v>
<v t="leo.20201108101544.17"><vh>void tst_RR3Vector::findDistance (tst_rbl_r3vector.cpp)</vh></v>
<v t="leo.20201108101544.18"><vh>void tst_RR3Vector::findOrthogonal (tst_rbl_r3vector.cpp)</vh></v>
<v t="leo.20201108101544.19"><vh>void tst_RR3Vector::cross (tst_rbl_r3vector.cpp)</vh></v>
<v t="leo.20201108101544.20"><vh>void tst_RR3Vector::angle (tst_rbl_r3vector.cpp)</vh></v>
</v>
<v t="leo.20201108101544.21"><vh>@clean tst_rbl_rmatrix.cpp</vh>
<v t="leo.20201108101544.22"><vh>void tst_RRMatrix::transpose (tst_rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101544.23"><vh>void tst_RRMatrix::invert (tst_rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101544.24"><vh>void tst_RRMatrix::decomposeToLU (tst_rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101544.25"><vh>void tst_RRMatrix::getDeterminant (tst_rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101544.26"><vh>void tst_RRMatrix::getSummedRows (tst_rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101544.27"><vh>void tst_RRMatrix::getBlock (tst_rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101544.28"><vh>void tst_RRMatrix::setBlock (tst_rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101544.29"><vh>void tst_RRMatrix::trace (tst_rbl_rmatrix.cpp)</vh></v>
<v t="leo.20201108101544.30"><vh>void tst_RRMatrix::mlt (tst_rbl_rmatrix.cpp)</vh></v>
</v>
<v t="leo.20201108101544.31"><vh>@clean tst_rbl_rvector.cpp</vh>
<v t="leo.20201108101544.32"><vh>void tst_RRVector::dot (tst_rbl_rvector.cpp)</vh></v>
<v t="leo.20201108101544.33"><vh>void tst_RRVector::norm (tst_rbl_rvector.cpp)</vh></v>
</v>
</v>
<v t="leo.20201108101544.34"><vh>@path TestRangeModel</vh>
<v t="leo.20201108101544.35"><vh>@clean tst_rml_sparse_matrix.cpp</vh>
<v t="leo.20201108101544.36"><vh>void tst_RSparseMatrix::addMatrix (tst_rml_sparse_matrix.cpp)</vh></v>
</v>
<v t="leo.20201108101544.37"><vh>@clean tst_rml_sparse_vector.cpp</vh>
<v t="leo.20201108101544.38"><vh>void tst_RSparseVector::addValue (tst_rml_sparse_vector.cpp)</vh></v>
<v t="leo.20201108101544.39"><vh>void tst_RSparseVector::addVector (tst_rml_sparse_vector.cpp)</vh></v>
</v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20201108101132.2">'''Recursively import all python files in a directory and clean the result.'''

c.recursiveImport(
    dir_ = r'./',
    kind = '@clean', # The new best practice.
    safe_at_file = False,
    #theTypes = None, # Same as ['.py']
    theTypes = ['.cpp']
)</t>
<t tx="leo.20201108101517.1"></t>
<t tx="leo.20201108101517.10"></t>
<t tx="leo.20201108101517.100">void Action::onSolverStop()
{
    if (QMessageBox::question(this-&gt;mainWindow,
                               tr("Stop solver"),
                               tr("Are you sure you want to stop all running solvers?"),
                               QMessageBox::No,
                               QMessageBox::Yes) == QMessageBox::No)
    {
        return;
    }

    try
    {
        SolverManager::getInstance().stopRunningTasks();
    }
    catch (RError &amp;error)
    {
        RLogger::error("Could not stop the solver (%s).\n",error.getMessage().toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101517.101">void Action::onSolverKill()
{
    if (QMessageBox::question(this-&gt;mainWindow,
                               tr("Kill solver"),
                               tr("Are you sure you want to kill all running solvers?"),
                               QMessageBox::No,
                               QMessageBox::Yes) == QMessageBox::No)
    {
        return;
    }

    try
    {
        SolverManager::getInstance().killRunningTasks();
    }
    catch (RError &amp;error)
    {
        RLogger::error("Could not kill the solver (%s).\n",error.getMessage().toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101517.102">void Action::onReportModelStatistics()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        ModelStatisticsDialog modelStatisticsDialog(modelIDs[i],this-&gt;mainWindow);
        modelStatisticsDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.103">void Action::onReportSolverLog()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QString fileName(RFileManager::findLastFile(Session::getInstance().getModel(modelIDs[i]).buildTmpFileName("log",QString("*"))));
        if (fileName.isEmpty())
        {
            QMessageBox::information(this-&gt;mainWindow,tr("No solver log file"),tr("There is no file containing solver log."));
        }
        else
        {
            LogBrowserDialog logBrowserDialog(fileName,this-&gt;mainWindow);
            logBrowserDialog.exec();
        }
    }
}

</t>
<t tx="leo.20201108101517.104">void Action::onReportConvergenceGraph()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QStringList fileNames;

        QString filePattern(Session::getInstance().getModel(modelIDs[i]).buildTmpFileName("cvg",QString("*")));

        std::vector&lt;RProblemType&gt; problemTypes = RProblem::getTypes(R_PROBLEM_ALL);
        for (uint i=0;i&lt;problemTypes.size();i++)
        {
            QString fileName(RFileManager::findLastFile(RFileManager::getFileNameWithSuffix(filePattern,RProblem::getId(problemTypes[i]))));
            if (!fileName.isEmpty())
            {
                fileNames.append(fileName);
            }
        }

        for (RMatrixSolverType type=RMatrixSolverConf::None;type&lt;RMatrixSolverConf::NTypes;type++)
        {
            QString fileName(RFileManager::findLastFile(RFileManager::getFileNameWithSuffix(filePattern,RMatrixSolverConf::getId(type))));
            if (!fileName.isEmpty())
            {
                fileNames.append(fileName);
            }
        }

        if (fileNames.isEmpty())
        {
            QMessageBox::information(this-&gt;mainWindow,tr("No convergence file"),tr("There is no file containing convergence values."));
        }
        else
        {
            ConvergenceGraphDialog *convergenceGraphDialog = new ConvergenceGraphDialog(fileNames,this-&gt;mainWindow);
            convergenceGraphDialog-&gt;setModal(false);
            convergenceGraphDialog-&gt;show();
        }
    }
}

</t>
<t tx="leo.20201108101517.105">void Action::onReportMonitoringPointGraph()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QString fileName(RFileManager::findLastFile(Session::getInstance().getModel(modelIDs[i]).buildTmpFileName("mon",QString("*"))));
        if (fileName.isEmpty())
        {
            QMessageBox::information(this-&gt;mainWindow,tr("No monitoring file"),tr("There is no file containing monitoring points."));
        }
        else
        {
            MonitoringPointGraphDialog monitoringPointGraphDialog(fileName,this-&gt;mainWindow);
            monitoringPointGraphDialog.exec();
        }
    }
}

</t>
<t tx="leo.20201108101517.106">void Action::onReportCreateReport()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        ReportDialog reportDialog(modelIDs[i],this-&gt;mainWindow);
        reportDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.107">void Action::onHelp()
{
    HelpCenterDialog *pHelpCenterDialog = new HelpCenterDialog(this-&gt;mainWindow);
    pHelpCenterDialog-&gt;setModal(false);
    pHelpCenterDialog-&gt;show();
}

</t>
<t tx="leo.20201108101517.108">void Action::onQuit()
{
    this-&gt;mainWindow-&gt;close();
}

</t>
<t tx="leo.20201108101517.109">void Action::onApplicationSettings()
{
    ApplicationSettingsDialog applicationSettingsDialog(MainSettings::getInstance().getApplicationSettings(),
                                                        this-&gt;mainWindow);
    applicationSettingsDialog.exec();
}

</t>
<t tx="leo.20201108101517.11">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   action.cpp                                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th August 2013                                         *
 *                                                                   *
 *  DESCRIPTION: Action class definition                             *
 *********************************************************************/

#include &lt;QString&gt;
#include &lt;QApplication&gt;
#include &lt;QMainWindow&gt;
#include &lt;QMessageBox&gt;
#include &lt;QFileDialog&gt;

#include &lt;rblib.h&gt;
#include &lt;rmlib.h&gt;

#include "action.h"
#include "application_settings_dialog.h"
#include "bool_difference_dialog.h"
#include "bool_intersection_dialog.h"
#include "bool_union_dialog.h"
#include "break_intersected_elements_dialog.h"
#include "convergence_graph_dialog.h"
#include "drop_results_dialog.h"
#include "new_model_dialog.h"
#include "coarsen_surface_dialog.h"
#include "cut_dialog.h"
#include "help_center_dialog.h"
#include "iso_dialog.h"
#include "job_manager.h"
#include "log_browser_dialog.h"
#include "find_sliver_elements_dialog.h"
#include "fix_sliver_elements_dialog.h"
#include "main_window.h"
#include "mark_entity_dialog.h"
#include "merge_entity_dialog.h"
#include "merge_near_nodes_dialog.h"
#include "remove_entity_dialog.h"
#include "material_list.h"
#include "matrix_solver_config_dialog.h"
#include "main_window.h"
#include "mesh_generator_dialog.h"
#include "model_action.h"
#include "model_io.h"
#include "model_statistics_dialog.h"
#include "monitoring_points_dialog.h"
#include "monitoring_point_graph_dialog.h"
#include "move_node_dialog.h"
#include "point_inside_surface_dialog.h"
#include "problem_selector_dialog.h"
#include "problem_task_dialog.h"
#include "rename_model_dialog.h"
#include "report_dialog.h"
#include "rra_session.h"
#include "session_entity_id.h"
#include "session.h"
#include "stream_line_dialog.h"
#include "solver_start_dialog.h"
#include "solver_manager.h"
#include "scalar_field_dialog.h"
#include "text_browser_dialog.h"
#include "update_dialog.h"
#include "vector_field_dialog.h"

Action::Action(ActionType type, MainWindow *mainWindow, QObject *parent) :
    QAction(parent),
    type(type),
    mainWindow(mainWindow)
{
    const ActionDefinition *actionDefinition = MainSettings::getInstance().getApplicationSettings()-&gt;getActionDefinition();

    switch (this-&gt;type)
    {
        case ACTION_NONE:
        {
            break;
        }
        case ACTION_SEPARATOR:
        {
            this-&gt;setSeparator(true);
            break;
        }
        default:
        {
            this-&gt;setText(tr(actionDefinition-&gt;getText(this-&gt;type).toUtf8().constData()));
            this-&gt;setToolTip(tr(actionDefinition-&gt;getDescription(this-&gt;type).toUtf8().constData()));
            this-&gt;setShortcut(tr(actionDefinition-&gt;getShortCut(this-&gt;type).toUtf8().constData()));
            if (!actionDefinition-&gt;getIcon(this-&gt;type).isEmpty())
            {
                this-&gt;setIcon(QIcon(actionDefinition-&gt;getIcon(this-&gt;type).toUtf8().constData()));
                this-&gt;setIconVisibleInMenu(true);
            }
            QObject::connect(this, &amp;Action::triggered, this, actionDefinition-&gt;getSlot(this-&gt;type));
            break;
        }
    }

    if (this-&gt;type == ACTION_SOLVER_START)
    {
        QObject::connect(&amp;SolverManager::getInstance(), &amp;SolverManager::jobStarted, this, &amp;Action::disable);
        QObject::connect(&amp;SolverManager::getInstance(), &amp;SolverManager::jobFinished, this, &amp;Action::enable);
    }
    if (this-&gt;type == ACTION_SOLVER_STOP || this-&gt;type == ACTION_SOLVER_KILL)
    {
        QObject::connect(&amp;SolverManager::getInstance(), &amp;SolverManager::jobStarted, this, &amp;Action::enable);
        QObject::connect(&amp;SolverManager::getInstance(), &amp;SolverManager::jobFinished, this, &amp;Action::disable);
    }
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101517.110">void Action::onUpdate()
{
    UpdateDialog updateDialog(RRASession::getInstance().getAvailableSoftwareVersion(),
                              RRASession::getInstance().getAvailableSoftwareLink(),
                              this-&gt;mainWindow);
    updateDialog.exec();
}

</t>
<t tx="leo.20201108101517.111">void Action::onAbout()
{
    QString title = tr("About");
    QString body = QString("&lt;h1&gt;") + RVendor::name + QString(" ") + QString::number(RVendor::version.getMajor()) + QString("&lt;/h1&gt;")
                 + QString("&lt;h2&gt;") + RVendor::description + QString("&lt;/h2&gt;")
                 + RVendor::version.toString()
                 + QString("&lt;br/&gt;")
                 + RVendor::author.toHtmlEscaped() + QString(" &amp;copy; ") + QString::number(RVendor::year) + QString("&lt;br/&gt;")
                 + QString("&lt;a href=\"mailto:") + RVendor::email + QString("\"&gt;") + RVendor::email + QString("&lt;/a&gt;&lt;br/&gt;")
                 + QString("&lt;a href=\"") + RVendor::www + QString("\"&gt;") + RVendor::www + QString("&lt;/a&gt;");

    QMessageBox::about(this-&gt;mainWindow,title,body);
}

</t>
<t tx="leo.20201108101517.112">void Action::onAboutQt()
{
    QString title = tr("About Qt");

    QMessageBox::aboutQt(this-&gt;mainWindow,title);
}

</t>
<t tx="leo.20201108101517.113">void Action::onLicense()
{
    QString licenseFileName(MainSettings::getInstance().findLicenseFileName());

    try
    {
        QFile file(licenseFileName);
        if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",licenseFileName.toUtf8().constData());
        }
        QString licenseText(file.readAll());
        file.close();

        TextBrowserDialog textBrowserDialog(tr("License"),
                                            licenseFileName,
                                            licenseText);
        textBrowserDialog.exec();
    }
    catch (const RError &amp;rError)
    {
        RLogger::error("Failed to display license from file \'%s\'. %s\n",licenseFileName.toUtf8().constData(),rError.getMessage().toUtf8().constData());
    }
    catch (...)
    {
        RLogger::error("Failed to display license from file \'%s\'.\n",licenseFileName.toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101517.114">void Action::onReleaseNotes()
{
    QString releaseNotesFileName(MainSettings::getInstance().findReleaseNotesFileName());

    try
    {
        QFile file(releaseNotesFileName);
        if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",releaseNotesFileName.toUtf8().constData());
        }
        QString releaseNotesText(file.readAll());
        file.close();

        TextBrowserDialog textBrowserDialog(tr("Release notes"),
                                            releaseNotesFileName,
                                            releaseNotesText);
        textBrowserDialog.exec();
    }
    catch (const RError &amp;rError)
    {
        RLogger::error("Failed to display release notes from file \'%s\'. %s\n",releaseNotesFileName.toUtf8().constData(),rError.getMessage().toUtf8().constData());
    }
    catch (...)
    {
        RLogger::error("Failed to display release notes from file \'%s\'.\n",releaseNotesFileName.toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101517.115">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   action_definition.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th September 2014                                      *
 *                                                                   *
 *  DESCRIPTION: Action definition class definition                  *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "action_definition.h"
#include "action.h"

ActionDefinition::ActionDefinition(QObject *parent)
    : QObject(parent)
{
    ActionDefinition::generateActionDescList(this-&gt;actionDesc);
}

ActionType ActionDefinition::findShortcutActionType(const QString &amp;shortCut) const
{
    for (int i=0;i&lt;int(ACTION_N_TYPES);i++)
    {
        if (this-&gt;actionDesc[i].shortCut == shortCut)
        {
            return ActionType(i);
        }
    }
    return ACTION_NONE;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101517.116">const QString &amp;ActionDefinition::getText(ActionType type) const
{
    if (!ACTION_TYPE_IS_VALID(type))
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid action type: &amp;d\n",int(type));
    }
    return this-&gt;actionDesc[type].text;
}

</t>
<t tx="leo.20201108101517.117">const QString &amp;ActionDefinition::getDescription(ActionType type) const
{
    if (!ACTION_TYPE_IS_VALID(type))
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid action type: &amp;d\n",int(type));
    }
    return this-&gt;actionDesc[type].desc;
}

</t>
<t tx="leo.20201108101517.118">const QString &amp;ActionDefinition::getShortCut(ActionType type) const
{
    if (!ACTION_TYPE_IS_VALID(type))
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid action type: &amp;d\n",int(type));
    }
    return this-&gt;actionDesc[type].shortCut;
}

</t>
<t tx="leo.20201108101517.119">void ActionDefinition::setShortcut(ActionType type, const QString &amp;shortCut)
{
    if (!ACTION_TYPE_IS_VALID(type))
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid action type: &amp;d\n",int(type));
    }
    this-&gt;actionDesc[type].shortCut = shortCut;
    emit this-&gt;shortcutChanged(type,shortCut);
}

</t>
<t tx="leo.20201108101517.12">void Action::enable()
{
    this-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.120">const QString &amp;ActionDefinition::getIcon(ActionType type) const
{
    if (!ACTION_TYPE_IS_VALID(type))
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid action type: &amp;d\n",int(type));
    }
    return this-&gt;actionDesc[type].icon;
}

PointerToMemberFunction ActionDefinition::getSlot(ActionType type) const
{
    if (!ACTION_TYPE_IS_VALID(type))
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid action type: &amp;d\n",int(type));
    }
    return this-&gt;actionDesc[type].slot;
}

QList&lt;ActionType&gt; ActionDefinition::getActionTypes(ActionGroupTypeMask actionGroupTypeMask) const
{
    QList&lt;ActionType&gt; actionTypes;

    foreach (ActionDefinitionItem item, this-&gt;actionDesc)
    {
        if (item.getGroupType() &amp; actionGroupTypeMask)
        {
            actionTypes.push_back(item.getType());
        }
    }

    return actionTypes;
}

</t>
<t tx="leo.20201108101517.121">void ActionDefinition::generateActionDescList(QList&lt;ActionDefinitionItem&gt; &amp;actionDesc)
{
    actionDesc.clear();
    actionDesc.push_back(ActionDefinitionItem(ACTION_NONE, ACTION_GROUP_NONE, "", "", "", "", nullptr ));
    actionDesc.push_back(ActionDefinitionItem(ACTION_SESSION_NEW, ACTION_GROUP_SESSION, "New Session", "Create a new session.", "Ctrl+Alt+N", ":/icons/file/pixmaps/range-session_new.svg", &amp;Action::onSessionNew));
    actionDesc.push_back(ActionDefinitionItem(ACTION_SESSION_OPEN, ACTION_GROUP_SESSION, "Open Session", "Open previously saved session.", "Ctrl+Alt+O", ":/icons/file/pixmaps/range-session_open.svg", &amp;Action::onSessionOpen));
    actionDesc.push_back(ActionDefinitionItem(ACTION_SESSION_SAVE, ACTION_GROUP_SESSION, "Save Session", "Save current session.", "Ctrl+Alt+S", ":/icons/file/pixmaps/range-session_save.svg", &amp;Action::onSessionSave));
    actionDesc.push_back(ActionDefinitionItem(ACTION_SESSION_SAVE_AS, ACTION_GROUP_SESSION, "Save Session As", "Save current session under different filename.", "Ctrl+Alt+Shift+S", ":/icons/file/pixmaps/range-session_save_as.svg", &amp;Action::onSessionSaveAs));
    actionDesc.push_back(ActionDefinitionItem(ACTION_SESSION_CLOSE, ACTION_GROUP_SESSION, "Close Session", "Close current session.", "Ctrl+Alt+W", ":/icons/file/pixmaps/range-session_close.svg", &amp;Action::onSessionClose));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_NEW, ACTION_GROUP_MODEL, "New Model", "Create a new empty model.", "Ctrl+N", ":/icons/file/pixmaps/range-model_new.svg", &amp;Action::onModelNew));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_OPEN, ACTION_GROUP_MODEL, "Open Model", "Open previously saved model.", "Ctrl+O", ":/icons/file/pixmaps/range-model_open.svg", &amp;Action::onModelOpen));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_SAVE, ACTION_GROUP_MODEL, "Save Model", "Save selected model. ", "Ctrl+S", ":/icons/file/pixmaps/range-model_save.svg", &amp;Action::onModelSave));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_SAVE_AS, ACTION_GROUP_MODEL, "Save Model As", "Save selected model under a different filename.", "Ctrl+Shift+S", ":/icons/file/pixmaps/range-model_save_as.svg", &amp;Action::onModelSaveAs));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_EXPORT_MSH, ACTION_GROUP_MODEL, "Export MSH model", "", "", ":/icons/file/pixmaps/range-model_export_msh.svg", &amp;Action::onModelExportMsh));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_EXPORT_RAW, ACTION_GROUP_MODEL, "Export RAW model", "", "", ":/icons/file/pixmaps/range-model_export_raw.svg", &amp;Action::onModelExportRaw));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_EXPORT_STL_ASCII, ACTION_GROUP_MODEL, "Export STL model (ascii)", "", "", ":/icons/file/pixmaps/range-model_export_stl.svg", &amp;Action::onModelExportStlAscii));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_EXPORT_STL_BINARY, ACTION_GROUP_MODEL, "Export STL model (binary)", "", "", ":/icons/file/pixmaps/range-model_export_stl.svg", &amp;Action::onModelExportStlBinary));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_CLOSE, ACTION_GROUP_MODEL, "Close Model", "", "Ctrl+W", ":/icons/file/pixmaps/range-model_close.svg", &amp;Action::onModelClose));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_RELOAD_RESULTS, ACTION_GROUP_MODEL, "Reload Results", "", "", ":/icons/file/pixmaps/range-refresh.svg", &amp;Action::onModelReloadResults));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_DROP_RESULTS, ACTION_GROUP_MODEL, "Drop Results", "", "", ":/icons/file/pixmaps/range-model_drop_results.svg", &amp;Action::onModelDropResults));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MODEL_RENAME, ACTION_GROUP_MODEL, "Rename Model", "", "", ":/icons/file/pixmaps/range-model_rename.svg", &amp;Action::onModelRename));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MATERIAL_NEW, ACTION_GROUP_MATERIAL, "New Material", "", "Ctrl+Alt+M", ":/icons/file/pixmaps/range-material_new.svg", &amp;Action::onMaterialNew));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MATERIAL_IMPORT, ACTION_GROUP_MATERIAL, "Import Material", "", "", ":/icons/file/pixmaps/range-material_import.svg", &amp;Action::onMaterialImport));
    actionDesc.push_back(ActionDefinitionItem(ACTION_MATERIAL_DELETE, ACTION_GROUP_MATERIAL, "Delete Material", "", "Ctrl+Alt+D", ":/icons/file/pixmaps/range-material_delete.svg", &amp;Action::onMaterialDelete));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_UNDO, ACTION_GROUP_GEOMETRY, "Undo", "", "Ctrl+Z", ":/icons/geometry/pixmaps/range-undo.svg", &amp;Action::onGeometryUndo));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_REDO, ACTION_GROUP_GEOMETRY, "Redo", "", "Ctrl+Shift+Z", ":/icons/geometry/pixmaps/range-redo.svg", &amp;Action::onGeometryRedo));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_POINT, ACTION_GROUP_GEOMETRY, "Draw point", "", "", ":/icons/geometry/pixmaps/range-draw_point.svg", &amp;Action::onGeometryDrawPoint));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_LINE, ACTION_GROUP_GEOMETRY, "Draw line", "", "", ":/icons/geometry/pixmaps/range-draw_line.svg", &amp;Action::onGeometryDrawLine));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_TRIANGLE, ACTION_GROUP_GEOMETRY, "Draw triangle", "", "", ":/icons/geometry/pixmaps/range-draw_triangle.svg", &amp;Action::onGeometryDrawTriangle));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_QUADRILATERAL, ACTION_GROUP_GEOMETRY, "Draw quadrilateral", "", "", ":/icons/geometry/pixmaps/range-draw_quadrilateral.svg", &amp;Action::onGeometryDrawQuadrilateral));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_CIRCLE, ACTION_GROUP_GEOMETRY, "Draw circle", "", "", ":/icons/geometry/pixmaps/range-draw_circle.svg", &amp;Action::onGeometryDrawCircle));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_ELLIPSE, ACTION_GROUP_GEOMETRY, "Draw ellipse", "", "", ":/icons/geometry/pixmaps/range-draw_ellipse.svg", &amp;Action::onGeometryDrawEllipse));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_TETRAHEDRON, ACTION_GROUP_GEOMETRY, "Draw tetrahedron", "", "", ":/icons/geometry/pixmaps/range-draw_tetrahedron.svg", &amp;Action::onGeometryDrawTetrahedron));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_HEXAHEDRON, ACTION_GROUP_GEOMETRY, "Draw hexahedron", "", "", ":/icons/geometry/pixmaps/range-draw_hexahedron.svg", &amp;Action::onGeometryDrawHexahedron));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_CYLINDER, ACTION_GROUP_GEOMETRY, "Draw cylinder", "", "", ":/icons/geometry/pixmaps/range-draw_cylinder.svg", &amp;Action::onGeometryDrawCylinder));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_SPHERE, ACTION_GROUP_GEOMETRY, "Draw sphere", "", "", ":/icons/geometry/pixmaps/range-draw_sphere.svg", &amp;Action::onGeometryDrawSphere));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DRAW_RAW, ACTION_GROUP_GEOMETRY, "Draw RAW object", "", "", ":/icons/geometry/pixmaps/range-draw_raw.svg", &amp;Action::onGeometryDrawRaw));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_CREATE_ELEMENT, ACTION_GROUP_GEOMETRY, "Create element", "", "Ctrl+Alt+E", ":/icons/geometry/pixmaps/range-element_create.svg", &amp;Action::onGeometryCreateElement));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_FIND_SLIVER_ELEMENTS, ACTION_GROUP_GEOMETRY, "Find sliver elements", "", "", ":/icons/geometry/pixmaps/range-sliver_find.svg", &amp;Action::onGeometryFindSliverElements));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_FIX_SLIVER_ELEMENTS, ACTION_GROUP_GEOMETRY, "Fix sliver elements", "", "", ":/icons/geometry/pixmaps/range-sliver_fix.svg", &amp;Action::onGeometryFixSliverElements));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_FIND_INTERSECTED_ELEMENTS, ACTION_GROUP_GEOMETRY, "Find intersected elements", "", "Ctrl+I", ":/icons/geometry/pixmaps/range-entity_surface_find_intersected.svg", &amp;Action::onGeometryFindIntersectedElements));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_BREAK_INTERSECTED_ELEMENTS, ACTION_GROUP_GEOMETRY, "Break intersected elements", "", "Ctrl+J", ":/icons/geometry/pixmaps/range-entity_surface_break_intersected.svg", &amp;Action::onGeometryBreakIntersectedElements));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_BOOL_UNION, ACTION_GROUP_GEOMETRY, "Union", "", "", ":/icons/geometry/pixmaps/range-entity_surface_bool_union.svg", &amp;Action::onGeometryBoolUnion));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_BOOL_DIFFERENCE, ACTION_GROUP_GEOMETRY, "Difference", "", "", ":/icons/geometry/pixmaps/range-entity_surface_bool_difference.svg", &amp;Action::onGeometryBoolDifference));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_BOOL_INTERSECTION, ACTION_GROUP_GEOMETRY, "Intersection", "", "", ":/icons/geometry/pixmaps/range-entity_surface_bool_intersection.svg", &amp;Action::onGeometryBoolIntersection));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_MERGE_NEAR_NODES, ACTION_GROUP_GEOMETRY, "Merge near nodes", "", "", ":/icons/geometry/pixmaps/range-merge_near_nodes.svg", &amp;Action::onGeometryMergeNearNodes));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_MOVE_NODE, ACTION_GROUP_GEOMETRY, "Move node", "", "", ":/icons/geometry/pixmaps/range-move_node.svg", &amp;Action::onGeometryMoveNode));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_REMOVE_NODE, ACTION_GROUP_GEOMETRY, "Remove node", "", "Ctrl+Shift+X", ":/icons/geometry/pixmaps/range-node_remove.svg", &amp;Action::onGeometryRemoveNode));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_REMOVE_NODE_AND_CLOSE_HOLE, ACTION_GROUP_GEOMETRY, "Remove node and close hole", "", "", ":/icons/geometry/pixmaps/range-node_remove_and_close.svg", &amp;Action::onGeometryRemoveNodeAndCloseHole));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_REMOVE_ELEMENT, ACTION_GROUP_GEOMETRY, "Remove element", "", "Ctrl+Alt+X", ":/icons/geometry/pixmaps/range-element_remove.svg", &amp;Action::onGeometryRemoveElement));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_LINE_GENERATE_FROM_EDGES, ACTION_GROUP_GEOMETRY, "Generate line(s) from surface edges", "", "", ":/icons/geometry/pixmaps/range-entity_line_from_surface.svg", &amp;Action::onGeometryLineGenerateFromEdges));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_SURFACE_MARK, ACTION_GROUP_GEOMETRY, "Mark surface", "", "", ":/icons/geometry/pixmaps/range-entity_surface_mark.svg", &amp;Action::onGeometrySurfaceMark));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_SURFACE_SWAP_ELEMENT_NORMAL, ACTION_GROUP_GEOMETRY, "Swap element normal", "", "", ":/icons/geometry/pixmaps/range-entity_surface_swap_element_normal.svg", &amp;Action::onGeometrySurfaceSwapElementNormal));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_SURFACE_SWAP_NORMALS, ACTION_GROUP_GEOMETRY, "Swap normals", "", "", ":/icons/geometry/pixmaps/range-entity_surface_swap_normals.svg", &amp;Action::onGeometrySurfaceSwapNormals));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_SURFACE_SYNC_NORMALS, ACTION_GROUP_GEOMETRY, "Synchronize normals", "", "", ":/icons/geometry/pixmaps/range-entity_surface_sync_normals.svg", &amp;Action::onGeometrySurfaceSyncNormals));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_SURFACE_CLOSE_HOLE, ACTION_GROUP_GEOMETRY, "Close hole", "", "", ":/icons/geometry/pixmaps/range-entity_surface_close_hole.svg", &amp;Action::onGeometrySurfaceCloseHole));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_SURFACE_COARSEN, ACTION_GROUP_GEOMETRY, "Coarsen surface", "", "", ":/icons/geometry/pixmaps/range-entity_surface_coarsen.svg", &amp;Action::onGeometrySurfaceCoarsen));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_VOLUME_GENERATE_TETRAHEDRA, ACTION_GROUP_GEOMETRY, "Generate tetrahedral mesh", "", "Ctrl+G", ":/icons/geometry/pixmaps/range-generate_volume_mesh.svg", &amp;Action::onGeometryGenerateTetrahedra));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_VECTOR_FIELD_CREATE, ACTION_GROUP_GEOMETRY, "Create vector field", "", "", ":/icons/geometry/pixmaps/range-entity_vector_field_create.svg", &amp;Action::onGeometryVectorFieldCreate));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_VECTOR_FIELD_EDIT, ACTION_GROUP_GEOMETRY, "Edit vector field", "", "", ":/icons/geometry/pixmaps/range-entity_vector_field_edit.svg", &amp;Action::onGeometryVectorFieldEdit));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_SCALAR_FIELD_CREATE, ACTION_GROUP_GEOMETRY, "Create scalar field", "", "", ":/icons/geometry/pixmaps/range-entity_scalar_field_create.svg", &amp;Action::onGeometryScalarFieldCreate));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_SCALAR_FIELD_EDIT, ACTION_GROUP_GEOMETRY, "Edit scalar field", "", "", ":/icons/geometry/pixmaps/range-entity_scalar_field_edit.svg", &amp;Action::onGeometryScalarFieldEdit));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_STREAM_LINE_CREATE, ACTION_GROUP_GEOMETRY, "Create stream line", "", "", ":/icons/geometry/pixmaps/range-entity_stream_line_create.svg", &amp;Action::onGeometryStreamLineCreate));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_STREAM_LINE_EDIT, ACTION_GROUP_GEOMETRY, "Edit stream line", "", "", ":/icons/geometry/pixmaps/range-entity_stream_line_edit.svg", &amp;Action::onGeometryStreamLineEdit));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_CUT_CREATE, ACTION_GROUP_GEOMETRY, "Create cut", "", "", ":/icons/geometry/pixmaps/range-entity_cut_create.svg", &amp;Action::onGeometryCutCreate));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_CUT_EDIT, ACTION_GROUP_GEOMETRY, "Edit cut", "", "", ":/icons/geometry/pixmaps/range-entity_cut_edit.svg", &amp;Action::onGeometryCutEdit));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_ISO_CREATE, ACTION_GROUP_GEOMETRY, "Create iso", "", "", ":/icons/geometry/pixmaps/range-entity_iso_create.svg", &amp;Action::onGeometryIsoCreate));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_ISO_EDIT, ACTION_GROUP_GEOMETRY, "Edit iso", "", "", ":/icons/geometry/pixmaps/range-entity_iso_edit.svg", &amp;Action::onGeometryIsoEdit));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_ENTITY_MERGE, ACTION_GROUP_GEOMETRY, "Merge selected entities", "", "Ctrl+M", ":/icons/geometry/pixmaps/range-entity_merge.svg", &amp;Action::onGeometryEntityMerge));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_ENTITY_REMOVE, ACTION_GROUP_GEOMETRY, "Remove selected entities", "", "Ctrl+X", ":/icons/geometry/pixmaps/range-entity_remove.svg", &amp;Action::onGeometryEntityRemove));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_TRANSFORM, ACTION_GROUP_GEOMETRY, "Scale, translate, rotate", "", "Ctrl+T", ":/icons/geometry/pixmaps/range-geometry_transform.svg", &amp;Action::onGeometryTransform));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DEV_EXPORT_SLIVER_ELEMENTS, ACTION_GROUP_GEOMETRY, "Export sliver elements", "", "", "", &amp;Action::onGeometryDevExportSliverElements));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DEV_EXPORT_INTERSECTED_ELEMENTS, ACTION_GROUP_GEOMETRY, "Export intersected elements", "", "", "", &amp;Action::onGeometryDevExportIntersectedElements));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DEV_PURGE_UNUSED_NODES, ACTION_GROUP_GEOMETRY, "Purge unused nodes", "", "", "", &amp;Action::onGeometryDevPurgeUnusedNodes));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DEV_PURGE_UNUSED_ELEMENTS, ACTION_GROUP_GEOMETRY, "Purge unused elements", "", "", "", &amp;Action::onGeometryDevPurgeUnusedElements));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DEV_REMOVE_DUPLICATE_NODES, ACTION_GROUP_GEOMETRY, "Remove duplicate nodes", "", "", "", &amp;Action::onGeometryDevRemoveDuplicateNodes));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DEV_REMOVE_DUPLICATE_ELEMENTS, ACTION_GROUP_GEOMETRY, "Remove duplicate elements", "", "", "", &amp;Action::onGeometryDevRemoveDuplicateElements));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DEV_POINT_INSIDE_SURFACE, ACTION_GROUP_GEOMETRY, "Check if point is inside surface", "", "", "", &amp;Action::onGeometryDevPointInsideSurface));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DEV_TETRAHEDRALIZE_SURFACE, ACTION_GROUP_GEOMETRY, "Tetrahedralize surface", "", "", "", &amp;Action::onGeometryDevTetrahedralizeeSurface));
    actionDesc.push_back(ActionDefinitionItem(ACTION_GEOMETRY_DEV_CONSOLIDATE, ACTION_GROUP_GEOMETRY, "Consolidate geometry", "", "", "", &amp;Action::onGeometryDevConsolidate));
    actionDesc.push_back(ActionDefinitionItem(ACTION_PROBLEM_TASK_FLOW, ACTION_GROUP_PROBLEM, "Problem(s) task flow", "", "Ctrl+P", ":/icons/problem/pixmaps/range-problem_task_flow.svg", &amp;Action::onProblemTaskFlow));
    actionDesc.push_back(ActionDefinitionItem(ACTION_PROBLEM_SOLVER_SETUP, ACTION_GROUP_PROBLEM, "Setup Problem(s) matrix solver", "", "", ":/icons/problem/pixmaps/range-problem_matrix_solver.svg", &amp;Action::onProblemSolverSetup));
    actionDesc.push_back(ActionDefinitionItem(ACTION_PROBLEM_DEFINE_MONITORING_POINTS, ACTION_GROUP_PROBLEM, "Define monitoring points", "", "", ":/icons/problem/pixmaps/range-problem_monitoring_points.svg", &amp;Action::onProblemDefineMonitoringPoints));
    actionDesc.push_back(ActionDefinitionItem(ACTION_PROBLEM_RESET, ACTION_GROUP_PROBLEM, "Reset setup", "", "", ":/icons/problem/pixmaps/range-problem_reset.svg", &amp;Action::onProblemReset));
    actionDesc.push_back(ActionDefinitionItem(ACTION_SOLVER_START, ACTION_GROUP_SOLVER, "Start solver", "", "Ctrl+R", ":/icons/solver/pixmaps/range-solver-start.svg", &amp;Action::onSolverStart));
    actionDesc.push_back(ActionDefinitionItem(ACTION_SOLVER_STOP, ACTION_GROUP_SOLVER, "Stop solver", "", "Ctrl+E", ":/icons/solver/pixmaps/range-solver-stop.svg", &amp;Action::onSolverStop));
    actionDesc.push_back(ActionDefinitionItem(ACTION_SOLVER_KILL, ACTION_GROUP_SOLVER, "Kill solver", "", "Ctrl+K", ":/icons/solver/pixmaps/range-solver-kill.svg", &amp;Action::onSolverKill));
    actionDesc.push_back(ActionDefinitionItem(ACTION_REPORT_MODEL_STATISTICS, ACTION_GROUP_REPORT, "Model statistics", "", "", ":/icons/report/pixmaps/range-report_model_statistics.svg", &amp;Action::onReportModelStatistics));
    actionDesc.push_back(ActionDefinitionItem(ACTION_REPORT_SOLVER_LOG, ACTION_GROUP_REPORT, "Solver log file", "", "", ":/icons/report/pixmaps/range-report_solver_log.svg", &amp;Action::onReportSolverLog));
    actionDesc.push_back(ActionDefinitionItem(ACTION_REPORT_CONVERGENCE_GRAPH, ACTION_GROUP_REPORT, "Solver convergence", "", "Ctrl+Alt+C", ":/icons/report/pixmaps/range-report-convergence.svg", &amp;Action::onReportConvergenceGraph));
    actionDesc.push_back(ActionDefinitionItem(ACTION_REPORT_MONITORING_POINT_GRAPH, ACTION_GROUP_REPORT, "Monitoring points", "", "", ":/icons/report/pixmaps/range-report_monitoring_point.svg", &amp;Action::onReportMonitoringPointGraph));
    actionDesc.push_back(ActionDefinitionItem(ACTION_REPORT_CREATE_REPORT, ACTION_GROUP_REPORT, "Create report", "", "Ctrl+Shift+R", ":/icons/report/pixmaps/range-report.svg", &amp;Action::onReportCreateReport));
    actionDesc.push_back(ActionDefinitionItem(ACTION_APPLICATION_SETTINGS, ACTION_GROUP_APPLICATION, "Application settings", "", "Ctrl+A", ":/icons/application/pixmaps/range-application_settings.svg", &amp;Action::onApplicationSettings));
    actionDesc.push_back(ActionDefinitionItem(ACTION_APPLICATION_UPDATE, ACTION_GROUP_APPLICATION, "Check for update", "", "", ":/icons/file/pixmaps/range-download.svg", &amp;Action::onUpdate));
    actionDesc.push_back(ActionDefinitionItem(ACTION_APPLICATION_ABOUT, ACTION_GROUP_APPLICATION, "About", "", "F1", ":/icons/logos/pixmaps/range-logo-128.png", &amp;Action::onAbout));
    actionDesc.push_back(ActionDefinitionItem(ACTION_APPLICATION_ABOUT_QT, ACTION_GROUP_APPLICATION, "About Qt", "", "", ":/icons/file/pixmaps/range-qt.svg", &amp;Action::onAboutQt));
    actionDesc.push_back(ActionDefinitionItem(ACTION_APPLICATION_LICENSE, ACTION_GROUP_APPLICATION, "License", "", "", ":/icons/logos/pixmaps/range-logo-128.png", &amp;Action::onLicense));
    actionDesc.push_back(ActionDefinitionItem(ACTION_APPLICATION_RELEASE_NOTES, ACTION_GROUP_APPLICATION, "Release notes", "", "", ":/icons/logos/pixmaps/range-logo-128.png", &amp;Action::onReleaseNotes));
    actionDesc.push_back(ActionDefinitionItem(ACTION_APPLICATION_HELP, ACTION_GROUP_APPLICATION, "Help", "", "Ctrl+H", ":/icons/file/pixmaps/range-help.svg", &amp;Action::onHelp));
    actionDesc.push_back(ActionDefinitionItem(ACTION_APPLICATION_QUIT, ACTION_GROUP_APPLICATION, "Quit", "", "Q", ":/icons/file/pixmaps/range-shutdown.svg", &amp;Action::onQuit));
    actionDesc.push_back(ActionDefinitionItem(ACTION_SEPARATOR, ACTION_GROUP_NONE, "", "", "", "", nullptr));
}
</t>
<t tx="leo.20201108101517.122">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   action_definition_item.cpp                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   10-th September 2014                                     *
 *                                                                   *
 *  DESCRIPTION: Action definition item class definition             *
 *********************************************************************/

#include &lt;QObject&gt;

#include "action_definition_item.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101517.123">void ActionDefinitionItem::_init(const ActionDefinitionItem *pActionDefinitionItem)
{
    if (pActionDefinitionItem)
    {
        this-&gt;type = pActionDefinitionItem-&gt;type;
        this-&gt;groupType = pActionDefinitionItem-&gt;groupType;
        this-&gt;text = pActionDefinitionItem-&gt;text;
        this-&gt;desc = pActionDefinitionItem-&gt;desc;
        this-&gt;shortCut = pActionDefinitionItem-&gt;shortCut;
        this-&gt;icon = pActionDefinitionItem-&gt;icon;
        this-&gt;slot = pActionDefinitionItem-&gt;slot;
    }
}

ActionDefinitionItem::ActionDefinitionItem(ActionType type, ActionGroupType groupType, const QString &amp;text, const QString &amp;desc, const QString &amp;shortCut, const QString &amp;icon, PointerToMemberFunction slot)
    : type(type)
    , groupType(groupType)
    , text(text)
    , desc(desc)
    , shortCut(shortCut)
    , icon(icon)
    , slot(slot)
{
    this-&gt;_init();
}

ActionDefinitionItem::ActionDefinitionItem(const ActionDefinitionItem &amp;actionDefinitionItem)
{
    this-&gt;_init(&amp;actionDefinitionItem);
}

ActionDefinitionItem::~ActionDefinitionItem()
{

}

ActionDefinitionItem &amp;ActionDefinitionItem::operator =(const ActionDefinitionItem &amp;actionDefinitionItem)
{
    this-&gt;_init(&amp;actionDefinitionItem);
    return (*this);
}

ActionType ActionDefinitionItem::getType() const
{
    return this-&gt;type;
}

ActionGroupType ActionDefinitionItem::getGroupType() const
{
    return this-&gt;groupType;
}

</t>
<t tx="leo.20201108101517.124">const QString &amp;ActionDefinitionItem::getShortcut() const
{
    return this-&gt;shortCut;
}

QString ActionDefinitionItem::getGroupName(ActionGroupType groupType)
{
    switch (groupType)
    {
        case ACTION_GROUP_SESSION:
            return QObject::tr("Session");
        case ACTION_GROUP_MODEL:
            return QObject::tr("Model");
        case ACTION_GROUP_MATERIAL:
            return QObject::tr("Material");
        case ACTION_GROUP_GEOMETRY:
            return QObject::tr("Geometry");
        case ACTION_GROUP_PROBLEM:
            return QObject::tr("Problem");
        case ACTION_GROUP_SOLVER:
            return QObject::tr("Solver");
        case ACTION_GROUP_REPORT:
            return QObject::tr("Report");
        case ACTION_GROUP_APPLICATION:
            return QObject::tr("Application");
        default:
            return QString();
    }
}

QList&lt;ActionGroupType&gt; ActionDefinitionItem::getGroupTypes(ActionGroupTypeMask groupTypeMask)
{
    QList&lt;ActionGroupType&gt; groupTypes;

    if (groupTypeMask &amp; ACTION_GROUP_SESSION)     groupTypes.append(ACTION_GROUP_SESSION);
    if (groupTypeMask &amp; ACTION_GROUP_MODEL)       groupTypes.append(ACTION_GROUP_MODEL);
    if (groupTypeMask &amp; ACTION_GROUP_MATERIAL)    groupTypes.append(ACTION_GROUP_MATERIAL);
    if (groupTypeMask &amp; ACTION_GROUP_GEOMETRY)    groupTypes.append(ACTION_GROUP_GEOMETRY);
    if (groupTypeMask &amp; ACTION_GROUP_PROBLEM)     groupTypes.append(ACTION_GROUP_PROBLEM);
    if (groupTypeMask &amp; ACTION_GROUP_SOLVER)      groupTypes.append(ACTION_GROUP_SOLVER);
    if (groupTypeMask &amp; ACTION_GROUP_REPORT)      groupTypes.append(ACTION_GROUP_REPORT);
    if (groupTypeMask &amp; ACTION_GROUP_APPLICATION) groupTypes.append(ACTION_GROUP_APPLICATION);

    return groupTypes;
}
</t>
<t tx="leo.20201108101517.125">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   action_list.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   16-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Action list class definition                        *
 *********************************************************************/

#include &lt;QKeySequence&gt;

#include "action_list.h"
#include "main_window.h"
#include "session.h"
#include "solver_manager.h"
#include "material_list.h"
#include "mark_entity_dialog.h"
#include "merge_entity_dialog.h"

ActionList::ActionList(QObject *parent) : QObject(parent)
{
    this-&gt;actions.resize(ACTION_N_TYPES);

    for (uint i=0;i&lt;ACTION_N_TYPES;i++)
    {
        if (ActionType(i) != ACTION_SEPARATOR)
        {
            this-&gt;actions[i] = new Action(ActionType(i),(MainWindow*)this-&gt;parent(),this);
        }
    }

    this-&gt;processAvailability();
}

uint ActionList::getNActions(void) const
{
    return this-&gt;actions.size();
}

Action * ActionList::getAction (ActionType type)
{
    if (type == ACTION_SEPARATOR)
    {
        return new Action(ACTION_SEPARATOR,(MainWindow*)this-&gt;parent(),this);
    }
    else
    {
        return this-&gt;actions[type];
    }
}

Action * ActionList::getAction (const QString &amp;name)
{
    for (QVector&lt;Action*&gt;::size_type i = 0; i != this-&gt;actions.size(); i++)
    {
        if (this-&gt;actions[i] == 0)
        {
            continue;
        }
        if (this-&gt;actions[i]-&gt;objectName() == name)
        {
            return this-&gt;getAction(ActionType(i));
        }
    }
    return 0;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101517.126">void ActionList::processAvailability(void)
{
    this-&gt;setDisabled(false);

    this-&gt;getAction(ACTION_GEOMETRY_UNDO)-&gt;setDisabled(!Session::getInstance().isUndoAvailable());
    this-&gt;getAction(ACTION_GEOMETRY_UNDO)-&gt;setToolTip(Session::getInstance().getUndoTooltip());
    this-&gt;getAction(ACTION_GEOMETRY_REDO)-&gt;setDisabled(!Session::getInstance().isRedoAvailable());
    this-&gt;getAction(ACTION_GEOMETRY_REDO)-&gt;setToolTip(Session::getInstance().getRedoTooltip());

    this-&gt;getAction(ACTION_SESSION_NEW)-&gt;setEnabled(true);
    this-&gt;getAction(ACTION_SESSION_OPEN)-&gt;setEnabled(true);
    this-&gt;getAction(ACTION_SESSION_SAVE)-&gt;setEnabled(true);
    this-&gt;getAction(ACTION_SESSION_SAVE_AS)-&gt;setEnabled(true);
    this-&gt;getAction(ACTION_SESSION_CLOSE)-&gt;setEnabled(true);
    this-&gt;getAction(ACTION_MODEL_NEW)-&gt;setEnabled(true);
    this-&gt;getAction(ACTION_MODEL_OPEN)-&gt;setEnabled(true);

    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();
    if (!selectedModelIDs.empty())
    {
        this-&gt;getAction(ACTION_MODEL_SAVE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_MODEL_SAVE_AS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_MODEL_EXPORT_MSH)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_MODEL_EXPORT_RAW)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_MODEL_EXPORT_STL_ASCII)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_MODEL_EXPORT_STL_BINARY)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_MODEL_CLOSE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_MODEL_RELOAD_RESULTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_MODEL_DROP_RESULTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_MODEL_RENAME)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_POINT)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_LINE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_TRIANGLE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_QUADRILATERAL)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_CIRCLE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_ELLIPSE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_TETRAHEDRON)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_HEXAHEDRON)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_CYLINDER)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_SPHERE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DRAW_RAW)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_CREATE_ELEMENT)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_FIND_SLIVER_ELEMENTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_FIX_SLIVER_ELEMENTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_FIND_INTERSECTED_ELEMENTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_BREAK_INTERSECTED_ELEMENTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_BOOL_UNION)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_BOOL_DIFFERENCE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_BOOL_INTERSECTION)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_MERGE_NEAR_NODES)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_MOVE_NODE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_REMOVE_NODE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_REMOVE_NODE_AND_CLOSE_HOLE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_REMOVE_ELEMENT)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_LINE_GENERATE_FROM_EDGES)-&gt;setEnabled(Session::selectedModelsHasEntities(R_ENTITY_GROUP_SURFACE));
        this-&gt;getAction(ACTION_GEOMETRY_SURFACE_MARK)-&gt;setEnabled(Session::selectedModelsHasEntities(R_ENTITY_GROUP_SURFACE));
        this-&gt;getAction(ACTION_GEOMETRY_SURFACE_SWAP_ELEMENT_NORMAL)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_SURFACE_SWAP_NORMALS)-&gt;setEnabled(Session::selectedModelsHasEntities(R_ENTITY_GROUP_SURFACE));
        this-&gt;getAction(ACTION_GEOMETRY_SURFACE_SYNC_NORMALS)-&gt;setEnabled(Session::selectedModelsHasEntities(R_ENTITY_GROUP_SURFACE));
        this-&gt;getAction(ACTION_GEOMETRY_SURFACE_CLOSE_HOLE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_SURFACE_COARSEN)-&gt;setEnabled(Session::selectedModelsHasEntities(R_ENTITY_GROUP_SURFACE));
        this-&gt;getAction(ACTION_GEOMETRY_VECTOR_FIELD_CREATE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_VECTOR_FIELD_EDIT)-&gt;setEnabled(Session::selectedModelsHasEntitySelected(R_ENTITY_GROUP_VECTOR_FIELD));
        this-&gt;getAction(ACTION_GEOMETRY_SCALAR_FIELD_CREATE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_SCALAR_FIELD_EDIT)-&gt;setEnabled(Session::selectedModelsHasEntitySelected(R_ENTITY_GROUP_SCALAR_FIELD));
        this-&gt;getAction(ACTION_GEOMETRY_STREAM_LINE_CREATE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_STREAM_LINE_EDIT)-&gt;setEnabled(Session::selectedModelsHasEntitySelected(R_ENTITY_GROUP_STREAM_LINE));
        this-&gt;getAction(ACTION_GEOMETRY_CUT_CREATE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_CUT_EDIT)-&gt;setEnabled(Session::selectedModelsHasEntitySelected(R_ENTITY_GROUP_CUT));
        this-&gt;getAction(ACTION_GEOMETRY_ISO_CREATE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_ISO_EDIT)-&gt;setEnabled(Session::selectedModelsHasEntitySelected(R_ENTITY_GROUP_ISO));
        this-&gt;getAction(ACTION_GEOMETRY_ENTITY_MERGE)-&gt;setEnabled(MergeEntityDialog::entitiesSelected());
        this-&gt;getAction(ACTION_GEOMETRY_ENTITY_REMOVE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_TRANSFORM)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_VOLUME_GENERATE_TETRAHEDRA)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DEV_EXPORT_SLIVER_ELEMENTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DEV_EXPORT_INTERSECTED_ELEMENTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DEV_PURGE_UNUSED_NODES)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DEV_PURGE_UNUSED_ELEMENTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DEV_REMOVE_DUPLICATE_NODES)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DEV_REMOVE_DUPLICATE_ELEMENTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DEV_POINT_INSIDE_SURFACE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DEV_TETRAHEDRALIZE_SURFACE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_GEOMETRY_DEV_CONSOLIDATE)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_PROBLEM_TASK_FLOW)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_PROBLEM_SOLVER_SETUP)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_PROBLEM_DEFINE_MONITORING_POINTS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_PROBLEM_RESET)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_SOLVER_START)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_REPORT_MODEL_STATISTICS)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_REPORT_SOLVER_LOG)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_REPORT_CONVERGENCE_GRAPH)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_REPORT_MONITORING_POINT_GRAPH)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_REPORT_CREATE_REPORT)-&gt;setEnabled(true);
    }

    if (MaterialList::getInstance().getSelectedMaterialName().length() &gt; 0)
    {
        this-&gt;getAction(ACTION_MATERIAL_DELETE)-&gt;setEnabled(true);
    }

    if (SolverManager::getInstance().getNRunning() &gt; 0)
    {
        this-&gt;getAction(ACTION_SOLVER_STOP)-&gt;setEnabled(true);
        this-&gt;getAction(ACTION_SOLVER_KILL)-&gt;setEnabled(true);
    }
}

</t>
<t tx="leo.20201108101517.127">void ActionList::enable(void)
{
    this-&gt;processAvailability();
}

</t>
<t tx="leo.20201108101517.128">void ActionList::disable(void)
{
    this-&gt;setDisabled(true);
}

</t>
<t tx="leo.20201108101517.129">void ActionList::setDisabled(bool allActions)
{
    bool enabled = false;

    if (allActions)
    {
        this-&gt;getAction(ACTION_SESSION_NEW)-&gt;setEnabled(enabled);
        this-&gt;getAction(ACTION_SESSION_OPEN)-&gt;setEnabled(enabled);
        this-&gt;getAction(ACTION_SESSION_SAVE)-&gt;setEnabled(enabled);
        this-&gt;getAction(ACTION_SESSION_SAVE_AS)-&gt;setEnabled(enabled);
        this-&gt;getAction(ACTION_SESSION_CLOSE)-&gt;setEnabled(enabled);
        this-&gt;getAction(ACTION_MODEL_NEW)-&gt;setEnabled(enabled);
        this-&gt;getAction(ACTION_MODEL_OPEN)-&gt;setEnabled(enabled);
    }
    this-&gt;getAction(ACTION_MODEL_SAVE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_MODEL_SAVE_AS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_MODEL_EXPORT_MSH)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_MODEL_EXPORT_RAW)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_MODEL_EXPORT_STL_ASCII)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_MODEL_EXPORT_STL_BINARY)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_MODEL_CLOSE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_MODEL_RELOAD_RESULTS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_MODEL_DROP_RESULTS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_MODEL_RENAME)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_UNDO)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_REDO)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_POINT)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_LINE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_TRIANGLE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_QUADRILATERAL)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_CIRCLE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_ELLIPSE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_TETRAHEDRON)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_HEXAHEDRON)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_CYLINDER)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_SPHERE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DRAW_RAW)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_CREATE_ELEMENT)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_FIND_SLIVER_ELEMENTS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_FIX_SLIVER_ELEMENTS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_FIND_INTERSECTED_ELEMENTS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_BREAK_INTERSECTED_ELEMENTS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_BOOL_UNION)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_BOOL_DIFFERENCE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_BOOL_INTERSECTION)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_MERGE_NEAR_NODES)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_MOVE_NODE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_REMOVE_NODE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_REMOVE_NODE_AND_CLOSE_HOLE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_REMOVE_ELEMENT)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_LINE_GENERATE_FROM_EDGES)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_SURFACE_MARK)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_SURFACE_SWAP_ELEMENT_NORMAL)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_SURFACE_SWAP_NORMALS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_SURFACE_SYNC_NORMALS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_SURFACE_CLOSE_HOLE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_SURFACE_COARSEN)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_VECTOR_FIELD_CREATE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_VECTOR_FIELD_EDIT)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_SCALAR_FIELD_CREATE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_SCALAR_FIELD_EDIT)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_STREAM_LINE_CREATE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_STREAM_LINE_EDIT)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_CUT_CREATE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_CUT_EDIT)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_ISO_CREATE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_ISO_EDIT)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_ENTITY_MERGE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_ENTITY_REMOVE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_TRANSFORM)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_VOLUME_GENERATE_TETRAHEDRA)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DEV_EXPORT_SLIVER_ELEMENTS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DEV_EXPORT_INTERSECTED_ELEMENTS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DEV_PURGE_UNUSED_NODES)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DEV_PURGE_UNUSED_ELEMENTS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DEV_POINT_INSIDE_SURFACE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DEV_TETRAHEDRALIZE_SURFACE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_GEOMETRY_DEV_CONSOLIDATE)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_PROBLEM_TASK_FLOW)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_PROBLEM_SOLVER_SETUP)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_PROBLEM_DEFINE_MONITORING_POINTS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_PROBLEM_RESET)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_SOLVER_START)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_SOLVER_STOP)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_SOLVER_KILL)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_REPORT_MODEL_STATISTICS)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_REPORT_SOLVER_LOG)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_REPORT_CONVERGENCE_GRAPH)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_REPORT_MONITORING_POINT_GRAPH)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_REPORT_CREATE_REPORT)-&gt;setEnabled(enabled);
    this-&gt;getAction(ACTION_MATERIAL_DELETE)-&gt;setEnabled(enabled);
}

</t>
<t tx="leo.20201108101517.13">void Action::disable()
{
    this-&gt;setDisabled(true);
}

</t>
<t tx="leo.20201108101517.130">void ActionList::changeShortcut(ActionType actionType, const QString &amp;shortcut)
{
    this-&gt;getAction(actionType)-&gt;setShortcut(QKeySequence(shortcut));
}
</t>
<t tx="leo.20201108101517.131">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   application.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-th June 2013                                          *
 *                                                                   *
 *  DESCRIPTION: Application class definition                        *
 *********************************************************************/

#include &lt;QTimer&gt;
#include &lt;QStyleFactory&gt;
#include &lt;QStyle&gt;
#include &lt;QPalette&gt;
#include &lt;QNetworkProxy&gt;
#include &lt;QMessageBox&gt;
#include &lt;QGuiApplication&gt;

#include &lt;rmlib.h&gt;

#include "application.h"
#include "crash_report_dialog.h"
#include "locker.h"
#include "logger.h"
#include "progress.h"
#include "main_settings.h"
#include "main_window.h"
#include "material_list.h"
#include "session.h"
#include "file_updater.h"
#include "material_updater.h"
#include "job_manager.h"
#include "rra_session.h"
#include "update_dialog.h"
#include "solver_manager.h"

Application::Application(int &amp;argc, char **argv) :
    QApplication(argc,argv)
{
    // Needed for printf functions family to work correctly.
    setlocale(LC_ALL,"C");

    MaterialList::initialize();
    Locker::initialize();
    Logger::initialize();
    Progress::initialize();

    MainSettings::getInstance().setDirApplicationPath(this-&gt;applicationDirPath());

    this-&gt;setStyleSheet(QLatin1String("QDialogButtonBox {"
                                      "  button-layout: 0;"
                                      "  dialogbuttonbox-buttons-have-icons: 1;"
                                      "}"));

    QObject::connect(this,&amp;Application::started,this,&amp;Application::onStarted);

    QTimer::singleShot(0, this, SIGNAL(started()));
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101517.132">void Application::applyStyle(const QString &amp;styleName)
{
    if (styleName == ApplicationSettings::FusionRange)
    {
        QStyle *style = QStyleFactory::create("Fusion");
        QPalette palette(style-&gt;standardPalette());

        palette.setColor(QPalette::Highlight, QColor(150,0,0));

        QApplication::setPalette(palette);
        QApplication::setStyle(style);
    }
    else if (styleName == ApplicationSettings::FusionDark)
    {
        QStyle *style = QStyleFactory::create("Fusion");
        QPalette palette(style-&gt;standardPalette());

        palette.setColor(QPalette::Window, QColor(61,67,69));
        palette.setColor(QPalette::WindowText, QColor(238,251,247));
        palette.setColor(QPalette::Base, QColor(35,39,41));
        palette.setColor(QPalette::AlternateBase, QColor(50,56,59));
        palette.setColor(QPalette::ToolTipBase, Qt::black);
        palette.setColor(QPalette::ToolTipText, QColor(238,251,247));
        palette.setColor(QPalette::Text, QColor(238,251,247));
        palette.setColor(QPalette::Button, QColor(35,39,41));
        palette.setColor(QPalette::ButtonText, QColor(238,251,247));
        palette.setColor(QPalette::BrightText, Qt::white);

        palette.setColor(QPalette::Light, QColor(73,73,73));
        palette.setColor(QPalette::Midlight, QColor(63,63,63));
        palette.setColor(QPalette::Dark, QColor(33,33,33));
        palette.setColor(QPalette::Mid, QColor(43,43,43));
        palette.setColor(QPalette::Shadow, QColor(0,0,0));

        palette.setColor(QPalette::Highlight, Qt::black);
        palette.setColor(QPalette::HighlightedText, QColor(238,251,247));


        palette.setColor(QPalette::Link, Qt::lightGray);
        palette.setColor(QPalette::LinkVisited, Qt::gray);

        palette.setColor(QPalette::Disabled, QPalette::Text, Qt::darkGray);
        palette.setColor(QPalette::Disabled, QPalette::ButtonText, Qt::darkGray);

        QApplication::setPalette(palette);
        QApplication::setStyle(style);
    }
    else if (styleName == ApplicationSettings::WindowsDark)
    {
        QStyle *style = QStyleFactory::create("Windows");
        QPalette palette(style-&gt;standardPalette());

        palette.setColor(QPalette::Window, QColor(51,57,59));
        palette.setColor(QPalette::WindowText, QColor(238,251,247));
        palette.setColor(QPalette::Base, QColor(35,39,41));
        palette.setColor(QPalette::AlternateBase, QColor(50,56,59));
        palette.setColor(QPalette::ToolTipBase, Qt::black);
        palette.setColor(QPalette::ToolTipText, QColor(238,251,247));
        palette.setColor(QPalette::Text, QColor(238,251,247));
        palette.setColor(QPalette::Button, QColor(35,39,41));
        palette.setColor(QPalette::ButtonText, QColor(238,251,247));
        palette.setColor(QPalette::BrightText, Qt::white);

        palette.setColor(QPalette::Light, QColor(73,73,73));
        palette.setColor(QPalette::Midlight, QColor(63,63,63));
        palette.setColor(QPalette::Dark, QColor(33,33,33));
        palette.setColor(QPalette::Mid, QColor(43,43,43));
        palette.setColor(QPalette::Shadow, QColor(0,0,0));

        palette.setColor(QPalette::Highlight, Qt::black);
        palette.setColor(QPalette::HighlightedText, QColor(238,251,247));

        palette.setColor(QPalette::Link, Qt::lightGray);
        palette.setColor(QPalette::LinkVisited, Qt::gray);

        palette.setColor(QPalette::Disabled, QPalette::Text, Qt::darkGray);
        palette.setColor(QPalette::Disabled, QPalette::ButtonText, Qt::darkGray);

        QApplication::setPalette(palette);
        QApplication::setStyle(style);
    }
    else
    {
        QStyle *style = QStyleFactory::create(styleName);
        QPalette palette(style-&gt;standardPalette());

        QApplication::setPalette(palette);
        QApplication::setStyle(style);
    }
}

</t>
<t tx="leo.20201108101517.133">void Application::onStarted(void)
{
    QStringList filesToLoad;

    // Process command line arguments.
    try
    {
        QList&lt;RArgumentOption&gt; validOptions;
        validOptions.append(RArgumentOption("log-debug",RArgumentOption::Switch,QVariant(),"Switch on debug log level",false,false));
        validOptions.append(RArgumentOption("log-trace",RArgumentOption::Switch,QVariant(),"Switch on trace log level",false,false));

        RArgumentsParser argumentsParser(Application::arguments(),validOptions,true);

        if (argumentsParser.isSet("help"))
        {
            argumentsParser.printHelp();
            this-&gt;exit(0);
            return;
        }

        if (argumentsParser.isSet("version"))
        {
            argumentsParser.printVersion();
            this-&gt;exit(0);
            return;
        }

        if (argumentsParser.isSet("log-debug"))
        {
            RLogger::getInstance().setLevel(R_LOG_LEVEL_DEBUG);
        }
        if (argumentsParser.isSet("log-trace"))
        {
            RLogger::getInstance().setLevel(R_LOG_LEVEL_TRACE);
        }

        filesToLoad = argumentsParser.getFiles();
    }
    catch (const RError &amp;rError)
    {
        RLogger::error("Failed to parse command line options. %s\n",rError.getMessage().toUtf8().constData());
        this-&gt;exit(1);
        return;
    }

    // Connect to aboutToQuit signal
    QObject::connect(this,&amp;Application::aboutToQuit,this,&amp;Application::onAboutToQuit);
    // Connect to style change signal
    QObject::connect(MainSettings::getInstance().getApplicationSettings(),&amp;ApplicationSettings::styleChanged,this,&amp;Application::onStyleChanged);

    // Rotate log file.
    QString rotatedLogFile = MainSettings::getInstance().getLogFileName() + "-" + QDateTime::currentDateTime().toString("yyMMdd_HHmmss");
    if (QFile::exists(MainSettings::getInstance().getLogFileName()))
    {
        if (!QFile::rename(MainSettings::getInstance().getLogFileName(),rotatedLogFile))
        {
            RLogger::error("Failed to rename the log file \'%s\' to \'%s\'\n",
                           MainSettings::getInstance().getLogFileName().toUtf8().constData(),
                           rotatedLogFile.toUtf8().constData());
        }
    }

    // Initialize lock file.
    qint64 lockPid;
    QString lockHostname;
    QString lockAppname;

    this-&gt;pLockFile = new QLockFile(MainSettings::getInstance().getTmpDir() + QDir::separator() + "range.lck");

    bool previousLockStillValid = this-&gt;pLockFile-&gt;getLockInfo(&amp;lockPid,&amp;lockHostname,&amp;lockAppname);

    this-&gt;pLockFile-&gt;setStaleLockTime(0);
    if (!this-&gt;pLockFile-&gt;tryLock(0))
    {
        QString lockMessage = "Failed to start.\nApplication " + lockAppname + " @ " + lockHostname + " (PID = " + QString::number(lockPid) + ") seems to be already running.\n";
        QMessageBox::warning(nullptr,tr("Application is already running"), lockMessage);

        this-&gt;exit(1);
        return;
    }

    // Prepare main window
    MainWindow::getInstance()-&gt;show();

    // Set log file
    RLogger::getInstance().setFile(MainSettings::getInstance().getLogFileName());

    Logger::getInstance().unhalt();

    // Set use system proxy settings
    QNetworkProxyFactory::setUseSystemConfiguration(true);

    // Print basic information
    RLogger::info("System information\n");
    RLogger::indent();
    RLogger::info("Build ABI: %s\n",QSysInfo::buildAbi().toUtf8().constData());
    RLogger::info("Build Cpu Architecture: %s\n",QSysInfo::buildCpuArchitecture().toUtf8().constData());
    RLogger::info("Current Cpu Architecture: %s\n",QSysInfo::currentCpuArchitecture().toUtf8().constData());
    RLogger::info("Kernel Type: %s\n",QSysInfo::kernelType().toUtf8().constData());
    RLogger::info("Kernel Version: %s\n",QSysInfo::kernelVersion().toUtf8().constData());
    RLogger::info("Machine HostName: %s\n",QSysInfo::machineHostName().toUtf8().constData());
    RLogger::info("Product Name: %s\n",QSysInfo::prettyProductName().toUtf8().constData());
    RLogger::info("Product Type: %s\n",QSysInfo::productType().toUtf8().constData());
    RLogger::info("Product Version: %s\n",QSysInfo::productVersion().toUtf8().constData());
    RLogger::unindent(false);
    RLogger::info("Machine precision (float):  %14g\n", double(RConstants::findMachineFloatEpsilon()));
    RLogger::info("Machine precision (double): %14g\n", RConstants::findMachineDoubleEpsilon());
    RLogger::info("Data directory: \'%s\'\n",MainSettings::getInstancePtr()-&gt;getDataDir().toUtf8().constData());
    RLogger::info("Document directory: \'%s\'\n",MainSettings::getInstancePtr()-&gt;getDocDir().toUtf8().constData());
    RLogger::info("Log directory: \'%s\'\n",MainSettings::getInstancePtr()-&gt;getLogDir().toUtf8().constData());
    RLogger::info("Temporary directory: \'%s\'\n",MainSettings::getInstancePtr()-&gt;getTmpDir().toUtf8().constData());
    RLogger::info("Material directory: \'%s\'\n",MainSettings::getInstancePtr()-&gt;getMaterialsDir().toUtf8().constData());
    RLogger::info("Session directory: \'%s\'\n",MainSettings::getInstancePtr()-&gt;getSessionDir().toUtf8().constData());
    RLogger::info("Solver path: \'%s\'\n",MainSettings::getInstancePtr()-&gt;getApplicationSettings()-&gt;getSolverPath().toUtf8().constData());

    // Read material database
    MaterialList::getInstance().setStorePath(MainSettings::getInstance().getMaterialsDir() + QDir::separator());

    // Check current version.
    RLogger::info("Checking current against last used software version.\n");
    RLogger::indent();
    RLogger::info("Last used version: %s\n",MainSettings::getInstance().getStoredVersion().toString().toUtf8().constData());
    RLogger::info("Currently used version: %s\n",RVendor::version.toString().toUtf8().constData());
    RLogger::unindent();

    if (RVendor::version &gt; MainSettings::getInstance().getStoredVersion())
    {
        // Newer version is being executed.

        // Perform material database update.
        RLogger::info("Preparing material database update.\n");
        RLogger::indent();

        MaterialUpdater *pMaterialUpdater = new MaterialUpdater;

        QDir matSrcDir(QDir::cleanPath(QDir(this-&gt;applicationDirPath()).filePath("../materials")));

        RLogger::info("Source directory: \'%s\'\n",matSrcDir.absolutePath().toUtf8().constData());

        if (matSrcDir.exists())
        {
            QStringList files = matSrcDir.entryList(QDir::Files | QDir::NoDotAndDotDot | QDir::Readable, QDir::Name);
            foreach (QString file, files)
            {
                RLogger::info("Adding material: \'%s\'\n",matSrcDir.filePath(file).toUtf8().constData());
                pMaterialUpdater-&gt;addMaterial(matSrcDir.filePath(file));
            }
        }
        RLogger::unindent();

        // Perform data files update.
        RLogger::info("Preparing data files update.\n");
        RLogger::indent();

        FileUpdater *pFileUpdater = new FileUpdater;

        QDir dataSrcDir(QDir::cleanPath(QDir(this-&gt;applicationDirPath()).filePath("../data")));
        QDir dataDstDir(MainSettings::getInstance().getDataDir());

        RLogger::info("Source directory: \'%s\'\n",dataSrcDir.absolutePath().toUtf8().constData());
        RLogger::info("Destination directory: \'%s\'\n",dataDstDir.absolutePath().toUtf8().constData());

        if (dataSrcDir.exists())
        {
            QStringList files = dataSrcDir.entryList(QDir::Files | QDir::NoDotAndDotDot | QDir::Readable, QDir::Name);
            foreach (QString file, files)
            {
                RLogger::info("Adding file: \'%s\' -&gt; \'%s\'\n",dataSrcDir.filePath(file).toUtf8().constData(),dataDstDir.filePath(file).toUtf8().constData());
                pFileUpdater-&gt;addFile(dataSrcDir.filePath(file),dataDstDir.filePath(file));
            }
        }
        RLogger::unindent();

        JobManager::getInstance().submit(pMaterialUpdater);
        JobManager::getInstance().submit(pFileUpdater);
    }

    // Start RRA Session
    RRASession::getInstance().start();

    QObject::connect(&amp;RRASession::getInstance(),&amp;RRASession::availableSoftware,this,&amp;Application::onAvailableSoftware);
    QObject::connect(&amp;RRASession::getInstance(),&amp;RRASession::signedIn,this,&amp;Application::onSignedIn);
    QObject::connect(&amp;RRASession::getInstance(),&amp;RRASession::signedOut,this,&amp;Application::onSignedOut);

    if (!filesToLoad.isEmpty())
    {
        try
        {
            Session::getInstance().readModels(filesToLoad);
        }
        catch (const RError &amp;rError)
        {
            RLogger::warning("Failed to read model file(s). ERROR: %s\n",rError.getMessage().toUtf8().constData());
        }
    }
    else
    {
        QString sessionFileName = MainSettings::getInstance().getSessionFileName();
        if (!sessionFileName.isEmpty() &amp;&amp; RFileManager::fileExists(sessionFileName))
        {
            try
            {
                Session::getInstance().read(sessionFileName);
            }
            catch (const RError &amp;rError)
            {
                RLogger::warning("Failed to read the session file \'%s\'. ERROR: %s\n",sessionFileName.toUtf8().constData(),rError.getMessage().toUtf8().constData());
            }
        }
    }

    if (previousLockStillValid)
    {
        CrashReportDialog crashReportDialog(MainWindow::getInstance(),rotatedLogFile);
        crashReportDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.134">void Application::onAboutToQuit(void)
{
    QString sessionFileName = Session::getInstance().getFileName();
    if (sessionFileName.isEmpty())
    {
        sessionFileName = Session::getInstance().getDefaultFileName();
    }
    try
    {
        Session::getInstance().write(sessionFileName);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to write the session file \'%s\'. ERROR: %s\n",sessionFileName.toUtf8().constData(),error.getMessage().toUtf8().constData());
    }

    this-&gt;pLockFile-&gt;unlock();
    delete this-&gt;pLockFile;

    // Stop solver manager server.
    RLogger::info("Stoping solver task server\n");
    SolverManager::getInstance().stopServer();

    // Stop RRA Session
    RLogger::info("Stoping RRA Session\n");
    RRASession::getInstance().stop();

    // Stop logger
    RLogger::info("Stoping logger\n");
    Logger::halt();

    // Delete main window
    delete MainWindow::getInstance();
}

</t>
<t tx="leo.20201108101517.135">void Application::onStyleChanged(const QString &amp;styleName)
{
    this-&gt;applyStyle(styleName);
}

</t>
<t tx="leo.20201108101517.136">void Application::onAvailableSoftware(const RVersion &amp;version, const QString &amp;link)
{
    if (RVendor::version &lt; version)
    {
        UpdateDialog updateDialog(version,link,MainWindow::getInstance());
        updateDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.137">void Application::onSignedIn(void)
{

}

</t>
<t tx="leo.20201108101517.138">void Application::onSignedOut(void)
{

}
</t>
<t tx="leo.20201108101517.139">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   application_settings.cpp                                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th July 2013                                          *
 *                                                                   *
 *  DESCRIPTION: Application class class definition                  *
 *********************************************************************/

#include &lt;omp.h&gt;

#include &lt;QStyleFactory&gt;
#include &lt;QApplication&gt;
#include &lt;QDir&gt;

#include "application_settings.h"
#include "main_settings.h"

const QString ApplicationSettings::WindowsDark = "Windows-Dark";
const QString ApplicationSettings::FusionDark = "Fusion-Dark";
const QString ApplicationSettings::FusionRange = "Fusion-Range";
const QString ApplicationSettings::Fusion = "Fusion";

ApplicationSettings::ApplicationSettings(QObject *parent)
    : QObject(parent)
    , nThreads(ApplicationSettings::getDefaultNThreads())
    , nHistoryRecords(ApplicationSettings::getDefaultNHistoryRecords())
    , style(ApplicationSettings::getDefaultStyle())
    , toolbarIconSize(ApplicationSettings::getDefaultToolbarIconSize())
    , sendUsageInfo(ApplicationSettings::getDefaultSendUsageInfo())
    , rangeApiAllowed(ApplicationSettings::getDefaultRangeApiAllowed())
    , rangeApiServer(ApplicationSettings::getDefaultRangeApiServer())
    , rangeAccount(ApplicationSettings::getDefaultRangeAccount())
    , rangePassword(ApplicationSettings::getDefaultRangePassword())
{
    this-&gt;actionDefinition = new ActionDefinition(this);

    QObject::connect(this-&gt;actionDefinition,
                     &amp;ActionDefinition::shortcutChanged,
                     this,
                     &amp;ApplicationSettings::onShortcutChanged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101517.14">void Action::onSessionNew()
{
    @others
}

</t>
<t tx="leo.20201108101517.140">const ActionDefinition *ApplicationSettings::getActionDefinition() const
{
    return this-&gt;actionDefinition;
}

ActionDefinition *ApplicationSettings::getActionDefinition()
{
    return this-&gt;actionDefinition;
}

</t>
<t tx="leo.20201108101517.141">const QString &amp;ApplicationSettings::getSolverPath() const
{
    return this-&gt;solverPath;
}

</t>
<t tx="leo.20201108101517.142">void ApplicationSettings::setSolverPath(const QString &amp;rangeSolverPath)
{
    this-&gt;solverPath = rangeSolverPath;
}

</t>
<t tx="leo.20201108101517.143">const QString &amp;ApplicationSettings::getHelpDir() const
{
    return this-&gt;helpDir;
}

</t>
<t tx="leo.20201108101517.144">void ApplicationSettings::setHelpDir(const QString &amp;helpDir)
{
    this-&gt;helpDir = helpDir;
}

uint ApplicationSettings::getNThreads() const
{
    return this-&gt;nThreads;
}

</t>
<t tx="leo.20201108101517.145">void ApplicationSettings::setNThreads(uint nCPUs)
{
    uint defaultNCPUs = ApplicationSettings::getDefaultNThreads();
    this-&gt;nThreads = (nCPUs &lt; 1 || nCPUs &gt; defaultNCPUs) ? defaultNCPUs : nCPUs;
}

uint ApplicationSettings::getNHistoryRecords() const
{
    return this-&gt;nHistoryRecords;
}

</t>
<t tx="leo.20201108101517.146">void ApplicationSettings::setNHistoryRecords(uint nHistoryRecords)
{
    bool changed = false;
    nHistoryRecords = nHistoryRecords &gt; 0 ? nHistoryRecords : 1;
    if (this-&gt;nHistoryRecords != nHistoryRecords)
    {
        changed = true;
    }
    this-&gt;nHistoryRecords = nHistoryRecords;
    if (changed)
    {
        emit this-&gt;nHistoryRecordsChanged(this-&gt;nHistoryRecords);
    }
}

</t>
<t tx="leo.20201108101517.147">const QString &amp;ApplicationSettings::getStyle() const
{
    return this-&gt;style;
}

</t>
<t tx="leo.20201108101517.148">void ApplicationSettings::setStyle(const QString &amp;style)
{
    QStringList styles = ApplicationSettings::getStyles();
    if (styles.contains(style))
    {
        this-&gt;style = style;
    }
    else
    {
        this-&gt;style = ApplicationSettings::getDefaultStyle();
    }
    emit this-&gt;styleChanged(this-&gt;style);
}

</t>
<t tx="leo.20201108101517.149">int ApplicationSettings::getToolbarIconSize() const
{
    return this-&gt;toolbarIconSize;
}

</t>
<t tx="leo.20201108101517.15">int response = QMessageBox::question(this-&gt;mainWindow,
                                     tr("Close session"),
                                     tr("Are you sure you want to close current session?"),
                                     QMessageBox::Yes | QMessageBox::No,
                                     QMessageBox::No);
if (response == QMessageBox::Yes)
{
    Session::getInstance().clear();
    this-&gt;onSessionSaveAs();
}
</t>
<t tx="leo.20201108101517.150">void ApplicationSettings::setToolbarIconSize(int toolbarIconSize)
{
    this-&gt;toolbarIconSize = toolbarIconSize;
    emit this-&gt;toolbarIconSizeChanged(this-&gt;toolbarIconSize);
}

</t>
<t tx="leo.20201108101517.151">bool ApplicationSettings::getSendUsageInfo() const
{
    return this-&gt;sendUsageInfo;
}

</t>
<t tx="leo.20201108101517.152">void ApplicationSettings::setSendUsageInfo(bool sendUsageInfo)
{
    this-&gt;sendUsageInfo = sendUsageInfo;
}

</t>
<t tx="leo.20201108101517.153">bool ApplicationSettings::getRangeApiAllowed() const
{
    return this-&gt;rangeApiAllowed;
}

</t>
<t tx="leo.20201108101517.154">void ApplicationSettings::setRangeApiAllowed(bool rangeApiAllowed)
{
    this-&gt;rangeApiAllowed = rangeApiAllowed;
}

</t>
<t tx="leo.20201108101517.155">const QString &amp;ApplicationSettings::getRangeApiServer() const
{
    return this-&gt;rangeApiServer;
}

</t>
<t tx="leo.20201108101517.156">void ApplicationSettings::setRangeApiServer(const QString &amp;rangeApiServer)
{
    this-&gt;rangeApiServer = rangeApiServer;
}

</t>
<t tx="leo.20201108101517.157">const QString &amp;ApplicationSettings::getRangeAccount() const
{
    return this-&gt;rangeAccount;
}

</t>
<t tx="leo.20201108101517.158">void ApplicationSettings::setRangeAccount(const QString &amp;rangeAccount)
{
    this-&gt;rangeAccount = rangeAccount;
}

</t>
<t tx="leo.20201108101517.159">const QString &amp;ApplicationSettings::getRangePassword() const
{
    return this-&gt;rangePassword;
}

</t>
<t tx="leo.20201108101517.16">void Action::onSessionOpen()
{
    QString fileExtension = Session::getDefaultFileExtension();
    QString dialogDesc = "Range model files (*." + fileExtension + ");;Any files (*)";
    QString fileName = QFileDialog::getOpenFileName(this-&gt;mainWindow,
                                                    tr("Open session"),
                                                    MainSettings::getInstance().getDataDir(),
                                                    dialogDesc);
    if (fileName.isEmpty())
    {
        return;
    }

    try
    {
        Session::getInstance().read(fileName);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to read the session file \'%s\'. ERROR: %s\n",fileName.toUtf8().constData(),error.getMessage().toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101517.160">void ApplicationSettings::setRangePassword(const QString &amp;rangePassword)
{
    this-&gt;rangePassword = rangePassword;
}

uint ApplicationSettings::getMaxThreads()
{
    return (uint)omp_get_num_procs();
}

QStringList ApplicationSettings::getStyles()
{
    QStringList styles = QStyleFactory::keys();
    styles.append(ApplicationSettings::FusionDark);
    styles.append(ApplicationSettings::FusionRange);
    styles.append(ApplicationSettings::WindowsDark);
    styles.sort();
    return styles;
}

QString ApplicationSettings::getDefaultRangeSolverExecutable()
{
#ifdef DEBUG
    QString baseName("RangeSolver_debug");
#else
    QString baseName("RangeSolver");
#endif

    return QDir(QApplication::applicationDirPath()).filePath(baseName);
}

QString ApplicationSettings::getDefaultHelpDir()
{
    return MainSettings::getInstance().findHelpDir();
}

uint ApplicationSettings::getDefaultNThreads()
{
    return ApplicationSettings::getMaxThreads();
}

uint ApplicationSettings::getDefaultNHistoryRecords()
{
    return 3;
}

QString ApplicationSettings::getDefaultStyle()
{
    return ApplicationSettings::Fusion;
}

</t>
<t tx="leo.20201108101517.161">int ApplicationSettings::getDefaultToolbarIconSize()
{
    return 32;
}

</t>
<t tx="leo.20201108101517.162">bool ApplicationSettings::getDefaultSendUsageInfo()
{
    return true;
}

</t>
<t tx="leo.20201108101517.163">bool ApplicationSettings::getDefaultRangeApiAllowed()
{
    return true;
}

</t>
<t tx="leo.20201108101517.164">const QString ApplicationSettings::getDefaultRangeApiServer()
{
    return RVendor::www;
}

</t>
<t tx="leo.20201108101517.165">const QString ApplicationSettings::getDefaultRangeAccount()
{
    return QString();
}

</t>
<t tx="leo.20201108101517.166">const QString ApplicationSettings::getDefaultRangePassword()
{
    return QString();
}

QColor ApplicationSettings::getDefaultBackgroundColor(const QString &amp;style)
{
    if (style == ApplicationSettings::Fusion)
    {
        return QColor(34,68,102);
    }
    else if (style == ApplicationSettings::FusionRange)
    {
        return QColor(48,0,0);
    }
    else if (style == ApplicationSettings::FusionDark)
    {
        return QColor(53,53,53);
    }
    else if (style == ApplicationSettings::WindowsDark)
    {
        return QColor(53,53,53);
    }
    else
    {
        return QColor(34,68,102);
    }
}

</t>
<t tx="leo.20201108101517.167">void ApplicationSettings::onShortcutChanged(ActionType actionType, const QString &amp;shortcut)
{
    emit this-&gt;shortcutChanged(actionType,shortcut);
}
</t>
<t tx="leo.20201108101517.168">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   application_settings_dialog.cpp                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th July 2013                                          *
 *                                                                   *
 *  DESCRIPTION: Application settings dialog class definition        *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QGroupBox&gt;
#include &lt;QLineEdit&gt;
#include &lt;QFileDialog&gt;
#include &lt;QSpinBox&gt;
#include &lt;QLabel&gt;
#include &lt;QTabWidget&gt;
#include &lt;QTreeWidget&gt;
#include &lt;QMessageBox&gt;

#include "application_settings_dialog.h"
#include "keyboard_shortcuts_edit.h"
#include "main_settings.h"

ApplicationSettingsDialog::ApplicationSettingsDialog(ApplicationSettings *applicationSettings, QWidget *parent) :
    QDialog(parent),
    applicationSettings(applicationSettings)
{
    this-&gt;setWindowTitle(tr("Application settings"));
    this-&gt;resize(500,500);

    QIcon defaultIcon(":/icons/file/pixmaps/range-undo.svg");
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout(mainLayout);

    QTabWidget *tabWidget = new QTabWidget;
    mainLayout-&gt;addWidget(tabWidget, 0, 0, 1, 1);

    QWidget *generalWidget = this-&gt;createGeneralTab();
    tabWidget-&gt;addTab(generalWidget,tr("General"));

    QWidget *shortcutsWidget = this-&gt;createShortcutsTab();
    tabWidget-&gt;addTab(shortcutsWidget,tr("Keyboard shortcuts"));

    QWidget *rangeAccountWidget = this-&gt;createRangeAccountTab();
    tabWidget-&gt;addTab(rangeAccountWidget,tr("Range account"));

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(buttonsLayout, 1, 0, 1, 1);

    QPushButton *defaultButton = new QPushButton(defaultIcon, tr("Default"));
    buttonsLayout-&gt;addWidget(defaultButton);

    buttonsLayout-&gt;addStretch(1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setDefault(true);
    this-&gt;okButton-&gt;setDisabled(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(defaultButton,&amp;QPushButton::clicked,this,&amp;ApplicationSettingsDialog::onDefaultClicked);
    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;QDialog::reject);
    QObject::connect(this-&gt;okButton,&amp;QPushButton::clicked,this,&amp;QDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101517.169">int ApplicationSettingsDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        this-&gt;applicationSettings-&gt;setSolverPath(this-&gt;solverFileChooserButton-&gt;getFileName());
        this-&gt;applicationSettings-&gt;setHelpDir(this-&gt;helpFileChooserButton-&gt;getFileName());
        this-&gt;applicationSettings-&gt;setNThreads(this-&gt;nThreadsSpin-&gt;value());
        this-&gt;applicationSettings-&gt;setNHistoryRecords(this-&gt;nHistoryRecordsSpin-&gt;value());
        this-&gt;applicationSettings-&gt;setStyle(this-&gt;styleCombo-&gt;currentText());
        this-&gt;applicationSettings-&gt;setToolbarIconSize(this-&gt;toolbarIconSizeSpin-&gt;value());
        this-&gt;applicationSettings-&gt;setSendUsageInfo(this-&gt;sendUsageInfoAllowed-&gt;isChecked());
        this-&gt;applicationSettings-&gt;setRangeApiAllowed(this-&gt;rangeApiAllowed-&gt;isChecked());
        this-&gt;applicationSettings-&gt;setRangeApiServer(this-&gt;rangeApiServer-&gt;text());

        for (QMap&lt;ActionType,QString&gt;::iterator iter = this-&gt;changedShortcut.begin(); iter != this-&gt;changedShortcut.end(); ++iter)
        {
            this-&gt;applicationSettings-&gt;getActionDefinition()-&gt;setShortcut(iter.key(),iter.value());
        }
    }
    return retVal;
}

QWidget *ApplicationSettingsDialog::createGeneralTab(void)
{
    QWidget *widget = new QWidget;

    QGridLayout *layout = new QGridLayout;
    widget-&gt;setLayout(layout);

    this-&gt;solverFileChooserButton = new FileChooserButton("Solver executable:",
                                                          FileChooserButton::OpenFile,
                                                          this,
                                                          "Select Range solver executable",
                                                          this-&gt;applicationSettings-&gt;getSolverPath(),
                                                          "Any files (*)");
    layout-&gt;addWidget(this-&gt;solverFileChooserButton,0,0,1,2);

    QLabel *ncpusLabel = new QLabel(tr("Number of threads:"));
    layout-&gt;addWidget(ncpusLabel,1,0,1,1);

    this-&gt;nThreadsSpin = new QSpinBox;
    this-&gt;nThreadsSpin-&gt;setRange(1,ApplicationSettings::getMaxThreads());
    this-&gt;nThreadsSpin-&gt;setValue(this-&gt;applicationSettings-&gt;getNThreads());
    this-&gt;nThreadsSpin-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Minimum);
    layout-&gt;addWidget(this-&gt;nThreadsSpin,1,1,1,1);

    QLabel *nHistoryRecordsLabel = new QLabel(tr("Number of history (undo) records:"));
    layout-&gt;addWidget(nHistoryRecordsLabel,2,0,1,1);

    this-&gt;nHistoryRecordsSpin = new QSpinBox;
    this-&gt;nHistoryRecordsSpin-&gt;setRange(1,INT_MAX);
    this-&gt;nHistoryRecordsSpin-&gt;setValue(this-&gt;applicationSettings-&gt;getNHistoryRecords());
    this-&gt;nHistoryRecordsSpin-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Minimum);
    layout-&gt;addWidget(this-&gt;nHistoryRecordsSpin,2,1,1,1);

    QLabel *styleLabel = new QLabel(tr("Style:"));
    layout-&gt;addWidget(styleLabel,3,0,1,1);

    QStringList styles(ApplicationSettings::getStyles());
    this-&gt;styleCombo = new QComboBox;
    this-&gt;styleCombo-&gt;addItems(styles);
    for (int i=0;i&lt;styles.size();i++)
    {
        if (styles.at(i) == this-&gt;applicationSettings-&gt;getStyle())
        {
            this-&gt;styleCombo-&gt;setCurrentIndex(i);
        }
    }
    layout-&gt;addWidget(this-&gt;styleCombo,3,1,1,1);

    QLabel *toolbarIconSizeLabel = new QLabel(tr("Icon size:"));
    layout-&gt;addWidget(toolbarIconSizeLabel,4,0,1,1);

    this-&gt;toolbarIconSizeSpin = new QSpinBox;
    this-&gt;toolbarIconSizeSpin-&gt;setRange(8,128);
    this-&gt;toolbarIconSizeSpin-&gt;setSingleStep(8);
    this-&gt;toolbarIconSizeSpin-&gt;setValue(this-&gt;applicationSettings-&gt;getToolbarIconSize());
    RLogger::info("%d\n",this-&gt;applicationSettings-&gt;getToolbarIconSize());
    this-&gt;toolbarIconSizeSpin-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Minimum);
    layout-&gt;addWidget(this-&gt;toolbarIconSizeSpin,4,1,1,1);

    this-&gt;helpFileChooserButton = new FileChooserButton("Help directory:",
                                                        FileChooserButton::Directory,
                                                        this,
                                                        "Select directory containing help files",
                                                        this-&gt;applicationSettings-&gt;getHelpDir());
    layout-&gt;addWidget(this-&gt;helpFileChooserButton,5,0,1,2);

    QWidget *spacer = new QWidget();
    spacer-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    layout-&gt;addWidget(spacer,6,0,1,2);

    this-&gt;connect(this-&gt;solverFileChooserButton,SIGNAL(fileNameChanged(QString)),SLOT(onSolverPathChanged(QString)));
    this-&gt;connect(this-&gt;helpFileChooserButton,SIGNAL(fileNameChanged(QString)),SLOT(onHelpDirChanged(QString)));
    this-&gt;connect(this-&gt;nThreadsSpin,SIGNAL(valueChanged(int)),SLOT(onNThreadsChanged(int)));
    this-&gt;connect(this-&gt;nHistoryRecordsSpin,SIGNAL(valueChanged(int)),SLOT(onNHistoryRecordsChanged(int)));
    this-&gt;connect(this-&gt;styleCombo,SIGNAL(currentIndexChanged(int)),SLOT(onStyleChanged(int)));
    this-&gt;connect(this-&gt;toolbarIconSizeSpin,SIGNAL(valueChanged(int)),SLOT(onToolbarIconSizeChanged(int)));

    return widget;
}

QWidget *ApplicationSettingsDialog::createShortcutsTab(void)
{
    QWidget *widget = new QWidget;

    QVBoxLayout *layout = new QVBoxLayout;
    widget-&gt;setLayout(layout);

    this-&gt;keyboardShortcutsEdit = new KeyboardShortcutsEdit(this-&gt;applicationSettings-&gt;getActionDefinition());
    layout-&gt;addWidget(this-&gt;keyboardShortcutsEdit);

    QObject::connect(this-&gt;keyboardShortcutsEdit,
                     &amp;KeyboardShortcutsEdit::shortcutChanged,
                     this,
                     &amp;ApplicationSettingsDialog::onKeyboardShortcutChanged);

    return widget;
}

QWidget *ApplicationSettingsDialog::createRangeAccountTab(void)
{
    QWidget *widget = new QWidget;

    QGridLayout *layout = new QGridLayout;
    widget-&gt;setLayout(layout);

    this-&gt;rangeApiAllowed = new QGroupBox(tr("Allow connection to Range API server"));
    this-&gt;rangeApiAllowed-&gt;setCheckable(true);
    this-&gt;rangeApiAllowed-&gt;setChecked(this-&gt;applicationSettings-&gt;getRangeApiAllowed());
    layout-&gt;addWidget(this-&gt;rangeApiAllowed,0,0,1,1);

    QGridLayout *rraLayout = new QGridLayout;
    this-&gt;rangeApiAllowed-&gt;setLayout(rraLayout);

    uint rowCount = 0;

    this-&gt;sendUsageInfoAllowed = new QCheckBox(tr("Send usage info"));
    this-&gt;sendUsageInfoAllowed-&gt;setCheckState(this-&gt;applicationSettings-&gt;getSendUsageInfo()?Qt::Checked:Qt::Unchecked);
    rraLayout-&gt;addWidget(this-&gt;sendUsageInfoAllowed,rowCount,0,1,2);

    QLabel *rangeApiServerLabel = new QLabel(tr("Range API server:"));
    rangeApiServerLabel-&gt;setSizePolicy(QSizePolicy::Fixed,QSizePolicy::Minimum);
    rraLayout-&gt;addWidget(rangeApiServerLabel,++rowCount,0,1,1);

    this-&gt;rangeApiServer = new QLineEdit(this-&gt;applicationSettings-&gt;getRangeApiServer());
    this-&gt;rangeApiServer-&gt;setPlaceholderText(tr("http://"));
    this-&gt;rangeApiServer-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Minimum);
    rraLayout-&gt;addWidget(this-&gt;rangeApiServer,rowCount,1,1,1);

    QWidget *spacer = new QWidget();
    spacer-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    layout-&gt;addWidget(spacer,++rowCount,0,1,2);

    this-&gt;connect(this-&gt;rangeApiAllowed,SIGNAL(toggled(bool)),SLOT(onRangeApiAllowedToggled(bool)));
    this-&gt;connect(this-&gt;sendUsageInfoAllowed,SIGNAL(toggled(bool)),SLOT(onSendUsageInfoAllowedToggled(bool)));
    this-&gt;connect(this-&gt;rangeApiServer,SIGNAL(textChanged(QString)),SLOT(onRangeApiServerChanged(QString)));

    return widget;
}

</t>
<t tx="leo.20201108101517.17">void Action::onSessionSave()
{
    QDir dataDir(MainSettings::getInstance().getDataDir());
    QString dialogDesc = "Range session files (*.ras);;Any files (*)";

    QString fileName = Session::getInstance().getFileName();
    if (fileName.isEmpty())
    {
        fileName = dataDir.filePath("default.ras");
        fileName = QFileDialog::getSaveFileName(this-&gt;mainWindow,
                                                tr("Save session"),
                                                fileName,
                                                dialogDesc);
    }
    if (fileName.isEmpty())
    {
        return;
    }

    Session::getInstance().write(fileName,true);
}

</t>
<t tx="leo.20201108101517.170">void ApplicationSettingsDialog::onSolverPathChanged(const QString &amp;)
{
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.171">void ApplicationSettingsDialog::onHelpDirChanged(const QString &amp;)
{
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.172">void ApplicationSettingsDialog::onNThreadsChanged(int)
{
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.173">void ApplicationSettingsDialog::onNHistoryRecordsChanged(int)
{
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.174">void ApplicationSettingsDialog::onStyleChanged(int)
{
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.175">void ApplicationSettingsDialog::onToolbarIconSizeChanged(int)
{
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.176">void ApplicationSettingsDialog::onKeyboardShortcutChanged(ActionType actionType, const QString &amp;shortcut)
{
    this-&gt;changedShortcut.insert(actionType,shortcut);
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.177">void ApplicationSettingsDialog::onRangeApiAllowedToggled(bool)
{
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.178">void ApplicationSettingsDialog::onSendUsageInfoAllowedToggled(bool)
{
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.179">void ApplicationSettingsDialog::onRangeApiServerChanged(const QString &amp;)
{
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101517.18">void Action::onSessionSaveAs()
{
    QDir sessionDir(MainSettings::getInstance().getSessionDir());
    QString dialogDesc = "Range session files (*.ras);;Any files (*)";

    QString fileName;
    if (fileName.isEmpty())
    {
        fileName = sessionDir.filePath("default.ras");
    }
    fileName = QFileDialog::getSaveFileName(this-&gt;mainWindow,
                                            tr("Save session"),
                                            fileName,
                                            dialogDesc);
    if (fileName.isEmpty())
    {
        return;
    }

    Session::getInstance().write(fileName,true);
}

</t>
<t tx="leo.20201108101517.180">void ApplicationSettingsDialog::onDefaultClicked(void)
{
    this-&gt;solverFileChooserButton-&gt;setFileName(ApplicationSettings::getDefaultRangeSolverExecutable());
    this-&gt;helpFileChooserButton-&gt;setFileName(ApplicationSettings::getDefaultHelpDir());
    this-&gt;nThreadsSpin-&gt;setValue(ApplicationSettings::getDefaultNThreads());
    this-&gt;nHistoryRecordsSpin-&gt;setValue(ApplicationSettings::getDefaultNHistoryRecords());
    for (int i=0;i&lt;this-&gt;styleCombo-&gt;count();i++)
    {
        if (this-&gt;styleCombo-&gt;itemText(i) == ApplicationSettings::getDefaultStyle())
        {
            this-&gt;styleCombo-&gt;setCurrentIndex(i);
            break;
        }
    }
    this-&gt;toolbarIconSizeSpin-&gt;setValue(ApplicationSettings::getDefaultToolbarIconSize());
    this-&gt;keyboardShortcutsEdit-&gt;resetToDefault();
    this-&gt;changedShortcut.clear();
    this-&gt;sendUsageInfoAllowed-&gt;setChecked(ApplicationSettings::getDefaultSendUsageInfo());
    this-&gt;rangeApiAllowed-&gt;setChecked(ApplicationSettings::getDefaultRangeApiAllowed());
    this-&gt;rangeApiServer-&gt;setText(ApplicationSettings::getDefaultRangeApiServer());
}
</t>
<t tx="leo.20201108101517.181">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   bc_manager_tree.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th February 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Boundary condition tree manager class definition    *
 *********************************************************************/

#include &lt;vector&gt;
#include &lt;QList&gt;
#include &lt;QMessageBox&gt;

#include &lt;rmlib.h&gt;

#include "session.h"
#include "bc_manager_tree.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101517.182">typedef enum _BoundaryConditionTreeColumn
{
    BC_TREE_COLUMN_NAME = 0,
    BC_TREE_N_COLUMNS
} BoundaryConditionTreeColumn;

BCManagerTree::BCManagerTree(QWidget *parent) :
    QTreeWidget(parent),
    doNotPopulate(false)
{
    this-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;setSortingEnabled(true);
    this-&gt;sortByColumn(BC_TREE_COLUMN_NAME,Qt::AscendingOrder);

    this-&gt;setColumnCount(BC_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(BC_TREE_COLUMN_NAME,QString("Name"));
    this-&gt;setHeaderItem(headerItem);
    this-&gt;setHeaderHidden(true);
    this-&gt;setRootIsDecorated(false);

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::problemSelectionChanged,
                     this,
                     &amp;BCManagerTree::onProblemChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelSelectionChanged,
                     this,
                     &amp;BCManagerTree::onModelSelectionChanged);
    QObject::connect(this,&amp;BCManagerTree::itemChanged,
                     this,&amp;BCManagerTree::onItemChanged);
    QObject::connect(this,&amp;BCManagerTree::itemSelectionChanged,
                     this,&amp;BCManagerTree::onItemSelectionChanged);
    QObject::connect(this,&amp;BCManagerTree::bcSelected,
                     this,&amp;BCManagerTree::onBcSelected);
}

</t>
<t tx="leo.20201108101517.183">void BCManagerTree::populate(void)
{
    if (this-&gt;doNotPopulate)
    {
        return;
    }

    RProblemTypeMask bcPrbTypeMask;
    RProblemTypeMask modelPrbTypeMask = R_PROBLEM_NONE;
    REntityGroupTypeMask elementGroupTypeMask = R_ENTITY_GROUP_NONE;
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;selectedEntityIDs.size();i++)
    {
        elementGroupTypeMask |= selectedEntityIDs[i].getType();
        modelPrbTypeMask |= Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getProblemTaskTree().getProblemTypeMask();
    }

    QList&lt;QTreeWidgetItem*&gt; selectedItemsList = this-&gt;selectedItems();
    // Following is a hack to not to clear selected types list if item is being deselected.
    if (selectedItemsList.size() &gt; 0)
    {
        this-&gt;selectedTypes.clear();
    }
    for (int i=0;i&lt;selectedItemsList.size();i++)
    {
        this-&gt;selectedTypes.append(RBoundaryConditionType(selectedItemsList[i]-&gt;data(BC_TREE_COLUMN_NAME,Qt::UserRole).toInt()));
    }

    this-&gt;blockSignals(true);

    this-&gt;clear();

    QMap&lt;RBoundaryConditionType,uint&gt; bcMap = this-&gt;getBcMap(selectedEntityIDs);

    for (RBoundaryConditionType bcType = (RBoundaryConditionType)((int)R_BOUNDARY_CONDITION_NONE + 1);
                                bcType &lt; R_BOUNDARY_CONDITION_N_TYPES;
                                bcType ++)
    {
        bcPrbTypeMask = RBoundaryCondition::getProblemTypeMask(bcType);
        if (!(bcPrbTypeMask &amp; modelPrbTypeMask))
        {
            continue;
        }
        bool applies = false;
        if (elementGroupTypeMask &amp; R_ENTITY_GROUP_POINT)
        {
            if (RBoundaryCondition::getApplyOnPoint(bcType))
            {
                applies = true;
            }
        }
        if (elementGroupTypeMask &amp; R_ENTITY_GROUP_LINE)
        {
            if (RBoundaryCondition::getApplyOnLine(bcType))
            {
                applies = true;
            }
        }
        if (elementGroupTypeMask &amp; R_ENTITY_GROUP_SURFACE)
        {
            if (RBoundaryCondition::getApplyOnSurface(bcType))
            {
                applies = true;
            }
        }
        if (elementGroupTypeMask &amp; R_ENTITY_GROUP_VOLUME)
        {
            if (RBoundaryCondition::getApplyOnVolume(bcType))
            {
                applies = true;
            }
        }
        if (!applies)
        {
            continue;
        }

        Qt::CheckState state = Qt::Unchecked;
        if (bcMap.contains(bcType))
        {
            if (bcMap.value(bcType,1) == (uint)selectedEntityIDs.size())
            {
                state = Qt::Checked;
            }
            else
            {
                state = Qt::PartiallyChecked;
            }
        }
        QTreeWidgetItem *itemModel = new QTreeWidgetItem(this);
        if (RBoundaryCondition::getExplicit(bcType))
        {
            itemModel-&gt;setForeground(BC_TREE_COLUMN_NAME,this-&gt;palette().brush(QPalette::Active,QPalette::Text));
            QFont font(itemModel-&gt;font(BC_TREE_COLUMN_NAME));
            font.setBold(true);
            itemModel-&gt;setFont(BC_TREE_COLUMN_NAME,font);
        }
        itemModel-&gt;setText(BC_TREE_COLUMN_NAME, RBoundaryCondition::getName(bcType));
        itemModel-&gt;setData(BC_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(state));
        itemModel-&gt;setData(BC_TREE_COLUMN_NAME,Qt::UserRole,QVariant(bcType));
    }

    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        this-&gt;topLevelItem(i)-&gt;setSelected(false);
        for (int j=0;j&lt;this-&gt;selectedTypes.size();j++)
        {
            if (this-&gt;selectedTypes[j] == RBoundaryConditionType(this-&gt;topLevelItem(i)-&gt;data(BC_TREE_COLUMN_NAME,Qt::UserRole).toInt()))
            {
                this-&gt;topLevelItem(i)-&gt;setSelected(true);
                break;
            }
        }
    }

    this-&gt;blockSignals(false);

    emit this-&gt;itemSelectionChanged();
}
</t>
<t tx="leo.20201108101517.184">void BCManagerTree::onModelSelectionChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101517.185">void BCManagerTree::onProblemChanged(uint)
{
    this-&gt;populate();
}

QMap&lt;RBoundaryConditionType,uint&gt; BCManagerTree::getBcMap(const QList&lt;SessionEntityID&gt; &amp;entityIDs) const
{
    QMap&lt;RBoundaryConditionType,uint&gt; bcMap;
    RBoundaryConditionType bcType;
    uint bcCount;

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(entityIDs[i].getMid());

        if (entityIDs[i].getType() == R_ENTITY_GROUP_POINT)
        {
            for (uint j=0;j&lt;pModel-&gt;getPoint(entityIDs[i].getEid()).getNBoundaryConditions();j++)
            {
                bcType = pModel-&gt;getPoint(entityIDs[i].getEid()).getBoundaryCondition(j).getType();
                bcCount = bcMap.value(bcType,0) + 1;
                bcMap.insert(bcType,bcCount);
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_LINE)
        {
            for (uint j=0;j&lt;pModel-&gt;getLine(entityIDs[i].getEid()).getNBoundaryConditions();j++)
            {
                bcType = pModel-&gt;getLine(entityIDs[i].getEid()).getBoundaryCondition(j).getType();
                bcCount = bcMap.value(bcType,0) + 1;
                bcMap.insert(bcType,bcCount);
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_SURFACE)
        {
            for (uint j=0;j&lt;pModel-&gt;getSurface(entityIDs[i].getEid()).getNBoundaryConditions();j++)
            {
                bcType = pModel-&gt;getSurface(entityIDs[i].getEid()).getBoundaryCondition(j).getType();
                bcCount = bcMap.value(bcType,0) + 1;
                bcMap.insert(bcType,bcCount);
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_VOLUME)
        {
            for (uint j=0;j&lt;pModel-&gt;getVolume(entityIDs[i].getEid()).getNBoundaryConditions();j++)
            {
                bcType = pModel-&gt;getVolume(entityIDs[i].getEid()).getBoundaryCondition(j).getType();
                bcCount = bcMap.value(bcType,0) + 1;
                bcMap.insert(bcType,bcCount);
            }
        }
    }

    return bcMap;
}

</t>
<t tx="leo.20201108101517.186">bool BCManagerTree::resolveConflicts(RBoundaryConditionType bcType)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    RProblemTypeMask problemTypeMask = R_PROBLEM_NONE;
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        problemTypeMask |= Session::getInstance().getModel(modelIDs[i]).getProblemTaskTree().getProblemTypeMask();
    }
    std::vector&lt;RBoundaryConditionType&gt; bcTypeConflicts = RBoundaryCondition::getConflictTypes(problemTypeMask,bcType);

    QString message = "Following boundary condition(s) will be deselected:&lt;ul&gt;";
    uint nConflicts = 0;
    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        QTreeWidgetItem *item = this-&gt;topLevelItem(i);
        if (item-&gt;checkState(BC_TREE_COLUMN_NAME) != Qt::Checked)
        {
            continue;
        }
        for (uint j=0;j&lt;bcTypeConflicts.size();j++)
        {
            if (bcTypeConflicts[j] == RBoundaryConditionType(item-&gt;data(BC_TREE_COLUMN_NAME,Qt::UserRole).toInt()))
            {
                message += "&lt;li&gt;&lt;b&gt;" + item-&gt;text(BC_TREE_COLUMN_NAME) + "&lt;/b&gt;&lt;/li&gt;";
                nConflicts++;
            }
        }
    }
    message += "&lt;/ul&gt;";

    if (nConflicts == 0)
    {
        return true;
    }

    @others
}

</t>
<t tx="leo.20201108101517.187">int response = QMessageBox::question(this,
                                     "Remove boundary condition(s)?",
                                     message,
                                     QMessageBox::Ok | QMessageBox::Cancel,
                                     QMessageBox::Cancel);
if (response == QMessageBox::Cancel)
{
    return false;
}

for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
{
    QTreeWidgetItem *item = this-&gt;topLevelItem(i);
    for (uint j=0;j&lt;bcTypeConflicts.size();j++)
    {
        if (bcTypeConflicts[j] == RBoundaryConditionType(item-&gt;data(BC_TREE_COLUMN_NAME,Qt::UserRole).toInt()))
        {
            item-&gt;setCheckState(BC_TREE_COLUMN_NAME,Qt::Unchecked);
        }
    }
}
return true;
</t>
<t tx="leo.20201108101517.188">void BCManagerTree::onItemChanged(QTreeWidgetItem *item, int column)
{
    Qt::CheckState checkState = item-&gt;checkState(column);
    RBoundaryConditionType bcType = (RBoundaryConditionType) item-&gt;data(BC_TREE_COLUMN_NAME,Qt::UserRole).toInt();
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    if (checkState == Qt::Checked)
    {
        if (!this-&gt;resolveConflicts(bcType))
        {
            this-&gt;blockSignals(true);
            item-&gt;setCheckState(column,Qt::Unchecked);
            this-&gt;blockSignals(false);
            return;
        }
    }

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(entityIDs[i].getMid());
        RBoundaryCondition defaultBoundaryCondition = pModel-&gt;generateDefaultBoundayCondition(bcType,entityIDs[i].getType(),entityIDs[i].getEid());

        if (entityIDs[i].getType() == R_ENTITY_GROUP_POINT)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getPoint(entityIDs[i].getEid()).addBoundaryCondition(defaultBoundaryCondition);
            }
            else
            {
                if (pModel-&gt;getPoint(entityIDs[i].getEid()).hasBoundaryCondition(bcType))
                {
                    pModel-&gt;getPoint(entityIDs[i].getEid()).removeBoundaryCondition(bcType);
                }
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_LINE)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getLine(entityIDs[i].getEid()).addBoundaryCondition(defaultBoundaryCondition);
            }
            else
            {
                if (pModel-&gt;getLine(entityIDs[i].getEid()).hasBoundaryCondition(bcType))
                {
                    pModel-&gt;getLine(entityIDs[i].getEid()).removeBoundaryCondition(bcType);
                }
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_SURFACE)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getSurface(entityIDs[i].getEid()).addBoundaryCondition(defaultBoundaryCondition);
            }
            else
            {
                if (pModel-&gt;getSurface(entityIDs[i].getEid()).hasBoundaryCondition(bcType))
                {
                    pModel-&gt;getSurface(entityIDs[i].getEid()).removeBoundaryCondition(bcType);
                }
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_VOLUME)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getVolume(entityIDs[i].getEid()).addBoundaryCondition(defaultBoundaryCondition);
            }
            else
            {
                if (pModel-&gt;getVolume(entityIDs[i].getEid()).hasBoundaryCondition(bcType))
                {
                    pModel-&gt;getVolume(entityIDs[i].getEid()).removeBoundaryCondition(bcType);
                }
            }
        }
    }

    if (item-&gt;isSelected())
    {
        emit this-&gt;bcSelected(bcType,(checkState == Qt::Checked));
    }
    else
    {
        emit this-&gt;bcSelected(R_BOUNDARY_CONDITION_NONE,false);
    }
}

</t>
<t tx="leo.20201108101517.189">void BCManagerTree::onItemSelectionChanged(void)
{
    QList&lt;QTreeWidgetItem *&gt; items = this-&gt;selectedItems();
    emit this-&gt;bcSelected(R_BOUNDARY_CONDITION_NONE,false);
    for (int i=0;i&lt;items.size();i++)
    {
        RBoundaryConditionType bcType = (RBoundaryConditionType)items[i]-&gt;data(BC_TREE_COLUMN_NAME,Qt::UserRole).toInt();
        bool applied = (items[i]-&gt;checkState(BC_TREE_COLUMN_NAME) == Qt::Checked);
        emit this-&gt;bcSelected(bcType,applied);
    }
}

</t>
<t tx="leo.20201108101517.19">void Action::onSessionClose()
{
    @others
}

</t>
<t tx="leo.20201108101517.190">void BCManagerTree::onBcSelected(void)
{
    this-&gt;doNotPopulate = true;
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
    this-&gt;doNotPopulate = false;
}
</t>
<t tx="leo.20201108101517.191">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   bc_tree.cpp                                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th February 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Boundary condition tree class definition            *
 *********************************************************************/

#include &lt;QStandardItemModel&gt;
#include &lt;QLineEdit&gt;
#include &lt;QPushButton&gt;

#include "component_edit_dialog.h"
#include "session.h"
#include "bc_tree.h"
#include "direction_widget.h"
#include "variable_value_edit.h"
#include "push_button.h"
#include "main_window.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101517.2"></t>
<t tx="leo.20201108101517.20">int response = QMessageBox::question(this-&gt;mainWindow,
                                     tr("Close session"),
                                     tr("Are you sure you want to close current session?"),
                                     QMessageBox::Yes | QMessageBox::No,
                                     QMessageBox::No);
if (response == QMessageBox::Yes)
{
    Session::getInstance().clear();
}
</t>
<t tx="leo.20201108101517.21">void Action::onModelNew()
{
    NewModelDialog(this-&gt;mainWindow).exec();
}

</t>
<t tx="leo.20201108101517.22">void Action::onModelOpen()
{
    QString binaryExtension = RModel::getDefaultFileExtension(true);
    QString asciiExtension = RModel::getDefaultFileExtension(false);
    QString dialogDesc = "All supported files (*." + binaryExtension + " *." + asciiExtension + " *.tmsh *.bmsh *.raw *.stl);;"
                       + "Range model files (*." + binaryExtension + " *." + asciiExtension + ");;" +
                       + "Old Range model mesh files (*.tmsh *.bmsh);;"
                       + "RAW triangle files (*.raw);;"
                       + "STL triangle files (*.stl);;"
                       + "Any files (*)";
    QString fileName = QFileDialog::getOpenFileName(this-&gt;mainWindow,
                                                    tr("Open model"),
                                                    MainSettings::getInstance().getDataDir(),
                                                    dialogDesc);
    if (fileName.isEmpty())
    {
        return;
    }

    ModelIOType modelIOType;

    QString extension = RFileManager::getExtension(fileName).toLower();
    if (extension == "tmsh" || extension == "bmsh")
    {
        modelIOType = MODEL_IO_MSH_IMPORT;
    }
    else if (extension == "raw")
    {
        modelIOType = MODEL_IO_RAW_IMPORT;
    }
    else if (extension == "stl")
    {
        modelIOType = MODEL_IO_STL_IMPORT;
    }
    else
    {
        modelIOType = MODEL_IO_OPEN;
    }

    JobManager::getInstance().submit(new ModelIO(modelIOType, fileName));
}

</t>
<t tx="leo.20201108101517.23">void Action::onModelSave()
{
    foreach (uint selectedModelID,Session::getInstance().getSelectedModelIDs())
    {
        Model &amp;rModel = Session::getInstance().getModel(selectedModelID);

        QString fileName = ModelIO::getModelSaveName(MainSettings::getInstance(),this-&gt;mainWindow,rModel);

        if (fileName.isEmpty())
        {
            continue;
        }

        JobManager::getInstance().submit(new ModelIO(MODEL_IO_SAVE, fileName, &amp;rModel));
    }
}

</t>
<t tx="leo.20201108101517.24">void Action::onModelSaveAs()
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);

        QString fileName = ModelIO::getModelSaveName(MainSettings::getInstance(),this-&gt;mainWindow,model,true);

        if (fileName.isEmpty())
        {
            continue;
        }

        JobManager::getInstance().submit(new ModelIO(MODEL_IO_SAVE, fileName, &amp;model));
    }
}

</t>
<t tx="leo.20201108101517.25">void Action::onModelExportMsh()
{
    QDir dataDir(MainSettings::getInstance().getDataDir());
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(selectedModelIDs[i]);
        QString fileName = dataDir.filePath(pModel-&gt;getName() + ".tmsh");
        fileName = QFileDialog::getSaveFileName(this-&gt;mainWindow,
                                                tr("Export model to MSH file"),
                                                fileName,
                                                "Range mesh files (*.tmsh *.bmsh);;Any files (*)");
        if (fileName.isEmpty())
        {
            continue;
        }

        JobManager::getInstance().submit(new ModelIO(MODEL_IO_MSH_EXPORT, fileName, pModel));
    }
}

</t>
<t tx="leo.20201108101517.26">void Action::onModelExportRaw()
{
    QDir dataDir(MainSettings::getInstance().getDataDir());
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(selectedModelIDs[i]);
        QString fileName = dataDir.filePath(pModel-&gt;getName() + ".raw");
        fileName = QFileDialog::getSaveFileName(this-&gt;mainWindow,
                                                tr("Export model to RAW file"),
                                                fileName,
                                                "RAW triangle files (*.raw);;Any files (*)");
        if (fileName.isEmpty())
        {
            continue;
        }

        JobManager::getInstance().submit(new ModelIO(MODEL_IO_RAW_EXPORT, fileName, pModel));
    }
}

</t>
<t tx="leo.20201108101517.27">void Action::onModelExportStlAscii()
{
    QDir dataDir(MainSettings::getInstance().getDataDir());
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(selectedModelIDs[i]);
        QString fileName = dataDir.filePath(pModel-&gt;getName() + ".stl");
        fileName = QFileDialog::getSaveFileName(this-&gt;mainWindow,
                                                tr("Export model to STL (ascii) file"),
                                                fileName,
                                                "STL triangle files (*.stl);;Any files (*)");
        if (fileName.isEmpty())
        {
            continue;
        }

        JobManager::getInstance().submit(new ModelIO(MODEL_IO_STL_ASCII_EXPORT, fileName, pModel));
    }
}

</t>
<t tx="leo.20201108101517.28">void Action::onModelExportStlBinary()
{
    QDir dataDir(MainSettings::getInstance().getDataDir());
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(selectedModelIDs[i]);
        QString fileName = dataDir.filePath(pModel-&gt;getName() + ".stl");
        fileName = QFileDialog::getSaveFileName(this-&gt;mainWindow,
                                                tr("Export model to STL (binary) file"),
                                                fileName,
                                                "STL triangle files (*.stl);;Any files (*)");
        if (fileName.isEmpty())
        {
            continue;
        }

        JobManager::getInstance().submit(new ModelIO(MODEL_IO_STL_BINARY_EXPORT, fileName, pModel));
    }
}

</t>
<t tx="leo.20201108101517.29">void Action::onModelClose()
{
    @others
}

</t>
<t tx="leo.20201108101517.3"></t>
<t tx="leo.20201108101517.30">int response = QMessageBox::question(this-&gt;mainWindow,
                                     tr("Close model?"),
                                     tr("Are you sure you want to close selected models?"));
if (response != QMessageBox::Yes)
{
    return;
}
QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
for (int i=0;i&lt;modelIDs.size();i++)
{
    RLogger::info("Closing model \'%s\'\n",Session::getInstance().getModel(uint(modelIDs.size()-i-1)).getName().toUtf8().constData());
    Session::getInstance().removeModel(modelIDs[modelIDs.size()-i-1]);
}
</t>
<t tx="leo.20201108101517.31">void Action::onModelReloadResults()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Job *updateJob = new ModelIO(MODEL_IO_UPDATE, Session::getInstance().getModel(modelIDs[i]).getFileName(), &amp;Session::getInstance().getModel(modelIDs[i]));
        JobManager::getInstance().submit(updateJob);
    }
}

</t>
<t tx="leo.20201108101517.32">void Action::onModelRename()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        RenameModelDialog(modelIDs.at(i)).exec();
    }
}

</t>
<t tx="leo.20201108101517.33">void Action::onModelDropResults()
{
    DropResultsDialog dropResultsDialog(this-&gt;mainWindow);
    dropResultsDialog.exec();
}

</t>
<t tx="leo.20201108101517.34">void Action::onMaterialNew()
{
    QString materialNameBase = tr("New material");
    QString materialName = materialNameBase;
    uint nTries = 0;
    while (MaterialList::getInstance().containName(materialName))
    {
        materialName = materialNameBase + " - " + QString::number(++nTries);
    }

    RMaterial material = RMaterial::generateDefault();
    material.setName(materialName);
    MaterialList::getInstance().addMaterial(material,true);
}

</t>
<t tx="leo.20201108101517.35">void Action::onMaterialImport()
{
    QString fileName = QFileDialog::getOpenFileName(this-&gt;mainWindow,
                                                    tr("Select material file"),
                                                    MainSettings::getInstance().getHomeDir(),
                                                    "Material files (*.tmat);;Any files (*)");
    if (fileName.isEmpty())
    {
        return;
    }

    RLogger::info("Importing legacy material file \'%s\'\n",fileName.toUtf8().constData());

    RMaterial material;
    try
    {
        material.import(fileName);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to import legacy material file \'%s\'. %s",
                       fileName.toUtf8().constData(),
                       error.getMessage().toUtf8().constData());
        return;
    }
    bool isNew = true;
    if (MaterialList::getInstance().containName(material.getName()))
    {
        @others
}

</t>
<t tx="leo.20201108101517.36">    int response = QMessageBox::question(this-&gt;mainWindow,
                                         tr("Overwrite?"),
                                         tr("Material with such name already exists. Do you want to overwrite it?"));
    if (response != QMessageBox::Yes)
    {
        return;
    }
    isNew = false;
}
MaterialList::getInstance().addMaterial(material,isNew);
</t>
<t tx="leo.20201108101517.37">void Action::onMaterialDelete()
{
    if (MaterialList::getInstance().getSelectedMaterialName().length() == 0)
    {
        return;
    }

    QString question = QString("Are you sure you want to delete material &lt;b&gt;")
                     + MaterialList::getInstance().getSelectedMaterialName()
                     + QString("&lt;/b&gt;?");

    @others
}

</t>
<t tx="leo.20201108101517.38">int response = QMessageBox::question(this-&gt;mainWindow,
                                     tr("Delete selected material?"),
                              question,
                              QMessageBox::Yes | QMessageBox::No,
                              QMessageBox::No);
if (response == QMessageBox::Yes)
{
    MaterialList::getInstance().remove(MaterialList::getInstance().getSelectedMaterialName());
}
</t>
<t tx="leo.20201108101517.39">void Action::onGeometryUndo()
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;rModel = Session::getInstance().getModel(selectedModelIDs[i]);
        if (rModel.getUndoStackSize() &gt; 0)
        {
            Session::getInstance().getPickList().removeItems(selectedModelIDs[i]);
            rModel.undo(0);
        }
        Session::getInstance().setModelChanged(selectedModelIDs[i]);
    }
}

</t>
<t tx="leo.20201108101517.40">void Action::onGeometryRedo()
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;rModel = Session::getInstance().getModel(selectedModelIDs[i]);
        if (rModel.getRedoStackSize() &gt; 0)
        {
            Session::getInstance().getPickList().removeItems(selectedModelIDs[i]);
            rModel.redo(0);
        }
        Session::getInstance().setModelChanged(selectedModelIDs[i]);
    }
}

</t>
<t tx="leo.20201108101517.41">void Action::onGeometryDrawPoint()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEnginePoint);
}

</t>
<t tx="leo.20201108101517.42">void Action::onGeometryDrawLine()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEngineLine);
}

</t>
<t tx="leo.20201108101517.43">void Action::onGeometryDrawTriangle()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEngineTriangle);
}

</t>
<t tx="leo.20201108101517.44">void Action::onGeometryDrawQuadrilateral()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEngineQuadrilateral);
}

</t>
<t tx="leo.20201108101517.45">void Action::onGeometryDrawCircle()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEngineCircle);
}

</t>
<t tx="leo.20201108101517.46">void Action::onGeometryDrawEllipse()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEngineEllipse);
}

</t>
<t tx="leo.20201108101517.47">void Action::onGeometryDrawTetrahedron()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEngineTetrahedron);
}

</t>
<t tx="leo.20201108101517.48">void Action::onGeometryDrawHexahedron()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEngineHexahedron);
}

</t>
<t tx="leo.20201108101517.49">void Action::onGeometryDrawCylinder()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEngineCylinder);
}

</t>
<t tx="leo.20201108101517.50">void Action::onGeometryDrawSphere()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEngineSphere);
}

</t>
<t tx="leo.20201108101517.51">void Action::onGeometryDrawRaw()
{
    Session::getInstance().getDrawEngine()-&gt;addObject(new DrawEngineRaw);
}

</t>
<t tx="leo.20201108101517.52">void Action::onGeometryCreateElement()
{
    PickList &amp;pickList = Session::getInstance().getPickList();

    if (pickList.getNItems(PICK_ITEM_NODE) == 0)
    {
        QMessageBox::information(this-&gt;mainWindow,
                                 tr("Create element"),
                                 tr("No node selected."),
                                 QMessageBox::Close);
        return;
    }

    QList&lt;uint&gt; modelIDs = pickList.getModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        uint nNodes = pickList.getNItems(PICK_ITEM_NODE,modelIDs[i]);

        RElementType elementType = R_ELEMENT_NONE;

        switch (nNodes)
        {
            case 0:
            {
                break;
            }
            case 1:
            {
                // Create point element.
                elementType = R_ELEMENT_POINT;
                break;
            }
            case 2:
            {
                // Create line element.
                elementType = R_ELEMENT_TRUSS1;
                break;
            }
            case 3:
            {
                // Create triangle element.
                elementType = R_ELEMENT_TRI1;
                break;
            }
            case 4:
            {
                // Create rectangle or tetrahedra element.
                QMessageBox msgBox(this-&gt;mainWindow);
                QPushButton *quadButton = msgBox.addButton(tr("Quadrilateral"), QMessageBox::YesRole);
                QPushButton *tetrButton = msgBox.addButton(tr("Tetrahedra"), QMessageBox::NoRole);

                msgBox.setWindowTitle(tr("Choose element type"));
                msgBox.setIcon(QMessageBox::Question);
                msgBox.setText(tr("Which element type to create?"));
                msgBox.exec();

                if (msgBox.clickedButton() == quadButton)
                {
                    // Create quadrilateral element.
                    elementType = R_ELEMENT_QUAD1;
                }
                else if (msgBox.clickedButton() == tetrButton)
                {
                    // Create tetrahedra element.
                    elementType = R_ELEMENT_TETRA1;
                }
                break;
            }
            default:
            {
                QMessageBox::information(this-&gt;mainWindow,
                                         tr("Create element"),
                                         tr("Too many nodes selected."),
                                         QMessageBox::Close);
                return;
            }
        }

        if (elementType == R_ELEMENT_NONE)
        {
            continue;
        }

        QList&lt;uint&gt; nodeIDs;

        QVector&lt;PickItem&gt; pickItems = pickList.getItems(modelIDs[i]);
        for (int j=0;j&lt;pickItems.size();j++)
        {
            if (pickItems[j].getItemType() == PICK_ITEM_NODE)
            {
                uint elementID = pickItems[j].getElementID();
                uint nodeID = pickItems[j].getNodeID();
                if (elementID != RConstants::eod &amp;&amp; nodeID != RConstants::eod)
                {
                    nodeIDs.append(nodeID);
                    pickList.removeItem(pickItems[j]);
                }
            }
        }

        ModelActionInput modelActionInput(modelIDs[i]);
        modelActionInput.setCreateElement(nodeIDs,elementType);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.53">void Action::onGeometryFindSliverElements()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        FindSliverElementsDialog findliverElementsDialog(modelIDs[i],this-&gt;mainWindow);
        findliverElementsDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.54">void Action::onGeometryFixSliverElements()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        FixSliverElementsDialog fixSliverElementsDialog(modelIDs[i],this-&gt;mainWindow);
        fixSliverElementsDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.55">void Action::onGeometryFindIntersectedElements()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        ModelActionInput modelActionInput(modelIDs[i]);
        modelActionInput.setFindIntersectedElements();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.56">void Action::onGeometryBreakIntersectedElements()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
//        // Questionable whether to remove volume elements
//        // It should not be possible to generate volume mesh if intersected elements are present
//        const Model &amp;rModel = Session::getInstance().getModel(modelIDs[i]);
//        if (rModel.getNVolumes() &gt; 0)
//        {
//            if (QMessageBox::question(this-&gt;mainWindow,
//                                      tr("Volume elements found"),
//                                      tr("To break intersected elements all volume elements must be removed.&lt;br/&gt;Are you sure you want to continue and remove all volume elements?"),
//                                      QMessageBox::No,
//                                      QMessageBox::Yes) == QMessageBox::No)
//            {
//                return;
//            }
//        }

        BreakIntersectedElementsDialog bieDialog(modelIDs[i],this-&gt;mainWindow);
        bieDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.57">void Action::onGeometryBoolUnion()
{
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        QList&lt;SessionEntityID&gt; entityIDs;

        for (int j=0;j&lt;selectedEntityIDs.size();j++)
        {
            if (selectedEntityIDs.at(j).getMid() == selectedModelIDs.at(i) &amp;&amp; selectedEntityIDs.at(j).getType() == R_ENTITY_GROUP_SURFACE)
            {
                entityIDs.push_back(selectedEntityIDs.at(j));
            }
        }

        if (entityIDs.size() &lt; 2)
        {
            QMessageBox::warning(this-&gt;mainWindow,
                              tr("Too few surfaces selected"),
                              tr("To perform union boolean operation at least two surfaces must be selected."));
            return;
        }

        for (int j=0;j&lt;entityIDs.size();j++)
        {
            const Model &amp;rModel = Session::getInstance().getModel(selectedModelIDs[i]);
            if (!rModel.checkIfSurfaceIsClosed(entityIDs[j].getEid()))
            {
                QMessageBox::warning(this-&gt;mainWindow,
                                     tr("Surface is not closed"),
                                     tr("Surface") + QString(" &lt;b&gt;") + rModel.getSurface(entityIDs[j].getEid()).getName()  + QString("&lt;/b&gt; ") + tr("is not closed.&lt;br/&gt;")
                                     + tr("To perform union boolean operation all selected surfaces must be closed."));
                return;
            }
        }

        BoolUnionDialog boolUnionDialog(selectedModelIDs[i],entityIDs,this-&gt;mainWindow);
        boolUnionDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.58">void Action::onGeometryBoolDifference()
{
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        QList&lt;SessionEntityID&gt; entityIDs;

        for (int j=0;j&lt;selectedEntityIDs.size();j++)
        {
            if (selectedEntityIDs.at(j).getMid() == selectedModelIDs.at(i) &amp;&amp; selectedEntityIDs.at(j).getType() == R_ENTITY_GROUP_SURFACE)
            {
                entityIDs.push_back(selectedEntityIDs.at(j));
            }
        }

        if (entityIDs.size() &lt; 2)
        {
            QMessageBox::warning(this-&gt;mainWindow,
                              tr("Too few surfaces selected"),
                              tr("To perform difference boolean operation at least two surfaces must be selected."));
            return;
        }

        for (int j=0;j&lt;entityIDs.size();j++)
        {
            const Model &amp;rModel = Session::getInstance().getModel(selectedModelIDs[i]);
            if (!rModel.checkIfSurfaceIsClosed(entityIDs[j].getEid()))
            {
                QMessageBox::warning(this-&gt;mainWindow,
                                     tr("Surface is not closed"),
                                     tr("Surface") + QString(" &lt;b&gt;") + rModel.getSurface(entityIDs[j].getEid()).getName()  + QString("&lt;/b&gt; ") + tr("is not closed.&lt;br/&gt;")
                                     + tr("To perform difference boolean operation all selected surfaces must be closed."));
                return;
            }
        }

        BoolDifferenceDialog boolDifferenceDialog(selectedModelIDs[i],entityIDs,this-&gt;mainWindow);
        boolDifferenceDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.59">void Action::onGeometryBoolIntersection()
{
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        QList&lt;SessionEntityID&gt; entityIDs;

        for (int j=0;j&lt;selectedEntityIDs.size();j++)
        {
            if (selectedEntityIDs.at(j).getMid() == selectedModelIDs.at(i) &amp;&amp; selectedEntityIDs.at(j).getType() == R_ENTITY_GROUP_SURFACE)
            {
                entityIDs.push_back(selectedEntityIDs.at(j));
            }
        }

        if (entityIDs.size() &lt; 2)
        {
            QMessageBox::warning(this-&gt;mainWindow,
                              tr("Too few surfaces selected"),
                              tr("To perform intersection boolean operation at least two surfaces must be selected."));
            return;
        }

        for (int j=0;j&lt;entityIDs.size();j++)
        {
            const Model &amp;rModel = Session::getInstance().getModel(selectedModelIDs[i]);
            if (!rModel.checkIfSurfaceIsClosed(entityIDs[j].getEid()))
            {
                QMessageBox::warning(this-&gt;mainWindow,
                                     tr("Surface is not closed"),
                                     tr("Surface") + QString(" &lt;b&gt;") + rModel.getSurface(entityIDs[j].getEid()).getName()  + QString("&lt;/b&gt; ") + tr("is not closed.&lt;br/&gt;")
                                     + tr("To perform intersection boolean operation all selected surfaces must be closed."));
                return;
            }
        }

        BoolIntersectionDialog boolIntersectionDialog(selectedModelIDs[i],entityIDs,this-&gt;mainWindow);
        boolIntersectionDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.60">void Action::onGeometryMergeNearNodes()
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        MergeNearNodesDialog mergeNearNodesDialog(selectedModelIDs[i],this-&gt;mainWindow);
        mergeNearNodesDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.61">void Action::onGeometryMoveNode()
{
    PickList &amp;pickList = Session::getInstance().getPickList();

    if (pickList.getNItems(PICK_ITEM_NODE) == 0)
    {
        QMessageBox::information(this-&gt;mainWindow,
                                 tr("Move node"),
                                 tr("No node selected."),
                                 QMessageBox::Close);
        return;
    }

    QList&lt;uint&gt; modelIDs = pickList.getModelIDs();
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QList&lt;uint&gt; nodeIDs;

        QVector&lt;PickItem&gt; pickItems = pickList.getItems(modelIDs[i]);
        for (int j=0;j&lt;pickItems.size();j++)
        {
            if (pickItems[j].getItemType() == PICK_ITEM_NODE)
            {
                uint elementID = pickItems[j].getElementID();
                uint lNodeID = pickItems[j].getNodeID();
                if (elementID != RConstants::eod &amp;&amp; lNodeID != RConstants::eod)
                {
                    nodeIDs.append(lNodeID);
                }
            }
        }

        if (nodeIDs.size() &gt; 0)
        {
            std::sort(nodeIDs.begin(),nodeIDs.end());

            MoveNodeDialog moveNodeDialog(modelIDs[i],nodeIDs,this-&gt;mainWindow);
            moveNodeDialog.exec();
        }
    }
}

</t>
<t tx="leo.20201108101517.62">void Action::onGeometryRemoveNode()
{
    PickList &amp;pickList = Session::getInstance().getPickList();

    if (pickList.getNItems(PICK_ITEM_NODE) == 0)
    {
        QMessageBox::information(this-&gt;mainWindow,
                                 tr("Remove nodes"),
                                 tr("No node selected."),
                                 QMessageBox::Close);
        return;
    }
    if (QMessageBox::question(this-&gt;mainWindow,
                               tr("Remove nodes"),
                               tr("Are you sure you want to remove picked nodes?"),
                               QMessageBox::No,
                               QMessageBox::Yes) == QMessageBox::No)
    {
        return;
    }

    QList&lt;uint&gt; modelIDs = pickList.getModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QList&lt;uint&gt; nodeIDs;

        QVector&lt;PickItem&gt; pickItems = pickList.getItems(modelIDs[i]);
        for (int j=0;j&lt;pickItems.size();j++)
        {
            if (pickItems[j].getItemType() == PICK_ITEM_NODE)
            {
                uint elementID = pickItems[j].getElementID();
                uint nodeID = pickItems[j].getNodeID();
                if (elementID != RConstants::eod &amp;&amp; nodeID != RConstants::eod)
                {
                    nodeIDs.append(nodeID);
                    pickList.removeItem(pickItems[j]);
                }
            }
        }

        ModelActionInput modelActionInput(modelIDs[i]);
        modelActionInput.setRemoveNodes(nodeIDs,false);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.63">void Action::onGeometryRemoveNodeAndCloseHole()
{
    PickList &amp;pickList = Session::getInstance().getPickList();

    if (pickList.getNItems(PICK_ITEM_NODE) == 0)
    {
        QMessageBox::information(this-&gt;mainWindow,
                                 tr("Remove nodes"),
                                 tr("No node selected."),
                                 QMessageBox::Close);
        return;
    }
    if (QMessageBox::question(this-&gt;mainWindow,
                               tr("Remove nodes"),
                               tr("Are you sure you want to remove picked nodes?"),
                               QMessageBox::No,
                               QMessageBox::Yes) == QMessageBox::No)
    {
        return;
    }

    QList&lt;uint&gt; modelIDs = pickList.getModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QList&lt;uint&gt; nodeIDs;

        QVector&lt;PickItem&gt; pickItems = pickList.getItems(modelIDs[i]);
        for (int j=0;j&lt;pickItems.size();j++)
        {
            if (pickItems[j].getItemType() == PICK_ITEM_NODE)
            {
                uint elementID = pickItems[j].getElementID();
                uint nodeID = pickItems[j].getNodeID();
                if (elementID != RConstants::eod &amp;&amp; nodeID != RConstants::eod)
                {
                    nodeIDs.append(nodeID);
                    pickList.removeItem(pickItems[j]);
                }
            }
        }

        ModelActionInput modelActionInput(modelIDs[i]);
        modelActionInput.setRemoveNodes(nodeIDs,true);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.64">void Action::onGeometryRemoveElement()
{
    PickList &amp;pickList = Session::getInstance().getPickList();

    if (pickList.getNItems(PICK_ITEM_ELEMENT) == 0)
    {
        QMessageBox::information(this-&gt;mainWindow,
                                 tr("Remove elements"),
                                 tr("No element selected."),
                                 QMessageBox::Close);
        return;
    }
    if (QMessageBox::question(this-&gt;mainWindow,
                               tr("Remove elements"),
                               tr("Are you sure you want to remove picked elements?"),
                               QMessageBox::No,
                               QMessageBox::Yes) == QMessageBox::No)
    {
        return;
    }

    QList&lt;uint&gt; modelIDs = pickList.getModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QList&lt;uint&gt; elementIDs;

        QVector&lt;PickItem&gt; pickItems = pickList.getItems(modelIDs[i]);
        for (int j=0;j&lt;pickItems.size();j++)
        {
            if (pickItems[j].getItemType() == PICK_ITEM_ELEMENT)
            {
                uint elementID = pickItems[j].getElementID();
                if (elementID != RConstants::eod)
                {
                    elementIDs.append(elementID);
                    pickList.removeItem(pickItems[j]);
                }
            }
        }

        ModelActionInput modelActionInput(modelIDs[i]);
        modelActionInput.setRemoveElements(elementIDs,false);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.65">void Action::onGeometryLineGenerateFromEdges()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        ModelActionInput modelActionInput(modelIDs[i]);
        modelActionInput.setGenerateLinesFromEdges(40.0);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.66">void Action::onGeometrySurfaceMark()
{
    MarkEntityDialog markEntityDialog(R_ENTITY_GROUP_SURFACE,this-&gt;mainWindow);
    markEntityDialog.exec();
}

</t>
<t tx="leo.20201108101517.67">void Action::onGeometrySurfaceSwapElementNormal()
{
    PickList &amp;pickList = Session::getInstance().getPickList();

    if (pickList.getNItems(PICK_ITEM_ELEMENT) == 0)
    {
        QMessageBox::information(this-&gt;mainWindow,
                                 tr("Swap element normal"),
                                 tr("No element selected."),
                                 QMessageBox::Close);
        return;
    }
    QList&lt;uint&gt; modelIDs = pickList.getModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QList&lt;uint&gt; elementIDs;
        QVector&lt;PickItem&gt; pickItems = pickList.getItems(modelIDs[i]);
        for (int j=0;j&lt;pickItems.size();j++)
        {
            if (pickItems[j].getItemType() == PICK_ITEM_ELEMENT)
            {
                uint elementID = pickItems[j].getElementID();
                if (elementID != RConstants::eod)
                {
                    elementIDs.append(elementID);
                    pickList.removeItem(pickItems[j]);
                }
            }
        }

        ModelActionInput modelActionInput(modelIDs[i]);
        modelActionInput.setSwapSurfaceElementNormal(elementIDs);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.68">void Action::onGeometrySurfaceSwapNormals()
{
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        QList&lt;SessionEntityID&gt; entityIDs;

        for (int j=0;j&lt;selectedEntityIDs.size();j++)
        {
            if (selectedEntityIDs.at(j).getMid() == selectedModelIDs.at(i))
            {
                entityIDs.push_back(selectedEntityIDs.at(j));
            }
        }

        ModelActionInput modelActionInput(selectedModelIDs.at(i));
        modelActionInput.setSwapSurfaceNormals(entityIDs);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.69">void Action::onGeometrySurfaceSyncNormals()
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        ModelActionInput modelActionInput(selectedModelIDs.at(i));
        modelActionInput.setSyncSurfaceNormals();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.70">void Action::onGeometrySurfaceCloseHole()
{
    PickList &amp;pickList = Session::getInstance().getPickList();

    if (pickList.getNItems(PICK_ITEM_HOLE_ELEMENT) == 0)
    {
        QMessageBox::information(this-&gt;mainWindow,
                                 tr("Close surface hole"),
                                 tr("No edge selected."),
                                 QMessageBox::Close);
        return;
    }

    foreach (uint modelID,pickList.getModelIDs())
    {
        QList&lt;uint&gt; holeIDs;

        QVector&lt;PickItem&gt; pickItems = pickList.getItems(modelID);
        for (int j=0;j&lt;pickItems.size();j++)
        {
            if (pickItems[j].getItemType() == PICK_ITEM_HOLE_ELEMENT)
            {
                uint elementID = pickItems[j].getElementID();
                if (elementID != RConstants::eod)
                {
                    holeIDs.append(elementID);
                    pickList.removeItem(pickItems[j]);
                }
            }
        }

        ModelActionInput modelActionInput(modelID);
        modelActionInput.setCloseSurfaceHole(holeIDs);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.71">void Action::onGeometrySurfaceCoarsen()
{
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        QList&lt;SessionEntityID&gt; entityIDs;

        for (int j=0;j&lt;selectedEntityIDs.size();j++)
        {
            if (selectedEntityIDs.at(j).getMid() == selectedModelIDs.at(i))
            {
                entityIDs.push_back(selectedEntityIDs.at(j));
            }
        }

        CoarsenSurfaceDialog coarsenSurfaceDialog(selectedModelIDs[i],entityIDs,this-&gt;mainWindow);
        coarsenSurfaceDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.72">void Action::onGeometryVectorFieldCreate()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        VectorFieldDialog vectorFieldDialog(modelIDs[i],this-&gt;mainWindow);
        vectorFieldDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.73">void Action::onGeometryVectorFieldEdit()
{
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs[i].getType() != R_ENTITY_GROUP_VECTOR_FIELD)
        {
            continue;
        }
        VectorFieldDialog vectorFieldDialog(entityIDs[i].getMid(),entityIDs[i].getEid(),this-&gt;mainWindow);
        vectorFieldDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.74">void Action::onGeometryScalarFieldCreate()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        ScalarFieldDialog scalarFieldDialog(modelIDs[i],this-&gt;mainWindow);
        scalarFieldDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.75">void Action::onGeometryScalarFieldEdit()
{
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs[i].getType() != R_ENTITY_GROUP_SCALAR_FIELD)
        {
            continue;
        }
        ScalarFieldDialog scalarFieldDialog(entityIDs[i].getMid(),entityIDs[i].getEid(),this-&gt;mainWindow);
        scalarFieldDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.76">void Action::onGeometryStreamLineCreate()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        StreamLineDialog streamLineDialog(modelIDs[i],this-&gt;mainWindow);
        streamLineDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.77">void Action::onGeometryStreamLineEdit()
{
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs[i].getType() != R_ENTITY_GROUP_STREAM_LINE)
        {
            continue;
        }
        StreamLineDialog streamLineDialog(entityIDs[i].getMid(),entityIDs[i].getEid(),this-&gt;mainWindow);
        streamLineDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.78">void Action::onGeometryCutCreate()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        CutDialog *cutDialog = new CutDialog(modelIDs[i],RConstants::eod,this-&gt;mainWindow);
        cutDialog-&gt;show();
    }
}

</t>
<t tx="leo.20201108101517.79">void Action::onGeometryCutEdit()
{
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs[i].getType() != R_ENTITY_GROUP_CUT)
        {
            continue;
        }
        CutDialog *cutDialog = new CutDialog(entityIDs[i].getMid(),entityIDs[i].getEid(),this-&gt;mainWindow);
        cutDialog-&gt;show();
    }
}

</t>
<t tx="leo.20201108101517.80">void Action::onGeometryIsoCreate()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        IsoDialog isoDialog(modelIDs[i],this-&gt;mainWindow);
        isoDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.81">void Action::onGeometryIsoEdit()
{
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs[i].getType() != R_ENTITY_GROUP_ISO)
        {
            continue;
        }
        IsoDialog isoDialog(entityIDs[i].getMid(),entityIDs[i].getEid(),this-&gt;mainWindow);
        isoDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.82">void Action::onGeometryEntityMerge()
{
    MergeEntityDialog mergeEntityDialog(R_ENTITY_GROUP_ELEMENT,this-&gt;mainWindow);
    mergeEntityDialog.exec();
}

</t>
<t tx="leo.20201108101517.83">void Action::onGeometryEntityRemove()
{
    RemoveEntityDialog removeEntityDialog(R_ENTITY_GROUP_ALL,this-&gt;mainWindow);
    removeEntityDialog.exec();
}

</t>
<t tx="leo.20201108101517.84">void Action::onGeometryGenerateTetrahedra()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        MeshGeneratorDialog meshGeneratorDialog(modelIDs[i],this-&gt;mainWindow);
        meshGeneratorDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.85">void Action::onGeometryTransform()
{
    MainWindow::getInstance()-&gt;showTransformGeometryWidget();
}

</t>
<t tx="leo.20201108101517.86">void Action::onGeometryDevExportSliverElements()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        ModelActionInput modelActionInput(modelIDs[i]);
        modelActionInput.setExportSliverElements();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.87">void Action::onGeometryDevExportIntersectedElements()
{
    foreach (uint modelID, Session::getInstance().getSelectedModelIDs())
    {
        ModelActionInput modelActionInput(modelID);
        modelActionInput.setExportIntersectedElements();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.88">void Action::onGeometryDevPurgeUnusedNodes()
{
    foreach (uint modelID, Session::getInstance().getSelectedModelIDs())
    {
        ModelActionInput modelActionInput(modelID);
        modelActionInput.setPurgeUnusedNodes();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.89">void Action::onGeometryDevPurgeUnusedElements()
{
    foreach (uint modelID, Session::getInstance().getSelectedModelIDs())
    {
        ModelActionInput modelActionInput(modelID);
        modelActionInput.setPurgeUnusedElements();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.90">void Action::onGeometryDevRemoveDuplicateNodes()
{
    foreach (uint modelID, Session::getInstance().getSelectedModelIDs())
    {
        ModelActionInput modelActionInput(modelID);
        modelActionInput.setRemoveDuplicateNodes();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.91">void Action::onGeometryDevRemoveDuplicateElements()
{
    foreach (uint modelID, Session::getInstance().getSelectedModelIDs())
    {
        ModelActionInput modelActionInput(modelID);
        modelActionInput.setRemoveDuplicateElements();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.92">void Action::onGeometryDevPointInsideSurface()
{
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        QList&lt;SessionEntityID&gt; entityIDs;
        QList&lt;uint&gt; surfaceIDs;

        for (int j=0;j&lt;selectedEntityIDs.size();j++)
        {
            if (selectedEntityIDs.at(j).getMid() == selectedModelIDs.at(i) &amp;&amp; selectedEntityIDs.at(j).getType() == R_ENTITY_GROUP_SURFACE)
            {
                entityIDs.append(selectedEntityIDs.at(j));
                surfaceIDs.append(selectedEntityIDs.at(j).getEid());
            }
        }

        if (entityIDs.size() == 0)
        {
            QMessageBox::warning(this-&gt;mainWindow,
                              tr("Too few surfaces selected"),
                              tr("To perform point inside check at least one surface must be selected."));
            return;
        }

        const Model &amp;rModel = Session::getInstance().getModel(selectedModelIDs[i]);
        if (!rModel.checkIfSurfacesAreClosed(surfaceIDs))
        {
            QMessageBox::warning(this-&gt;mainWindow,
                              tr("Unclosed surfaces"),
                              tr("Selected surfaces do not form closed surface."));
            return;
        }

        PointInsideSurfaceDialog pointInsideSurfaceDialog(selectedModelIDs[i],entityIDs,this-&gt;mainWindow);
        pointInsideSurfaceDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.93">void Action::onGeometryDevTetrahedralizeeSurface()
{
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        QList&lt;SessionEntityID&gt; entityIDs;
        QList&lt;uint&gt; surfaceIDs;

        for (int j=0;j&lt;selectedEntityIDs.size();j++)
        {
            if (selectedEntityIDs.at(j).getMid() == selectedModelIDs.at(i) &amp;&amp; selectedEntityIDs.at(j).getType() == R_ENTITY_GROUP_SURFACE)
            {
                entityIDs.append(selectedEntityIDs.at(j));
                surfaceIDs.append(selectedEntityIDs.at(j).getEid());
            }
        }

        if (entityIDs.size() == 0)
        {
            QMessageBox::warning(this-&gt;mainWindow,
                              tr("Too few surfaces selected"),
                              tr("To perform point inside check at least one surface must be selected."));
            return;
        }

        const Model &amp;rModel = Session::getInstance().getModel(selectedModelIDs[i]);
        if (!rModel.checkIfSurfacesAreClosed(surfaceIDs))
        {
            QMessageBox::warning(this-&gt;mainWindow,
                              tr("Unclosed surfaces"),
                              tr("Selected surfaces do not form closed surface."));
            return;
        }

        ModelActionInput modelActionInput(selectedModelIDs[i]);
        modelActionInput.setTetrahedralizeSurface(entityIDs);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.94">void Action::onGeometryDevConsolidate()
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        ModelActionInput modelActionInput(selectedModelIDs[i]);
        modelActionInput.setConsolidate();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101517.95">void Action::onProblemTaskFlow()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        ProblemTaskDialog problemTaskDialog(modelIDs[i],this-&gt;mainWindow);
        problemTaskDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.96">void Action::onProblemSolverSetup()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        MatrixSolverConfigDialog matrixSolverConfigDialog(modelIDs[i],this-&gt;mainWindow);
        matrixSolverConfigDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.97">void Action::onProblemDefineMonitoringPoints()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        MonitoringPointsDialog monitoringPointsDialog(modelIDs[i],this-&gt;mainWindow);
        monitoringPointsDialog.exec();
    }
}

</t>
<t tx="leo.20201108101517.98">void Action::onProblemReset()
{
    if (QMessageBox::question(this-&gt;mainWindow,
                               tr("Reset problem setup"),
                               tr("Are you sure you want to reset all problem setup including boundary, initial and environment conditions?"),
                               QMessageBox::No,
                               QMessageBox::Yes) == QMessageBox::No)
    {
        return;
    }

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().storeCurentModelVersion(modelIDs[i],tr("Problem reset"));
        Session::getInstance().getModel(modelIDs[i]).RProblem::operator =(RProblem());
        Session::getInstance().getModel(modelIDs[i]).clearBoundaryConditions();
        Session::getInstance().getModel(modelIDs[i]).clearInitialConditions();
        Session::getInstance().getModel(modelIDs[i]).clearEnvironmentConditions();
        Session::getInstance().getModel(modelIDs[i]).clearEntityVariableData();
        Session::getInstance().setModelChanged(modelIDs[i]);
    }
}

</t>
<t tx="leo.20201108101517.99">void Action::onSolverStart()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    // First perform checks whether setup is correct.
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Model &amp;rModel = Session::getInstance().getModel(modelIDs[i]);
        QString modelFileName = ModelIO::getModelSaveName(MainSettings::getInstance(),this-&gt;mainWindow,rModel);
        if (!modelFileName.isEmpty())
        {
            rModel.setFileName(modelFileName);
            SolverStartDialog solverStartDialog(modelIDs[i],this-&gt;mainWindow);
            solverStartDialog.exec();
        }
    }
}

</t>
<t tx="leo.20201108101518.1">typedef enum _BCTreeColumn
{
    BC_TREE_PROPERTY_NAME = 0,
    BC_TREE_PROPERTY_VALUE,
    BC_TREE_PROPERTY_UNITS,
    BC_TREE_PROPERTY_TYPE,
    BC_TREE_N_COLUMNS
} BCTreeColumn;

BCTree::BCTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setRootIsDecorated(true);
    this-&gt;setSelectionMode(QAbstractItemView::NoSelection);

    this-&gt;setColumnCount(BC_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(BC_TREE_PROPERTY_TYPE,QString("Property type"));
    headerItem-&gt;setText(BC_TREE_PROPERTY_NAME,QString("Property name"));
    headerItem-&gt;setText(BC_TREE_PROPERTY_VALUE,QString("Value"));
    headerItem-&gt;setText(BC_TREE_PROPERTY_UNITS,QString("Units"));
    this-&gt;setHeaderItem(headerItem);

    this-&gt;setColumnHidden(BC_TREE_PROPERTY_TYPE,true);

    this-&gt;populate();
}

</t>
<t tx="leo.20201108101518.10">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   bool_difference_dialog.cpp                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th March 2015                                         *
 *                                                                   *
 *  DESCRIPTION: Bool operation - difference dialog class definition *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include "bool_difference_dialog.h"
#include "model_action.h"
#include "job_manager.h"
#include "session.h"

BoolDifferenceDialog::BoolDifferenceDialog(uint modelID, const QList&lt;SessionEntityID&gt; &amp;entityIDs, QWidget *parent) :
    QDialog(parent),
    modelID(modelID)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Difference"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QLabel *label = new QLabel(tr("Select entity which will be substracted."));
    mainLayout-&gt;addWidget(label);

    this-&gt;listWidget = new QListWidget;
    this-&gt;listWidget-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    mainLayout-&gt;addWidget(this-&gt;listWidget);

    Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);
    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs[i].getMid() != this-&gt;modelID)
        {
            continue;
        }
        uint groupID = rModel.getEntityGroupID(entityIDs[i].getType(),entityIDs[i].getEid());
        if (groupID == RConstants::eod)
        {
            continue;
        }
        const REntityGroup *pEntityGroup = rModel.getEntityGroupPtr(groupID,true);
        if (!pEntityGroup)
        {
            continue;
        }
        this-&gt;entityIDs.push_back(entityIDs[i]);

        QListWidgetItem *item = new QListWidgetItem(this-&gt;listWidget);
        item-&gt;setText(pEntityGroup-&gt;getName());
        item-&gt;setSelected(true);
        item-&gt;setData(Qt::UserRole,QVariant(this-&gt;entityIDs.size()-1));
    }

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;QDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;QDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.100">void DocumentGenerator::insertH2(QTextCursor &amp;cursor, const QString &amp;text, bool useCurrentBlockFormat)
{
    if (!useCurrentBlockFormat)
    {
        QTextBlockFormat blockFormat;
        blockFormat.setIndent(0);
        blockFormat.setAlignment(Qt::AlignLeft);
        blockFormat.setTopMargin(10.0);
        blockFormat.setBottomMargin(5.0);
        cursor.insertBlock(blockFormat,QTextCharFormat());
    }
    QTextCharFormat textFormat = DocumentGenerator::getH2Format();
    textFormat.setFontPointSize(textFormat.fontPointSize() * this-&gt;fontSizeScale);
    if (this-&gt;enableHeaderCounters)
    {
        cursor.insertText(QString::number(this-&gt;headerCounters.nH1) +
                          "." +
                          QString::number(++this-&gt;headerCounters.nH2) +
                          " " + text,
                          textFormat);
    }
    else
    {
        cursor.insertText(text, textFormat);
    }
}

</t>
<t tx="leo.20201108101518.101">void DocumentGenerator::insertH3(QTextCursor &amp;cursor, const QString &amp;text, bool useCurrentBlockFormat)
{
    if (!useCurrentBlockFormat)
    {
        QTextBlockFormat blockFormat;
        blockFormat.setIndent(1);
        blockFormat.setAlignment(Qt::AlignLeft);
        blockFormat.setTopMargin(5.0);
        blockFormat.setBottomMargin(2.0);
        cursor.insertBlock(blockFormat,QTextCharFormat());
    }
    QTextCharFormat textFormat = DocumentGenerator::getH3Format();
    textFormat.setFontPointSize(textFormat.fontPointSize() * this-&gt;fontSizeScale);
    if (this-&gt;enableHeaderCounters)
    {
        cursor.insertText(QString::number(this-&gt;headerCounters.nH1) +
                          "." +
                          QString::number(this-&gt;headerCounters.nH2) +
                          "." +
                          QString::number(++this-&gt;headerCounters.nH3) +
                          " " +
                          text,
                          textFormat);
    }
    else
    {
        cursor.insertText(text, textFormat);
    }
}

</t>
<t tx="leo.20201108101518.102">void DocumentGenerator::insertH4(QTextCursor &amp;cursor, const QString &amp;text, bool useCurrentBlockFormat)
{
    if (!useCurrentBlockFormat)
    {
        QTextBlockFormat blockFormat;
        blockFormat.setIndent(2);
        blockFormat.setAlignment(Qt::AlignLeft);
        cursor.insertBlock(blockFormat,QTextCharFormat());
    }
    QTextCharFormat textFormat = DocumentGenerator::getH4Format();
    textFormat.setFontPointSize(textFormat.fontPointSize() * this-&gt;fontSizeScale);
    if (this-&gt;enableHeaderCounters)
    {
        cursor.insertText(QString::number(this-&gt;headerCounters.nH1) +
                          "." +
                          QString::number(this-&gt;headerCounters.nH2) +
                          "." +
                          QString::number(this-&gt;headerCounters.nH3) +
                          "." +
                          QString::number(++this-&gt;headerCounters.nH4) +
                          " " +
                          text,
                          textFormat);
    }
    else
    {
        cursor.insertText(text, textFormat);
    }
}

</t>
<t tx="leo.20201108101518.103">void DocumentGenerator::insertH5(QTextCursor &amp;cursor, const QString &amp;text, bool useCurrentBlockFormat)
{
    if (!useCurrentBlockFormat)
    {
        QTextBlockFormat blockFormat;
        blockFormat.setIndent(3);
        blockFormat.setAlignment(Qt::AlignLeft);
        cursor.insertBlock(blockFormat,QTextCharFormat());
    }
    QTextCharFormat textFormat = DocumentGenerator::getH5Format();
    textFormat.setFontPointSize(textFormat.fontPointSize() * this-&gt;fontSizeScale);
    if (this-&gt;enableHeaderCounters)
    {
        cursor.insertText(QString::number(this-&gt;headerCounters.nH1) +
                          "." +
                          QString::number(this-&gt;headerCounters.nH2) +
                          "." +
                          QString::number(this-&gt;headerCounters.nH3) +
                          "." +
                          QString::number(this-&gt;headerCounters.nH4) +
                          "." +
                          QString::number(++this-&gt;headerCounters.nH5) +
                          " " +
                          text,
                          textFormat);
    }
    else
    {
        cursor.insertText(text, textFormat);
    }
}

</t>
<t tx="leo.20201108101518.104">void DocumentGenerator::insertText(QTextCursor &amp;cursor, const QString &amp;text, bool useCurrentBlockFormat)
{
    if (!useCurrentBlockFormat)
    {
        QTextBlockFormat blockFormat;
        blockFormat.setAlignment(Qt::AlignLeft);
        cursor.insertBlock(blockFormat,QTextCharFormat());
    }
    QTextCharFormat textFormat = DocumentGenerator::getTextFormat();
    textFormat.setFontPointSize(textFormat.fontPointSize() * this-&gt;fontSizeScale);
    cursor.insertText(text,textFormat);
}

</t>
<t tx="leo.20201108101518.105">void DocumentGenerator::insertBold(QTextCursor &amp;cursor, const QString &amp;text, bool useCurrentBlockFormat)
{
    if (!useCurrentBlockFormat)
    {
        QTextBlockFormat blockFormat;
        blockFormat.setAlignment(Qt::AlignLeft);
        cursor.insertBlock(blockFormat,QTextCharFormat());
    }
    QTextCharFormat textFormat = DocumentGenerator::getBoldFormat();
    textFormat.setFontPointSize(textFormat.fontPointSize() * this-&gt;fontSizeScale);
    cursor.insertText(text,textFormat);
}

QTextTableFormat DocumentGenerator::getTableFormat(void)
{
    QTextTableFormat tableFormat;
    tableFormat.setCellPadding(1);
    tableFormat.setCellSpacing(0);
    tableFormat.setBorder(0.2);
    tableFormat.setHeaderRowCount(1);
    tableFormat.setBorderStyle(QTextFrameFormat::BorderStyle_Solid);
    tableFormat.setAlignment(Qt::AlignCenter);
    return tableFormat;
}

QTextBlockFormat DocumentGenerator::getBlockFormat(void)
{
    QTextBlockFormat blockFormat;
    blockFormat.setIndent(0);
    blockFormat.setAlignment(Qt::AlignLeft);
    return blockFormat;
}

QTextCharFormat DocumentGenerator::getH1Format(void)
{
    QTextCharFormat fmt;
    fmt.setFontPointSize(18.0);
    fmt.setFontCapitalization(QFont::AllUppercase);
    fmt.setFontWeight(QFont::Bold);
    return fmt;
}

QTextCharFormat DocumentGenerator::getH2Format(void)
{
    QTextCharFormat fmt;
    fmt.setFontPointSize(16.0);
    fmt.setFontWeight(QFont::Bold);
    return fmt;
}

QTextCharFormat DocumentGenerator::getH3Format(void)
{
    QTextCharFormat fmt;
    fmt.setFontPointSize(16.0);
    fmt.setFontWeight(QFont::Bold);
    return fmt;
}

QTextCharFormat DocumentGenerator::getH4Format(void)
{
    QTextCharFormat fmt;
    fmt.setFontPointSize(12.0);
    fmt.setFontWeight(QFont::Bold);
    return fmt;
}

QTextCharFormat DocumentGenerator::getH5Format(void)
{

    QTextCharFormat fmt;
    fmt.setFontPointSize(12.0);
    fmt.setFontUnderline(true);
    return fmt;
}

QTextCharFormat DocumentGenerator::getTextFormat(void)
{
    QTextCharFormat fmt;
    fmt.setFontPointSize(10.0);
    return fmt;
}

QTextCharFormat DocumentGenerator::getBoldFormat(void)
{
    QTextCharFormat fmt;
    fmt.setFontPointSize(10.0);
    fmt.setFontWeight(QFont::Bold);
    return fmt;
}
</t>
<t tx="leo.20201108101518.106">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   document_tree.cpp                                        *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   1-st October 2013                                        *
 *                                                                   *
 *  DESCRIPTION: Document tree class definition                      *
 *********************************************************************/

#include &lt;QDesktopServices&gt;

#include "document_tree.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.107">typedef enum _DocumentTreeColumn
{
    DOCUMENT_TREE_COLUMN_NAME = 0,
    DOCUMENT_TREE_COLUMN_FILENAME,
    DOCUMENT_TREE_COLUMN_MODEL_ID,
    DOCUMENT_TREE_COLUMN_IS_DOCUMENT,
    DOCUMENT_TREE_N_COLUMNS
} DocumentTreeColumn;

DocumentTree::DocumentTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setColumnCount(DOCUMENT_TREE_N_COLUMNS);
    this-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection);
    this-&gt;setRootIsDecorated(true);
    this-&gt;setAutoScroll(true);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(DOCUMENT_TREE_COLUMN_NAME,QString(tr("File name")));
    headerItem-&gt;setIcon(DOCUMENT_TREE_COLUMN_NAME,QIcon(":/icons/mime/pixmaps/range-file-document.svg"));
    this-&gt;setHeaderItem(headerItem);

    this-&gt;setColumnHidden(DOCUMENT_TREE_COLUMN_FILENAME,true);
    this-&gt;setColumnHidden(DOCUMENT_TREE_COLUMN_MODEL_ID,true);
    this-&gt;setColumnHidden(DOCUMENT_TREE_COLUMN_IS_DOCUMENT,true);

    this-&gt;sortByColumn(DOCUMENT_TREE_COLUMN_FILENAME,Qt::AscendingOrder);

    this-&gt;populate();

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelAdded,
                     this,
                     &amp;DocumentTree::onModelAdded);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelChanged,
                     this,
                     &amp;DocumentTree::onModelChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelRenamed,
                     this,
                     &amp;DocumentTree::onModelChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelRemoved,
                     this,
                     &amp;DocumentTree::onModelRemoved);

    QObject::connect(this,
                     &amp;QTreeWidget::itemDoubleClicked,
                     this,
                     &amp;DocumentTree::onItemDoubleClicked);

    QTimer *timer = new QTimer(this);
    QObject::connect(timer,
                     &amp;QTimer::timeout,
                     this,
                     &amp;DocumentTree::updateDocuments);
    timer-&gt;start(1000);
}

</t>
<t tx="leo.20201108101518.108">void DocumentTree::addDocument(QTreeWidgetItem *item, uint modelID, const QString &amp;filename)
{
    QFileInfo fi(filename);

    QTreeWidgetItem *childItem = new QTreeWidgetItem(item);

    childItem-&gt;setText(DOCUMENT_TREE_COLUMN_NAME,fi.fileName());
    childItem-&gt;setText(DOCUMENT_TREE_COLUMN_FILENAME,filename);
    childItem-&gt;setData(DOCUMENT_TREE_COLUMN_MODEL_ID,Qt::UserRole,QVariant(modelID));
    childItem-&gt;setData(DOCUMENT_TREE_COLUMN_IS_DOCUMENT,Qt::UserRole,QVariant(true));
}

</t>
<t tx="leo.20201108101518.109">void DocumentTree::populate(void)
{
    this-&gt;blockSignals(true);
    this-&gt;clear();
    this-&gt;blockSignals(false);

    for (uint i=0;i&lt;Session::getInstance().getNModels();i++)
    {
        this-&gt;onModelAdded(i);
    }
}

</t>
<t tx="leo.20201108101518.11">int BoolDifferenceDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        QList&lt;QListWidgetItem*&gt; selectedItems = this-&gt;listWidget-&gt;selectedItems();
        if (selectedItems.size() &gt; 0)
        {
            int position = selectedItems[0]-&gt;data(Qt::UserRole).toInt();
            if (position &gt;= 0 &amp;&amp; position &lt; this-&gt;entityIDs.size())
            {
                qSwap(this-&gt;entityIDs[position],this-&gt;entityIDs[this-&gt;entityIDs.size()-1]);
            }
        }

        ModelActionInput modelActionInput(this-&gt;modelID);
        modelActionInput.setBoolDifference(this-&gt;entityIDs);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }

    return retVal;
}
</t>
<t tx="leo.20201108101518.110">void DocumentTree::updateDocuments(void)
{
    if (!Session::getInstance().trylock())
    {
        return;
    }

    this-&gt;blockSignals(true);

    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        QTreeWidgetItem *item = this-&gt;topLevelItem(i);

        uint modelID = item-&gt;data(DOCUMENT_TREE_COLUMN_MODEL_ID,Qt::UserRole).toUInt();

        Model &amp;rModel = Session::getInstance().getModel(modelID);
        QList&lt;QString&gt; documentFiles = rModel.getDocumentFiles();
        QVector&lt;bool&gt; documentExistenceBook;
        documentExistenceBook.fill(false,documentFiles.size());

        int j = item-&gt;childCount() - 1;
        while (j &gt;= 0)
        {
            QTreeWidgetItem *childItem = item-&gt;child(j);

            int documentFilePosition = documentFiles.indexOf(childItem-&gt;text(DOCUMENT_TREE_COLUMN_FILENAME));
            if (documentFilePosition &gt;= 0)
            {
                documentExistenceBook[documentFilePosition] = true;
            }
            else
            {
                item-&gt;takeChild(j);
            }
            j --;
        }

        for (j=0;j&lt;documentFiles.size();j++)
        {
            if (!documentExistenceBook[j])
            {
                this-&gt;addDocument(item,modelID,documentFiles[j]);
            }
        }
    }

    this-&gt;blockSignals(false);

    Session::getInstance().unlock();
}

</t>
<t tx="leo.20201108101518.111">void DocumentTree::onModelAdded(uint modelID)
{
    this-&gt;blockSignals(true);
    Model &amp;rModel = Session::getInstance().getModel(modelID);

    QList&lt;QString&gt; documentFiles = rModel.getDocumentFiles();

    QTreeWidgetItem *item = new QTreeWidgetItem(this);
    item-&gt;setText(DOCUMENT_TREE_COLUMN_NAME,rModel.getName());
    item-&gt;setData(DOCUMENT_TREE_COLUMN_MODEL_ID,Qt::UserRole,QVariant(modelID));
    item-&gt;setData(DOCUMENT_TREE_COLUMN_IS_DOCUMENT,Qt::UserRole,QVariant(false));

    for (int i=0;i&lt;documentFiles.size();i++)
    {
        this-&gt;addDocument(item,modelID,documentFiles[i]);
    }
    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101518.112">void DocumentTree::onModelChanged(uint modelID)
{
    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        QTreeWidgetItem *item = this-&gt;topLevelItem(i);
        if (item-&gt;data(DOCUMENT_TREE_COLUMN_MODEL_ID,Qt::UserRole).toUInt() == modelID)
        {
            Model &amp;rModel = Session::getInstance().getModel(modelID);
            item-&gt;setText(DOCUMENT_TREE_COLUMN_NAME,rModel.getName());
        }
    }
}

</t>
<t tx="leo.20201108101518.113">void DocumentTree::onModelRemoved(uint modelID)
{
    int i = this-&gt;topLevelItemCount() - 1;
    while (i &gt;= 0)
    {
        if (this-&gt;topLevelItem(i)-&gt;data(DOCUMENT_TREE_COLUMN_MODEL_ID,Qt::UserRole).toUInt() == modelID)
        {
            this-&gt;takeTopLevelItem(i);
        }
        i--;
    }
    for (i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        QTreeWidgetItem *item = this-&gt;topLevelItem(i);
        uint oldModelID = item-&gt;data(DOCUMENT_TREE_COLUMN_MODEL_ID,Qt::UserRole).toUInt();
        if (oldModelID &gt; modelID)
        {
            item-&gt;setData(DOCUMENT_TREE_COLUMN_MODEL_ID,Qt::UserRole,QVariant(oldModelID-1));
        }
    }
}

</t>
<t tx="leo.20201108101518.114">void DocumentTree::onItemDoubleClicked(QTreeWidgetItem *item, int column)
{
    if (column == DOCUMENT_TREE_COLUMN_NAME)
    {
        if (item-&gt;data(DOCUMENT_TREE_COLUMN_IS_DOCUMENT,Qt::UserRole).toBool())
        {
            QString fileName = item-&gt;text(DOCUMENT_TREE_COLUMN_FILENAME);

            RLogger::info("Opening the file \'%s\'\n",fileName.toUtf8().constData());

            if (!QDesktopServices::openUrl(QUrl("file:///" + fileName)))
            {
                RLogger::error("Failed to open the file \'%s\'\n",fileName.toUtf8().constData());
            }
        }
    }
}
</t>
<t tx="leo.20201108101518.12">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   bool_intersection_dialog.cpp                             *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th March 2015                                         *
 *                                                                   *
 *  DESCRIPTION: Bool operation - intersection dialog class          *
 *               definition                                          *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include "bool_intersection_dialog.h"
#include "model_action.h"
#include "job_manager.h"
#include "session.h"

BoolIntersectionDialog::BoolIntersectionDialog(uint modelID, const QList&lt;SessionEntityID&gt; &amp;entityIDs, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityIDs(entityIDs)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Intersection"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QLabel *messageLabel = new QLabel(tr("Create intersection from selected surfaces?"));
    mainLayout-&gt;addWidget(messageLabel);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;QDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;QDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.13">int BoolIntersectionDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        ModelActionInput modelActionInput(this-&gt;modelID);
        modelActionInput.setBoolIntersection(this-&gt;entityIDs);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }

    return retVal;
}
</t>
<t tx="leo.20201108101518.14">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   bool_union_dialog.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th March 2015                                         *
 *                                                                   *
 *  DESCRIPTION: Bool operation - union dialog class definition      *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include "bool_union_dialog.h"
#include "model_action.h"
#include "job_manager.h"
#include "session.h"

BoolUnionDialog::BoolUnionDialog(uint modelID, const QList&lt;SessionEntityID&gt; &amp;entityIDs, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityIDs(entityIDs)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Union"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QLabel *messageLabel = new QLabel(tr("Create union from selected surfaces?"));
    mainLayout-&gt;addWidget(messageLabel);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;QDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;QDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.15">int BoolUnionDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        ModelActionInput modelActionInput(this-&gt;modelID);
        modelActionInput.setBoolUnion(this-&gt;entityIDs);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }

    return retVal;
}
</t>
<t tx="leo.20201108101518.16">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   break_intersected_elements_dialog.cpp                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   24-th March 2015                                         *
 *                                                                   *
 *  DESCRIPTION: Break intersected elements dialog class definition  *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include "break_intersected_elements_dialog.h"
#include "model_action.h"
#include "job_manager.h"
#include "session.h"


BreakIntersectedElementsDialog::BreakIntersectedElementsDialog(uint modelID, QWidget *parent)
    : QDialog(parent)
    , modelID(modelID)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Break intersected elements"));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout(mainLayout);

    uint mainLayoutRow = 0;

    QLabel *nIterationsLabel = new QLabel(tr("Number of iterations:"));
    mainLayout-&gt;addWidget(nIterationsLabel, mainLayoutRow,0,1,1);

    this-&gt;nIterationsSpin = new QSpinBox;
    this-&gt;nIterationsSpin-&gt;setRange(1,100);
    this-&gt;nIterationsSpin-&gt;setValue(3);
    mainLayout-&gt;addWidget(this-&gt;nIterationsSpin, mainLayoutRow,1,1,1);

    mainLayoutRow++;

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRow++, 0, 1, 2);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;QDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;QDialog::accept);

}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.17">int BreakIntersectedElementsDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        ModelActionInput modelActionInput(this-&gt;modelID);
        modelActionInput.setBreakIntersectedElements(uint(this-&gt;nIterationsSpin-&gt;value()));

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }

    return retVal;
}
</t>
<t tx="leo.20201108101518.18">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   central_tab_widget.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th December 2017                                      *
 *                                                                   *
 *  DESCRIPTION: Main window's central tab widget class definition   *
 *********************************************************************/

#include &lt;QMessageBox&gt;
#include &lt;QApplication&gt;
#include &lt;QScrollBar&gt;

#include "central_tab_widget.h"
#include "logger.h"
#include "session.h"
#include "solver_manager.h"

const QString CentralTabWidget::informationIconFile(":/icons/file/pixmaps/range-information.svg");
const QString CentralTabWidget::importantIconFile(":/icons/file/pixmaps/range-important.svg");
const QString CentralTabWidget::severeIconFile(":/icons/file/pixmaps/range-severe.svg");

const bool useTabIcons = false;

CentralTabWidget::CentralTabWidget(QWidget *parent)
    : QTabWidget(parent)
{
    this-&gt;setTabPosition(QTabWidget::South);

    this-&gt;mdiArea = new QMdiArea(this);
    this-&gt;mdiArea-&gt;setObjectName(QString::fromUtf8("mdiArea"));
    this-&gt;mdiArea-&gt;setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    this-&gt;mdiArea-&gt;setHorizontalScrollBarPolicy(Qt::ScrollBarAsNeeded);

    this-&gt;applicationOutputBrowser = new TextBrowser(true);
    this-&gt;processOutputBrowser = new TextBrowser(true);
    this-&gt;pickDetailsTree = new PickDetailsTree;


    this-&gt;modelTabPosition = this-&gt;addTab(this-&gt;mdiArea,QString());
    this-&gt;applicationOutputTabPosition = this-&gt;addTab(this-&gt;applicationOutputBrowser,QString());
    this-&gt;processOutputTabPosition = this-&gt;addTab(this-&gt;processOutputBrowser,QString());
    this-&gt;pickDetailsTabPosition = this-&gt;addTab(this-&gt;pickDetailsTree,QString());

    this-&gt;setTabTitle(CentralTabWidget::Model);
    this-&gt;setTabTitle(CentralTabWidget::ApplicationOutput);
    this-&gt;setTabTitle(CentralTabWidget::ProcessOutput);
    this-&gt;setTabTitle(CentralTabWidget::PickDetails);

    QObject::connect(this,&amp;QTabWidget::currentChanged,this,&amp;CentralTabWidget::onCurrentChanged);

    // Pick list signals
    QObject::connect(&amp;Session::getInstance().getPickList(),&amp;PickList::pickListChanged,this,&amp;CentralTabWidget::onPickLostChanged);

    // Logger signals
    QObject::connect(&amp;Logger::getInstance(),&amp;Logger::infoPrinted,this,&amp;CentralTabWidget::onInfoPrinted);
    QObject::connect(&amp;Logger::getInstance(),&amp;Logger::noticePrinted,this,&amp;CentralTabWidget::onNoticePrinted);
    QObject::connect(&amp;Logger::getInstance(),&amp;Logger::warningPrinted,this,&amp;CentralTabWidget::onWarningPrinted);
    QObject::connect(&amp;Logger::getInstance(),&amp;Logger::errorPrinted,this,&amp;CentralTabWidget::onErrorPrinted);

    // Solver manager signals
    QObject::connect(&amp;SolverManager::getInstance(),&amp;SolverManager::readyReadStandardOutput,this,&amp;CentralTabWidget::onProcessReadyStandardOutput);
    QObject::connect(&amp;SolverManager::getInstance(),&amp;SolverManager::readyReadStandardError,this,&amp;CentralTabWidget::onProcessReadyStandardError);
}

QMdiArea *CentralTabWidget::getMdiArea(void)
{
    return this-&gt;mdiArea;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.19">void CentralTabWidget::setTabTitle(CentralTabWidget::Type tabType, RMessageType messageType, const QString &amp;additionalText)
{
    QString defaultText;
    int tabPosition = 0;
    QString iconFile;

    if (tabType == CentralTabWidget::Model)
    {
        defaultText = tr("Model");
        tabPosition = this-&gt;modelTabPosition;
    }
    else if (tabType == CentralTabWidget::ApplicationOutput)
    {
        defaultText = tr("Application output");
        tabPosition = this-&gt;applicationOutputTabPosition;
        iconFile = this-&gt;applicationOutputLastIcon;
    }
    else if (tabType == CentralTabWidget::ProcessOutput)
    {
        defaultText = tr("Process output");
        tabPosition = this-&gt;processOutputTabPosition;
        iconFile = this-&gt;processOutputLastIcon;
    }
    else if (tabType == CentralTabWidget::PickDetails)
    {
        defaultText = tr("Pick details");
        tabPosition = this-&gt;pickDetailsTabPosition;
    }
    else
    {
        return;
    }

    if (!additionalText.isEmpty())
    {
        defaultText += " (" + additionalText + ")";
    }

    if (this-&gt;currentIndex() == tabPosition)
    {
        iconFile = QString();
    }
    else
    {
        if (messageType == R_MESSAGE_INFO)
        {
            if (iconFile != CentralTabWidget::importantIconFile &amp;&amp; iconFile != CentralTabWidget::severeIconFile)
            {
                iconFile = CentralTabWidget::informationIconFile;
            }
        }
        else if (messageType == R_MESSAGE_WARNING)
        {
            if (iconFile != CentralTabWidget::severeIconFile)
            {
                iconFile = CentralTabWidget::importantIconFile;
            }
        }
        else if (messageType == R_MESSAGE_ERROR)
        {
            iconFile = CentralTabWidget::severeIconFile;
        }
    }

    if (tabType == CentralTabWidget::ApplicationOutput)
    {
        this-&gt;applicationOutputLastIcon = iconFile;
    }
    else if (tabType == CentralTabWidget::ProcessOutput)
    {
        this-&gt;processOutputLastIcon = iconFile;
    }

    QColor tabTextColor = QApplication::palette().text().color();
    if (!iconFile.isEmpty())
    {
        // TODO: For unknown reason this hangs if text is printed from QDialog::exec()
        if (useTabIcons)
        {
            this-&gt;setTabIcon(tabPosition,QIcon(iconFile));
        }
        if (iconFile == CentralTabWidget::informationIconFile)
        {
            if (!useTabIcons)
            {
                defaultText.prepend("* ");
            }
            tabTextColor = Qt::darkCyan;
        }
        else if (iconFile == CentralTabWidget::importantIconFile)
        {
            if (!useTabIcons)
            {
                defaultText.prepend("! ");
            }
            tabTextColor = Qt::red;
        }
        else if (iconFile == CentralTabWidget::severeIconFile)
        {
            if (!useTabIcons)
            {
                defaultText.prepend("!!! ");
                defaultText.append(" !!!");
            }
            tabTextColor = Qt::red;
        }
    }
    this-&gt;tabBar()-&gt;setTabTextColor(tabPosition,tabTextColor);
    this-&gt;setTabText(tabPosition,defaultText);
}

</t>
<t tx="leo.20201108101518.2">void BCTree::populate(void)
{
    this-&gt;clear();

    for (uint i=0;i&lt;this-&gt;bc.size();i++)
    {
        RConditionComponent component = this-&gt;bc.getComponent(i);

        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setData(BC_TREE_PROPERTY_TYPE,Qt::DisplayRole,QVariant(component.getType()));
        item-&gt;setText(BC_TREE_PROPERTY_NAME,component.getName());
        item-&gt;setText(BC_TREE_PROPERTY_UNITS,component.getUnits());
        VariableValueEdit *lineEdit = new VariableValueEdit(component.getType());
        lineEdit-&gt;setValue(component.getValue(0));
        this-&gt;setItemWidget(item,BC_TREE_PROPERTY_VALUE,lineEdit);
        if (component.size() &gt; 1)
        {
            lineEdit-&gt;setDisabled(true);
        }

        QTreeWidgetItem *child = new QTreeWidgetItem(item);
        child-&gt;setFirstColumnSpanned(true);
        PushButton *buttonValues = new PushButton(uint(component.getType()),QString("Edit time dependent values"));
        this-&gt;setItemWidget(child,BC_TREE_PROPERTY_NAME,buttonValues);

        QObject::connect(lineEdit,&amp;VariableValueEdit::valueChanged,this,&amp;BCTree::onBcValueChanged);
        QObject::connect(buttonValues,&amp;PushButton::clicked,this,&amp;BCTree::onButtonValueClicked);
    }

    if (bc.getHasLocalDirection())
    {
        if (Session::selectedModelsHasEntitySelected(R_ENTITY_GROUP_POINT))
        {
            QTreeWidgetItem *item = new QTreeWidgetItem(this);
            item-&gt;setFirstColumnSpanned(true);

            DirectionWidget *directionWidget = new DirectionWidget(tr("Local direction"),bc.getLocalDirection());
            directionWidget-&gt;hideButtons();
            this-&gt;setItemWidget(item,BC_TREE_PROPERTY_NAME,directionWidget);

            QObject::connect(directionWidget,&amp;DirectionWidget::changed,this,&amp;BCTree::onDirectionChanged);
        }
        this-&gt;drawLocalRotationBegin();
    }
    else
    {
        this-&gt;drawLocalRotationEnd();
    }

    this-&gt;resizeColumnToContents(BC_TREE_PROPERTY_NAME);
    this-&gt;resizeColumnToContents(BC_TREE_PROPERTY_VALUE);
    this-&gt;resizeColumnToContents(BC_TREE_PROPERTY_UNITS);
}

</t>
<t tx="leo.20201108101518.20">void CentralTabWidget::onInfoPrinted(const QString &amp;message)
{
    QScrollBar *sb = this-&gt;applicationOutputBrowser-&gt;verticalScrollBar();
    int scrollBarValue = sb-&gt;value();
    bool scrollBarAtMax = ((sb-&gt;maximum() - scrollBarValue) &lt;= 10);

    this-&gt;applicationOutputBrowser-&gt;moveCursor(QTextCursor::End);
    this-&gt;applicationOutputBrowser-&gt;setTextBackgroundColor(QApplication::palette().base().color());
    this-&gt;applicationOutputBrowser-&gt;setTextColor(QApplication::palette().text().color());
    this-&gt;applicationOutputBrowser-&gt;insertPlainText(message);
    this-&gt;applicationOutputBrowser-&gt;moveCursor(QTextCursor::End);
    if (scrollBarAtMax)
    {
        scrollBarValue = sb-&gt;maximum();
    }
    sb-&gt;setValue(scrollBarValue);

    this-&gt;setTabTitle(CentralTabWidget::ApplicationOutput,R_MESSAGE_INFO);
}

</t>
<t tx="leo.20201108101518.21">void CentralTabWidget::onNoticePrinted(const QString &amp;message)
{
    QMessageBox::information(this,tr("Notice"),QString(message).replace("NOTICE: ",""));
}

</t>
<t tx="leo.20201108101518.22">void CentralTabWidget::onWarningPrinted(const QString &amp;message)
{
    QTextCharFormat charFormat = this-&gt;applicationOutputBrowser-&gt;currentCharFormat();

    this-&gt;applicationOutputBrowser-&gt;moveCursor(QTextCursor::End);
    this-&gt;applicationOutputBrowser-&gt;setTextBackgroundColor(QApplication::palette().base().color());
    this-&gt;applicationOutputBrowser-&gt;setTextColor(QColor(170,0,0));
    this-&gt;applicationOutputBrowser-&gt;insertPlainText(message);
    this-&gt;applicationOutputBrowser-&gt;moveCursor(QTextCursor::End);
    this-&gt;applicationOutputBrowser-&gt;setTextColor(QApplication::palette().text().color());
    this-&gt;applicationOutputBrowser-&gt;setCurrentCharFormat(charFormat);
    QScrollBar *sb = this-&gt;applicationOutputBrowser-&gt;verticalScrollBar();
    sb-&gt;setValue(sb-&gt;maximum());
    this-&gt;setTabTitle(CentralTabWidget::ApplicationOutput,R_MESSAGE_WARNING);
}

</t>
<t tx="leo.20201108101518.23">void CentralTabWidget::onErrorPrinted(const QString &amp;message)
{
    QTextCharFormat charFormat = this-&gt;applicationOutputBrowser-&gt;currentCharFormat();

    this-&gt;applicationOutputBrowser-&gt;moveCursor(QTextCursor::End);
    this-&gt;applicationOutputBrowser-&gt;setTextBackgroundColor(QColor(170,0,0));
    this-&gt;applicationOutputBrowser-&gt;setTextColor(QColor(255,255,255));
    this-&gt;applicationOutputBrowser-&gt;insertPlainText(message);
    this-&gt;applicationOutputBrowser-&gt;moveCursor(QTextCursor::End);
    this-&gt;applicationOutputBrowser-&gt;setTextBackgroundColor(QApplication::palette().base().color());
    this-&gt;applicationOutputBrowser-&gt;setTextColor(QApplication::palette().text().color());
    this-&gt;applicationOutputBrowser-&gt;setCurrentCharFormat(charFormat);
    QScrollBar *sb = this-&gt;applicationOutputBrowser-&gt;verticalScrollBar();
    sb-&gt;setValue(sb-&gt;maximum());
//    this-&gt;setCurrentIndex(this-&gt;applicationOutputTabPosition);
    this-&gt;setTabTitle(CentralTabWidget::ApplicationOutput,R_MESSAGE_ERROR);
}

</t>
<t tx="leo.20201108101518.24">void CentralTabWidget::onProcessReadyStandardOutput(const QString &amp;message)
{
    QScrollBar *sb = this-&gt;processOutputBrowser-&gt;verticalScrollBar();
    int scrollBarValue = sb-&gt;value();
    bool scrollBarAtMax = ((sb-&gt;maximum() - scrollBarValue) &lt;= 10);

    this-&gt;processOutputBrowser-&gt;moveCursor(QTextCursor::End);
    this-&gt;processOutputBrowser-&gt;setTextBackgroundColor(QApplication::palette().base().color());
    this-&gt;processOutputBrowser-&gt;setTextColor(QApplication::palette().text().color());
    this-&gt;processOutputBrowser-&gt;insertPlainText(message);
    this-&gt;processOutputBrowser-&gt;moveCursor(QTextCursor::End);
    if (scrollBarAtMax)
    {
        scrollBarValue = sb-&gt;maximum();
    }
    sb-&gt;setValue(scrollBarValue);

    QVector&lt;uint&gt; runningIDs = SolverManager::getInstance().getRunningIDs();
    static uint lastRunningID = 0;
    if (runningIDs.size() &gt; 0)
    {
        if (runningIDs[0] != lastRunningID)
        {
            this-&gt;setCurrentIndex(this-&gt;processOutputTabPosition);
            lastRunningID = runningIDs[0];
        }
    }

    this-&gt;setTabTitle(CentralTabWidget::ProcessOutput,R_MESSAGE_INFO);
}

</t>
<t tx="leo.20201108101518.25">void CentralTabWidget::onProcessReadyStandardError(const QString &amp;message)
{
    QTextCharFormat charFormat = this-&gt;processOutputBrowser-&gt;currentCharFormat();

    this-&gt;processOutputBrowser-&gt;moveCursor(QTextCursor::End);
    this-&gt;processOutputBrowser-&gt;setTextBackgroundColor(QColor(170,0,0));
    this-&gt;processOutputBrowser-&gt;setTextColor(QColor(255,255,255));
    this-&gt;processOutputBrowser-&gt;insertPlainText(message);
    this-&gt;processOutputBrowser-&gt;moveCursor(QTextCursor::End);
    this-&gt;processOutputBrowser-&gt;setTextBackgroundColor(QApplication::palette().base().color());
    this-&gt;processOutputBrowser-&gt;setTextColor(QApplication::palette().text().color());
    this-&gt;processOutputBrowser-&gt;setCurrentCharFormat(charFormat);
    QScrollBar *sb = this-&gt;processOutputBrowser-&gt;verticalScrollBar();
    sb-&gt;setValue(sb-&gt;maximum());
    this-&gt;setCurrentIndex(this-&gt;processOutputTabPosition);
    this-&gt;setTabTitle(CentralTabWidget::ProcessOutput,R_MESSAGE_ERROR);
}

</t>
<t tx="leo.20201108101518.26">void CentralTabWidget::onCurrentChanged(int tabPosition)
{
    if (useTabIcons)
    {
        this-&gt;setTabIcon(tabPosition,QIcon());
    }
    if (tabPosition == this-&gt;applicationOutputTabPosition)
    {
        this-&gt;setTabTitle(CentralTabWidget::ApplicationOutput);
    }
    else if (tabPosition == this-&gt;processOutputTabPosition)
    {
        this-&gt;setTabTitle(CentralTabWidget::ProcessOutput);
    }
}

</t>
<t tx="leo.20201108101518.27">void CentralTabWidget::onPickLostChanged(void)
{
    int nItems = Session::getInstance().getPickList().getItems().size();
    if (nItems &gt; 0)
    {
        this-&gt;setTabTitle(CentralTabWidget::PickDetails,R_MESSAGE_NONE,QString::number(nItems));
    }
    else
    {
        this-&gt;setTabTitle(CentralTabWidget::PickDetails);
    }
}
</t>
<t tx="leo.20201108101518.28">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   clipping_plane_widget.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   18-th March 2015                                         *
 *                                                                   *
 *  DESCRIPTION: Clipping plane widget class definition              *
 *********************************************************************/

#include &lt;QHBoxLayout&gt;

#include "clipping_plane_widget.h"

ClippingPlaneWidget::ClippingPlaneWidget(QWidget *parent) :
    QWidget(parent)
{
    bool isEnabled = false;

    QHBoxLayout *layout = new QHBoxLayout;
    this-&gt;setLayout(layout);

    this-&gt;enabledCheck = new QCheckBox(tr("Clipping plane"));
    this-&gt;enabledCheck-&gt;setChecked(isEnabled);
    layout-&gt;addWidget(this-&gt;enabledCheck);

    this-&gt;distanceLabel = new QLabel(tr("Distance"));
    this-&gt;distanceLabel-&gt;setEnabled(isEnabled);
    layout-&gt;addWidget(this-&gt;distanceLabel);

    this-&gt;distanceSlider = new QSlider(Qt::Horizontal);
    this-&gt;distanceSlider-&gt;setMinimum(0);
    this-&gt;distanceSlider-&gt;setMaximum(100);
    this-&gt;distanceSlider-&gt;setValue(50);
    this-&gt;distanceSlider-&gt;setEnabled(isEnabled);
    layout-&gt;addWidget(this-&gt;distanceSlider);

    QObject::connect(this-&gt;enabledCheck,&amp;QCheckBox::stateChanged,this,&amp;ClippingPlaneWidget::onStateChanged);
    QObject::connect(this-&gt;distanceSlider,&amp;QSlider::valueChanged,this,&amp;ClippingPlaneWidget::onValueChanged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.29">void ClippingPlaneWidget::onStateChanged(int state)
{
    this-&gt;distanceLabel-&gt;setDisabled(state == Qt::Unchecked);
    this-&gt;distanceSlider-&gt;setDisabled(state == Qt::Unchecked);

    emit this-&gt;changed(state != Qt::Unchecked,double(this-&gt;distanceSlider-&gt;value())/100.0);
}

</t>
<t tx="leo.20201108101518.3">void BCTree::updateSelectedEntities(void) const
{
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        switch (entityIDs[i].getType())
        {
            case R_ENTITY_GROUP_POINT:
                Session::getInstance().getModel(entityIDs[i].getMid()).getPoint(entityIDs[i].getEid()).addBoundaryCondition(this-&gt;bc);
                break;
            case R_ENTITY_GROUP_LINE:
                Session::getInstance().getModel(entityIDs[i].getMid()).getLine(entityIDs[i].getEid()).addBoundaryCondition(this-&gt;bc);
                break;
            case R_ENTITY_GROUP_SURFACE:
                Session::getInstance().getModel(entityIDs[i].getMid()).getSurface(entityIDs[i].getEid()).addBoundaryCondition(this-&gt;bc);
                break;
            case R_ENTITY_GROUP_VOLUME:
                Session::getInstance().getModel(entityIDs[i].getMid()).getVolume(entityIDs[i].getEid()).addBoundaryCondition(this-&gt;bc);
                break;
            default:
                break;
        }
        Session::getInstance().setBoundaryConditionChanged(entityIDs[i].getMid(),
                                                           entityIDs[i].getType(),
                                                           entityIDs[i].getEid());
    }

    foreach (uint modelID, Session::getInstance().getSelectedModelIDs())
    {
        Session::getInstance().setProblemChanged(modelID);
    }
}

</t>
<t tx="leo.20201108101518.30">void ClippingPlaneWidget::onValueChanged(int value)
{
    emit this-&gt;changed(this-&gt;enabledCheck-&gt;isChecked(),double(value)/100.0);
}
</t>
<t tx="leo.20201108101518.31">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   coarsen_surface_dialog.cpp                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th March 2015                                         *
 *                                                                   *
 *  DESCRIPTION: Coarsen surface dialog class definition             *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include &lt;float.h&gt;

#include &lt;rblib.h&gt;

#include "coarsen_surface_dialog.h"
#include "model_action.h"
#include "job_manager.h"
#include "session.h"

static uint mid = RConstants::eod;
static double edgeLength = RConstants::eps;
static double elementArea = RConstants::eps;

CoarsenSurfaceDialog::CoarsenSurfaceDialog(uint modelID, const QList&lt;SessionEntityID&gt; &amp;entityIDs, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityIDs(entityIDs)
{
    if (mid != modelID)
    {
        this-&gt;findGeometryLimits();
    }

    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Coarsen surface elements"));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout(mainLayout);

    uint mainLayoutRow = 0;

    QLabel *messageLabel = new QLabel(tr("Coarsen selected surfaces."));
    mainLayout-&gt;addWidget(messageLabel, mainLayoutRow++,0,1,2);

    QLabel *edgeLengthLabel = new QLabel(tr("Edge length:"));
    mainLayout-&gt;addWidget(edgeLengthLabel, mainLayoutRow,0,1,1);

    this-&gt;edgeLengthEdit = new ValueLineEdit(0.0,DBL_MAX);
    this-&gt;edgeLengthEdit-&gt;setValue(edgeLength);
    mainLayout-&gt;addWidget(this-&gt;edgeLengthEdit, mainLayoutRow,1,1,1);
    mainLayoutRow++;

    QLabel *elementAreaLabel = new QLabel(tr("Element area:"));
    mainLayout-&gt;addWidget(elementAreaLabel, mainLayoutRow,0,1,1);

    this-&gt;elementAreaEdit = new ValueLineEdit(0.0,DBL_MAX);
    this-&gt;elementAreaEdit-&gt;setValue(elementArea);
    mainLayout-&gt;addWidget(this-&gt;elementAreaEdit, mainLayoutRow,1,1,1);
    mainLayoutRow++;

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRow++, 0, 1, 2);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;QDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;QDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.32">int CoarsenSurfaceDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        mid = this-&gt;modelID;
        edgeLength = this-&gt;edgeLengthEdit-&gt;getValue();
        elementArea = this-&gt;elementAreaEdit-&gt;getValue();

        ModelActionInput modelActionInput(this-&gt;modelID);
        modelActionInput.setCoarsenSurface(this-&gt;entityIDs,this-&gt;edgeLengthEdit-&gt;getValue(),this-&gt;elementAreaEdit-&gt;getValue());

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }

    return retVal;
}

</t>
<t tx="leo.20201108101518.33">void CoarsenSurfaceDialog::findGeometryLimits(void)
{
    edgeLength = elementArea = RConstants::eps;

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    bool firstTime = true;
    for (uint i=0;i&lt;rModel.getNElements();i++)
    {
        const RElement &amp;rElement = rModel.getElement(i);

        if (!R_ELEMENT_TYPE_IS_SURFACE(rElement.getType()))
        {
            continue;
        }

        uint n1, n2;
        double lenght, area;

        if (!rElement.findShortestEdge(rModel.getNodes(),lenght,n1,n2))
        {
            continue;
        }

        if (!rElement.findArea(rModel.getNodes(),area))
        {
            continue;
        }

        if (firstTime)
        {
            edgeLength = lenght;
            elementArea = area;
            firstTime = false;
        }
        else
        {
            edgeLength = std::min(edgeLength,lenght);
            elementArea = std::min(elementArea,area);
        }
    }
}
</t>
<t tx="leo.20201108101518.34">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   color.cpp                                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th February 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Color class definition                              *
 *********************************************************************/

#include &lt;QtCore&gt;

#include "color.h"

Color::Color()
{
}

Color::Color(int r, int g, int b, int a) : QColor(r,g,b,a)
{
}

Color::Color(QRgb color) : QColor(color)
{
}

Color::Color(const QString &amp;name) : QColor(name)
{
}

Color::Color(const char *name) : QColor(name)
{
}

Color::Color(const QColor &amp;color) : QColor(color)
{
}

Color::Color(const Color &amp;color) : QColor(color)
{
}

Color::Color(Qt::GlobalColor color) : QColor(color)
{
}

Color &amp;Color::operator=(const Color &amp;color)
{
    this-&gt;QColor::operator=(color);
    return (*this);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.35">void Color::randomize(bool fromGlobal, bool excludeWhiteAndBlack)
{
    if (fromGlobal)
    {
        QList&lt;Qt::GlobalColor&gt; colorList = this-&gt;getGlobalColors(excludeWhiteAndBlack);
        int nColors = colorList.size();
        if (nColors == 0)
        {
            return;
        }
        int colorPos = int((nColors-1)*double(qrand())/double(RAND_MAX));
        this-&gt;operator = (colorList[colorPos]);
    }
    else
    {
        this-&gt;setRed(int(51.0*qrand()/(RAND_MAX*5.0)));
        this-&gt;setGreen(int(51.0*qrand()/(RAND_MAX*5.0)));
        this-&gt;setBlue(int(51.0*qrand()/(RAND_MAX*5.0)));
        this-&gt;setAlpha(255);
    }
}

QColor Color::random(bool fromGlobal, bool excludeWhiteAndBlack)
{
    Color color;
    color.randomize(fromGlobal,excludeWhiteAndBlack);
    return QColor(color.rgba());
}

QList&lt;Qt::GlobalColor&gt; Color::getGlobalColors(bool excludeWhiteAndBlack)
{
    QList&lt;Qt::GlobalColor&gt; colorList;
    if (!excludeWhiteAndBlack)
    {
        colorList.append(Qt::white);
        colorList.append(Qt::black);
    }
    colorList.append(Qt::red);
    colorList.append(Qt::darkRed);
    colorList.append(Qt::green);
    colorList.append(Qt::darkGreen);
    colorList.append(Qt::blue);
    colorList.append(Qt::darkBlue);
    colorList.append(Qt::cyan);
    colorList.append(Qt::darkCyan);
    colorList.append(Qt::magenta);
    colorList.append(Qt::darkMagenta);
    colorList.append(Qt::yellow);
    colorList.append(Qt::darkYellow);
    colorList.append(Qt::gray);
    colorList.append(Qt::darkGray);
    colorList.append(Qt::lightGray);
    return colorList;
}

QList&lt;Qt::GlobalColor&gt; Color::getPaintColors(void)
{
    QList&lt;Qt::GlobalColor&gt; colorList;
    colorList.append(Qt::red);
    colorList.append(Qt::green);
    colorList.append(Qt::blue);
    colorList.append(Qt::cyan);
    colorList.append(Qt::magenta);
    colorList.append(Qt::yellow);
    colorList.append(Qt::darkRed);
    colorList.append(Qt::darkGreen);
    colorList.append(Qt::darkBlue);
    colorList.append(Qt::darkCyan);
    colorList.append(Qt::darkMagenta);
    colorList.append(Qt::darkYellow);
    return colorList;
}
</t>
<t tx="leo.20201108101518.36">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   color_combo_box.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   16-th February 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Color combo box class definition                    *
 *********************************************************************/

#include &lt;QAbstractItemModel&gt;
#include &lt;QStandardItemModel&gt;
#include &lt;QColorDialog&gt;

#include "color.h"
#include "color_combo_box.h"

ColorComboBox::ColorComboBox(QWidget *parent) :
    QComboBox (parent),
    whFactor(3)
{
    this-&gt;addItem("Custom Color..");
    QList&lt;Qt::GlobalColor&gt; colorList = Color::getGlobalColors();
    for (int i=0;i&lt;colorList.size();i++)
    {
        this-&gt;addColor(QColor(colorList[i]));
    }

    this-&gt;setCurrentIndex(1);
    QSize iSize = this-&gt;iconSize();
    iSize.rwidth() *= this-&gt;whFactor;
    this-&gt;setIconSize(iSize);

    this-&gt;connect(this,SIGNAL(currentIndexChanged(int)),SLOT(onCurrentIndexChanged(int)));
}

QColor ColorComboBox::getColor(void)
{
    int index = this-&gt;currentIndex();
    if (index &gt; 0 &amp;&amp; index &lt; this-&gt;count())
    {
        return this-&gt;itemData(index).value&lt;QColor&gt;();
    }

    return Color::random(true);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.37">void ColorComboBox::setColor(const QColor &amp;color)
{
    this-&gt;setColorName(color.name());
}

QString ColorComboBox::getColorName(void)
{
    return this-&gt;getColor().name();
}

</t>
<t tx="leo.20201108101518.38">void ColorComboBox::setColorName(const QString &amp;colorName)
{
    if (!QColor(colorName).isValid())
    {
        return;
    }

    for (int i=1;i&lt;this-&gt;count();i++)
    {
        if (this-&gt;itemText(i) == colorName)
        {
            this-&gt;setCurrentIndex(i);
            return;
        }
    }
    this-&gt;addColor(colorName);
}

QIcon ColorComboBox::createIcon(const QString &amp;colorName)
{
    QPixmap iconPixmap(32*this-&gt;whFactor,32);
    iconPixmap.fill(QColor(colorName));
    QIcon itemIcon(iconPixmap);
    return itemIcon;
}

</t>
<t tx="leo.20201108101518.39">void ColorComboBox::addColor(const QColor &amp;color)
{
    this-&gt;addColor(color.name());
}

</t>
<t tx="leo.20201108101518.4">void BCTree::drawLocalRotationBegin()
{
    Session::getInstance().setBeginDrawLocalDirections(this-&gt;findSelectedEntityLocalDirections());
}

</t>
<t tx="leo.20201108101518.40">void ColorComboBox::addColor(const QString &amp;colorName)
{
    if (!QColor(colorName).isValid())
    {
        return;
    }

    this-&gt;addItem(this-&gt;createIcon(colorName),colorName,QColor(colorName));
    this-&gt;setCurrentIndex(this-&gt;count()-1);
}

</t>
<t tx="leo.20201108101518.41">void ColorComboBox::onCurrentIndexChanged(int index)
{
    if (index &gt; 0 &amp;&amp; index &lt; this-&gt;count())
    {
        emit this-&gt;colorChanged(this-&gt;itemData(index).value&lt;QColor&gt;());
        emit this-&gt;colorChanged(this-&gt;itemData(index).value&lt;QColor&gt;(),this-&gt;id);
        this-&gt;color = this-&gt;itemData(index).value&lt;QColor&gt;();
        return;
    }
    if (index == 0)
    {
        // Select custom color.
        QColor color = QColorDialog::getColor(this-&gt;color,this-&gt;parentWidget(),"Choose entity color",QColorDialog::ShowAlphaChannel);
        if (color.isValid())
        {
            this-&gt;setColor(color);
        }
    }
}
</t>
<t tx="leo.20201108101518.42">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   color_scale.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   3-rd May 2013                                            *
 *                                                                   *
 *  DESCRIPTION: Color scale class definition                        *
 *********************************************************************/

#include &lt;QDirIterator&gt;

#include "color_scale.h"

ColorScale::ColorScale(const QString &amp;scaleName, QObject *parent) :
    QObject(parent),
    scaleName(scaleName)
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.43">const QString &amp;ColorScale::getName(void) const
{
    return this-&gt;scaleName;
}

</t>
<t tx="leo.20201108101518.44">void ColorScale::setName(const QString &amp;scaleName)
{
    this-&gt;scaleName = scaleName;
    emit this-&gt;changed(this-&gt;scaleName);
}

</t>
<t tx="leo.20201108101518.45">bool ColorScale::validate(const QString &amp;scaleName)
{
    QDirIterator it(":/pixmaps/colorscale/", QDirIterator::Subdirectories);
    while (it.hasNext())
    {
        if (it.next() == scaleName)
        {
            return true;
        }
    }
    return false;
}

QList&lt;QString&gt; ColorScale::getColorScales(void)
{
    QList&lt;QString&gt; colorScales;
    QDirIterator it(":/pixmaps/colorscale/pixmaps/", QDirIterator::Subdirectories);
    while (it.hasNext())
    {
        colorScales.append(it.next());
    }
    std::sort(colorScales.begin(),colorScales.end());
    return colorScales;
}

QString ColorScale::getDefaultColorScale()
{
    QList&lt;QString&gt; colorScales = ColorScale::getColorScales();

    for (int i=0;i&lt;colorScales.size();i++)
    {
        if (colorScales[i].contains("01-RGB"))
        {
            return colorScales[i];
        }
    }

    if (colorScales.size() &gt; 0)
    {
        return colorScales[0];
    }
    else
    {
        return QString();
    }
}
</t>
<t tx="leo.20201108101518.46">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   color_scale_combo_box.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   3-rd May 2013                                            *
 *                                                                   *
 *  DESCRIPTION: Color scale combo box class definition              *
 *********************************************************************/

#include "color_scale.h"
#include "color_scale_combo_box.h"

ColorScaleComboBox::ColorScaleComboBox(QWidget *parent) :
    QComboBox(parent),
    whFactor(10)
{
    this-&gt;addItem("None");

    QList&lt;QString&gt; colorScales = ColorScale::getColorScales();
    for (int i=0;i&lt;colorScales.size();i++)
    {
        this-&gt;addItem(this-&gt;createIcon(colorScales[i]),
                      colorScales[i].section(QRegExp("[-.]"),3,3),
                      QColor(colorScales[i]));
        this-&gt;setItemData(i,QVariant(colorScales[i]));
    }

    this-&gt;setCurrentIndex(0);

    QSize iSize = this-&gt;iconSize();
    iSize.rwidth() *= this-&gt;whFactor;
    this-&gt;setIconSize(iSize);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.47">void ColorScaleComboBox::setColorScaleName(const QString &amp;colorScaleName)
{
    for (int i=0;i&lt;this-&gt;count();i++)
    {
        if (this-&gt;itemData(i).toString() == colorScaleName)
        {
            this-&gt;setCurrentIndex(i+1);
            return;
        }
    }
}

QIcon ColorScaleComboBox::createIcon(const QString &amp;colorScaleName)
{
    QPixmap iconPixmap;
    iconPixmap.load(colorScaleName);
    QTransform rotate_disc;
    rotate_disc.translate(iconPixmap.width()/2.0 , iconPixmap.height()/2.0);
    rotate_disc.translate(-iconPixmap.width()/2.0 , -iconPixmap.height()/2.0);
    QIcon itemIcon(iconPixmap.transformed(rotate_disc).scaled(32*this-&gt;whFactor,32));
    return itemIcon;
}
</t>
<t tx="leo.20201108101518.48">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   component_edit_dialog.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   2-nd August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Component edit dialog class definition              *
 *********************************************************************/

#include &lt;QPushButton&gt;
#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QSpinBox&gt;

#include "component_edit_dialog.h"
#include "session.h"

ComponentEditDialog::ComponentEditDialog(RConditionComponent &amp;component, QWidget *parent) :
    QDialog(parent),
    pComponent(&amp;component)
{
    this-&gt;setWindowTitle(QString("Component editor"));
    this-&gt;resize(400,500);

    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    int mainLayoutRow = 0;

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QHBoxLayout *nValuesLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(nValuesLayout, mainLayoutRow++, 0, 1, 1);

    QLabel *labelNValues = new QLabel(tr("Number of values:"));
    nValuesLayout-&gt;addWidget(labelNValues);

    QSpinBox *spinNValues = new QSpinBox;
    spinNValues-&gt;setRange(R_TIME_STEP_MIN_NUMBER,R_TIME_STEP_MAX_NUMBER);
    spinNValues-&gt;setValue(component.size());
    nValuesLayout-&gt;addWidget(spinNValues);

    nValuesLayout-&gt;addStretch(1);

    this-&gt;editTable = new ComponentEditTable(component, parent);
    mainLayout-&gt;addWidget(this-&gt;editTable, mainLayoutRow++, 0, 1, 1);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRow++, 0, 1, 1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    this-&gt;connect(spinNValues,SIGNAL(valueChanged(int)),SLOT(onSpinNValuesChanged(int)));

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;ComponentEditDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;ComponentEditDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.49">int ComponentEditDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted &amp;&amp; this-&gt;pComponent)
    {
        this-&gt;pComponent-&gt;clear();
        for (int i=0;i&lt;this-&gt;editTable-&gt;rowCount();i++)
        {
            this-&gt;pComponent-&gt;add(this-&gt;editTable-&gt;getKey(i),
                                  this-&gt;editTable-&gt;getValue(i));
        }
    }
    return retVal;
}

</t>
<t tx="leo.20201108101518.5">void BCTree::drawLocalRotationEnd()
{
    Session::getInstance().setEndDrawLocalDirections();
}

QList&lt;RLocalDirection&gt; BCTree::findSelectedEntityLocalDirections() const
{
    QList&lt;RLocalDirection&gt; localDirections;

    foreach (uint modelID, Session::getInstance().getSelectedModelIDs())
    {
        QSet&lt;uint&gt; nodeIDs;

        const Model &amp;rModel = Session::getInstance().getModel(modelID);
        foreach (const SessionEntityID &amp;entityID, rModel.getSelectedEntityIDs(modelID))
        {
            switch (entityID.getType())
            {
                case R_ENTITY_GROUP_POINT:
                {
                    const RPoint &amp;rPoint = rModel.getPoint(entityID.getEid());
                    for (uint i=0;i&lt;rPoint.size();i++)
                    {
                        const RElement &amp;rElement = rModel.getElement(rPoint.get(i));
                        for (uint j=0;j&lt;rElement.size();j++)
                        {
                            nodeIDs.insert(rElement.getNodeId(j));
                        }
                    }
                    break;
                }
                case R_ENTITY_GROUP_LINE:
                {
                    const RLine &amp;rLine = rModel.getLine(entityID.getEid());
                    for (uint i=0;i&lt;rLine.size();i++)
                    {
                        const RElement &amp;rElement = rModel.getElement(rLine.get(i));

                        RR3Vector center;
                        RR3Vector d1, d2, d3;

                        rElement.findCenter(rModel.getNodes(),center[0],center[1],center[2]);
                        RSegment(rModel.getNode(rElement.getNodeId(0)),rModel.getNode(rElement.getNodeId(1))).findPerpendicularVectors(d1,d2,d3);

                        localDirections.append(RLocalDirection(center,d2));
                        localDirections.append(RLocalDirection(center,d3));
                    }
                    break;
                }
                case R_ENTITY_GROUP_SURFACE:
                {
                    const RSurface &amp;rSurface = rModel.getSurface(entityID.getEid());
                    for (uint i=0;i&lt;rSurface.size();i++)
                    {
                        const RElement &amp;rElement = rModel.getElement(rSurface.get(i));

                        RR3Vector center;
                        RR3Vector normal;
                        rElement.findCenter(rModel.getNodes(),center[0],center[1],center[2]);
                        rElement.findNormal(rModel.getNodes(),normal[0],normal[1],normal[2]);

                        localDirections.append(RLocalDirection(center,normal));
                    }
                    break;
                }
                default:
                {
                    break;
                }
            }
        }
        foreach (uint nodeID, nodeIDs)
        {
            const RNode &amp;rNode = rModel.getNode(nodeID);
            localDirections.append(RLocalDirection(rNode.toVector(),bc.getLocalDirection()));
        }
    }

    return localDirections;
}

</t>
<t tx="leo.20201108101518.50">void ComponentEditDialog::onSpinNValuesChanged(int nValues)
{
    int oldRowCount = this-&gt;editTable-&gt;rowCount();

    if (oldRowCount &gt; nValues)
    {
        this-&gt;editTable-&gt;setRowCount(nValues);
        return;
    }

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    double timeStepSize = R_TIME_STEP_DEFAULT_SIZE;
    if (modelIDs.size() &gt; 0)
    {
        timeStepSize = Session::getInstance().getModel(modelIDs[0]).getTimeSolver().getInputTimeStepSize();
    }

    double currTime = this-&gt;editTable-&gt;getKey(oldRowCount-1);
    double value = this-&gt;editTable-&gt;getValue(oldRowCount-1);

    for (int i=oldRowCount;i&lt;nValues;i++)
    {
        currTime += timeStepSize;
        this-&gt;editTable-&gt;addValue(currTime,value);
    }
}
</t>
<t tx="leo.20201108101518.51">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   component_edit_table.cpp                                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   3-rd August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Component edit table class definition               *
 *********************************************************************/

#include "component_edit_table.h"

ComponentEditTable::ComponentEditTable(const RConditionComponent &amp;component, QWidget *parent) :
    ValueTable(parent)
{
    this-&gt;setKeyHeader(component.getKeyName());
    this-&gt;setValueHeader(component.getValueName());
    this-&gt;setDataType(RVariable::getDataType(component.getType()));
    this-&gt;populate(component);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.52">void ComponentEditTable::populate(const RConditionComponent &amp;component)
{
    for (uint i=0;i&lt;component.size();i++)
    {
        this-&gt;addValue(component.getKey(i),
                       component.getValue(i));
    }
    this-&gt;resizeColumnsToContents();
}
</t>
<t tx="leo.20201108101518.53">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   convergence_graph_dialog.cpp                             *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th February 2014                                       *
 *                                                                   *
 *  DESCRIPTION: Convergence graph dialog class definition           *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;
#include &lt;QTabWidget&gt;

#include &lt;rmlib.h&gt;

#include "convergence_graph_dialog.h"
#include "convergence_graph_widget.h"

ConvergenceGraphDialog::ConvergenceGraphDialog(const QStringList &amp;convergenceFileNames, QWidget *parent) :
    QDialog(parent)
{
    QIcon closeIcon(":/icons/file/pixmaps/range-close.svg");

    this-&gt;setWindowTitle(tr("Solver convergence"));
    this-&gt;resize(600,400);

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QTabWidget *tabWidget = new QTabWidget;
    mainLayout-&gt;addWidget(tabWidget);

    for (int i=0;i&lt;convergenceFileNames.size();i++)
    {
        ConvergenceGraphWidget *convergenceGraphWidget = new ConvergenceGraphWidget(convergenceFileNames.at(i),this);
        tabWidget-&gt;addTab(convergenceGraphWidget,ConvergenceGraphDialog::getNameFromID(convergenceFileNames.at(i),QString::number(i+1)));
    }

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(buttonsLayout);
    buttonsLayout-&gt;addStretch(1);

    QPushButton *closeButton = new QPushButton(closeIcon, tr("Close"));
    closeButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(closeButton);

    QObject::connect(closeButton,&amp;QPushButton::clicked,this,&amp;ConvergenceGraphDialog::close);
}

QString ConvergenceGraphDialog::getNameFromID(const QString &amp;fileName, const QString &amp;fallbackName)
{
    std::vector&lt;RProblemType&gt; problemTypes = RProblem::getTypes(R_PROBLEM_ALL);
    for (uint i=0;i&lt;problemTypes.size();i++)
    {
        if (fileName.contains("-" + RProblem::getId(problemTypes[i]) + "."))
        {
            return RProblem::getName(problemTypes[i]);
        }
    }

    for (RMatrixSolverType type=RMatrixSolverConf::None;type&lt;RMatrixSolverConf::NTypes;type++)
    {
        if (fileName.contains(RMatrixSolverConf::getId(type)))
        {
            return RMatrixSolverConf::getName(type);
        }
    }

    return fallbackName;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.54">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   convergence_graph_object.cpp                             *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   7-th March 2014                                          *
 *                                                                   *
 *  DESCRIPTION: Convergence graph object class definition           *
 *********************************************************************/

#include &lt;QFile&gt;
#include &lt;QTextStream&gt;

#include &lt;rblib.h&gt;

#include "convergence_graph_object.h"

ConvergenceGraphObject::ConvergenceGraphObject(QObject *parent) :
    GraphObject(parent),
    dataColumn(1)
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.55">const QString &amp;ConvergenceGraphObject::getSourceFileName(void) const
{
    return this-&gt;sourceFileName;
}

</t>
<t tx="leo.20201108101518.56">void ConvergenceGraphObject::setSourceFileName(const QString &amp;sourceFileName, bool loadData)
{
    this-&gt;sourceFileName = sourceFileName;
    if (loadData)
    {
        this-&gt;loadData();
    }
}

</t>
<t tx="leo.20201108101518.57">void ConvergenceGraphObject::setDataColumn(uint dataColumn, bool loadData)
{
    this-&gt;dataColumn = dataColumn;
    if (loadData)
    {
        this-&gt;loadData();
    }
}

</t>
<t tx="leo.20201108101518.58">bool ConvergenceGraphObject::isSourceSet(void) const
{
    return (!this-&gt;sourceFileName.isEmpty());
}

</t>
<t tx="leo.20201108101518.59">void ConvergenceGraphObject::clearSourceFile()
{
    QFile file(this-&gt;sourceFileName);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",sourceFileName.toUtf8().constData());
    }

    QTextStream in(&amp;file);

    QString line = in.readLine();
    file.close();

    if (!file.open(QFile::WriteOnly|QFile::Truncate))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to truncate the file \'%s\'.",this-&gt;sourceFileName.toUtf8().constData());
    }
    file.write(line.toUtf8().constData());
    file.write("\n");
    file.close();
    this-&gt;loadData();
}

QStringList ConvergenceGraphObject::findDataColumns(const QString &amp;sourceFileName)
{
    QFile file(sourceFileName);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",sourceFileName.toUtf8().constData());
    }

    QTextStream in(&amp;file);

    QString line = in.readLine();

    QStringList dataColumns = line.split(QRegExp("(\\||\\;)"));
    dataColumns.erase(dataColumns.begin());

    file.close();

    return dataColumns;
}

</t>
<t tx="leo.20201108101518.6">void BCTree::onBcSelected(RBoundaryConditionType bcType, bool applied)
{
    if (applied)
    {
        foreach (const SessionEntityID entityID,Session::getInstance().getSelectedEntityIDs())
        {
            switch (entityID.getType())
            {
                case R_ENTITY_GROUP_POINT:
                    this-&gt;bc = Session::getInstance().getModel(entityID.getMid()).getPoint(entityID.getEid()).getBoundaryCondition(bcType);
                    break;
                case R_ENTITY_GROUP_LINE:
                    this-&gt;bc = Session::getInstance().getModel(entityID.getMid()).getLine(entityID.getEid()).getBoundaryCondition(bcType);
                    break;
                case R_ENTITY_GROUP_SURFACE:
                    this-&gt;bc = Session::getInstance().getModel(entityID.getMid()).getSurface(entityID.getEid()).getBoundaryCondition(bcType);
                    break;
                case R_ENTITY_GROUP_VOLUME:
                    this-&gt;bc = Session::getInstance().getModel(entityID.getMid()).getVolume(entityID.getEid()).getBoundaryCondition(bcType);
                    break;
                default:
                    this-&gt;bc.setType(bcType);
                    break;
            }
        }

        this-&gt;populate();
    }
    else
    {
        this-&gt;bc.setType(R_BOUNDARY_CONDITION_NONE);
        this-&gt;drawLocalRotationEnd();
        this-&gt;clear();
    }
}

</t>
<t tx="leo.20201108101518.60">void ConvergenceGraphObject::readSource(void)
{
    if (!this-&gt;isSourceSet())
    {
        return;
    }

    QFile file(this-&gt;sourceFileName);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",this-&gt;sourceFileName.toUtf8().constData());
    }

    QTextStream in(&amp;file);

    double iteration;
    RRVector error(1);

    this-&gt;graphData.setTitle(tr("Convergence"));
    this-&gt;graphData.setTypeMask(GRAPH_LINES);

    this-&gt;graphData.clear();

    bool isFirst = true;
    while (!in.atEnd())
    {
        QString line = in.readLine();

        QStringList query = line.split(QRegExp("(\\||\\;)"));

        if (uint(query.size()) &lt; this-&gt;dataColumn + 1)
        {
            file.close();
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid file format. Expected %u columns but found only %d.",this-&gt;dataColumn + 1,query.size());
        }

        // First line is header
        if (isFirst)
        {
            isFirst = false;
            this-&gt;graphData.setXLabel(query.at(0));
            this-&gt;graphData.setYLabel(query.at(this-&gt;dataColumn));
        }
        else
        {
            iteration = query.at(0).toDouble();
            error[0] = query.at(this-&gt;dataColumn).toDouble();

            this-&gt;graphData[iteration] = error;
        }
    }

    file.close();
}
</t>
<t tx="leo.20201108101518.61">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   convergence_graph_widget.cpp                             *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   21-st September 2017                                     *
 *                                                                   *
 *  DESCRIPTION: Convergence graph widget class definition           *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include &lt;QMessageBox&gt;

#include "convergence_graph_widget.h"
#include "graph_widget.h"

ConvergenceGraphWidget::ConvergenceGraphWidget(const QString &amp;convergenceFileName, QWidget *parent) : QWidget(parent)
{
    QIcon clearIcon(":/icons/file/pixmaps/range-clear.svg");

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *label = new QLabel("Source: &lt;i&gt;" + convergenceFileName + "&lt;/i&gt;");
    mainLayout-&gt;addWidget(label);

    this-&gt;dataColumnCombo = new QComboBox;
    this-&gt;dataColumnCombo-&gt;addItems(ConvergenceGraphObject::findDataColumns(convergenceFileName));
    this-&gt;dataColumnCombo-&gt;setCurrentIndex(0);
    mainLayout-&gt;addWidget(this-&gt;dataColumnCombo);

    this-&gt;connect(this-&gt;dataColumnCombo,SIGNAL(currentIndexChanged(int)),SLOT(onCurrentIndexChanged(int)));

    this-&gt;graphObject = new ConvergenceGraphObject;
    this-&gt;graphObject-&gt;setSourceFileName(convergenceFileName);
    this-&gt;graphObject-&gt;setSourceReadInterval(1000);

    GraphWidget *graphWidget = new GraphWidget(graphObject,false,this);
    mainLayout-&gt;addWidget(graphWidget);
    graphWidget-&gt;setPaintGraphLimits(false);
    graphWidget-&gt;setPaintY0(true);

    QPushButton *clearButton = new QPushButton(clearIcon, tr("Clear"));
    mainLayout-&gt;addWidget(clearButton);

    QObject::connect(clearButton,&amp;QPushButton::clicked,this,&amp;ConvergenceGraphWidget::onClearButtonClicked);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.62">void ConvergenceGraphWidget::onCurrentIndexChanged(int index)
{
    this-&gt;graphObject-&gt;setDataColumn(index+1,true);
}

</t>
<t tx="leo.20201108101518.63">void ConvergenceGraphWidget::onClearButtonClicked(void)
{
    try
    {
        @others
}
</t>
<t tx="leo.20201108101518.64">    int response = QMessageBox::question(this,
                                      tr("Clear convergence log"),
                                      tr("Are you sure you want to clear cconvergence log?"),
                                      QMessageBox::Yes | QMessageBox::No,
                                      QMessageBox::No);
    if (response == QMessageBox::Yes)
    {
        this-&gt;graphObject-&gt;clearSourceFile();
    }
}
catch (RError &amp;error)
{
    RLogger::error("Failed to clear graph source. %s\n",error.getMessage().toUtf8().constData());
}
</t>
<t tx="leo.20201108101518.65">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   crash_report_dialog.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   25-th October 2019                                       *
 *                                                                   *
 *  DESCRIPTION: Crash report dialog class definition                *
 *********************************************************************/

#include &lt;QFile&gt;
#include &lt;QIcon&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;
#include &lt;QGroupBox&gt;

#include "crash_report_dialog.h"
#include "rra_session.h"

CrashReportDialog::CrashReportDialog(QWidget *parent, const QString &amp;logFile)
    : QDialog(parent)
{
    bool hasLogFile = QFile::exists(logFile);

    QIcon closeIcon(":/icons/file/pixmaps/range-close.svg");
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");
    QIcon importantIcon(":/icons/file/pixmaps/range-important.svg");

    this-&gt;setWindowTitle(tr("Crash report"));
    this-&gt;resize(900,600);

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QHBoxLayout *titleLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(titleLayout);

    QLabel *titlePixmapLabel = new QLabel;
    titlePixmapLabel-&gt;setPixmap(importantIcon.pixmap(64,64));
    titleLayout-&gt;addWidget(titlePixmapLabel);

    QLabel *titleLabel = new QLabel(tr("Previous instance has terminated unexpectedly.") + "\n" + tr("Would you like to report the crash?"));
    titleLabel-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Maximum);
    titleLayout-&gt;addWidget(titleLabel);

    if (hasLogFile)
    {
        QGroupBox *logGroupBox = new QGroupBox(tr("Log file from crashed instance"));
        logGroupBox-&gt;setCheckable(false);
        logGroupBox-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
        mainLayout-&gt;addWidget(logGroupBox);

        QVBoxLayout *logGroupLayout = new QVBoxLayout;
        logGroupBox-&gt;setLayout(logGroupLayout);

        this-&gt;logBrowser = new LogBrowser(logFile);
        logGroupLayout-&gt;addWidget(logBrowser);
    }

    QGroupBox *userGroupBox = new QGroupBox(tr("Additional information"));
    userGroupBox-&gt;setCheckable(false);
    userGroupBox-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    mainLayout-&gt;addWidget(userGroupBox);

    QVBoxLayout *userGroupLayout = new QVBoxLayout;
    userGroupBox-&gt;setLayout(userGroupLayout);

    this-&gt;textEdit = new QPlainTextEdit;
    userGroupLayout-&gt;addWidget(this-&gt;textEdit);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Report"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;QDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;QDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.66">int CrashReportDialog::exec()
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        QString crashReport = "LOG BEGIN:\n"
                            + logBrowser-&gt;toPlainText()
                            + "\nLOG END\n"
                            + "USER BEGIN\n"
                            + textEdit-&gt;toPlainText()
                            + "\nUSER END\n";
        RRASession::getInstance().submitCrashReport(crashReport);
    }
    return retVal;
}
</t>
<t tx="leo.20201108101518.67">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   cut_dialog.cpp                                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   22-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Cut dialog class definition                         *
 *********************************************************************/

#include &lt;cmath&gt;

#include &lt;QGridLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;
#include &lt;QGroupBox&gt;
#include &lt;QSlider&gt;

#include "session.h"
#include "cut_dialog.h"
#include "direction_widget.h"
#include "position_widget.h"

CutDialog::CutDialog(uint modelID, uint entityID, QWidget *parent)
    : QDialog(parent)
    , modelID(modelID)
    , entityID(entityID)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Cut editor"));
    this-&gt;resize(500,650);

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *titleLabel = new QLabel;
    if (this-&gt;entityID == RConstants::eod)
    {
        titleLabel-&gt;setText(tr("Create new cut."));
    }
    else
    {
        titleLabel-&gt;setText(tr("Modify cut:") + " &lt;b&gt;" + Session::getInstance().getModel(modelID).getCut(entityID).getName() + "&lt;/b&gt;");
    }
    mainLayout-&gt;addWidget(titleLabel, 0, 0, 1, 1);

    REntityGroupTypeMask typeMask = R_ENTITY_GROUP_POINT
                                  | R_ENTITY_GROUP_LINE
                                  | R_ENTITY_GROUP_SURFACE
                                  | R_ENTITY_GROUP_VOLUME;

    Model &amp;rModel = Session::getInstance().getModel(modelID);

    this-&gt;modelTree = new ModelTreeSimple(this-&gt;modelID,typeMask,this);
    if (this-&gt;entityID != RConstants::eod)
    {
        const RCut &amp;rCut = rModel.getCut(entityID);
        this-&gt;cutPlane = rCut.getPlane();

        const std::vector&lt;unsigned int&gt; groupIDs = rCut.getElementGroupIDs();
        this-&gt;modelTree-&gt;clearSelection();
        for (uint i=0;i&lt;groupIDs.size();i++)
        {
            REntityGroupType entityGroupType;
            uint entityIDNum;
            if (rModel.getEntityID(groupIDs[i],entityGroupType,entityIDNum))
            {
                this-&gt;modelTree-&gt;selectEntity(modelID,entityGroupType,entityIDNum);
            }
        }
    }
    else
    {
        RR3Vector position;
        rModel.findNodeCenter(position[0],position[1],position[2]);
        this-&gt;cutPlane.setPosition(position);
    }
    mainLayout-&gt;addWidget(this-&gt;modelTree, 1, 0, 1, 1);

    QObject::connect(this-&gt;modelTree,
                     &amp;ModelTreeSimple::itemSelectionChanged,
                     this,
                     &amp;CutDialog::onModelTreeSelectionChanged);

    double xMin = 0.0;
    double xMax = 0.0;
    double yMin = 0.0;
    double yMax = 0.0;
    double zMin = 0.0;
    double zMax = 0.0;

    rModel.findNodeLimits(xMin,xMax,yMin,yMax,zMin,zMax);

    double dx = xMax - xMin;
    double dy = yMax - yMin;
    double dz = zMax - zMin;

    xMin -= dx;
    xMax += dx;

    yMin -= dy;
    yMax += dy;

    zMin -= dz;
    zMax += dz;

    PositionWidget *positionWidget = new PositionWidget("Plane position",this-&gt;cutPlane.getPosition());
    positionWidget-&gt;hideButtons();
    positionWidget-&gt;hidePickButton();
    positionWidget-&gt;setXRange(xMin,xMax);
    positionWidget-&gt;setYRange(yMin,yMax);
    positionWidget-&gt;setZRange(zMin,zMax);
    mainLayout-&gt;addWidget(positionWidget, 2, 0, 1, 1);

    DirectionWidget *directionWidget = new DirectionWidget("Plane normal",this-&gt;cutPlane.getNormal());
    directionWidget-&gt;hideButtons();
    mainLayout-&gt;addWidget(directionWidget, 3, 0, 1, 1);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, 4, 0, 1, 1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setEnabled(this-&gt;modelTree-&gt;selectedItems().size());
    this-&gt;okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(positionWidget,&amp;PositionWidget::changed,this,&amp;CutDialog::onPositionChanged);
    QObject::connect(directionWidget,&amp;DirectionWidget::changed,this,&amp;CutDialog::onDirectionChanged);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;CutDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;CutDialog::accept);

    Session::getInstance().setBeginDrawCutPlane(this-&gt;cutPlane);

    QObject::connect(this,&amp;QDialog::rejected,this,&amp;CutDialog::onReject);
    QObject::connect(this,&amp;QDialog::accepted,this,&amp;CutDialog::onAccept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.68">void CutDialog::onAccept(void)
{
    Session::getInstance().storeCurentModelVersion(this-&gt;modelID,tr("Create a cut"));

    QList&lt;SessionEntityID&gt; entities = this-&gt;modelTree-&gt;getSelected();

    if (this-&gt;entityID != RConstants::eod)
    {
        RCut &amp;rCut = Session::getInstance().getModel(this-&gt;modelID).getCut(this-&gt;entityID);

        rCut.setPlane(this-&gt;cutPlane);

        rCut.clearElementGroupIDs();

        for (int i=0;i&lt;entities.size();i++)
        {
            uint elementGroupId = Session::getInstance().getModel(this-&gt;modelID).getElementGroupID(entities[i].getType(),
                                                                                                   entities[i].getEid());
            if (elementGroupId == RConstants::eod)
            {
                continue;
            }
            rCut.addElementGroupID(elementGroupId);
        }

        RLogger::info("Modified vector field \'%s\'\n",rCut.getName().toUtf8().constData());
    }
    else
    {
        RCut cut;

        cut.setName("Cut");
        cut.setPlane(this-&gt;cutPlane);

        for (int i=0;i&lt;entities.size();i++)
        {
            uint elementGroupId = Session::getInstance().getModel(this-&gt;modelID).getElementGroupID(entities[i].getType(),
                                                                                                   entities[i].getEid());
            cut.addElementGroupID(elementGroupId);
        }

        Session::getInstance().getModel(this-&gt;modelID).addCut(cut);
        RLogger::info("Created new vector field \'%s\'\n",cut.getName().toUtf8().constData());
    }

    Session::getInstance().setModelChanged(this-&gt;modelID);

    this-&gt;close();
    Session::getInstance().setEndDrawCutPlane();
}

</t>
<t tx="leo.20201108101518.69">void CutDialog::onReject(void)
{
    this-&gt;close();
    Session::getInstance().setEndDrawCutPlane();
}

</t>
<t tx="leo.20201108101518.7">void BCTree::onBcValueChanged(RVariableType variableType, double value)
{
    for (uint i=0;i&lt;this-&gt;bc.size();i++)
    {
        if (this-&gt;bc.getComponent(i).getType() == variableType)
        {
            this-&gt;bc.getComponent(i).add(0,value);
        }
    }

    this-&gt;updateSelectedEntities();
}

</t>
<t tx="leo.20201108101518.70">void CutDialog::onPositionChanged(const RR3Vector &amp;position)
{
    this-&gt;cutPlane.setPosition(position);
    Session::getInstance().setBeginDrawCutPlane(this-&gt;cutPlane);
}

</t>
<t tx="leo.20201108101518.71">void CutDialog::onDirectionChanged(const RR3Vector &amp;direction)
{
    this-&gt;cutPlane.setNormal(direction);
    Session::getInstance().setBeginDrawCutPlane(this-&gt;cutPlane);
}

</t>
<t tx="leo.20201108101518.72">void CutDialog::onModelTreeSelectionChanged(void)
{
    this-&gt;okButton-&gt;setEnabled(this-&gt;modelTree-&gt;selectedItems().size());
}
</t>
<t tx="leo.20201108101518.73">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   direction_widget.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   30-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Direction widget class definition                   *
 *********************************************************************/

#include &lt;cmath&gt;

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;

#include "direction_widget.h"


DirectionWidget::DirectionWidget(const QString &amp;title, const RR3Vector &amp;direction, QWidget *parent)
    : QGroupBox(title, parent)
    , showButtonBox(true)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QGridLayout *layout = new QGridLayout;
    this-&gt;setLayout(layout);

    QLabel *xLabel = new QLabel("X:");
    layout-&gt;addWidget(xLabel, 0, 0, 1, 1);

    this-&gt;xSlider = new QSlider(Qt::Horizontal);
    layout-&gt;addWidget(this-&gt;xSlider, 0, 1, 1, 1);

    this-&gt;xSpin = new QDoubleSpinBox;
    this-&gt;xSpin-&gt;setRange(-1.0,1.0);
    this-&gt;xSpin-&gt;setSingleStep(0.01);
    layout-&gt;addWidget(this-&gt;xSpin, 0, 2, 1, 1);

    QLabel *yLabel = new QLabel("Y:");
    layout-&gt;addWidget(yLabel, 1, 0, 1, 1);

    this-&gt;ySlider = new QSlider(Qt::Horizontal);
    layout-&gt;addWidget(this-&gt;ySlider, 1, 1, 1, 1);

    this-&gt;ySpin = new QDoubleSpinBox;
    this-&gt;ySpin-&gt;setRange(-1.0,1.0);
    this-&gt;ySpin-&gt;setSingleStep(0.01);
    layout-&gt;addWidget(this-&gt;ySpin, 1, 2, 1, 1);

    QLabel *zLabel = new QLabel("Z:");
    layout-&gt;addWidget(zLabel, 2, 0, 1, 1);

    this-&gt;zSlider = new QSlider(Qt::Horizontal);
    layout-&gt;addWidget(this-&gt;zSlider, 2, 1, 1, 1);

    this-&gt;zSpin = new QDoubleSpinBox;
    this-&gt;zSpin-&gt;setRange(-1.0,1.0);
    this-&gt;zSpin-&gt;setSingleStep(0.01);
    layout-&gt;addWidget(this-&gt;zSpin, 2, 2, 1, 1);

    this-&gt;setDirection(direction);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    layout-&gt;addLayout(buttonsLayout,3,0,1,3);

    this-&gt;cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(this-&gt;cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setDisabled(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    layout-&gt;addWidget(new QWidget,4,0,1,3);
    layout-&gt;setRowStretch(4,1);

    this-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Maximum);

    QObject::connect(this-&gt;xSlider,&amp;QSlider::valueChanged,this,&amp;DirectionWidget::onXSliderValueChanged);
    QObject::connect(this-&gt;ySlider,&amp;QSlider::valueChanged,this,&amp;DirectionWidget::onYSliderValueChanged);
    QObject::connect(this-&gt;zSlider,&amp;QSlider::valueChanged,this,&amp;DirectionWidget::onZSliderValueChanged);

    this-&gt;connect(this-&gt;xSpin,SIGNAL(valueChanged(double)),SLOT(onXSpinValueChanged(double)));
    this-&gt;connect(this-&gt;ySpin,SIGNAL(valueChanged(double)),SLOT(onYSpinValueChanged(double)));
    this-&gt;connect(this-&gt;zSpin,SIGNAL(valueChanged(double)),SLOT(onZSpinValueChanged(double)));

    QObject::connect(this-&gt;cancelButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;DirectionWidget::onCancelButtonClicked);
    QObject::connect(this-&gt;okButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;DirectionWidget::onOkButtonClicked);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.74">void DirectionWidget::showButtons(void)
{
    this-&gt;showButtonBox = true;
    this-&gt;okButton-&gt;show();
    this-&gt;cancelButton-&gt;show();
}

</t>
<t tx="leo.20201108101518.75">void DirectionWidget::hideButtons(void)
{
    this-&gt;showButtonBox = false;
    this-&gt;okButton-&gt;hide();
    this-&gt;cancelButton-&gt;hide();
}

RR3Vector DirectionWidget::getDirection(void) const
{
    RR3Vector direction;

    direction[0] = this-&gt;xSpin-&gt;value();
    direction[1] = this-&gt;ySpin-&gt;value();
    direction[2] = this-&gt;zSpin-&gt;value();

    return direction;
}

</t>
<t tx="leo.20201108101518.76">void DirectionWidget::setDirection(const RR3Vector &amp;direction)
{
    int xnsp = 0;
    int ynsp = 0;
    int znsp = 0;

    this-&gt;findSliderPositions(direction,xnsp,ynsp,znsp);

    this-&gt;xSlider-&gt;blockSignals(true);
    this-&gt;xSlider-&gt;setValue(xnsp);
    this-&gt;xSlider-&gt;blockSignals(false);

    this-&gt;ySlider-&gt;blockSignals(true);
    this-&gt;ySlider-&gt;setValue(ynsp);
    this-&gt;ySlider-&gt;blockSignals(false);

    this-&gt;zSlider-&gt;blockSignals(true);
    this-&gt;zSlider-&gt;setValue(znsp);
    this-&gt;zSlider-&gt;blockSignals(false);

    this-&gt;xSpin-&gt;blockSignals(true);
    this-&gt;xSpin-&gt;setValue(direction[0]);
    this-&gt;xSpin-&gt;blockSignals(false);

    this-&gt;ySpin-&gt;blockSignals(true);
    this-&gt;ySpin-&gt;setValue(direction[1]);
    this-&gt;ySpin-&gt;blockSignals(false);

    this-&gt;zSpin-&gt;blockSignals(true);
    this-&gt;zSpin-&gt;setValue(direction[2]);
    this-&gt;zSpin-&gt;blockSignals(false);

    if (!this-&gt;showButtonBox)
    {
        emit this-&gt;changed(direction);
    }
}

</t>
<t tx="leo.20201108101518.77">void DirectionWidget::normalize(RR3Vector &amp;direction, int keepPosition)
{
    double x = direction[0];
    double y = direction[1];
    double z = direction[2];

    if (keepPosition == 0)
    {
        double yz2 = 1-direction[0]*direction[0];
        double y2 = direction[1]*direction[1];
        double z2 = direction[2]*direction[2];

        if (yz2 &lt; y2)
        {
            y2 = yz2;
            bool negative = y &lt; 0.0;
            y = std::sqrt(y2);
            if (negative) y *= -1;
        }
        z2 = yz2 - y2;
        z = std::sqrt(z2);
    }
    else if (keepPosition == 1)
    {
        double xz2 = 1-direction[1]*direction[1];
        double x2 = direction[0]*direction[0];
        double z2 = direction[2]*direction[2];

        if (xz2 &lt; x2)
        {
            x2 = xz2;
            bool negative = x &lt; 0.0;
            x = std::sqrt(x2);
            if (negative) x *= -1;
        }
        z2 = xz2 - x2;
        z = std::sqrt(z2);
    }
    else if (keepPosition == 2)
    {
        double xy2 = 1-direction[2]*direction[2];
        double x2 = direction[0]*direction[0];
        double y2 = direction[1]*direction[1];

        if (xy2 &lt; x2)
        {
            x2 = xy2;
            bool negative = x &lt; 0.0;
            x = std::sqrt(x2);
            if (negative) x *= -1;
        }
        y2 = xy2 - x2;
        y = std::sqrt(y2);
    }

    direction[0] = x;
    direction[1] = y;
    direction[2] = z;
}

</t>
<t tx="leo.20201108101518.78">void DirectionWidget::findSliderPositions(const RR3Vector &amp;direction, int &amp;x, int &amp;y, int &amp;z)
{
    int xMin = this-&gt;xSlider-&gt;minimum();
    int xMax = this-&gt;xSlider-&gt;maximum();
    int yMin = this-&gt;ySlider-&gt;minimum();
    int yMax = this-&gt;ySlider-&gt;maximum();
    int zMin = this-&gt;zSlider-&gt;minimum();
    int zMax = this-&gt;zSlider-&gt;maximum();

    double vxMin = this-&gt;xSpin-&gt;minimum();
    double vxMax = this-&gt;xSpin-&gt;maximum();
    double vyMin = this-&gt;ySpin-&gt;minimum();
    double vyMax = this-&gt;ySpin-&gt;maximum();
    double vzMin = this-&gt;zSpin-&gt;minimum();
    double vzMax = this-&gt;zSpin-&gt;maximum();

    double xRate = (direction[0] - vxMin) / (vxMax - vxMin);
    double yRate = (direction[1] - vyMin) / (vyMax - vyMin);
    double zRate = (direction[2] - vzMin) / (vzMax - vzMin);

    x = qRound(xRate * double(xMax - xMin) + double(xMin));
    y = qRound(yRate * double(yMax - yMin) + double(yMin));
    z = qRound(zRate * double(zMax - zMin) + double(zMin));
}

</t>
<t tx="leo.20201108101518.79">void DirectionWidget::onXSliderValueChanged(int value)
{
    int min = this-&gt;xSlider-&gt;minimum();
    int max = this-&gt;xSlider-&gt;maximum();
    double vMin = this-&gt;xSpin-&gt;minimum();
    double vMax = this-&gt;xSpin-&gt;maximum();

    double rate = double(value - min) / double(max - min);

    this-&gt;xSpin-&gt;blockSignals(true);
    this-&gt;xSpin-&gt;setValue(rate*(vMax-vMin)+vMin);
    this-&gt;xSpin-&gt;blockSignals(false);

    RR3Vector direction = this-&gt;getDirection();
    this-&gt;normalize(direction,0);
    this-&gt;setDirection(direction);

    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101518.8">void BCTree::onButtonValueClicked(int id)
{
    unsigned int cPosition = this-&gt;bc.findComponentPosition(RVariableType(id));
    if (cPosition == RConstants::eod)
    {
        return;
    }
    ComponentEditDialog componentEditDialog(this-&gt;bc.getComponent(cPosition),MainWindow::getInstance());
    if (componentEditDialog.exec() == QDialog::Accepted)
    {
        this-&gt;updateSelectedEntities();
        for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
        {
            RVariableType variableType = RVariableType(this-&gt;topLevelItem(i)-&gt;data(BC_TREE_PROPERTY_TYPE,Qt::DisplayRole).toInt());
            if (variableType != RVariableType(id))
            {
                continue;
            }
            VariableValueEdit *lineEdit = dynamic_cast&lt;VariableValueEdit*&gt;(this-&gt;itemWidget(this-&gt;topLevelItem(i),BC_TREE_PROPERTY_VALUE));
            lineEdit-&gt;setValue(this-&gt;bc.getComponent(cPosition).getValue(0));
            lineEdit-&gt;setEnabled(this-&gt;bc.getComponent(cPosition).size() == 1);
        }
    }
}

</t>
<t tx="leo.20201108101518.80">void DirectionWidget::onYSliderValueChanged(int value)
{
    int min = this-&gt;ySlider-&gt;minimum();
    int max = this-&gt;ySlider-&gt;maximum();
    double vMin = this-&gt;ySpin-&gt;minimum();
    double vMax = this-&gt;ySpin-&gt;maximum();

    double rate = double(value - min) / double(max - min);

    this-&gt;ySpin-&gt;blockSignals(true);
    this-&gt;ySpin-&gt;setValue(rate*(vMax-vMin)+vMin);
    this-&gt;ySpin-&gt;blockSignals(false);

    RR3Vector direction = this-&gt;getDirection();
    this-&gt;normalize(direction,1);
    this-&gt;setDirection(direction);

    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101518.81">void DirectionWidget::onZSliderValueChanged(int value)
{
    int min = this-&gt;zSlider-&gt;minimum();
    int max = this-&gt;zSlider-&gt;maximum();
    double vMin = this-&gt;zSpin-&gt;minimum();
    double vMax = this-&gt;zSpin-&gt;maximum();

    double rate = double(value - min) / double(max - min);

    this-&gt;zSpin-&gt;blockSignals(true);
    this-&gt;zSpin-&gt;setValue(rate*(vMax-vMin)+vMin);
    this-&gt;zSpin-&gt;blockSignals(false);

    RR3Vector direction = this-&gt;getDirection();
    this-&gt;normalize(direction,2);
    this-&gt;setDirection(direction);

    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101518.82">void DirectionWidget::onXSpinValueChanged(double)
{
    RR3Vector direction = this-&gt;getDirection();
    this-&gt;normalize(direction,0);
    this-&gt;setDirection(direction);

    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101518.83">void DirectionWidget::onYSpinValueChanged(double)
{
    RR3Vector direction = this-&gt;getDirection();
    this-&gt;normalize(direction,1);
    this-&gt;setDirection(direction);

    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101518.84">void DirectionWidget::onZSpinValueChanged(double)
{
    RR3Vector direction = this-&gt;getDirection();
    this-&gt;normalize(direction,2);
    this-&gt;setDirection(direction);

    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101518.85">void DirectionWidget::onOkButtonClicked(void)
{
    emit this-&gt;changed(this-&gt;getDirection());
    emit this-&gt;closed();
}

</t>
<t tx="leo.20201108101518.86">void DirectionWidget::onCancelButtonClicked(void)
{
    emit this-&gt;closed();
}
</t>
<t tx="leo.20201108101518.87">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   document_generator.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   3-rd May 2016                                            *
 *                                                                   *
 *  DESCRIPTION: Document generator class definition                 *
 *********************************************************************/

#include &lt;QTextDocument&gt;
#include &lt;QTextCursor&gt;
#include &lt;QtPrintSupport/QPrinter&gt;
#include &lt;QTextDocumentWriter&gt;
#include &lt;QTextTable&gt;
#include &lt;QHostInfo&gt;
#include &lt;QPainter&gt;

#include &lt;rblib.h&gt;

#include "document_generator.h"

DocumentGenerator::DocumentGenerator(QObject *parent)
    : Job(parent)
    , enableHeaderCounters(true)
    , fontSizeScale(1.0)
{
    this-&gt;docTitle = new QTextDocument(this);
    this-&gt;docHeader = new QTextDocument(this);
    this-&gt;docFooter = new QTextDocument(this);
    this-&gt;docBody = new QTextDocument(this);
    this-&gt;printer = new QPrinter(QPrinter::ScreenResolution);
    this-&gt;printer-&gt;setPageSize(QPrinter::A4);
    this-&gt;printer-&gt;setPageMargins(20.0,15.0,20.0,10.0,QPrinter::Millimeter);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101518.88">void DocumentGenerator::setEnableHeaderCounters(bool enableHeaderCounters)
{
    this-&gt;enableHeaderCounters = enableHeaderCounters;
}

</t>
<t tx="leo.20201108101518.89">void DocumentGenerator::setFontSizeScale(double fontSizeScale)
{
    this-&gt;fontSizeScale = fontSizeScale;
}

</t>
<t tx="leo.20201108101518.9">void BCTree::onDirectionChanged(const RR3Vector &amp;direction)
{
    this-&gt;bc.setLocalDirection(direction);
    this-&gt;drawLocalRotationBegin();

    this-&gt;updateSelectedEntities();
}
</t>
<t tx="leo.20201108101518.90">void DocumentGenerator::addExportType(DocumentGenerator::Type type, const QString &amp;fileName)
{
    this-&gt;exportTypes[type] = fileName;
}

</t>
<t tx="leo.20201108101518.91">void DocumentGenerator::run(void)
{
    RLogger::info("Generating document\n");
    RLogger::indent();

    try
    {
        this-&gt;generate();

        QMap&lt;DocumentGenerator::Type,QString&gt;::iterator iter;
        for (iter = this-&gt;exportTypes.begin(); iter != this-&gt;exportTypes.end(); ++iter)
        {
            RLogger::info("Exporting document to '%s'\n",iter.value().toUtf8().constData());
            switch (iter.key())
            {
                case DocumentGenerator::PlainText:
                {
                    this-&gt;exportToPlainText(iter.value());
                    break;
                }
                case DocumentGenerator::HTML:
                {
                    this-&gt;exportToHTML(iter.value());
                    break;
                }
                case DocumentGenerator::ODF:
                {
                    this-&gt;exportToODF(iter.value());
                    break;
                }
                case DocumentGenerator::PDF:
                {
                    this-&gt;exportToPDF(iter.value());
                    break;
                }
            }
        }
        RLogger::notice("Documents have been generated.");
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to generate document: %s\n",error.getMessage().toUtf8().constData());
        RLogger::unindent();
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101518.92">void DocumentGenerator::generate(void)
{
    RLogger::info("Generating document.\n");
    RLogger::indent();

    this-&gt;docHeader-&gt;setPageSize(this-&gt;printer-&gt;pageRect().size());

    this-&gt;generateHeader();

    this-&gt;docFooter-&gt;setPageSize(this-&gt;printer-&gt;pageRect().size());

    this-&gt;generateFooter();

    this-&gt;docTitle-&gt;setPageSize(this-&gt;printer-&gt;pageRect().size());
    // Calculating the main document size for one page
    QSizeF centerSize(this-&gt;printer-&gt;pageRect().width(),
                      this-&gt;printer-&gt;pageRect().height() - this-&gt;docHeader-&gt;size().toSize().height() - this-&gt;docFooter-&gt;size().toSize().height());
    this-&gt;docBody-&gt;setPageSize(centerSize);
    this-&gt;docBody-&gt;setIndentWidth(10.0);

    this-&gt;generateTitle();
    this-&gt;generateBody();

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101518.93">void DocumentGenerator::generateHeader(void)
{
    QTextImageFormat imageFormat;
    imageFormat.setName(":/icons/logos/pixmaps/range-logo-128.png");
    imageFormat.setHeight(64.0);
    imageFormat.setWidth(64.0);

    QTextTableFormat tableFormat;
    tableFormat.setCellPadding(5);
    tableFormat.setBorder(0.0);
    tableFormat.setBorderStyle(QTextFrameFormat::BorderStyle_None);

    QTextCursor cursor(this-&gt;docHeader);
    cursor.insertTable(1,2,tableFormat);

    cursor.insertImage(imageFormat,QTextFrameFormat::FloatLeft);
    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,RVendor::name,true);
    cursor.insertBlock(QTextBlockFormat(),QTextCharFormat());
    this-&gt;insertText(cursor,RVendor::title,true);
    cursor.insertBlock(QTextBlockFormat(),QTextCharFormat());
    this-&gt;insertText(cursor,RVendor::www,true);
    cursor.movePosition(QTextCursor::End);
    cursor.insertHtml("&lt;hr noshade/&gt;");
}

</t>
<t tx="leo.20201108101518.94">void DocumentGenerator::generateFooter(void)
{
    QTextCursor cursor(this-&gt;docFooter);
    cursor.insertHtml(QString("&lt;center&gt;&lt;b&gt;") + RVendor::name + QString("&lt;/b&gt; - ") + RVendor::author.toHtmlEscaped() + QString(" &amp;copy; ") + QString::number(RVendor::year) + "&lt;/center&gt;");
    cursor.insertBlock(QTextBlockFormat(),QTextCharFormat());
}

</t>
<t tx="leo.20201108101518.95">void DocumentGenerator::exportToPlainText(const QString &amp;fileName) const
{
    QTextDocumentWriter writer(fileName);

    writer.setFormat("plaintext");
    if (!writer.write(this-&gt;docBody))
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF, "Failed to write to file \'%s\'.",fileName.toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101518.96">void DocumentGenerator::exportToHTML(const QString &amp;fileName) const
{
    QTextDocumentWriter writer(fileName);

    writer.setFormat("HTML");
    if (!writer.write(this-&gt;docBody))
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF, "Failed to write to file \'%s\'.",fileName.toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101518.97">void DocumentGenerator::exportToODF(const QString &amp;fileName) const
{
    QTextDocumentWriter writer(fileName);

    writer.setFormat("ODF");
    if (!writer.write(this-&gt;docBody))
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF, "Failed to write to file \'%s\'.",fileName.toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101518.98">void DocumentGenerator::exportToPDF(const QString &amp;fileName) const
{
    this-&gt;printer-&gt;setOutputFormat(QPrinter::PdfFormat);
    this-&gt;printer-&gt;setOutputFileName(fileName);

    // Setting up the rectangles for each section.
    QRect titleRect = QRect(QPoint(0,0), this-&gt;docTitle-&gt;size().toSize());
    QRect headerRect = QRect(QPoint(0,0), this-&gt;docHeader-&gt;size().toSize());
    QRect footerRect = QRect(QPoint(0,0), this-&gt;docFooter-&gt;size().toSize());
    QRect contentRect = QRect(QPoint(0,0), this-&gt;docBody-&gt;size().toSize());    // Main content rectangle.
    QRect currentRect = QRect(QPoint(0,0), this-&gt;docBody-&gt;pageSize().toSize());        // Current main content rectangle.

    QPainter painter(this-&gt;printer);

    // Drawing the title
    painter.resetTransform();
    painter.translate(0, this-&gt;docTitle-&gt;pageSize().height()/2.0 - titleRect.height());
    this-&gt;docTitle-&gt;drawContents(&amp;painter,titleRect);
    painter.resetTransform();
    // Drawing the header on the top of the page
    this-&gt;docHeader-&gt;drawContents(&amp;painter, headerRect);

    this-&gt;printer-&gt;newPage();

    // Loop if the current content rectangle intersects with the main content rectangle.
    uint nPages = 0;
    while (currentRect.intersects(contentRect))
    {
        // Resetting the painter matrix co ordinate system.
        painter.resetTransform();
        // Applying negative translation of painter co-ordinate system by current main content rectangle top y coordinate.
        painter.translate(0, -currentRect.y());
        // Applying positive translation of painter co-ordinate system by header hight.
        painter.translate(0, headerRect.height());
        // Drawing the center content for current page.
        this-&gt;docBody-&gt;drawContents(&amp;painter, currentRect);
        // Resetting the painter matrix co ordinate system.
        painter.resetTransform();
        // Drawing the header on the top of the page
        this-&gt;docHeader-&gt;drawContents(&amp;painter, headerRect);
        // Applying positive translation of painter co-ordinate system to draw the footer
        painter.translate(0, headerRect.height());
        painter.translate(0, this-&gt;docBody-&gt;pageSize().height());
        this-&gt;docFooter-&gt;drawContents(&amp;painter, footerRect);

        // Translating the current rectangle to the area to be printed for the next page
        currentRect.translate(0, currentRect.height());

        painter.drawText(footerRect, Qt::AlignBottom | Qt::AlignCenter, QObject::tr("Page %1").arg(nPages+1));

        // Inserting a new page if there is till area left to be printed
        if (currentRect.intersects(contentRect))
        {
            this-&gt;printer-&gt;newPage();
        }
        nPages++;
    }
}

</t>
<t tx="leo.20201108101518.99">void DocumentGenerator::insertH1(QTextCursor &amp;cursor, const QString &amp;text, bool useCurrentBlockFormat)
{
    if (!useCurrentBlockFormat)
    {
        QTextBlockFormat blockFormat;
        blockFormat.setIndent(0);
        blockFormat.setAlignment(Qt::AlignLeft);
        blockFormat.setTopMargin(10.0);
        blockFormat.setBottomMargin(5.0);
        cursor.insertBlock(blockFormat,QTextCharFormat());
    }
    QTextCharFormat textFormat = DocumentGenerator::getH1Format();
    textFormat.setFontPointSize(textFormat.fontPointSize() * this-&gt;fontSizeScale);
    if (this-&gt;enableHeaderCounters)
    {
        cursor.insertText(QString::number(++this-&gt;headerCounters.nH1) + " " + text, textFormat);
    }
    else
    {
        cursor.insertText(text, textFormat);
    }
}

</t>
<t tx="leo.20201108101519.1">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   document_widget.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th November 2017                                      *
 *                                                                   *
 *  DESCRIPTION: Document widget class definition                    *
 *********************************************************************/

#include &lt;QSplitter&gt;
#include &lt;QVBoxLayout&gt;

#include &lt;rmlib.h&gt;

#include "document_widget.h"
#include "main_settings.h"

DocumentWidget::DocumentWidget(const QString &amp;defaultFileName, QWidget *parent)
    : QWidget(parent)
    , defaultFileName(defaultFileName)
{
    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QSplitter *splitter = new QSplitter;
    splitter-&gt;setOrientation(Qt::Horizontal);
    mainLayout-&gt;addWidget(splitter);

    this-&gt;listWidget = new QListWidget;
    this-&gt;listWidget-&gt;setSizePolicy(QSizePolicy::Minimum,QSizePolicy::Expanding);
    splitter-&gt;addWidget(this-&gt;listWidget);

    QObject::connect(this-&gt;listWidget,&amp;QListWidget::itemSelectionChanged,this,&amp;DocumentWidget::onListSelectionChanged);

    this-&gt;textBrowser = new QTextBrowser;
    this-&gt;textBrowser-&gt;setSearchPaths(QStringList() &lt;&lt; MainSettings::getInstance().getApplicationSettings()-&gt;getHelpDir());
    this-&gt;textBrowser-&gt;setReadOnly(true);
    this-&gt;textBrowser-&gt;setSizePolicy(QSizePolicy::MinimumExpanding,QSizePolicy::Expanding);
    splitter-&gt;addWidget(this-&gt;textBrowser);

    splitter-&gt;setStretchFactor(1,1);

    this-&gt;loadFile(this-&gt;defaultFileName);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.10">void DownloadManager::downloadReadyRead(void)
{
    output.write(this-&gt;currentDownload-&gt;readAll());
}
</t>
<t tx="leo.20201108101519.11">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th September 2014                                     *
 *                                                                   *
 *  DESCRIPTION: Draw engine class definition                        *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "draw_engine.h"
#include "session.h"

DrawEngine::DrawEngine(QObject *parent) :
    QObject(parent)
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.12">void DrawEngine::start()
{
    if (this-&gt;isRunning)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Engine is already running");
    }
}

</t>
<t tx="leo.20201108101519.13">void DrawEngine::stop()
{
    if (!this-&gt;isRunning)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Engine is not running");
    }

}

</t>
<t tx="leo.20201108101519.14">void DrawEngine::processObjects(const QList&lt;uint&gt; &amp;modelIDs, bool mergeNearNodes, double tolerance, bool findNearest)
{
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().storeCurentModelVersion(modelIDs[i],tr("Draw object"));
        for (int j=0;j&lt;this-&gt;objects.size();j++)
        {
            // Change alpha of each entity to 255
            Model &amp;model = this-&gt;objects[j]-&gt;getModel();
            for (uint i=0;i&lt;model.getNEntityGroups();i++)
            {
                REntityGroup *rEntityGroup = model.getEntityGroupPtr(i);
                int r,g,b,a;
                rEntityGroup-&gt;getData().getColor(r,g,b,a);
                a = 255;
                rEntityGroup-&gt;getData().setColor(r,g,b,a);
            }
            Session::getInstance().getModel(modelIDs[i]).insertModel(this-&gt;objects[j]-&gt;getModel(),mergeNearNodes,tolerance,findNearest);
        }
        Session::getInstance().setModelChanged(modelIDs[i]);
    }
    this-&gt;objects.clear();
    emit this-&gt;objectsRemoved();
}

</t>
<t tx="leo.20201108101519.15">void DrawEngine::addObject(DrawEngineObject *object)
{
    object-&gt;setParent(this);
    this-&gt;objects.push_back(object);
    emit this-&gt;objectAdded();
}

</t>
<t tx="leo.20201108101519.16">void DrawEngine::removeObject(uint position)
{
    DrawEngineObject *pObject = this-&gt;objects[position];
    this-&gt;objects.removeAt(position);
    delete pObject;
    emit this-&gt;objectRemoved(position);
}

uint DrawEngine::getNObjects() const
{
    return uint(this-&gt;objects.size());
}

</t>
<t tx="leo.20201108101519.17">const DrawEngineObject *DrawEngine::getObject(uint position) const
{
    return this-&gt;objects[position];
}

DrawEngineObject *DrawEngine::getObject(uint position)
{
    return this-&gt;objects[position];
}

</t>
<t tx="leo.20201108101519.18">void DrawEngine::setObjectChanged(uint position)
{
    emit this-&gt;objectChanged(position);
}
</t>
<t tx="leo.20201108101519.19">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_circle.h                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   header file (*.h)                                        *
 *  DATE:   12-th February 2015                                      *
 *                                                                   *
 *  DESCRIPTION: Draw engine circle class declaration                *
 *********************************************************************/

#include "draw_engine_circle.h"

DrawEngineCircle::DrawEngineCircle(QObject *parent) :
    DrawEngineObject(parent)
{
    this-&gt;name = tr("circle");

    this-&gt;inputParameters.append(DrawEngineInput(RLocalDirection(RR3Vector(0.0,0.0,0.0),RR3Vector(0.0,0.0,1.0)),
                                                 tr("Center node position and direction"),
                                                 tr("Center node position in X,Y,Z coordinate system and its direction (normal)."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(0.25,
                                                 tr("Radius"),
                                                 tr("Circle\'s radius."),
                                                 "m",
                                                 RConstants::eps));
    this-&gt;inputParameters.append(DrawEngineInput(0.0,
                                                 tr("Start angle"),
                                                 tr("Opening angle of the circle section."),
                                                 "deg",
                                                 0.0,
                                                 360.0));
    this-&gt;inputParameters.append(DrawEngineInput(360.0,
                                                 tr("End angle"),
                                                 tr("Closing angle of the circle section."),
                                                 "deg",
                                                 0.0,
                                                 360.0));
    this-&gt;inputParameters.append(DrawEngineInput(uint(20),
                                                 tr("Anglular divisions"),
                                                 tr("Number of angular divisions."),
                                                 "#",
                                                 uint(3)));

    this-&gt;updateModel();
}

RModelRaw DrawEngineCircle::generate() const
{
    RModelRaw modelRaw;

    RLocalDirection localDirection = this-&gt;inputParameters.at(0).toLocalDirection();
    const RR3Vector &amp;center = localDirection.getPosition();
    const RR3Vector &amp;direction = localDirection.getDirection();

    double r = this-&gt;inputParameters.at(1).toDouble();
    double sa = this-&gt;inputParameters.at(2).toDouble();
    double ea = this-&gt;inputParameters.at(3).toDouble();
    double nai = this-&gt;inputParameters.at(4).toUint();

    double da = 0.0;
    if (sa &gt; ea)
    {
        da = 360.0 - (sa-ea);
    }
    else if (sa == ea)
    {
        da = 360.0;
    }
    else
    {
        da = ea - sa;
    }
    da /= double(nai);

    RNode centerNode(0.0,0.0,0.0);

    for (uint i=0;i&lt;nai;i++)
    {
        double a1 = sa + i*da;
        double a2 = a1 + da;

        if (a1 &gt; 360.0)
        {
            a1 -= 360.0;
        }

        if (a2 &gt; 360.0)
        {
            a2 -= 360.0;
        }

        a1 = R_DEG_TO_RAD(a1);
        a2 = R_DEG_TO_RAD(a2);

        RNode bNode1(0.0,r*cos(a1),r*sin(a1));
        RNode bNode2(0.0,r*cos(a2),r*sin(a2));

        modelRaw.addTriangle(centerNode,bNode1,bNode2);
    }

    RRMatrix R;
//    direction.normalize();
    direction.findRotationMatrix(R);

    for (uint i=0;i&lt;modelRaw.getNNodes();i++)
    {
        modelRaw.getNode(i).transform(R,center);
    }

    return modelRaw;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.2">void DocumentWidget::addListItem(QIcon icon, const QString &amp;text, const QString &amp;fileName)
{
    QListWidgetItem *item = new QListWidgetItem(this-&gt;listWidget);
    item-&gt;setIcon(icon);
    item-&gt;setText(text);
    item-&gt;setData(Qt::UserRole,fileName);
}

</t>
<t tx="leo.20201108101519.20">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_cylinder.cpp                                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th October 2014                                        *
 *                                                                   *
 *  DESCRIPTION: Draw engine cylinder class definition               *
 *********************************************************************/

#include &lt;cmath&gt;
#include &lt;algorithm&gt;

#include "draw_engine_cylinder.h"

DrawEngineCylinder::DrawEngineCylinder(QObject *parent) :
    DrawEngineObject(parent)
{
    this-&gt;name = tr("cylinder");
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,0.0,0.0),
                                                 tr("Position (bottom)"),
                                                 tr("Position in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,0.0,1.0),
                                                 tr("Position (top)"),
                                                 tr("Position in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(0.25,
                                                 tr("Radius (bottom)"),
                                                 tr("Radius of bottom circle."),
                                                 "m",
                                                 0.0));
    this-&gt;inputParameters.append(DrawEngineInput(0.25,
                                                 tr("Radius (top)"),
                                                 tr("Radius of top circle."),
                                                 "m",
                                                 0.0));
    this-&gt;inputParameters.append(DrawEngineInput(0.0,
                                                 tr("Start angle"),
                                                 tr("Opening angle of the cylinder section."),
                                                 "deg",
                                                 0.0,
                                                 360.0));
    this-&gt;inputParameters.append(DrawEngineInput(360.0,
                                                 tr("End angle"),
                                                 tr("Closing angle of the cylinder section."),
                                                 "deg",
                                                 0.0,
                                                 360.0));
    this-&gt;inputParameters.append(DrawEngineInput(uint(20),
                                                 tr("Anglular divisions"),
                                                 tr("Number of angular divisions."),
                                                 "#",
                                                 uint(3)));
    this-&gt;inputParameters.append(DrawEngineInput(uint(10),
                                                 tr("Axial divisions"),
                                                 tr("Number of divisions along rotation axis."),
                                                 "#",
                                                 uint(1)));
    this-&gt;updateModel();
}

RModelRaw DrawEngineCylinder::generate() const
{
    RModelRaw modelRaw;

    RR3Vector bc = this-&gt;inputParameters.at(0).toVector();
    RR3Vector tc = this-&gt;inputParameters.at(1).toVector();
    double br = this-&gt;inputParameters.at(2).toDouble();
    double tr = this-&gt;inputParameters.at(3).toDouble();
    double sa = this-&gt;inputParameters.at(4).toDouble();
    double ea = this-&gt;inputParameters.at(5).toDouble();
    double nai = this-&gt;inputParameters.at(6).toUint();
    double nxi = this-&gt;inputParameters.at(7).toUint();

    double da = 0.0;
    if (sa &gt; ea)
    {
        da = 360.0 - (sa-ea);
    }
    else if (sa == ea)
    {
        da = 360.0;
    }
    else
    {
        da = ea - sa;
    }
    da /= double(nai);

    bool bCone = std::fabs(br) &lt; RConstants::eps;
    bool tCone = std::fabs(tr) &lt; RConstants::eps;

    RR3Vector direction(tc[0]-bc[0],tc[1]-bc[1],tc[2]-bc[2]);
    double length = direction.length();

    RNode bCenterNode(0.0,0.0,0.0);
    RNode tCenterNode(length,0.0,0.0);

    for (uint i=0;i&lt;nai;i++)
    {
        double a1 = sa + i*da;
        double a2 = a1 + da;

        if (a1 &gt; 360.0)
        {
            a1 -= 360.0;
        }

        if (a2 &gt; 360.0)
        {
            a2 -= 360.0;
        }

        a1 = R_DEG_TO_RAD(a1);
        a2 = R_DEG_TO_RAD(a2);

        RNode bNode1(0.0,br*cos(a1),br*sin(a1));
        RNode bNode2(0.0,br*cos(a2),br*sin(a2));

        RNode tNode1(length,tr*cos(a1),tr*sin(a1));
        RNode tNode2(length,tr*cos(a2),tr*sin(a2));

        if (!bCone)
        {
            modelRaw.addTriangle(bCenterNode,bNode1,bNode2);
        }

        if (!tCone)
        {
            modelRaw.addTriangle(tCenterNode,tNode2,tNode1);
        }

        double dx = length / nxi;
        double dr = (tr-br) / nxi;
        for (uint j=0;j&lt;nxi;j++)
        {
            double r1 = j*dr+br;
            double r2 = r1+dr;
            double x1 = j*dx;
            double x2 = x1 + dx;

            RNode bNode1(x1,r1*cos(a1),r1*sin(a1));
            RNode bNode2(x1,r1*cos(a2),r1*sin(a2));

            RNode tNode1(x2,r2*cos(a1),r2*sin(a1));
            RNode tNode2(x2,r2*cos(a2),r2*sin(a2));

            if (j == 0 &amp;&amp; bCone)
            {
                modelRaw.addTriangle(bNode1,tNode1,tNode2);
            }
            else if (j == nxi - 1 &amp;&amp; tCone)
            {
                modelRaw.addTriangle(tNode1,bNode2,bNode1);
            }
            else
            {
                modelRaw.addQuadrilateral(bNode2,bNode1,tNode1,tNode2);
            }
        }
    }

    RRMatrix R;
    direction.findRotationMatrix(R);

    for (uint i=0;i&lt;modelRaw.getNNodes();i++)
    {
        modelRaw.getNode(i).transform(R,bc);
    }

    return modelRaw;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.21">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_ellipse.h                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   header file (*.h)                                        *
 *  DATE:   26-th August 2016                                        *
 *                                                                   *
 *  DESCRIPTION: Draw engine ellipse class declaration               *
 *********************************************************************/

#include "draw_engine_ellipse.h"

DrawEngineEllipse::DrawEngineEllipse(QObject *parent) :
    DrawEngineObject(parent)
{
    this-&gt;name = tr("ellipse");

    this-&gt;inputParameters.append(DrawEngineInput(RLocalDirection(RR3Vector(0.0,0.0,0.0),RR3Vector(0.0,0.0,1.0)),
                                                 tr("Center node position and direction"),
                                                 tr("Center node position in X,Y,Z coordinate system and its direction (normal)."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(0.25,
                                                 tr("Radius R1"),
                                                 tr("Ellipse\'s 1-st radius."),
                                                 "m",
                                                 RConstants::eps));
    this-&gt;inputParameters.append(DrawEngineInput(0.15,
                                                 tr("Radius R2"),
                                                 tr("Ellipse\'s 2-nd radius."),
                                                 "m",
                                                 RConstants::eps));
    this-&gt;inputParameters.append(DrawEngineInput(0.0,
                                                 tr("Start angle"),
                                                 tr("Opening angle of the ellipse section."),
                                                 "deg",
                                                 0.0,
                                                 360.0));
    this-&gt;inputParameters.append(DrawEngineInput(360.0,
                                                 tr("End angle"),
                                                 tr("Closing angle of the ellipse section."),
                                                 "deg",
                                                 0.0,
                                                 360.0));
    this-&gt;inputParameters.append(DrawEngineInput(uint(20),
                                                 tr("Anglular divisions"),
                                                 tr("Number of angular divisions."),
                                                 "#",
                                                 uint(3)));

    this-&gt;updateModel();
}

RModelRaw DrawEngineEllipse::generate() const
{
    RModelRaw modelRaw;

    RLocalDirection localDirection = this-&gt;inputParameters.at(0).toLocalDirection();
    const RR3Vector &amp;center = localDirection.getPosition();
    const RR3Vector &amp;direction = localDirection.getDirection();

    double r1 = this-&gt;inputParameters.at(1).toDouble();
    double r2 = this-&gt;inputParameters.at(2).toDouble();
    double sa = this-&gt;inputParameters.at(3).toDouble();
    double ea = this-&gt;inputParameters.at(4).toDouble();
    double nai = this-&gt;inputParameters.at(5).toUint();

    double da = 0.0;
    if (sa &gt; ea)
    {
        da = 360.0 - (sa-ea);
    }
    else if (sa == ea)
    {
        da = 360.0;
    }
    else
    {
        da = ea - sa;
    }
    da /= double(nai);

    RNode centerNode(0.0,0.0,0.0);

    for (uint i=0;i&lt;nai;i++)
    {
        double a1 = sa + i*da;
        double a2 = a1 + da;

        if (a1 &gt; 360.0)
        {
            a1 -= 360.0;
        }

        if (a2 &gt; 360.0)
        {
            a2 -= 360.0;
        }

        a1 = R_DEG_TO_RAD(a1);
        a2 = R_DEG_TO_RAD(a2);

        RNode bNode1(0.0,r1*cos(a1),r2*sin(a1));
        RNode bNode2(0.0,r1*cos(a2),r2*sin(a2));

        modelRaw.addTriangle(centerNode,bNode1,bNode2);
    }

    RRMatrix R;
    direction.findRotationMatrix(R);

    for (uint i=0;i&lt;modelRaw.getNNodes();i++)
    {
        modelRaw.getNode(i).transform(R,center);
    }

    return modelRaw;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.22">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_hexahedron.cpp                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th October 2014                                        *
 *                                                                   *
 *  DESCRIPTION: Draw engine hexahedron class definition             *
 *********************************************************************/

#include "draw_engine_hexahedron.h"

DrawEngineHexahedron::DrawEngineHexahedron(QObject *parent) :
    DrawEngineObject(parent)
{
    this-&gt;name = tr("hexahedron");

    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,0.0,0.0),
                                                 tr("Position"),
                                                 tr("Position in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(1.0,tr("X size"),tr("Size in X direction."),"m"));
    this-&gt;inputParameters.append(DrawEngineInput(1.0,tr("Y size"),tr("Size in Y direction."),"m"));
    this-&gt;inputParameters.append(DrawEngineInput(1.0,tr("Z size"),tr("Size in Z direction."),"m"));
    this-&gt;inputParameters.append(DrawEngineInput(uint(1),tr("X divisions"),tr("Number of divisions in X direction."),"#",uint(1)));
    this-&gt;inputParameters.append(DrawEngineInput(uint(1),tr("Y divisions"),tr("Number of divisions in Y direction."),"#",uint(1)));
    this-&gt;inputParameters.append(DrawEngineInput(uint(1),tr("Z divisions"),tr("Number of divisions in Z direction."),"#",uint(1)));

    this-&gt;updateModel();
}

RModelRaw DrawEngineHexahedron::generate() const
{
    RModelRaw modelRaw;

    RR3Vector origin = this-&gt;inputParameters.at(0).toVector();
    double sx = this-&gt;inputParameters.at(1).toDouble();
    double sy = this-&gt;inputParameters.at(2).toDouble();
    double sz = this-&gt;inputParameters.at(3).toDouble();
    uint nx = this-&gt;inputParameters.at(4).toUint();
    uint ny = this-&gt;inputParameters.at(5).toUint();
    uint nz = this-&gt;inputParameters.at(6).toUint();

    double dx = sx/nx;
    double dy = sy/ny;
    double dz = sz/nz;

    double x, y, z;

    // XY
    x = origin[0];
    z = origin[2];
    for (uint i=0;i&lt;nx;i++)
    {
        y = origin[1];
        for (uint j=0;j&lt;ny;j++)
        {
            modelRaw.addQuadrilateral(RNode(x,y,z+sz),RNode(x+dx,y,z+sz),RNode(x+dx,y+dy,z+sz),RNode(x,y+dy,z+sz));
            modelRaw.addQuadrilateral(RNode(x,y,z),RNode(x,y+dy,z),RNode(x+dx,y+dy,z),RNode(x+dx,y,z));
            y += dy;
        }
        x += dx;
    }

    // XZ
    x = origin[0];
    y = origin[1];
    for (uint i=0;i&lt;nx;i++)
    {
        z = origin[2];
        for (uint j=0;j&lt;nz;j++)
        {
            modelRaw.addQuadrilateral(RNode(x,y+sy,z),RNode(x,y+sy,z+dz),RNode(x+dx,y+sy,z+dz),RNode(x+dx,y+sy,z));
            modelRaw.addQuadrilateral(RNode(x,y,z),RNode(x+dx,y,z),RNode(x+dx,y,z+dz),RNode(x,y,z+dz));
            z += dz;
        }
        x += dx;
    }

    // YZ
    x = origin[0];
    y = origin[1];
    for (uint i=0;i&lt;ny;i++)
    {
        z = origin[2];
        for (uint j=0;j&lt;nz;j++)
        {
            modelRaw.addQuadrilateral(RNode(x+sx,y,z),RNode(x+sx,y+dy,z),RNode(x+sx,y+dy,z+dz),RNode(x+sx,y,z+dz));
            modelRaw.addQuadrilateral(RNode(x,y,z),RNode(x,y,z+dz),RNode(x,y+dy,z+dz),RNode(x,y+dy,z));
            z += dz;
        }
        y += dy;
    }

    return modelRaw;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.23">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_input.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th October 2014                                        *
 *                                                                   *
 *  DESCRIPTION: Draw engine input class definition                  *
 *********************************************************************/


#include "draw_engine_input.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.24">void DrawEngineInput::_init(const DrawEngineInput *pDrawEngineInput)
{
    if (pDrawEngineInput)
    {
        this-&gt;type = pDrawEngineInput-&gt;type;
        this-&gt;value = pDrawEngineInput-&gt;value;
        this-&gt;minValue = pDrawEngineInput-&gt;minValue;
        this-&gt;maxValue = pDrawEngineInput-&gt;maxValue;
        this-&gt;name = pDrawEngineInput-&gt;name;
        this-&gt;desc = pDrawEngineInput-&gt;desc;
        this-&gt;units = pDrawEngineInput-&gt;units;
    } 
}

DrawEngineInput::DrawEngineInput(bool b, const QString &amp;name, const QString &amp;desc, const QString &amp;units)
    : type(DrawEngineInput::Bool)
    , name(name)
    , desc(desc)
    , units(units)
{
    this-&gt;value.b = b;
    this-&gt;_init();
}

DrawEngineInput::DrawEngineInput(int i, const QString &amp;name, const QString &amp;desc, const QString &amp;units, int minValue, int maxValue)
    : type(DrawEngineInput::Int)
    , name(name)
    , desc(desc)
    , units(units)
{
    this-&gt;value.i = i;
    this-&gt;minValue.i = minValue;
    this-&gt;maxValue.i = maxValue;
    this-&gt;_init();
}

DrawEngineInput::DrawEngineInput(uint u, const QString &amp;name, const QString &amp;desc, const QString &amp;units, uint minValue, uint maxValue)
    : type(DrawEngineInput::Uint)
    , name(name)
    , desc(desc)
    , units(units)
{
    this-&gt;value.u = u;
    this-&gt;minValue.u = minValue;
    this-&gt;maxValue.u = maxValue;
    this-&gt;_init();
}

DrawEngineInput::DrawEngineInput(double d, const QString &amp;name, const QString &amp;desc, const QString &amp;units, double minValue, double maxValue)
    : type(DrawEngineInput::Double)
    , name(name)
    , desc(desc)
    , units(units)
{
    this-&gt;value.d = d;
    this-&gt;minValue.d = minValue;
    this-&gt;maxValue.d = maxValue;
    this-&gt;_init();
}

DrawEngineInput::DrawEngineInput(const RR3Vector &amp;v, const QString &amp;name, const QString &amp;desc, const QString &amp;units)
    : type(DrawEngineInput::Vector)
    , name(name)
    , desc(desc)
    , units(units)
{
    this-&gt;value.v[0] = v[0];
    this-&gt;value.v[1] = v[1];
    this-&gt;value.v[2] = v[2];
    this-&gt;_init();
}

DrawEngineInput::DrawEngineInput(const RLocalDirection &amp;localDirection, const QString &amp;name, const QString &amp;desc, const QString &amp;units)
    : type(DrawEngineInput::LocalDirection)
    , name(name)
    , desc(desc)
    , units(units)
{
    this-&gt;value.localDirection = localDirection;
}

DrawEngineInput::DrawEngineInput(const QString &amp;text, const QString &amp;name, const QString &amp;desc, const QString &amp;units)
    : type(DrawEngineInput::Text)
    , name(name)
    , desc(desc)
    , units(units)
{
    this-&gt;value.text = text;
    this-&gt;_init();
}

DrawEngineInput::DrawEngineInput(const DrawEngineInput &amp;drawEngineInput)
{
    this-&gt;_init(&amp;drawEngineInput);
}

DrawEngineInput &amp; DrawEngineInput::operator =(const DrawEngineInput &amp;drawEngineInput)
{
    this-&gt;_init(&amp;drawEngineInput);
    return (*this);
}

</t>
<t tx="leo.20201108101519.25">bool DrawEngineInput::setValue(bool b)
{
    if (!this-&gt;isValid(b))
    {
        return false;
    }
    this-&gt;type = DrawEngineInput::Bool;
    this-&gt;value.b = b;
    return true;
}

</t>
<t tx="leo.20201108101519.26">bool DrawEngineInput::setValue(int i)
{
    if (!this-&gt;isValid(i))
    {
        return false;
    }
    this-&gt;type = DrawEngineInput::Int;
    this-&gt;value.i = i;
    return true;
}

</t>
<t tx="leo.20201108101519.27">bool DrawEngineInput::setValue(uint u)
{
    if (!this-&gt;isValid(u))
    {
        return false;
    }
    this-&gt;type = DrawEngineInput::Uint;
    this-&gt;value.u = u;
    return true;
}

</t>
<t tx="leo.20201108101519.28">bool DrawEngineInput::setValue(double d)
{
    if (!this-&gt;isValid(d))
    {
        return false;
    }
    this-&gt;type = DrawEngineInput::Double;
    this-&gt;value.d = d;
    return true;
}

</t>
<t tx="leo.20201108101519.29">bool DrawEngineInput::setValue(const RR3Vector &amp;v)
{
    if (!this-&gt;isValid(v))
    {
        return false;
    }
    this-&gt;type = DrawEngineInput::Vector;
    this-&gt;value.v[0] = v[0];
    this-&gt;value.v[1] = v[1];
    this-&gt;value.v[2] = v[2];
    return true;
}

</t>
<t tx="leo.20201108101519.3">void DocumentWidget::addListItem(const QString &amp;text, const QString &amp;fileName)
{
    QListWidgetItem *item = new QListWidgetItem(this-&gt;listWidget);
    item-&gt;setText(text);
    item-&gt;setData(Qt::UserRole,fileName);
}

</t>
<t tx="leo.20201108101519.30">bool DrawEngineInput::setValue(const RLocalDirection &amp;localDirection)
{
    if (!this-&gt;isValid(localDirection))
    {
        return false;
    }
    this-&gt;type = DrawEngineInput::LocalDirection;
    this-&gt;value.localDirection = localDirection;
    return true;
}

</t>
<t tx="leo.20201108101519.31">bool DrawEngineInput::setValue(const QString &amp;text)
{
    if (!this-&gt;isValid(text))
    {
        return false;
    }
    this-&gt;type = DrawEngineInput::Text;
    this-&gt;value.text = text;
    return true;
}

</t>
<t tx="leo.20201108101519.32">bool DrawEngineInput::toBool(bool *isOk) const
{
    if (isOk)
    {
        (*isOk) = this-&gt;type == DrawEngineInput::Bool;
    }
    if (this-&gt;type == DrawEngineInput::Bool)
    {
        return this-&gt;value.b;
    }
    return bool();
}

</t>
<t tx="leo.20201108101519.33">int DrawEngineInput::toInt(bool *isOk) const
{
    if (isOk)
    {
        (*isOk) = this-&gt;type == DrawEngineInput::Int;
    }
    if (this-&gt;type == DrawEngineInput::Int)
    {
        return this-&gt;value.i;
    }
    return int();
}

uint DrawEngineInput::toUint(bool *isOk) const
{
    if (isOk)
    {
        (*isOk) = this-&gt;type == DrawEngineInput::Uint;
    }
    if (this-&gt;type == DrawEngineInput::Uint)
    {
        return this-&gt;value.u;
    }
    return uint();
}

double DrawEngineInput::toDouble(bool *isOk) const
{
    if (isOk)
    {
        (*isOk) = this-&gt;type == DrawEngineInput::Double;
    }
    if (this-&gt;type == DrawEngineInput::Double)
    {
        return this-&gt;value.d;
    }
    return double();
}

RR3Vector DrawEngineInput::toVector(bool *isOk) const
{
    if (isOk)
    {
        (*isOk) = this-&gt;type == DrawEngineInput::Vector;
    }
    if (this-&gt;type == DrawEngineInput::Vector)
    {
        return RR3Vector(this-&gt;value.v[0],this-&gt;value.v[1],this-&gt;value.v[2]);
    }
    return RR3Vector();
}

RLocalDirection DrawEngineInput::toLocalDirection(bool *isOk) const
{
    if (isOk)
    {
        (*isOk) = this-&gt;type == DrawEngineInput::LocalDirection;
    }
    if (this-&gt;type == DrawEngineInput::LocalDirection)
    {
        return this-&gt;value.localDirection;
    }
    return RLocalDirection(RR3Vector(0.0,0.0,0.0),RR3Vector(1.0,0.0,0.0));
}

QString DrawEngineInput::toText(bool *isOk) const
{
    if (isOk)
    {
        (*isOk) = this-&gt;type == DrawEngineInput::Text;
    }
    if (this-&gt;type == DrawEngineInput::Text)
    {
        return this-&gt;value.text;
    }
    return QString();
}

DrawEngineInput::Type DrawEngineInput::getType() const
{
    return this-&gt;type;
}

</t>
<t tx="leo.20201108101519.34">const QString &amp;DrawEngineInput::getName() const
{
    return this-&gt;name;
}

</t>
<t tx="leo.20201108101519.35">const QString &amp;DrawEngineInput::getDescription() const
{
    return this-&gt;desc;
}

</t>
<t tx="leo.20201108101519.36">const QString &amp;DrawEngineInput::getUnits() const
{
    return this-&gt;units;
}

</t>
<t tx="leo.20201108101519.37">bool DrawEngineInput::isValid(bool value) const
{
    if (this-&gt;type != DrawEngineInput::Bool)
    {
        return false;
    }
    return (value == true || value == false);
}

</t>
<t tx="leo.20201108101519.38">bool DrawEngineInput::isValid(int value) const
{
    if (this-&gt;type != DrawEngineInput::Int)
    {
        return false;
    }
    return (value &gt;= this-&gt;minValue.i &amp;&amp; value &lt;= this-&gt;maxValue.i);
}

</t>
<t tx="leo.20201108101519.39">bool DrawEngineInput::isValid(uint value) const
{
    if (this-&gt;type != DrawEngineInput::Uint)
    {
        return false;
    }
    return (value &gt;= this-&gt;minValue.u &amp;&amp; value &lt;= this-&gt;maxValue.u);
}

</t>
<t tx="leo.20201108101519.4">void DocumentWidget::loadFile(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        this-&gt;textBrowser-&gt;clear();
    }
    else
    {
        QFile file(fileName);
        if (!file.open(QFile::ReadOnly | QFile::Text))
        {
            RLogger::warning("Failed to load document file \'%s\'\n",fileName.toUtf8().constData());
            this-&gt;textBrowser-&gt;setHtml(tr("No document file available."));
        }
        else
        {
            QTextStream in(&amp;file);
            this-&gt;textBrowser-&gt;setHtml(in.readAll());
            file.close();
        }
    }
}

</t>
<t tx="leo.20201108101519.40">bool DrawEngineInput::isValid(double value) const
{
    if (this-&gt;type != DrawEngineInput::Double)
    {
        return false;
    }
    return (value &gt;= this-&gt;minValue.d &amp;&amp; value &lt;= this-&gt;maxValue.d);
}

</t>
<t tx="leo.20201108101519.41">bool DrawEngineInput::isValid(const RR3Vector &amp;value) const
{
    if (this-&gt;type != DrawEngineInput::Vector)
    {
        return false;
    }
    return (value.size() == 3);
}

</t>
<t tx="leo.20201108101519.42">bool DrawEngineInput::isValid(const RLocalDirection &amp;value) const
{
    if (this-&gt;type != DrawEngineInput::LocalDirection)
    {
        return false;
    }
    return true;
}

</t>
<t tx="leo.20201108101519.43">bool DrawEngineInput::isValid(const QString &amp;value) const
{
    if (this-&gt;type != DrawEngineInput::Text)
    {
        return false;
    }
    return !value.isEmpty();
}
</t>
<t tx="leo.20201108101519.44">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_line.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th October 2014                                        *
 *                                                                   *
 *  DESCRIPTION: Draw engine line class definition                   *
 *********************************************************************/

#include "draw_engine_line.h"

DrawEngineLine::DrawEngineLine(QObject *parent) :
    DrawEngineObject(parent)
{
    this-&gt;name = tr("line");

    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,0.0,0.0),
                                                 tr("1-st node position"),
                                                 tr("Node position in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(1.0,0.0,0.0),
                                                 tr("2-nd node position"),
                                                 tr("Node position in X,Y,Z coordinate system."),
                                                 "m"));

    this-&gt;updateModel();
}

RModelRaw DrawEngineLine::generate() const
{
    RModelRaw modelRaw;

    modelRaw.addSegment(RNode(this-&gt;inputParameters.at(0).toVector()),
                        RNode(this-&gt;inputParameters.at(1).toVector()));

    return modelRaw;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.45">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_object.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   1-st October 2014                                        *
 *                                                                   *
 *  DESCRIPTION: Draw engine object class definition                 *
 *********************************************************************/

#include "color.h"
#include "draw_engine_object.h"
#include "model.h"

DrawEngineObject::DrawEngineObject(QObject *parent) :
    QObject(parent),
    color(QColor(255,255,255,255))
{
    this-&gt;color = Color::random(true);
    this-&gt;color.setAlpha(100);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.46">const QString &amp;DrawEngineObject::getName() const
{
    return this-&gt;name;
}

uint DrawEngineObject::getNInputParameters() const
{
    return uint(this-&gt;inputParameters.size());
}

</t>
<t tx="leo.20201108101519.47">const DrawEngineInput &amp;DrawEngineObject::getInputParamater(uint position) const
{
    return this-&gt;inputParameters[int(position)];
}

DrawEngineInput &amp;DrawEngineObject::getInputParamater(uint position)
{
    return this-&gt;inputParameters[int(position)];
}

</t>
<t tx="leo.20201108101519.48">void DrawEngineObject::updateModel()
{
    this-&gt;model = Model(this-&gt;generate(),this-&gt;getName(),tr("Model to be drawn"),false);

    const bool onlyElements = true;

    for (uint i=0;i&lt;this-&gt;model.getNEntityGroups(onlyElements);i++)
    {
        REntityGroupType entityGroupType = this-&gt;model.getEntityGroupType(i,onlyElements);
        uint entityGroupPosition = this-&gt;model.getEntityGroupPosition(i,onlyElements);
        this-&gt;model.setVisible(entityGroupType,entityGroupPosition,true);
        this-&gt;model.setColor(entityGroupType,entityGroupPosition,this-&gt;color);
        this-&gt;model.setDrawEdges(entityGroupType,entityGroupPosition,true);
    }
}

Model &amp;DrawEngineObject::getModel()
{
    return this-&gt;model;
}

</t>
<t tx="leo.20201108101519.49">const Model &amp;DrawEngineObject::getModel() const
{
    return this-&gt;model;
}

</t>
<t tx="leo.20201108101519.5">void DocumentWidget::onListSelectionChanged(void)
{
    QList&lt;QListWidgetItem*&gt; selectedItems = this-&gt;listWidget-&gt;selectedItems();

    if (selectedItems.size() == 0)
    {
        this-&gt;loadFile(this-&gt;defaultFileName);
    }
    else
    {
        this-&gt;loadFile(selectedItems.at(0)-&gt;data(Qt::UserRole).toString());
    }
}
</t>
<t tx="leo.20201108101519.50">void DrawEngineObject::glDraw(GLWidget *glWidget) const
{
    bool useGlModelList = glWidget-&gt;getUseGLVoidModelList();
    glWidget-&gt;setUseGLVoidModelList(true);

    glWidget-&gt;getGLModelList().clear();
    this-&gt;model.glDraw(glWidget);
    glWidget-&gt;getGLModelList().clear();

    glWidget-&gt;setUseGLVoidModelList(useGlModelList);
}
</t>
<t tx="leo.20201108101519.51">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_point.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th October 2014                                        *
 *                                                                   *
 *  DESCRIPTION: Draw engine point class definition                  *
 *********************************************************************/

#include "draw_engine_point.h"

DrawEnginePoint::DrawEnginePoint(QObject *parent) :
    DrawEngineObject(parent)
{
    this-&gt;name = tr("point");

    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,0.0,0.0),
                                                 tr("Position"),
                                                 tr("Node position in X,Y,Z coordinate system."),
                                                 "m"));

    this-&gt;updateModel();
}

RModelRaw DrawEnginePoint::generate() const
{
    RModelRaw modelRaw;

    modelRaw.addPoint(RNode(this-&gt;inputParameters.at(0).toVector()));

    return modelRaw;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.52">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_quadrilateral.cpp                            *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th October 2014                                        *
 *                                                                   *
 *  DESCRIPTION: Draw engine quadrilateral class definition          *
 *********************************************************************/

#include "draw_engine_quadrilateral.h"

DrawEngineQuadrilateral::DrawEngineQuadrilateral(QObject *parent) :
    DrawEngineObject(parent)
{
    this-&gt;name = tr("quadrilateral");

    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,0.0,0.0),
                                                 tr("1-st node position"),
                                                 tr("Node position in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(1.0,0.0,0.0),
                                                 tr("2-nd node position"),
                                                 tr("Node position in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,1.0,0.0),
                                                 tr("3-rd node position"),
                                                 tr("Node position in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(1.0,1.0,0.0),
                                                 tr("4-th node position"),
                                                 tr("Node position in X,Y,Z coordinate system."),
                                                 "m"));

    this-&gt;updateModel();
}

RModelRaw DrawEngineQuadrilateral::generate() const
{
    RModelRaw modelRaw;

    modelRaw.addQuadrilateral(RNode(this-&gt;inputParameters.at(0).toVector()),
                              RNode(this-&gt;inputParameters.at(1).toVector()),
                              RNode(this-&gt;inputParameters.at(2).toVector()),
                              RNode(this-&gt;inputParameters.at(3).toVector()));

    return modelRaw;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.53">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_raw.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   2-nd November 2018                                       *
 *                                                                   *
 *  DESCRIPTION: Draw engine RAW object class definition             *
 *********************************************************************/

#include "draw_engine_raw.h"

DrawEngineRaw::DrawEngineRaw(QObject *parent) :
    DrawEngineObject(parent)
{
    this-&gt;name = tr("Geometry");

    QString rawContent("# RAW model file content\n"
                       "# Comments start with hash sign '#'\n"
                       "# Comments and empty lines are ignored\n"
                       "# \n"
                       "# Point element\n"
                       "# 0.0 0.0 0.0\n"
                       "# \n"
                       "# Line element\n"
                       "# 0.0 0.0 0.0  1.0 0.0 0.0\n"
                       "# \n"
                       "# Triangle element\n"
                       "# 0.0 0.0 0.0  1.0 0.0 0.0  1.0 0.0 0.0\n"
                       "# \n"
                       "# Quadrilateral element\n"
                       "# 0.0 0.0 0.0  1.0 0.0 0.0  1.0 1.0 0.0  0.0 1.0 0.0\n");

    this-&gt;inputParameters.append(DrawEngineInput(rawContent,tr("RAW model"),tr("RAW model file content."),"ASCII"));

    this-&gt;updateModel();
}

RModelRaw DrawEngineRaw::generate(const QString &amp;rawModelContent)
{
    RModelRaw model;

    QString content(rawModelContent);
    QTextStream textStream(&amp;content);

    try
    {
        model.readTextStream(textStream,RConstants::eps);
    }
    catch (const RError &amp;rError)
    {
        RLogger::warning("Failed to generate object from RAW model input. %s\n",rError.getMessage().toUtf8().constData());
    }

    return model;
}

RModelRaw DrawEngineRaw::generate() const
{
    return DrawEngineRaw::generate(this-&gt;inputParameters.at(0).toText());
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.54">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_sphere.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th October 2014                                        *
 *                                                                   *
 *  DESCRIPTION: Draw engine sphere class definition                 *
 *********************************************************************/

#include &lt;cmath&gt;

#include "draw_engine_sphere.h"

DrawEngineSphere::DrawEngineSphere(QObject *parent) :
    DrawEngineObject(parent)
{
    this-&gt;name = tr("sphere");

    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,0.0,0.0),
                                                 tr("Position"),
                                                 tr("Position in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(0.25,tr("Radius"),tr("Sphere radius."),"m",RConstants::eps));
    this-&gt;inputParameters.append(DrawEngineInput(uint(3),tr("Refinement"),tr("Number of refinement iterations."),"#",uint(1),uint(5)));

    this-&gt;updateModel();
}

RModelRaw DrawEngineSphere::generate(const RR3Vector &amp;center, double radius, uint nIter)
{
    double a = 1.0/sqrt(2.0);

    RNode n1(0.0,0.0,1.0);
    RNode n2(0.0,0.0,-1.0);
    RNode n3(-a,-a,0.0);
    RNode n4(a,-a,0.0);
    RNode n5(a,a,0.0);
    RNode n6(-a,a,0.0);

    std::vector&lt;RTriangle*&gt; s;

    s.push_back(new RTriangle(n1,n4,n5));
    s.push_back(new RTriangle(n1,n5,n6));
    s.push_back(new RTriangle(n1,n6,n3));
    s.push_back(new RTriangle(n1,n3,n4));
    s.push_back(new RTriangle(n2,n5,n4));
    s.push_back(new RTriangle(n2,n6,n5));
    s.push_back(new RTriangle(n2,n3,n6));
    s.push_back(new RTriangle(n2,n4,n3));

    RModelRaw modelRaw;

    // Perform bisection untill sone refinement is reached
    for (uint iter=0;iter&lt;nIter;iter++)
    {
        uint nt = uint(s.size());
        for (uint i=0;i&lt;nt;i++)
        {
            RTriangle *t = s.at(i);

            RNode n1 = t-&gt;getNode1();
            RNode n2 = t-&gt;getNode2();
            RNode n3 = t-&gt;getNode3();

            RR3Vector v1 = n1.toVector();
            RR3Vector v2 = n2.toVector();
            RR3Vector v3 = n3.toVector();

            RR3Vector v12((v1[0]+v2[0])/2.0,(v1[1]+v2[1])/2.0,(v1[2]+v2[2])/2.0);
            RR3Vector v23((v2[0]+v3[0])/2.0,(v2[1]+v3[1])/2.0,(v2[2]+v3[2])/2.0);
            RR3Vector v31((v3[0]+v1[0])/2.0,(v3[1]+v1[1])/2.0,(v3[2]+v1[2])/2.0);

            v12.normalize();
            v23.normalize();
            v31.normalize();

            RNode n12(v12);
            RNode n23(v23);
            RNode n31(v31);

            t-&gt;setNodes(n12,n23,n31);

            s.push_back(new RTriangle(n1,n12,n31));
            s.push_back(new RTriangle(n2,n23,n12));
            s.push_back(new RTriangle(n3,n31,n23));
        }
    }

    // Convert to RAW model
    for (uint i=0;i&lt;s.size();i++)
    {
        RTriangle *t = s.at(i);

        RNode n1 = t-&gt;getNode1();
        RNode n2 = t-&gt;getNode2();
        RNode n3 = t-&gt;getNode3();

        n1.scale(radius);
        n1.translate(center);

        n2.scale(radius);
        n2.translate(center);

        n3.scale(radius);
        n3.translate(center);

        modelRaw.addTriangle(n1,n2,n3);
    }

    return modelRaw;
}

RModelRaw DrawEngineSphere::generate() const
{
    RR3Vector c = this-&gt;inputParameters.at(0).toVector();
    double r = this-&gt;inputParameters.at(1).toDouble();
    uint nIter = this-&gt;inputParameters.at(2).toUint();

    return DrawEngineSphere::generate(c,r,nIter);
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.55">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_tetrahedron.cpp                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th Jun 2015                                           *
 *                                                                   *
 *  DESCRIPTION: Draw engine tetrahedron class definition            *
 *********************************************************************/

#include "draw_engine_tetrahedron.h"

DrawEngineTetrahedron::DrawEngineTetrahedron(QObject *parent)
    : DrawEngineObject(parent)
{
    this-&gt;name = tr("tetrahedron");

    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,0.0,0.0),
                                                 tr("1-st node"),
                                                 tr("Position of 1-st node in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(1.0,0.0,0.0),
                                                 tr("2-nd node"),
                                                 tr("Position of 2-nd node in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,1.0,0.0),
                                                 tr("3-rd node"),
                                                 tr("Position of 3-rd node in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,0.0,1.0),
                                                 tr("4-th node"),
                                                 tr("Position of 4-th node in X,Y,Z coordinate system."),
                                                 "m"));

    this-&gt;updateModel();
}

RModelRaw DrawEngineTetrahedron::generate() const
{
    RModelRaw modelRaw;

    RNode node1(this-&gt;inputParameters.at(0).toVector());
    RNode node2(this-&gt;inputParameters.at(1).toVector());
    RNode node3(this-&gt;inputParameters.at(2).toVector());
    RNode node4(this-&gt;inputParameters.at(3).toVector());

    modelRaw.addTriangle(node1,node3,node2);
    modelRaw.addTriangle(node1,node2,node4);
    modelRaw.addTriangle(node3,node1,node4);
    modelRaw.addTriangle(node2,node3,node4);

    return modelRaw;
}

@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.56">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_engine_triangle.cpp                                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th October 2014                                        *
 *                                                                   *
 *  DESCRIPTION: Draw engine triangle class definition               *
 *********************************************************************/

#include "draw_engine_triangle.h"

DrawEngineTriangle::DrawEngineTriangle(QObject *parent) :
    DrawEngineObject(parent)
{
    this-&gt;name = tr("triangle");

    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,0.0,0.0),
                                                 tr("1-st node position"),
                                                 tr("Node position in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(1.0,0.0,0.0),
                                                 tr("2-nd node position"),
                                                 tr("Node position in X,Y,Z coordinate system."),
                                                 "m"));
    this-&gt;inputParameters.append(DrawEngineInput(RR3Vector(0.0,1.0,0.0),
                                                 tr("3-rd node position"),
                                                 tr("Node position in X,Y,Z coordinate system."),
                                                 "m"));

    this-&gt;updateModel();
}

RModelRaw DrawEngineTriangle::generate() const
{
    RModelRaw modelRaw;

    modelRaw.addTriangle(RNode(this-&gt;inputParameters.at(0).toVector()),
                         RNode(this-&gt;inputParameters.at(1).toVector()),
                         RNode(this-&gt;inputParameters.at(2).toVector()));

    return modelRaw;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.57">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_input_tree.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th September 2014                                     *
 *                                                                   *
 *  DESCRIPTION: Draw input tree class definition                    *
 *********************************************************************/

#include "draw_input_tree.h"
#include "session.h"
#include "main_window.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.58">typedef enum _DrawInputTreeColumn
{
    DRAW_INPUT_TREE_COLUMN_1 = 0,
    DRAW_INPUT_TREE_COLUMN_2,
    DRAW_INPUT_TREE_COLUMN_3,
    DRAW_INPUT_TREE_COLUMN_4,
    DRAW_INPUT_TREE_N_COLUMNS
} DrawInputTreeColumn;

DrawInputTree::DrawInputTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setColumnCount(DRAW_INPUT_TREE_N_COLUMNS);
    this-&gt;setHeaderHidden(true);
    this-&gt;setRootIsDecorated(false);

    this-&gt;populate();

    QObject::connect(Session::getInstance().getDrawEngine(),
                     &amp;DrawEngine::objectAdded,
                     this,
                     &amp;DrawInputTree::onDrawObjectAdded);

    QObject::connect(Session::getInstance().getDrawEngine(),
                     &amp;DrawEngine::objectRemoved,
                     this,
                     &amp;DrawInputTree::onDrawObjectRemoved);

    QObject::connect(Session::getInstance().getDrawEngine(),
                     &amp;DrawEngine::objectsRemoved,
                     this,
                     &amp;DrawInputTree::onDrawObjectsRemoved);

    QObject::connect(this,
                     &amp;QTreeWidget::itemDoubleClicked,
                     this,
                     &amp;DrawInputTree::onItemDoubleClicked);

    QObject::connect(this,
                     &amp;QTreeWidget::itemChanged,
                     this,
                     &amp;DrawInputTree::onItemChanged);

    QObject::connect(this,
                     &amp;QTreeWidget::itemSelectionChanged,
                     this,
                     &amp;DrawInputTree::onItemSelectionChanged);

//    QObject::connect(&amp;Session::getInstance(),
//                     &amp;Session::pickListChanged,
//                     this,
//                     &amp;DrawInputTree::onPickListChanged);
//    QObject::connect(&amp;Session::getInstance(),
//                     &amp;Session::modelAdded,
//                     this,
//                     &amp;DrawInputTree::onPickListChanged);
//    QObject::connect(&amp;Session::getInstance(),
//                     &amp;Session::modelRemoved,
//                     this,
//                     &amp;DrawInputTree::onPickListChanged);
//    QObject::connect(&amp;Session::getInstance(),
//                     &amp;Session::modelChanged,
//                     this,
//                     &amp;DrawInputTree::onPickListChanged);
}

QList&lt;uint&gt; DrawInputTree::getSelectedObjectIDs() const
{
    QList&lt;QTreeWidgetItem*&gt; selectedItems = this-&gt;selectedItems();
    QSet&lt;uint&gt; objectIDs;

    for (int i=0;i&lt;selectedItems.size();i++)
    {
        objectIDs.insert(this-&gt;getItemObjectID(selectedItems[i]));
    }
    return objectIDs.toList();
}

</t>
<t tx="leo.20201108101519.59">void DrawInputTree::setRequestedItemVectorValue(const RR3Vector &amp;v)
{
    if (this-&gt;requestedItem)
    {
        DrawInputTree::setItemVectorValue(this-&gt;requestedItem,v);
    }
}

</t>
<t tx="leo.20201108101519.6">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   download_manager.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th May 2016                                            *
 *                                                                   *
 *  DESCRIPTION: Download manager class definition                   *
 *********************************************************************/

#include &lt;QUrlQuery&gt;
#include &lt;QFileInfo&gt;
#include &lt;QDir&gt;
#include &lt;QNetworkRequest&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QString&gt;
#include &lt;QStringList&gt;
#include &lt;QTimer&gt;

#include &lt;rblib.h&gt;
#include &lt;rmlib.h&gt;

#include "download_manager.h"
#include "main_settings.h"

DownloadManager::DownloadManager(QObject *parent)
    : QObject(parent)
    , downloadID(0)
    , downloadedCount(0)
    , totalCount(0)
{
}

uint DownloadManager::append(const QUrl &amp;url)
{
    if (this-&gt;downloadQueue.isEmpty())
    {
        QTimer::singleShot(0, this, SLOT(startNextDownload()));
    }

    this-&gt;downloadQueue.enqueue(url);
    this-&gt;totalCount++;
    return ++this-&gt;downloadID;
}

QString DownloadManager::saveFileNameFromUrl(const QUrl &amp;url)
{
    QString basename = QFileInfo(url.path()).fileName();

    if (basename.isEmpty())
    {
        basename = QUrlQuery(url).queryItemValue("file");
    }

    if (basename.isEmpty())
    {        
        basename = "download";
    }

    basename = QDir(MainSettings::getInstance().getTmpDir()).filePath(basename);

    if (QFile::exists(basename))
    {
        // already exists, don't overwrite
        int i = 1;
        while (QFile::exists(RFileManager::getFileNameWithTimeStep(basename,i)))
        {
            ++i;
        }

        basename = RFileManager::getFileNameWithTimeStep(basename,i);
    }

    return basename;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.60">void DrawInputTree::setRequestedItemLocalDirectionValue(const RLocalDirection &amp;localDirection)
{
    if (this-&gt;requestedItem)
    {
        DrawInputTree::setItemLocalDirectionValue(this-&gt;requestedItem,localDirection);
    }
}

</t>
<t tx="leo.20201108101519.61">void DrawInputTree::setRequestedItemTextValue(const QString &amp;text)
{
    if (this-&gt;requestedItem)
    {
        DrawInputTree::setItemTextValue(this-&gt;requestedItem,text);
    }
}

</t>
<t tx="leo.20201108101519.62">void DrawInputTree::releaseRequestedItem()
{
    this-&gt;requestedItem = 0;
}

</t>
<t tx="leo.20201108101519.63">void DrawInputTree::populate()
{
    this-&gt;blockSignals(true);

    this-&gt;clear();

    for (uint i=0;i&lt;Session::getInstance().getDrawEngine()-&gt;getNObjects();i++)
    {
        const DrawEngineObject *object = Session::getInstance().getDrawEngine()-&gt;getObject(i);

        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setText(DRAW_INPUT_TREE_COLUMN_1,object-&gt;getName());
        item-&gt;setFirstColumnSpanned(true);

        item-&gt;setForeground(DRAW_INPUT_TREE_COLUMN_1,this-&gt;palette().brush(QPalette::Active,QPalette::Text));
        QFont font1(item-&gt;font(DRAW_INPUT_TREE_COLUMN_1));
        font1.setBold(true);
        item-&gt;setFont(DRAW_INPUT_TREE_COLUMN_1,font1);

        for (uint j=0;j&lt;object-&gt;getNInputParameters();j++)
        {
            QTreeWidgetItem *childItem = new QTreeWidgetItem(item);
            childItem-&gt;setText(DRAW_INPUT_TREE_COLUMN_1,object-&gt;getInputParamater(j).getName());
            childItem-&gt;setData(DRAW_INPUT_TREE_COLUMN_1,Qt::UserRole,QVariant(object-&gt;getInputParamater(j).getType()));
            childItem-&gt;setText(DRAW_INPUT_TREE_COLUMN_3,object-&gt;getInputParamater(j).getUnits());
            childItem-&gt;setText(DRAW_INPUT_TREE_COLUMN_4,object-&gt;getInputParamater(j).getDescription());

            childItem-&gt;setForeground(DRAW_INPUT_TREE_COLUMN_2,this-&gt;palette().brush(QPalette::Active,QPalette::Text));
            QFont font2(childItem-&gt;font(DRAW_INPUT_TREE_COLUMN_2));
            font2.setBold(true);
            childItem-&gt;setFont(DRAW_INPUT_TREE_COLUMN_2,font2);

            childItem-&gt;setForeground(DRAW_INPUT_TREE_COLUMN_4,this-&gt;palette().brush(QPalette::Active,QPalette::Text));
            QFont font4(childItem-&gt;font(DRAW_INPUT_TREE_COLUMN_4));
            font4.setItalic(true);
            childItem-&gt;setFont(DRAW_INPUT_TREE_COLUMN_4,font4);

            switch (object-&gt;getInputParamater(j).getType())
            {
                case DrawEngineInput::Bool:
                {
                    childItem-&gt;setFlags(childItem-&gt;flags() | Qt::ItemIsUserCheckable);
                    childItem-&gt;setCheckState(DRAW_INPUT_TREE_COLUMN_2,object-&gt;getInputParamater(j).toBool()?Qt::Checked:Qt::Unchecked);
                    break;
                }
                case DrawEngineInput::Int:
                {
                    childItem-&gt;setText(DRAW_INPUT_TREE_COLUMN_2,QString::number(object-&gt;getInputParamater(j).toInt()));
                    break;
                }
                case DrawEngineInput::Uint:
                {
                    childItem-&gt;setText(DRAW_INPUT_TREE_COLUMN_2,QString::number(object-&gt;getInputParamater(j).toUint()));
                    break;
                }
                case DrawEngineInput::Double:
                {
                    childItem-&gt;setText(DRAW_INPUT_TREE_COLUMN_2,QString::number(object-&gt;getInputParamater(j).toDouble()));
                    break;
                }
                case DrawEngineInput::Vector:
                {
                    DrawInputTree::setItemVectorValue(childItem,object-&gt;getInputParamater(j).toVector());
                    break;
                }
                case DrawEngineInput::LocalDirection:
                {
                    DrawInputTree::setItemLocalDirectionValue(childItem,object-&gt;getInputParamater(j).toLocalDirection());
                    break;
                }
                case DrawEngineInput::Text:
                {
                    DrawInputTree::setItemTextValue(childItem,object-&gt;getInputParamater(j).toText());
                    break;
                }
                default:
                {
                    break;
                }
            }
        }
    }

    this-&gt;expandAll();

    this-&gt;resizeColumnToContents(DRAW_INPUT_TREE_COLUMN_1);
    this-&gt;resizeColumnToContents(DRAW_INPUT_TREE_COLUMN_2);
    this-&gt;resizeColumnToContents(DRAW_INPUT_TREE_COLUMN_3);
    this-&gt;resizeColumnToContents(DRAW_INPUT_TREE_COLUMN_4);

    this-&gt;blockSignals(false);
}

uint DrawInputTree::getItemObjectID(QTreeWidgetItem *item) const
{
    if (item-&gt;childCount() &gt; 0)
    {
        return uint(this-&gt;indexOfTopLevelItem(item));
    }
    else
    {
        return uint(this-&gt;indexOfTopLevelItem(item-&gt;parent()));
    }
}

</t>
<t tx="leo.20201108101519.64">void DrawInputTree::setItemVectorValue(QTreeWidgetItem *item, const RR3Vector &amp;v)
{
    QString vStr = QString::number(v[0]) + ";" + QString::number(v[1]) + ";" + QString::number(v[2]);
    item-&gt;setText(DRAW_INPUT_TREE_COLUMN_2,vStr);
}

RR3Vector DrawInputTree::getItemVectorValue(QTreeWidgetItem *item)
{
    return DrawInputTree::stringToVector(item-&gt;text(DRAW_INPUT_TREE_COLUMN_2));
}

RR3Vector DrawInputTree::stringToVector(const QString &amp;vectorStr)
{
    RR3Vector v;

    QStringList strList = vectorStr.split(';');
    if (strList.size() &gt; 0)
    {
        v[0] = strList[0].toDouble();
    }
    if (strList.size() &gt; 1)
    {
        v[1] = strList[1].toDouble();
    }
    if (strList.size() &gt; 2)
    {
        v[2] = strList[2].toDouble();
    }

    return v;
}

</t>
<t tx="leo.20201108101519.65">void DrawInputTree::setItemLocalDirectionValue(QTreeWidgetItem *item, const RLocalDirection &amp;localDirectionStr)
{
    const RR3Vector &amp;p = localDirectionStr.getPosition();
    const RR3Vector &amp;d = localDirectionStr.getDirection();
    QString vStr = QString::number(p[0]) + ";" + QString::number(p[1]) + ";" + QString::number(p[2]) + "/" + QString::number(d[0]) + ";" + QString::number(d[1]) + ";" + QString::number(d[2]);
    item-&gt;setText(DRAW_INPUT_TREE_COLUMN_2,vStr);
}

RLocalDirection DrawInputTree::getItemLocalDirectionValue(QTreeWidgetItem *item)
{
    return DrawInputTree::stringToLocalDirection(item-&gt;text(DRAW_INPUT_TREE_COLUMN_2));
}

RLocalDirection DrawInputTree::stringToLocalDirection(const QString &amp;localDirectionStr)
{
    RR3Vector position(0.0,0.0,0.0);
    RR3Vector direction(0.0,0.0,1.0);

    QStringList strList = localDirectionStr.split('/');
    if (strList.size() &gt; 0)
    {
        position = DrawInputTree::stringToVector(strList[0]);
    }
    if (strList.size() &gt; 1)
    {
        direction = DrawInputTree::stringToVector(strList[1]);
    }
    return RLocalDirection(position,direction);
}

</t>
<t tx="leo.20201108101519.66">void DrawInputTree::setItemTextValue(QTreeWidgetItem *item, const QString &amp;text)
{
    int nLines = 0;
    if (!text.isEmpty())
    {
        nLines++;
    }
    nLines += text.count(QLatin1Char('\n'));

    item-&gt;setText(DRAW_INPUT_TREE_COLUMN_2,"content (" + QString::number(nLines) + " lines)");
    item-&gt;setData(DRAW_INPUT_TREE_COLUMN_2,Qt::UserRole,QVariant(text));
}

QString DrawInputTree::getItemTextValue(QTreeWidgetItem *item)
{
    return item-&gt;data(DRAW_INPUT_TREE_COLUMN_2,Qt::UserRole).toString();
}

</t>
<t tx="leo.20201108101519.67">void DrawInputTree::onDrawObjectAdded()
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101519.68">void DrawInputTree::onDrawObjectRemoved(uint position)
{
    this-&gt;takeTopLevelItem(position);
}

</t>
<t tx="leo.20201108101519.69">void DrawInputTree::onDrawObjectsRemoved()
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101519.7">void DownloadManager::startNextDownload(void)
{
    emit this-&gt;started(this-&gt;downloadID);
    if (this-&gt;downloadQueue.isEmpty())
    {
        RLogger::info("%d/%d files downloaded successfully\n", this-&gt;downloadedCount, this-&gt;totalCount);
        return;
    }

    QUrl url = this-&gt;downloadQueue.dequeue();

    QString filename = DownloadManager::saveFileNameFromUrl(url);
    RLogger::info("Writing to file \'%s\'\n",filename.toUtf8().constData());
    this-&gt;output.setFileName(filename);
    if (!this-&gt;output.open(QIODevice::WriteOnly))
    {
        RLogger::warning("Problem opening save file '%s' for download '%s': %s\n",
                         qPrintable(filename),
                         url.toEncoded().constData(),
                         qPrintable(this-&gt;output.errorString()));
        emit this-&gt;failed(this-&gt;downloadID);

        this-&gt;startNextDownload();
        return;                 // skip this download
    }

    QNetworkRequest request(url);
    this-&gt;currentDownload = this-&gt;manager.get(request);
    connect(this-&gt;currentDownload, SIGNAL(downloadProgress(qint64,qint64)), SLOT(downloadProgress(qint64,qint64)));
    connect(this-&gt;currentDownload, SIGNAL(finished()), SLOT(downloadFinished()));
    connect(this-&gt;currentDownload, SIGNAL(readyRead()), SLOT(downloadReadyRead()));

    // prepare the output
    RLogger::info("Downloading %s...\n", url.toEncoded().constData());
    this-&gt;downloadTime.start();
}

</t>
<t tx="leo.20201108101519.70">void DrawInputTree::onItemDoubleClicked(QTreeWidgetItem *item, int column)
{
    if (column == DRAW_INPUT_TREE_COLUMN_2)
    {
        if (item-&gt;data(DRAW_INPUT_TREE_COLUMN_1,Qt::UserRole).toInt() == DrawEngineInput::Vector)
        {
            this-&gt;requestedItem = item;
            emit this-&gt;positionRequest(DrawInputTree::getItemVectorValue(item));
        }
        else if (item-&gt;data(DRAW_INPUT_TREE_COLUMN_1,Qt::UserRole).toInt() == DrawEngineInput::LocalDirection)
        {
            this-&gt;requestedItem = item;
            emit this-&gt;localDirectionRequest(DrawInputTree::getItemLocalDirectionValue(item));
        }
        else if (item-&gt;data(DRAW_INPUT_TREE_COLUMN_1,Qt::UserRole).toInt() == DrawEngineInput::Text)
        {
            this-&gt;requestedItem = item;
            emit this-&gt;textRequest(DrawInputTree::getItemTextValue(item));
        }
        else
        {
            item-&gt;setFlags(item-&gt;flags() | Qt::ItemIsEditable);
        }
    }
    else
    {
        if (item-&gt;flags() &amp; Qt::ItemIsEditable)
        {
            item-&gt;setFlags(item-&gt;flags() ^ Qt::ItemIsEditable);
        }
    }
}

</t>
<t tx="leo.20201108101519.71">void DrawInputTree::onItemChanged(QTreeWidgetItem *item, int column)
{
    if (column != DRAW_INPUT_TREE_COLUMN_2)
    {
        return;
    }

    QString valueStr = item-&gt;text(DRAW_INPUT_TREE_COLUMN_2);

    uint objectID = this-&gt;getItemObjectID(item);
    uint parameterID = uint(item-&gt;parent()-&gt;indexOfChild(item));

    DrawEngineObject *object = Session::getInstance().getDrawEngine()-&gt;getObject(objectID);
    bool valueChanged = false;

    this-&gt;blockSignals(true);
    switch (item-&gt;data(DRAW_INPUT_TREE_COLUMN_1,Qt::UserRole).toInt())
    {
        case DrawEngineInput::Bool:
        {
            bool value = item-&gt;checkState(DRAW_INPUT_TREE_COLUMN_2) != Qt::Unchecked;
            valueChanged = object-&gt;getInputParamater(parameterID).setValue(value);
            break;
        }
        case DrawEngineInput::Int:
        {
            int value = valueStr.toInt();
            if (!(valueChanged = object-&gt;getInputParamater(parameterID).setValue(value)))
            {
                value = object-&gt;getInputParamater(parameterID).toInt();
            }
            item-&gt;setText(DRAW_INPUT_TREE_COLUMN_2,QString::number(value));
            break;
        }
        case DrawEngineInput::Uint:
        {
            uint value = valueStr.toUInt();
            if (!(valueChanged = object-&gt;getInputParamater(parameterID).setValue(value)))
            {
                value = object-&gt;getInputParamater(parameterID).toUint();
            }
            item-&gt;setText(DRAW_INPUT_TREE_COLUMN_2,QString::number(value));
            break;
        }
        case DrawEngineInput::Double:
        {
            double value = valueStr.toDouble();
            if (!(valueChanged = object-&gt;getInputParamater(parameterID).setValue(value)))
            {
                value = object-&gt;getInputParamater(parameterID).toDouble();
            }
            item-&gt;setText(DRAW_INPUT_TREE_COLUMN_2,QString::number(value));
            break;
        }
        case DrawEngineInput::Vector:
        {
            RR3Vector v(DrawInputTree::stringToVector(valueStr));
            if (!(valueChanged = object-&gt;getInputParamater(parameterID).setValue(v)))
            {
                v = object-&gt;getInputParamater(parameterID).toVector();
            }
            DrawInputTree::setItemVectorValue(item,v);
            break;
        }
        case DrawEngineInput::LocalDirection:
        {
            RLocalDirection localDirection(DrawInputTree::stringToLocalDirection(valueStr));
            if (!(valueChanged = object-&gt;getInputParamater(parameterID).setValue(localDirection)))
            {
                localDirection = object-&gt;getInputParamater(parameterID).toLocalDirection();
            }
            DrawInputTree::setItemLocalDirectionValue(item,localDirection);
            break;
        }
        case DrawEngineInput::Text:
        {
            QString valueStr = item-&gt;data(DRAW_INPUT_TREE_COLUMN_2,Qt::UserRole).toString();
            if (!(valueChanged = object-&gt;getInputParamater(parameterID).setValue(valueStr)))
            {
                valueStr = object-&gt;getInputParamater(parameterID).toText();
            }
            DrawInputTree::setItemTextValue(item,valueStr);
            break;
        }
        default:
        {
            break;
        }
    }

    if (valueChanged)
    {
        Session::getInstance().getDrawEngine()-&gt;setObjectChanged(objectID);
    }

    this-&gt;blockSignals(false);
    this-&gt;resizeColumnToContents(DRAW_INPUT_TREE_COLUMN_2);

    emit this-&gt;inputParameterChanged(objectID,parameterID);
}

</t>
<t tx="leo.20201108101519.72">void DrawInputTree::onItemSelectionChanged()
{
    emit this-&gt;selectionChanged(this-&gt;getSelectedObjectIDs());
}
</t>
<t tx="leo.20201108101519.73">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   draw_input_widget.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th October 2014                                       *
 *                                                                   *
 *  DESCRIPTION: Draw input widget class definition                  *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QStackedLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QMessageBox&gt;

#include "draw_input_widget.h"
#include "session.h"

DrawInputWidget::DrawInputWidget(QWidget *parent) :
    QWidget(parent)
{
    this-&gt;stackedLayout = new QStackedLayout;
    this-&gt;setLayout(this-&gt;stackedLayout);

    this-&gt;positionWidget = new PositionWidget(tr("Position"),RR3Vector());
    this-&gt;positionWidget-&gt;hideSliders();
    this-&gt;positionWidget-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Minimum);
    this-&gt;stackedLayout-&gt;addWidget(this-&gt;positionWidget);

    QObject::connect(this-&gt;positionWidget,
                     &amp;PositionWidget::changed,
                     this,
                     &amp;DrawInputWidget::onPositionWidgetChanged);
    QObject::connect(this-&gt;positionWidget,
                     &amp;PositionWidget::closed,
                     this,
                     &amp;DrawInputWidget::onPositionWidgetClosed);

    this-&gt;localDirectionWidget = new LocalDirectionWidget(tr("Local direction"),RLocalDirection());
    this-&gt;localDirectionWidget-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Minimum);
    this-&gt;stackedLayout-&gt;addWidget(this-&gt;localDirectionWidget);

    QObject::connect(this-&gt;localDirectionWidget,
                     &amp;LocalDirectionWidget::changed,
                     this,
                     &amp;DrawInputWidget::onLocalDirectionWidgetChanged);
    QObject::connect(this-&gt;localDirectionWidget,
                     &amp;LocalDirectionWidget::closed,
                     this,
                     &amp;DrawInputWidget::onLocalDirectionWidgetClosed);

    this-&gt;textWidget = new TextEditWidget;
    this-&gt;textWidget-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Minimum);
    this-&gt;stackedLayout-&gt;addWidget(this-&gt;textWidget);

    QObject::connect(this-&gt;textWidget,
                     &amp;TextEditWidget::changed,
                     this,
                     &amp;DrawInputWidget::onTextWidgetChanged);
    QObject::connect(this-&gt;textWidget,
                     &amp;TextEditWidget::closed,
                     this,
                     &amp;DrawInputWidget::onPositionWidgetClosed);

    this-&gt;layoutWidget = new QWidget;
    this-&gt;stackedLayout-&gt;addWidget(this-&gt;layoutWidget);
    this-&gt;stackedLayout-&gt;setCurrentWidget(this-&gt;layoutWidget);

    QGridLayout *layout = new QGridLayout;
    this-&gt;layoutWidget-&gt;setLayout(layout);

    this-&gt;tree = new DrawInputTree;
    layout-&gt;addWidget(this-&gt;tree,0,0,1,2);

    QObject::connect(this-&gt;tree,
                     &amp;DrawInputTree::selectionChanged,
                     this,
                     &amp;DrawInputWidget::onSelectionChanged);
    QObject::connect(this-&gt;tree,
                     &amp;DrawInputTree::positionRequest,
                     this,
                     &amp;DrawInputWidget::onPositionRequest);
    QObject::connect(this-&gt;tree,
                     &amp;DrawInputTree::localDirectionRequest,
                     this,
                     &amp;DrawInputWidget::onLocalDirectionRequest);
    QObject::connect(this-&gt;tree,
                     &amp;DrawInputTree::textRequest,
                     this,
                     &amp;DrawInputWidget::onTextRequest);
    QObject::connect(this-&gt;tree,
                     &amp;DrawInputTree::inputParameterChanged,
                     this,
                     &amp;DrawInputWidget::onInputParameterChanged);

    this-&gt;mergeNodesCheck = new QCheckBox(tr("Merge near nodes"));
    this-&gt;mergeNodesCheck-&gt;setCheckState(Qt::Checked);
    layout-&gt;addWidget(this-&gt;mergeNodesCheck,1,0,1,2);

    QIcon removeIcon(":/icons/file/pixmaps/range-remove.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");

    this-&gt;removeButton = new QPushButton(removeIcon,tr("Remove"));
    this-&gt;removeButton-&gt;setDisabled(true);
    layout-&gt;addWidget(this-&gt;removeButton,2,0,1,1);

    QObject::connect(this-&gt;removeButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;DrawInputWidget::onRemoveClicked);

    this-&gt;okButton = new QPushButton(okIcon,tr("Ok"));
    layout-&gt;addWidget(this-&gt;okButton,2,1,1,1);

    QObject::connect(this-&gt;okButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;DrawInputWidget::onOkClicked);

    QPushButton *cancelButton = new QPushButton(cancelIcon,tr("Cancel"));
    layout-&gt;addWidget(cancelButton,3,0,1,2);

    QObject::connect(cancelButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;DrawInputWidget::onCancelClicked);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.74">void DrawInputWidget::onPositionRequest(const RR3Vector &amp;position)
{
    this-&gt;positionWidget-&gt;setPosition(position);
    this-&gt;stackedLayout-&gt;setCurrentWidget(this-&gt;positionWidget);
}

</t>
<t tx="leo.20201108101519.75">void DrawInputWidget::onPositionWidgetChanged(const RR3Vector &amp;position)
{
    this-&gt;tree-&gt;setRequestedItemVectorValue(position);
}

</t>
<t tx="leo.20201108101519.76">void DrawInputWidget::onPositionWidgetClosed()
{
    this-&gt;stackedLayout-&gt;setCurrentWidget(this-&gt;layoutWidget);
}

</t>
<t tx="leo.20201108101519.77">void DrawInputWidget::onLocalDirectionRequest(const RLocalDirection &amp;localDirection)
{
    this-&gt;localDirectionWidget-&gt;setLocalDirection(localDirection);
    this-&gt;stackedLayout-&gt;setCurrentWidget(this-&gt;localDirectionWidget);
}

</t>
<t tx="leo.20201108101519.78">void DrawInputWidget::onLocalDirectionWidgetChanged(const RLocalDirection &amp;localDirection)
{
    this-&gt;tree-&gt;setRequestedItemLocalDirectionValue(localDirection);
}

</t>
<t tx="leo.20201108101519.79">void DrawInputWidget::onLocalDirectionWidgetClosed()
{
    this-&gt;stackedLayout-&gt;setCurrentWidget(this-&gt;layoutWidget);
}

</t>
<t tx="leo.20201108101519.8">void DownloadManager::downloadProgress(qint64 bytesReceived, qint64 bytesTotal)
{
    // calculate the download speed
    double speed = bytesReceived * 1000.0 / this-&gt;downloadTime.elapsed();
    emit this-&gt;progress(this-&gt;downloadID,bytesReceived, bytesTotal,speed);
}

</t>
<t tx="leo.20201108101519.80">void DrawInputWidget::onTextRequest(const QString &amp;text)
{
    this-&gt;textWidget-&gt;setText(text);
    this-&gt;stackedLayout-&gt;setCurrentWidget(this-&gt;textWidget);
}

</t>
<t tx="leo.20201108101519.81">void DrawInputWidget::onTextWidgetChanged(const QString &amp;text)
{
    this-&gt;tree-&gt;setRequestedItemTextValue(text);
}

</t>
<t tx="leo.20201108101519.82">void DrawInputWidget::onTextWidgetClosed()
{
    this-&gt;stackedLayout-&gt;setCurrentWidget(this-&gt;layoutWidget);
}

</t>
<t tx="leo.20201108101519.83">void DrawInputWidget::onSelectionChanged(const QList&lt;uint&gt; &amp;objectIDs)
{
    this-&gt;removeButton-&gt;setEnabled(objectIDs.size() &gt; 0);
}

</t>
<t tx="leo.20201108101519.84">void DrawInputWidget::onInputParameterChanged(uint objectID, uint)
{
    Session::getInstance().getDrawEngine()-&gt;getObject(objectID)-&gt;updateModel();
}

</t>
<t tx="leo.20201108101519.85">void DrawInputWidget::onRemoveClicked()
{
    QList&lt;uint&gt; objectIDs = this-&gt;tree-&gt;getSelectedObjectIDs();

    for (int i=objectIDs.size()-1;i&gt;=0;--i)
    {
        Session::getInstance().getDrawEngine()-&gt;removeObject(objectIDs[i]);
    }
}

</t>
<t tx="leo.20201108101519.86">void DrawInputWidget::onOkClicked()
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    if (modelIDs.size() == 0)
    {
        QMessageBox::warning(this,tr("No model is selected"),tr("To draw an object at least one model must be selected."),QMessageBox::Ok);
        return;
    }

    QString message = "Prepared objects will be added to following (selected) models:&lt;ul&gt;";
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        message += "&lt;li&gt;" + Session::getInstance().getModel(modelIDs[i]).getName() + "&lt;/li&gt;";
    }
    message += "&lt;/ul&gt;";

    @others
}

</t>
<t tx="leo.20201108101519.87">int response = QMessageBox::question(this,
                                     "Draw objects(s)?",
                                     message,
                                     QMessageBox::Ok | QMessageBox::Cancel,
                                     QMessageBox::Cancel);
if (response == QMessageBox::Cancel)
{
    return;
}

this-&gt;tree-&gt;releaseRequestedItem();
Session::getInstance().getDrawEngine()-&gt;processObjects(modelIDs,
                                                       this-&gt;mergeNodesCheck-&gt;checkState() != Qt::Unchecked,
                                                       RConstants::eps,
                                                       true);
</t>
<t tx="leo.20201108101519.88">void DrawInputWidget::onCancelClicked()
{
    uint nObjects = Session::getInstance().getDrawEngine()-&gt;getNObjects();
    do
    {
        Session::getInstance().getDrawEngine()-&gt;removeObject(--nObjects);
    } while (nObjects &gt; 0);
}
</t>
<t tx="leo.20201108101519.89">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   drop_results_dialog.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   25-th Septamber 2013                                     *
 *                                                                   *
 *  DESCRIPTION: Drop results dialog class definition                *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QCheckBox&gt;
#include &lt;QListWidget&gt;
#include &lt;QPushButton&gt;

#include "drop_results_dialog.h"
#include "session.h"

static bool clearResults = true;
static bool deleteResults = false;

DropResultsDialog::DropResultsDialog(QWidget *parent) :
    QDialog(parent)
{
    this-&gt;setWindowTitle(QString("Drop results"));
    this-&gt;resize(600,300);

    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    int mainLayoutRow = 0;

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    this-&gt;clearResultsCheckBox = new QCheckBox(tr("Clear results from current model"));
    this-&gt;clearResultsCheckBox-&gt;setChecked(clearResults);
    mainLayout-&gt;addWidget(this-&gt;clearResultsCheckBox, mainLayoutRow++, 0, 1, 1);

    this-&gt;deleteResultsCheckBox = new QCheckBox(tr("Delete all records (model files) related to this model"));
    this-&gt;deleteResultsCheckBox-&gt;setChecked(deleteResults);
    mainLayout-&gt;addWidget(this-&gt;deleteResultsCheckBox, mainLayoutRow++, 0, 1, 1);

    QListWidget *resultsRecordsList = new QListWidget;
    resultsRecordsList-&gt;setEnabled(deleteResults);
    mainLayout-&gt;addWidget(resultsRecordsList, mainLayoutRow++, 0, 1, 1);

    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    uint nRecords = 0;
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        QList&lt;QString&gt; recordFiles = Session::getInstance().getModel(selectedModelIDs[i]).getRecordFiles(true);

        for (int j=0;j&lt;recordFiles.size();j++)
        {
            QListWidgetItem *item = new QListWidgetItem(resultsRecordsList);
            item-&gt;setText(recordFiles[j]);
            nRecords++;
        }
    }
    if (nRecords == 0)
    {
        this-&gt;deleteResultsCheckBox-&gt;setDisabled(true);
        resultsRecordsList-&gt;setDisabled(true);
    }

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRow++, 0, 1, 1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(this-&gt;deleteResultsCheckBox,
                     &amp;QCheckBox::clicked,
                     resultsRecordsList,
                     &amp;QListWidget::setEnabled);

    QObject::connect(cancelButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;DropResultsDialog::reject);
    QObject::connect(okButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;DropResultsDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.9">void DownloadManager::downloadFinished(void)
{
    QString fileName(this-&gt;output.fileName());

    //progressBar.clear();
    this-&gt;output.close();

    if (this-&gt;currentDownload-&gt;error())
    {
        // download failed
        RLogger::warning("Failed: %s\n", qPrintable(this-&gt;currentDownload-&gt;errorString()));
        emit this-&gt;failed(this-&gt;downloadID);
    }
    else
    {
        RLogger::info("Downloaded file saved as \'%s\'.\n",fileName.toUtf8().constData());
        this-&gt;downloadedCount++;
        emit this-&gt;fileSaved(this-&gt;downloadID,fileName);
    }
    emit this-&gt;finished(this-&gt;downloadID);

    this-&gt;currentDownload-&gt;deleteLater();
    this-&gt;startNextDownload();
}

</t>
<t tx="leo.20201108101519.90">int DropResultsDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        clearResults = this-&gt;clearResultsCheckBox-&gt;isChecked();
        deleteResults = this-&gt;deleteResultsCheckBox-&gt;isChecked();

        if (clearResults)
        {
            QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

            for (int i=0;i&lt;selectedModelIDs.size();i++)
            {
                Session::getInstance().storeCurentModelVersion(selectedModelIDs[i],tr("Drop results"));
                Session::getInstance().getModel(selectedModelIDs[i]).clearResults();
                Session::getInstance().setModelChanged(selectedModelIDs[i]);
            }
        }
        if (deleteResults)
        {
            QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

            for (int i=0;i&lt;selectedModelIDs.size();i++)
            {
                QList&lt;QString&gt; recordFiles = Session::getInstance().getModel(selectedModelIDs[i]).getRecordFiles(true);

                for (int j=0;j&lt;recordFiles.size();j++)
                {
                    QFile file(recordFiles[j]);
                    RLogger::info("Removing file \'%s\'\n",recordFiles[j].toUtf8().constData());

                    if (!file.remove())
                    {
                        RLogger::warning("Failed to remove file \'%s\'\n",recordFiles[j].toUtf8().constData());
                    }
                }
            }
        }
    }
    return retVal;
}
</t>
<t tx="leo.20201108101519.91">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   ec_manager_tree.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   7-th August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Environment condition tree manager class definition *
 *********************************************************************/

#include &lt;vector&gt;
#include &lt;QList&gt;
#include &lt;QMessageBox&gt;

#include &lt;rmlib.h&gt;

#include "session.h"
#include "ec_manager_tree.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101519.92">typedef enum _EnvironmentConditionTreeColumn
{
    EC_TREE_COLUMN_NAME = 0,
    EC_TREE_N_COLUMNS
} EnvironmentConditionTreeColumn;

ECManagerTree::ECManagerTree(QObject *parent) :
    QTreeWidget((QWidget*)parent),
    doNotPopulate(false)
{
    this-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;setSortingEnabled(true);
    this-&gt;sortByColumn(EC_TREE_COLUMN_NAME,Qt::AscendingOrder);

    this-&gt;setColumnCount(EC_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(EC_TREE_COLUMN_NAME,QString("Name"));
    this-&gt;setHeaderItem(headerItem);
    this-&gt;setHeaderHidden(true);
    this-&gt;setRootIsDecorated(false);

    QObject::connect(&amp;Session::getInstance(),&amp;Session::problemSelectionChanged,this,&amp;ECManagerTree::onProblemChanged);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::modelSelectionChanged,this,&amp;ECManagerTree::onModelSelectionChanged);
    QObject::connect(this,&amp;ECManagerTree::itemChanged,this,&amp;ECManagerTree::onItemChanged);
    QObject::connect(this,&amp;ECManagerTree::itemSelectionChanged,this,&amp;ECManagerTree::onItemSelectionChanged);
    QObject::connect(this,&amp;ECManagerTree::ecSelected,this,&amp;ECManagerTree::onEcSelected);
}

</t>
<t tx="leo.20201108101519.93">void ECManagerTree::populate(void)
{
    if (this-&gt;doNotPopulate)
    {
        return;
    }

    RProblemTypeMask ecPrbTypeMask;
    RProblemTypeMask modelPrbTypeMask = R_PROBLEM_NONE;
    REntityGroupTypeMask elementGroupTypeMask = R_ENTITY_GROUP_NONE;
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;selectedEntityIDs.size();i++)
    {
        elementGroupTypeMask |= selectedEntityIDs[i].getType();
        modelPrbTypeMask |= Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getProblemTaskTree().getProblemTypeMask();
    }

    QList&lt;QTreeWidgetItem*&gt; selectedItemsList = this-&gt;selectedItems();
    // Following is a hack to not to clear selected types list if item is being deselected.
    if (selectedItemsList.size() &gt; 0)
    {
        this-&gt;selectedTypes.clear();
    }
    for (int i=0;i&lt;selectedItemsList.size();i++)
    {
        this-&gt;selectedTypes.append(REnvironmentConditionType(selectedItemsList[i]-&gt;data(EC_TREE_COLUMN_NAME,Qt::UserRole).toInt()));
    }

    this-&gt;blockSignals(true);

    this-&gt;clear();

    QMap&lt;REnvironmentConditionType,uint&gt; ecMap = this-&gt;getEcMap(selectedEntityIDs);

    for (REnvironmentConditionType ecType = (REnvironmentConditionType)((int)R_ENVIRONMENT_CONDITION_NONE + 1);
                                ecType &lt; R_ENVIRONMENT_CONDITION_N_TYPES;
                                ecType ++)
    {
        ecPrbTypeMask = REnvironmentCondition::getProblemTypeMask(ecType);
        if (!(ecPrbTypeMask &amp; modelPrbTypeMask))
        {
            continue;
        }
        bool applies = false;
        if (elementGroupTypeMask &amp; R_ENTITY_GROUP_POINT ||
            elementGroupTypeMask &amp; R_ENTITY_GROUP_LINE ||
            elementGroupTypeMask &amp; R_ENTITY_GROUP_SURFACE ||
            elementGroupTypeMask &amp; R_ENTITY_GROUP_VOLUME)
        {
            applies = true;
        }
        if (!applies)
        {
            continue;
        }

//        Qt::CheckState state = Qt::Unchecked;
//        if (ecMap.contains(ecType))
//        {
//            if (ecMap.value(ecType,1) == (uint)selectedEntityIDs.size())
//            {
//                state = Qt::Checked;
//            }
//            else
//            {
//                state = Qt::PartiallyChecked;
//            }
//        }
        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setText(EC_TREE_COLUMN_NAME, REnvironmentCondition::getName(ecType));
//        item-&gt;setData(EC_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(state));
        item-&gt;setData(EC_TREE_COLUMN_NAME,Qt::UserRole,QVariant(ecType));
    }

    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        this-&gt;topLevelItem(i)-&gt;setSelected(false);
        for (int j=0;j&lt;this-&gt;selectedTypes.size();j++)
        {
            if (this-&gt;selectedTypes[j] == REnvironmentConditionType(this-&gt;topLevelItem(i)-&gt;data(EC_TREE_COLUMN_NAME,Qt::UserRole).toInt()))
            {
                this-&gt;topLevelItem(i)-&gt;setSelected(true);
                break;
            }
        }
    }

    this-&gt;blockSignals(false);

    emit this-&gt;itemSelectionChanged();
}
</t>
<t tx="leo.20201108101520.1">void ECManagerTree::onModelSelectionChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101520.10">void ECTree::onEcSelected(REnvironmentConditionType ecType, bool applied)
{
    if (applied)
    {
        QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

        for (int i=0;i&lt;entityIDs.size();i++)
        {
            switch (entityIDs[i].getType())
            {
                case R_ENTITY_GROUP_POINT:
                    this-&gt;ec = Session::getInstance().getModel(entityIDs[i].getMid()).getPoint(entityIDs[i].getEid()).getEnvironmentCondition(ecType);
                    break;
                case R_ENTITY_GROUP_LINE:
                    this-&gt;ec = Session::getInstance().getModel(entityIDs[i].getMid()).getLine(entityIDs[i].getEid()).getEnvironmentCondition(ecType);
                    break;
                case R_ENTITY_GROUP_SURFACE:
                    this-&gt;ec = Session::getInstance().getModel(entityIDs[i].getMid()).getSurface(entityIDs[i].getEid()).getEnvironmentCondition(ecType);
                    break;
                case R_ENTITY_GROUP_VOLUME:
                    this-&gt;ec = Session::getInstance().getModel(entityIDs[i].getMid()).getVolume(entityIDs[i].getEid()).getEnvironmentCondition(ecType);
                    break;
                default:
                    this-&gt;ec.setType(ecType);
                    break;
            }
        }

        this-&gt;populate();
    }
    else
    {
        this-&gt;ec.setType(R_ENVIRONMENT_CONDITION_NONE);
        this-&gt;clear();
    }
}

</t>
<t tx="leo.20201108101520.100">void GLAxis::setType(GLAxisType type)
{
    this-&gt;type = type;
}

</t>
<t tx="leo.20201108101520.101">float GLAxis::getSize(void) const
{
    return this-&gt;size;
}

</t>
<t tx="leo.20201108101520.102">void GLAxis::setSize(float size)
{
    this-&gt;size = size;
}

</t>
<t tx="leo.20201108101520.103">void GLAxis::initialize()
{
    // Save current settings
    GL_SAFE_CALL(glGetBooleanv(GL_DEPTH_TEST, &amp;this-&gt;depthTestEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_LINE_SMOOTH, &amp;this-&gt;lineSmoothEnabled));
    GL_SAFE_CALL(glGetIntegerv(GL_LINE_SMOOTH_HINT, &amp;this-&gt;lineSmoothHint));
    GL_SAFE_CALL(glGetBooleanv(GL_NORMALIZE, &amp;this-&gt;normalizeEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    GL_SAFE_CALL(glGetFloatv(GL_LINE_WIDTH, &amp;this-&gt;lineWidth));
    GL_SAFE_CALL(glGetBooleanv(GL_CULL_FACE, &amp;this-&gt;cullFaceEnabled));
    // Initialize environment
    GL_SAFE_CALL(glEnable(GL_DEPTH_TEST));
    GL_SAFE_CALL(glEnable(GL_LINE_SMOOTH));
    GL_SAFE_CALL(glHint(GL_LINE_SMOOTH_HINT, GL_DONT_CARE));
    GL_SAFE_CALL(glEnable(GL_NORMALIZE));
    GL_SAFE_CALL(glDisable(GL_LIGHTING));
    GL_SAFE_CALL(glDisable(GL_CULL_FACE));
    GL_SAFE_CALL(glLineWidth(1.0f));
}

</t>
<t tx="leo.20201108101520.104">void GLAxis::finalize()
{
    // Restore previous environment
    GL_SAFE_CALL(this-&gt;depthTestEnabled ? glEnable(GL_DEPTH_TEST) : glDisable(GL_DEPTH_TEST));
    GL_SAFE_CALL(this-&gt;lineSmoothEnabled ? glEnable(GL_LINE_SMOOTH) : glDisable(GL_LINE_SMOOTH));
    GL_SAFE_CALL(this-&gt;normalizeEnabled ? glEnable(GL_NORMALIZE) :glDisable(GL_NORMALIZE));
    GL_SAFE_CALL(this-&gt;lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
    GL_SAFE_CALL(this-&gt;cullFaceEnabled ? glEnable(GL_CULL_FACE) : glDisable(GL_CULL_FACE));
    GL_SAFE_CALL(glLineWidth(this-&gt;lineWidth));
    GL_SAFE_CALL(glHint(GL_LINE_SMOOTH_HINT, GLenum(this-&gt;lineSmoothHint)));
//    glBlendFunc(GL_SRC_ALPHA, this-&gt;bendAlphaFunc);
}

</t>
<t tx="leo.20201108101520.105">void GLAxis::draw(void)
{
    GLfloat axisScale = this-&gt;getSize();

    QColor red(Qt::red);
    QColor green(Qt::green);
    QColor blue(Qt::blue);
    QColor gray(Qt::gray);

    QString postFix(this-&gt;name.length() == 0 ? QString() : QString(" - ") + this-&gt;name);

    switch (this-&gt;getType())
    {
        case GL_AXIS_GLOBAL:
        {
            this-&gt;getGLWidget()-&gt;qglColor(red);
            this-&gt;getGLWidget()-&gt;renderText(double(axisScale),0.0,0.0,QString("X") + postFix);

            this-&gt;getGLWidget()-&gt;qglColor(green);
            this-&gt;getGLWidget()-&gt;renderText(0.0,double(axisScale),0.0,QString("Y") + postFix);

            this-&gt;getGLWidget()-&gt;qglColor(blue);
            this-&gt;getGLWidget()-&gt;renderText(0.0,0.0,double(axisScale),QString("Z") + postFix);

            GLboolean stipple;
            GL_SAFE_CALL(glGetBooleanv(GL_LINE_STIPPLE,&amp;stipple));

            GL_SAFE_CALL(glPushAttrib(GL_ENABLE_BIT));

            GL_SAFE_CALL(glLineStipple(6, 0xAAAA));
            GL_SAFE_CALL(glEnable(GL_LINE_STIPPLE));

            GLFunctions::begin(GL_LINES);

            this-&gt;getGLWidget()-&gt;qglColor(red);
            GL_SAFE_CALL(glVertex3f(  0.0f,  0.0f,  0.0f));
            GL_SAFE_CALL(glVertex3f( axisScale,  0.0f,  0.0f));

            this-&gt;getGLWidget()-&gt;qglColor(green);
            GL_SAFE_CALL(glVertex3f(  0.0f,  0.0f,  0.0f));
            GL_SAFE_CALL(glVertex3f(  0.0f, axisScale,  0.0f));

            this-&gt;getGLWidget()-&gt;qglColor(blue.lighter());
            GL_SAFE_CALL(glVertex3f(  0.0f,  0.0f,  0.0f));
            GL_SAFE_CALL(glVertex3f(  0.0f,  0.0f, axisScale));

            GLFunctions::end();

            this-&gt;getGLWidget()-&gt;qglColor(gray);

            GLFunctions::begin(GL_LINES);

            GL_SAFE_CALL(glVertex3f(  0.0f,  0.0f,  0.0f));
            GL_SAFE_CALL(glVertex3f( -axisScale,  0.0f,  0.0f));

            GL_SAFE_CALL(glVertex3f(  0.0f,  0.0f,  0.0f));
            GL_SAFE_CALL(glVertex3f(  0.0f, -axisScale,  0.0f));

            GL_SAFE_CALL(glVertex3f(  0.0f,  0.0f,  0.0f));
            GL_SAFE_CALL(glVertex3f(  0.0f,  0.0f, -axisScale));

            GLFunctions::end();

            GL_SAFE_CALL(glPopAttrib());

            if (!stipple)
            {
                GL_SAFE_CALL(glDisable(GL_LINE_STIPPLE));
            }
            break;
        }
        case GL_AXIS_LOCAL:
        {
            GLFunctions::begin(GL_LINES);

            // Lable the X axis.
            this-&gt;getGLWidget()-&gt;qglColor(red);

            GL_SAFE_CALL(glVertex3f(0.0f, 0.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(axisScale, 0.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 1.1f*axisScale, 0.7f*axisScale));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.9f*axisScale, 0.9f*axisScale));
            GL_SAFE_CALL(glVertex3f(0.0f, 1.1f*axisScale, 0.9f*axisScale));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.9f*axisScale, 0.7f*axisScale));

            // Lable the Y axis.
            this-&gt;getGLWidget()-&gt;qglColor(green);

            GL_SAFE_CALL(glVertex3f(0.0f, 0.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, axisScale, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.7f*axisScale, 0.0f, axisScale));
            GL_SAFE_CALL(glVertex3f(0.8f*axisScale, 0.0f, axisScale));
            GL_SAFE_CALL(glVertex3f(0.8f*axisScale, 0.0f, axisScale));
            GL_SAFE_CALL(glVertex3f(0.9f*axisScale, 0.0f, 1.1f*axisScale));
            GL_SAFE_CALL(glVertex3f(0.8f*axisScale, 0.0f, axisScale));
            GL_SAFE_CALL(glVertex3f(0.9f*axisScale, 0.0f, 0.9f*axisScale));

            // And the Z.
            this-&gt;getGLWidget()-&gt;qglColor(blue);
            GL_SAFE_CALL(glVertex3f(0.0f, 0.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.0f, axisScale));
            GL_SAFE_CALL(glVertex3f(0.9f*axisScale, 0.9f*axisScale, 0.0f));
            GL_SAFE_CALL(glVertex3f(1.1f*axisScale, 0.9f*axisScale, 0.0f));
            GL_SAFE_CALL(glVertex3f(1.1f*axisScale, 0.9f*axisScale, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.9f*axisScale, 0.7f*axisScale, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.9f*axisScale, 0.7f*axisScale, 0.0f));
            GL_SAFE_CALL(glVertex3f(1.1f*axisScale, 0.7f*axisScale, 0.0f));

            GLFunctions::end();

            GLFunctions::begin(GL_TRIANGLES);

            this-&gt;getGLWidget()-&gt;qglColor(red);

            GL_SAFE_CALL(glNormal3f(1.0f, 0.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.7f*axisScale, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.0f, 0.7f*axisScale));

            this-&gt;getGLWidget()-&gt;qglColor(green);

            GL_SAFE_CALL(glNormal3f(0.0f, 1.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.7f*axisScale, 0.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.0f, 0.7f*axisScale));

            this-&gt;getGLWidget()-&gt;qglColor(blue);

            GL_SAFE_CALL(glNormal3f(0.0f, 0.0f, 1.0f));
            GL_SAFE_CALL(glVertex3f(0.7f*axisScale, 0.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.7f*axisScale, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.0f, 0.0f));

            GL_SAFE_CALL(glColor4f (0.8f, 0.8f, 0.8f, 0.8f));

            GL_SAFE_CALL(glNormal3f(0.49f, 0.49f, 0.49f));
            GL_SAFE_CALL(glVertex3f(0.7f*axisScale, 0.0f, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.7f*axisScale, 0.0f));
            GL_SAFE_CALL(glVertex3f(0.0f, 0.0f, 0.7f*axisScale));

            GLFunctions::end();
            break;
        }
        case GL_AXIS_NONE:
        case GL_AXIS_POSITION:
        default:
        {
            this-&gt;getGLWidget()-&gt;qglColor(QColor("#ffffff"));
            this-&gt;getGLWidget()-&gt;renderText(double(axisScale),0.0,0.0,QString("X") + postFix);

            this-&gt;getGLWidget()-&gt;qglColor(QColor("#ffffff"));
            this-&gt;getGLWidget()-&gt;renderText(0.0,double(axisScale),0.0,QString("Y") + postFix);

            this-&gt;getGLWidget()-&gt;qglColor(QColor("#ffffff"));
            this-&gt;getGLWidget()-&gt;renderText(0.0,0.0,double(axisScale),QString("Z") + postFix);

            GLFunctions::begin(GL_LINES);

            this-&gt;getGLWidget()-&gt;qglColor(gray);

            GL_SAFE_CALL(glVertex3f(  axisScale,  0.0f,  0.0f));
            GL_SAFE_CALL(glVertex3f( -axisScale,  0.0f,  0.0f));

            GL_SAFE_CALL(glVertex3f(  0.0f,  axisScale,  0.0f));
            GL_SAFE_CALL(glVertex3f(  0.0f, -axisScale,  0.0f));

            GL_SAFE_CALL(glVertex3f(  0.0f,  0.0f,  axisScale));
            GL_SAFE_CALL(glVertex3f(  0.0f,  0.0f, -axisScale));

            GLFunctions::end();
            break;
        }
    }
}
</t>
<t tx="leo.20201108101520.106">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_cut_plane.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: OpenGL cut plane class definition                   *
 *********************************************************************/

#include "gl_cut_plane.h"
#include "gl_arrow.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.107">void GLCutPlane::_init(const GLCutPlane *pGlCutPlane)
{
    if (pGlCutPlane)
    {
        this-&gt;size = pGlCutPlane-&gt;size;
    }
}

GLCutPlane::GLCutPlane(GLWidget *glWidget, const RPlane &amp;plane)
    : GLObject(glWidget)
    , RPlane(plane)
    , size(1.0)
{
    this-&gt;_init();
}

GLCutPlane::GLCutPlane(const GLCutPlane &amp;glCutPlane)
    : GLObject(glCutPlane)
    , RPlane(glCutPlane)
{
    this-&gt;_init(&amp;glCutPlane);
}

GLCutPlane::~GLCutPlane()
{
}

GLCutPlane &amp;GLCutPlane::operator =(const GLCutPlane &amp;glCutPlane)
{
    this-&gt;GLObject::operator =(glCutPlane);
    this-&gt;RPlane::operator =(glCutPlane);
    this-&gt;_init(&amp;glCutPlane);
    return (*this);
}

</t>
<t tx="leo.20201108101520.108">float GLCutPlane::getSize(void) const
{
    return this-&gt;size;
}

</t>
<t tx="leo.20201108101520.109">void GLCutPlane::setSize(float size)
{
    this-&gt;size = size;
}

</t>
<t tx="leo.20201108101520.11">void ECTree::onEcValueChanged(RVariableType variableType, double value)
{
    for (uint i=0;i&lt;this-&gt;ec.size();i++)
    {
        if (this-&gt;ec.getComponent(i).getType() == variableType)
        {
            this-&gt;ec.getComponent(i).add(0,value);
        }
    }

    this-&gt;updateSelectedEntities();
}
</t>
<t tx="leo.20201108101520.110">void GLCutPlane::initialize(void)
{
    // Save current settings
    GL_SAFE_CALL(glGetBooleanv(GL_DEPTH_TEST, &amp;this-&gt;depthTestEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_LINE_SMOOTH, &amp;this-&gt;lineSmoothEnabled));
    GL_SAFE_CALL(glGetIntegerv(GL_LINE_SMOOTH_HINT, &amp;this-&gt;lineSmoothHint));
    GL_SAFE_CALL(glGetBooleanv(GL_NORMALIZE, &amp;this-&gt;normalizeEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    GL_SAFE_CALL(glGetFloatv(GL_LINE_WIDTH, &amp;this-&gt;lineWidth));
    GL_SAFE_CALL(glGetBooleanv(GL_CULL_FACE, &amp;this-&gt;cullFaceEnabled));
    // Initialize environment
    GL_SAFE_CALL(glEnable(GL_DEPTH_TEST));
    GL_SAFE_CALL(glEnable(GL_LINE_SMOOTH));
    GL_SAFE_CALL(glHint(GL_LINE_SMOOTH_HINT, GL_DONT_CARE));
    GL_SAFE_CALL(glEnable(GL_NORMALIZE));
    GL_SAFE_CALL(glDisable(GL_LIGHTING));
    GL_SAFE_CALL(glDisable(GL_CULL_FACE));
    GL_SAFE_CALL(glLineWidth(1.0f));
}

</t>
<t tx="leo.20201108101520.111">void GLCutPlane::finalize(void)
{
    // Restore previous environment
    GL_SAFE_CALL(this-&gt;depthTestEnabled ? glEnable(GL_DEPTH_TEST) : glDisable(GL_DEPTH_TEST));
    GL_SAFE_CALL(this-&gt;lineSmoothEnabled ? glEnable(GL_LINE_SMOOTH) : glDisable(GL_LINE_SMOOTH));
    GL_SAFE_CALL(this-&gt;normalizeEnabled ? glEnable(GL_NORMALIZE) :glDisable(GL_NORMALIZE));
    GL_SAFE_CALL(this-&gt;lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
    GL_SAFE_CALL(this-&gt;cullFaceEnabled ? glEnable(GL_CULL_FACE) : glDisable(GL_CULL_FACE));
    GL_SAFE_CALL(glLineWidth(this-&gt;lineWidth));
    GL_SAFE_CALL(glHint(GL_LINE_SMOOTH_HINT, this-&gt;lineSmoothHint));
}

</t>
<t tx="leo.20201108101520.112">void GLCutPlane::draw(void)
{
    GLfloat cutScale = this-&gt;getSize();

    GL_SAFE_CALL(glEnable(GL_LIGHTING));
    this-&gt;getGLWidget()-&gt;qglColor(QColor(255,100,0,255));
    RR3Vector direction(this-&gt;normal);
    direction *= 0.5;
    GLArrow glArrow(this-&gt;glWidget,this-&gt;position,direction,true,true);
    glArrow.paint();
    GL_SAFE_CALL(glDisable(GL_LIGHTING));

    RRMatrix R;

    this-&gt;findRotationMatrix(R);

    RNode n1(0.0,-cutScale / 2.0,-cutScale / 2.0);
    RNode n2(0.0, cutScale / 2.0,-cutScale / 2.0);
    RNode n3(0.0, cutScale / 2.0, cutScale / 2.0);
    RNode n4(0.0,-cutScale / 2.0, cutScale / 2.0);
    RNode nw(0.0,-cutScale / 2.0, 0.0           );
    RNode ne(0.0, cutScale / 2.0, 0.0           );
    RNode ns(0.0, 0.0,           -cutScale / 2.0);
    RNode nn(0.0, 0.0,            cutScale / 2.0);

    n1.transform(R,this-&gt;position);
    n2.transform(R,this-&gt;position);
    n3.transform(R,this-&gt;position);
    n4.transform(R,this-&gt;position);
    nw.transform(R,this-&gt;position);
    ne.transform(R,this-&gt;position);
    ns.transform(R,this-&gt;position);
    nn.transform(R,this-&gt;position);

    this-&gt;getGLWidget()-&gt;qglColor(QColor(255,255,255,100));

    GL_SAFE_CALL(glNormal3d(this-&gt;normal[0],this-&gt;normal[1],this-&gt;normal[2]));
    GLFunctions::begin(GL_QUADS);
    GL_SAFE_CALL(glVertex3d(n1.getX(),n1.getY(),n1.getZ()));
    GL_SAFE_CALL(glVertex3d(n2.getX(),n2.getY(),n2.getZ()));
    GL_SAFE_CALL(glVertex3d(n3.getX(),n3.getY(),n3.getZ()));
    GL_SAFE_CALL(glVertex3d(n4.getX(),n4.getY(),n4.getZ()));
    GLFunctions::end();

    this-&gt;getGLWidget()-&gt;qglColor(QColor(255,0,0,255));

    GL_SAFE_CALL(glLineWidth(1.0f));

    GLFunctions::begin(GL_LINE_LOOP);
    GL_SAFE_CALL(glVertex3d(n1.getX(),n1.getY(),n1.getZ()));
    GL_SAFE_CALL(glVertex3d(n2.getX(),n2.getY(),n2.getZ()));
    GL_SAFE_CALL(glVertex3d(n3.getX(),n3.getY(),n3.getZ()));
    GL_SAFE_CALL(glVertex3d(n4.getX(),n4.getY(),n4.getZ()));
    GLFunctions::end();

    GLFunctions::begin(GL_LINES);
    GL_SAFE_CALL(glVertex3d(nw.getX(),nw.getY(),nw.getZ()));
    GL_SAFE_CALL(glVertex3d(ne.getX(),ne.getY(),ne.getZ()));
    GL_SAFE_CALL(glVertex3d(ns.getX(),ns.getY(),ns.getZ()));
    GL_SAFE_CALL(glVertex3d(nn.getX(),nn.getY(),nn.getZ()));
    GLFunctions::end();

    uint nDivs = 10;
    double inc = double(cutScale) / double(nDivs);

    this-&gt;getGLWidget()-&gt;qglColor(QColor(255,50,0,255));

    GL_SAFE_CALL(glLineWidth(1.0f));

    for (uint i=0;i&lt;=nDivs;i++)
    {
        double zc = i*inc - cutScale / 2.0;

        RNode nodeEast(0.0,-cutScale / 2.0, zc);
        RNode nodeWest(0.0, cutScale / 2.0, zc);

        RNode nodeSouth(0.0, zc,-cutScale / 2.0);
        RNode nodeNorth(0.0, zc, cutScale / 2.0);

        nodeEast.transform(R,this-&gt;position);
        nodeWest.transform(R,this-&gt;position);
        nodeSouth.transform(R,this-&gt;position);
        nodeNorth.transform(R,this-&gt;position);

        GLFunctions::begin(GL_LINES);
        GL_SAFE_CALL(glVertex3d(nodeEast.getX(),nodeEast.getY(),nodeEast.getZ()));
        GL_SAFE_CALL(glVertex3d(nodeWest.getX(),nodeWest.getY(),nodeWest.getZ()));
        GL_SAFE_CALL(glVertex3d(nodeSouth.getX(),nodeSouth.getY(),nodeSouth.getZ()));
        GL_SAFE_CALL(glVertex3d(nodeNorth.getX(),nodeNorth.getY(),nodeNorth.getZ()));
        GLFunctions::end();
    }
}
</t>
<t tx="leo.20201108101520.113">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_dimension.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th May 2017                                            *
 *                                                                   *
 *  DESCRIPTION: OpenGL dimension class definition                   *
 *********************************************************************/

#include "gl_arrow.h"
#include "gl_dimension.h"

const double GLDimension::arrowScale = 0.1;

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20201108101520.114">void GLDimension::_init(const GLDimension *pGlDimension)
{
    if (pGlDimension)
    {
        this-&gt;scale = pGlDimension-&gt;scale;
        this-&gt;xMin = pGlDimension-&gt;xMin;
        this-&gt;xMax = pGlDimension-&gt;xMax;
        this-&gt;yMin = pGlDimension-&gt;yMin;
        this-&gt;yMax = pGlDimension-&gt;yMax;
        this-&gt;zMin = pGlDimension-&gt;zMin;
        this-&gt;zMax = pGlDimension-&gt;zMax;
    }
}

GLDimension::GLDimension(GLWidget *glWidget,
                         double scale,
    , yMin(yMin)
    , yMax(yMax)
    , zMin(zMin)
    , zMax(zMax)
{
    this-&gt;_init();
}

GLDimension::GLDimension(const GLDimension &amp;glDimension)
    : GLObject(glDimension)
{
    this-&gt;_init(&amp;glDimension);
}

GLDimension &amp;GLDimension::operator=(const GLDimension &amp;glDimension)
{
    this-&gt;_init(&amp;glDimension);
    return (*this);
}

</t>
<t tx="leo.20201108101520.115">void GLDimension::initialize(void)
{

}

</t>
<t tx="leo.20201108101520.116">void GLDimension::finalize(void)
{

}

</t>
<t tx="leo.20201108101520.117">void GLDimension::draw(void)
{
    double dx = this-&gt;xMax-this-&gt;xMin;
    double dy = this-&gt;yMax-this-&gt;yMin;
    double dz = this-&gt;zMax-this-&gt;zMin;

    double dmax = std::max(std::max(std::fabs(dx),std::fabs(dy)),std::fabs(dz));

    double dxScale = GLDimension::arrowScale * this-&gt;scale * dmax / std::fabs(dx);
    double dyScale = GLDimension::arrowScale * this-&gt;scale * dmax / std::fabs(dy);
    double dzScale = GLDimension::arrowScale * this-&gt;scale * dmax / std::fabs(dz);

    GLArrow(this-&gt;getGLWidget(),RR3Vector(this-&gt;xMin,this-&gt;yMin,this-&gt;zMin),RR3Vector( dx,0.0,0.0),true,true,dxScale).paint();
    GLArrow(this-&gt;getGLWidget(),RR3Vector(this-&gt;xMax,this-&gt;yMin,this-&gt;zMin),RR3Vector(-dx,0.0,0.0),true,true,dxScale).paint();

    this-&gt;getGLWidget()-&gt;renderText((this-&gt;xMin+this-&gt;xMax)/2.0,this-&gt;yMin,this-&gt;zMin,"∆x = " + QString::number(dx) + " " + RVariable::getUnits(R_VARIABLE_LENGTH),QFont("Courier",20));

    GLArrow(this-&gt;getGLWidget(),RR3Vector(this-&gt;xMin,this-&gt;yMin,this-&gt;zMin),RR3Vector(0.0, dy,0.0),true,true,dyScale).paint();
    GLArrow(this-&gt;getGLWidget(),RR3Vector(this-&gt;xMin,this-&gt;yMax,this-&gt;zMin),RR3Vector(0.0,-dy,0.0),true,true,dyScale).paint();

    this-&gt;getGLWidget()-&gt;renderText(this-&gt;xMin,(this-&gt;yMin+this-&gt;yMax)/2.0,this-&gt;zMin,"∆y = " + QString::number(dy) + " " + RVariable::getUnits(R_VARIABLE_LENGTH),QFont("Courier",20));

    GLArrow(this-&gt;getGLWidget(),RR3Vector(this-&gt;xMin,this-&gt;yMin,this-&gt;zMin),RR3Vector(0.0,0.0, dz),true,true,dzScale).paint();
    GLArrow(this-&gt;getGLWidget(),RR3Vector(this-&gt;xMin,this-&gt;yMin,this-&gt;zMax),RR3Vector(0.0,0.0,-dz),true,true,dzScale).paint();

    this-&gt;getGLWidget()-&gt;renderText(this-&gt;xMin,this-&gt;yMin,(this-&gt;zMin+this-&gt;zMax)/2.0,"∆z = " + QString::number(dz) + " " + RVariable::getUnits(R_VARIABLE_LENGTH),QFont("Courier",20));
}
</t>
<t tx="leo.20201108101520.118">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_display_properties.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th April 2016                                          *
 *                                                                   *
 *  DESCRIPTION: OpenGL display properties class definition          *
 *********************************************************************/

#include "gl_display_properties.h"
#include "main_settings.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.119">void GLDisplayProperties::_init(const GLDisplayProperties *pDisplayProperties)
{
    if (pDisplayProperties)
    {
        this-&gt;fileName = pDisplayProperties-&gt;fileName;
    }
}

GLDisplayProperties::GLDisplayProperties()
{
    this-&gt;_init();
    this-&gt;bgColor = ApplicationSettings::getDefaultBackgroundColor(MainSettings::getInstance().getApplicationSettings()-&gt;getStyle());
}

GLDisplayProperties::GLDisplayProperties(const GLDisplayProperties &amp;displayProperties)
    : RGLDisplayProperties(displayProperties)
{
    this-&gt;_init(&amp;displayProperties);
}

GLDisplayProperties::~GLDisplayProperties()
{

}

GLDisplayProperties &amp;GLDisplayProperties::operator =(const GLDisplayProperties &amp;displayProperties)
{
    this-&gt;RGLDisplayProperties::operator =(displayProperties);
    this-&gt;_init(&amp;displayProperties);
    return (*this);
}

</t>
<t tx="leo.20201108101520.12">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   file_chooser_button.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-st August 2013                                        *
 *                                                                   *
 *  DESCRIPTION: File chooser button class definition                *
 *********************************************************************/

#include &lt;QHBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QLineEdit&gt;
#include &lt;QPushButton&gt;
#include &lt;QFileDialog&gt;

#include &lt;rblib.h&gt;

#include "file_chooser_button.h"

FileChooserButton::FileChooserButton(const QString &amp;labelText, Type type, QWidget *parent, const QString &amp;caption, const QString &amp;path, const QString &amp;filter)
    : QWidget(parent)
    , type(type)
    , caption(caption)
    , path(path)
    , filter(filter)
{
    QHBoxLayout *layout = new QHBoxLayout;
    layout-&gt;setMargin(0);
    this-&gt;setLayout(layout);

    QIcon icon(":/icons/file/pixmaps/range-open.svg");

    this-&gt;label = new QLabel(labelText);
    this-&gt;label-&gt;setSizePolicy(QSizePolicy(QSizePolicy::Maximum,QSizePolicy::Maximum));
    layout-&gt;addWidget(this-&gt;label);

    this-&gt;pushButton = new QPushButton(icon,QString());
    pushButton-&gt;setSizePolicy(QSizePolicy(QSizePolicy::Expanding,QSizePolicy::Maximum));
    layout-&gt;addWidget(pushButton);

    this-&gt;setFileName(this-&gt;path);

    QObject::connect(this-&gt;pushButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;FileChooserButton::onPushButtonClicked);
}

QString FileChooserButton::getFileName(void) const
{
    return this-&gt;path;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.120">const QString &amp;GLDisplayProperties::getFileName(void) const
{
    return this-&gt;fileName;
}

</t>
<t tx="leo.20201108101520.121">void GLDisplayProperties::setFileName(const QString &amp;fileName)
{
    this-&gt;fileName = fileName;
}

</t>
<t tx="leo.20201108101520.122">void GLDisplayProperties::load(const QString &amp;fileName)
{
    this-&gt;fileName = fileName;

    if (!RFile::exists(this-&gt;fileName))
    {
        return;
    }

    RLogger::info("Reading display properties file \'%s\'.\n",this-&gt;fileName.toUtf8().constData());
    RLogger::indent();
    try
    {
        this-&gt;read(this-&gt;fileName);
    }
    catch (const RError &amp;rError)
    {
        RLogger::error("Failed to read the file \'%s\': %s\n",this-&gt;fileName.toUtf8().constData(),rError.getMessage().toUtf8().constData());
    }
    RLogger::unindent();
}

</t>
<t tx="leo.20201108101520.123">void GLDisplayProperties::store(void) const
{
    RLogger::info("Writing display properties file \'%s\'.\n",this-&gt;fileName.toUtf8().constData());
    RLogger::indent();
    try
    {
        this-&gt;write(this-&gt;fileName);
    }
    catch (const RError &amp;rError)
    {
        RLogger::error("Failed to write the file \'%s\': %s\n",this-&gt;fileName.toUtf8().constData(),rError.getMessage().toUtf8().constData());
    }
    RLogger::unindent();
}
</t>
<t tx="leo.20201108101520.124">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_display_properties_dialog.cpp                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   2-nd March 2012                                          *
 *                                                                   *
 *  DESCRIPTION: OpenGL display properties dialog class definition   *
 *********************************************************************/

#include &lt;QPushButton&gt;
#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QCheckBox&gt;

#include "gl_display_properties_dialog.h"
#include "session.h"
#include "color_combo_box.h"
#include "light_properties_widget.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.125">typedef enum _PropertiesListColumn
{
    PROPERTIES_LIST_COLUMN_1,
    PROPERTIES_LIST_N_COLUMNS
} PropertiesListColumn;

GLDisplayPropertiesDialog::GLDisplayPropertiesDialog(GLWidget *pGlWidget, QWidget *parent)
    : QDialog(parent)
    , pGlWidget(pGlWidget)
{
    this-&gt;backupDisplayProperties = this-&gt;pGlWidget-&gt;getGLDisplayProperties();

    this-&gt;setWindowTitle(QString("Display preferences"));
    this-&gt;resize(500,500);

    QIcon defaultIcon(":/icons/file/pixmaps/range-undo.svg");
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    int mainLayoutRow = 0;

    this-&gt;propertyTree = new QTreeWidget;
    this-&gt;propertyTree-&gt;setHeaderHidden(true);
    this-&gt;propertyTree-&gt;setRootIsDecorated(false);
    this-&gt;propertyTree-&gt;setSelectionMode(QAbstractItemView::NoSelection);
    this-&gt;propertyTree-&gt;setColumnCount(PROPERTIES_LIST_N_COLUMNS);
    this-&gt;propertyTree-&gt;setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
    mainLayout-&gt;addWidget(this-&gt;propertyTree, mainLayoutRow++, 0);
    this-&gt;populate();

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRow++, 0, 1, 1);

    QPushButton *defaultButton = new QPushButton(defaultIcon, tr("Default"));
    buttonsLayout-&gt;addWidget(defaultButton);

    buttonsLayout-&gt;addStretch(1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(defaultButton,&amp;QPushButton::clicked,this,&amp;GLDisplayPropertiesDialog::onDefaultClicked);
    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;GLDisplayPropertiesDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;GLDisplayPropertiesDialog::accept);
}

</t>
<t tx="leo.20201108101520.126">int GLDisplayPropertiesDialog::exec()
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        this-&gt;pGlWidget-&gt;getGLDisplayProperties().store();
    }
    else
    {
        this-&gt;pGlWidget-&gt;getGLDisplayProperties() = this-&gt;backupDisplayProperties;
    }
    this-&gt;pGlWidget-&gt;update();

    return retVal;
}

</t>
<t tx="leo.20201108101520.127">void GLDisplayPropertiesDialog::populate(void)
{
    // Items --------------------------------------------------------------
    QTreeWidgetItem *itemItems = new QTreeWidgetItem(this-&gt;propertyTree);
    QGroupBox *itemsGroupBox = new QGroupBox(tr("Items"));

    QVBoxLayout *itemsLayout = new QVBoxLayout;
    itemsGroupBox-&gt;setLayout(itemsLayout);

    // Show model edges
    QCheckBox *showModelEdgesCheckBox = new QCheckBox(tr("Show model edges"));
    showModelEdgesCheckBox-&gt;setChecked(this-&gt;pGlWidget-&gt;getGLDisplayProperties().getShowModelEdges());
    itemsLayout-&gt;addWidget(showModelEdgesCheckBox);
    QObject::connect(showModelEdgesCheckBox,&amp;QCheckBox::clicked,this,&amp;GLDisplayPropertiesDialog::onShowModelEdgesClicked);

    // Show model edges
    QCheckBox *showModelDimensionsCheckBox = new QCheckBox(tr("Show model dimensions"));
    showModelDimensionsCheckBox-&gt;setChecked(this-&gt;pGlWidget-&gt;getGLDisplayProperties().getShowModelDimensions());
    itemsLayout-&gt;addWidget(showModelDimensionsCheckBox);
    QObject::connect(showModelDimensionsCheckBox,&amp;QCheckBox::clicked,this,&amp;GLDisplayPropertiesDialog::onShowModelDimensionsClicked);

    // Show model errors
    QCheckBox *showModelErrorsCheckBox = new QCheckBox(tr("Show model errors"));
    showModelErrorsCheckBox-&gt;setChecked(this-&gt;pGlWidget-&gt;getGLDisplayProperties().getShowErrors());
    itemsLayout-&gt;addWidget(showModelErrorsCheckBox);
    QObject::connect(showModelErrorsCheckBox,&amp;QCheckBox::clicked,this,&amp;GLDisplayPropertiesDialog::onShowModelErrorsClicked);

    // Show global axis
    QCheckBox *showGlobalAxisCheckBox = new QCheckBox(tr("Show global axis"));
    showGlobalAxisCheckBox-&gt;setChecked(this-&gt;pGlWidget-&gt;getGLDisplayProperties().getDrawGlobalAxis());
    itemsLayout-&gt;addWidget(showGlobalAxisCheckBox);
    QObject::connect(showGlobalAxisCheckBox,&amp;QCheckBox::clicked,this,&amp;GLDisplayPropertiesDialog::onShowGlobalAxisClicked);

    // Show local axis
    QCheckBox *showLocalAxisCheckBox = new QCheckBox(tr("Show local axis"));
    showLocalAxisCheckBox-&gt;setChecked(this-&gt;pGlWidget-&gt;getGLDisplayProperties().getDrawLocalAxis());
    itemsLayout-&gt;addWidget(showLocalAxisCheckBox);
    QObject::connect(showLocalAxisCheckBox,&amp;QCheckBox::clicked,this,&amp;GLDisplayPropertiesDialog::onShowLocalAxisClicked);

    this-&gt;propertyTree-&gt;setItemWidget(itemItems,PROPERTIES_LIST_COLUMN_1,itemsGroupBox);

    // Background color ---------------------------------------------------
    QTreeWidgetItem *itemBgColor = new QTreeWidgetItem(this-&gt;propertyTree);
    QGroupBox *bgGroupBox = new QGroupBox(tr("Background"));

    QGridLayout *bgLayout = new QGridLayout;
    bgGroupBox-&gt;setLayout(bgLayout);

    QLabel *bgColorLabel = new QLabel(tr("Color:"));
    bgLayout-&gt;addWidget(bgColorLabel,0,0,1,1);

    ColorComboBox *bgColorComboBox = new ColorComboBox;
    bgColorComboBox-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Fixed);
    bgColorComboBox-&gt;setColor(this-&gt;pGlWidget-&gt;getGLDisplayProperties().getBgColor());
    bgLayout-&gt;addWidget(bgColorComboBox,0,1,1,1);

    this-&gt;connect(bgColorComboBox,
                  SIGNAL(colorChanged(QColor)),
                  SLOT(onBgColorChanged(QColor)));

    // Background gradient
    QCheckBox *bgGradientCheckBox = new QCheckBox(tr("Gradient"));
    bgGradientCheckBox-&gt;setCheckState(this-&gt;pGlWidget-&gt;getGLDisplayProperties().getBgGradient() ? Qt::Checked : Qt::Unchecked);
    bgLayout-&gt;addWidget(bgGradientCheckBox,1,0,1,2);

    QObject::connect(bgGradientCheckBox,&amp;QCheckBox::stateChanged,this,&amp;GLDisplayPropertiesDialog::onBgGradientStateChanged);

    this-&gt;propertyTree-&gt;setItemWidget(itemBgColor,PROPERTIES_LIST_COLUMN_1,bgGroupBox);

    // Lights -------------------------------------------------------------
    for (uint i=0;i&lt;this-&gt;pGlWidget-&gt;getGLDisplayProperties().getNLights();i++)
    {
        QTreeWidgetItem *itemLight = new QTreeWidgetItem(this-&gt;propertyTree);

        LightPropertiesWidget *lightGroupBox = new LightPropertiesWidget("Light: " + QString::number(i+1),this-&gt;pGlWidget-&gt;getGLDisplayProperties().getLight(i));
        lightGroupBox-&gt;setID(i);

        this-&gt;propertyTree-&gt;setItemWidget(itemLight,PROPERTIES_LIST_COLUMN_1,lightGroupBox);

        this-&gt;connect(lightGroupBox,SIGNAL(lightChanged(RGLLight,uint)),SLOT(onLightChanged(RGLLight,uint)));
    }

    this-&gt;propertyTree-&gt;resizeColumnToContents(PROPERTIES_LIST_COLUMN_1);
}

</t>
<t tx="leo.20201108101520.13">void FileChooserButton::setFileName(const QString &amp;fileName)
{
    this-&gt;path = fileName;
    QFileInfo fileInfo(this-&gt;path);
    this-&gt;pushButton-&gt;setText(fileInfo.fileName());
    emit this-&gt;fileNameChanged(this-&gt;path);
}

</t>
<t tx="leo.20201108101520.14">void FileChooserButton::setFilter(const QString &amp;filter)
{
    this-&gt;filter = filter;
}

</t>
<t tx="leo.20201108101520.15">void FileChooserButton::setShowLabel(bool showLabel)
{
    if (showLabel)
    {
        this-&gt;label-&gt;show();
    }
    else
    {
        this-&gt;label-&gt;hide();
    }
}

</t>
<t tx="leo.20201108101520.16">void FileChooserButton::onPushButtonClicked(void)
{
    QString fileName;

    switch (this-&gt;type)
    {
        case FileChooserButton::SaveFile:
        {
            fileName = QFileDialog::getSaveFileName(this,
                                                    this-&gt;caption,
                                                    this-&gt;getFileName(),
                                                    this-&gt;filter);
            break;
        }
        case FileChooserButton::OpenFile:
        {
            fileName = QFileDialog::getOpenFileName(this,
                                                    this-&gt;caption,
                                                    this-&gt;getFileName(),
                                                    this-&gt;filter);
            if (!fileName.isEmpty())
            {
                if (!QFile::exists(fileName))
                {
                    fileName.clear();
                }
            }
            break;
        }
        case FileChooserButton::Directory:
        {
            fileName = QFileDialog::getExistingDirectory(this,
                                                         this-&gt;caption,
                                                         this-&gt;getFileName());
            if (!fileName.isEmpty())
            {
                if (!QFile::exists(fileName))
                {
                    fileName.clear();
                }
            }
            break;
        }
        default:
        {
            RLogger::error("Unknown FileChooserButton::type\n");
            break;
        }
    }

    if (!fileName.isEmpty())
    {
        this-&gt;setFileName(fileName);
    }
}
</t>
<t tx="leo.20201108101520.17">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   file_updater.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th May 2016                                           *
 *                                                                   *
 *  DESCRIPTION: File updater class definition                       *
 *********************************************************************/

#include &lt;QFile&gt;

#include &lt;rblib.h&gt;

#include "file_updater.h"

FileUpdater::FileUpdater(QObject *parent)
    : Job(parent)
{

}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.18">void FileUpdater::addFile(const QString &amp;source, const QString &amp;destination)
{
    this-&gt;files.append(QPair&lt;QString,QString&gt;(source,destination));
}

</t>
<t tx="leo.20201108101520.19">void FileUpdater::run(void)
{
    RLogger::info("Updating files.\n");
    RLogger::indent();
    RProgressInitialize("Updating files");
    for (int i=0;i&lt;this-&gt;files.size();i++)
    {
        RProgressPrint(i+1,this-&gt;files.size());
        RLogger::info("Checking file \'%s\'.\n",this-&gt;files.at(i).first.toUtf8().constData());

        if (QFile::exists(this-&gt;files.at(i).second.toUtf8().constData()))
        {
            RLogger::info("Destination file exists \'%s\' and will not be updated.\n",this-&gt;files.at(i).second.toUtf8().constData());
        }
        else
        {
            RLogger::info("Copying file \'%s\' to \'%s\'\n",
                          this-&gt;files.at(i).first.toUtf8().constData(),
                          this-&gt;files.at(i).second.toUtf8().constData());
            if (!QFile::copy(this-&gt;files.at(i).first,this-&gt;files.at(i).second))
            {
                RLogger::warning("Failed to copy file \'%s\' to \'%s\'\n",
                                 this-&gt;files.at(i).first.toUtf8().constData(),
                                 this-&gt;files.at(i).second.toUtf8().constData());
            }
        }
    }
    RProgressFinalize();
    RLogger::unindent();
}
</t>
<t tx="leo.20201108101520.2">void ECManagerTree::onProblemChanged(uint)
{
    this-&gt;populate();
}

QMap&lt;REnvironmentConditionType,uint&gt; ECManagerTree::getEcMap(const QList&lt;SessionEntityID&gt; &amp;entityIDs) const
{
    QMap&lt;REnvironmentConditionType,uint&gt; ecMap;
    REnvironmentConditionType ecType;
    uint ecCount;

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(entityIDs[i].getMid());

        if (entityIDs[i].getType() == R_ENTITY_GROUP_POINT)
        {
            for (uint j=0;j&lt;pModel-&gt;getPoint(entityIDs[i].getEid()).getNEnvironmentConditions();j++)
            {
                ecType = pModel-&gt;getPoint(entityIDs[i].getEid()).getEnvironmentCondition(j).getType();
                ecCount = ecMap.value(ecType,0) + 1;
                ecMap.insert(ecType,ecCount);
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_LINE)
        {
            for (uint j=0;j&lt;pModel-&gt;getLine(entityIDs[i].getEid()).getNEnvironmentConditions();j++)
            {
                ecType = pModel-&gt;getLine(entityIDs[i].getEid()).getEnvironmentCondition(j).getType();
                ecCount = ecMap.value(ecType,0) + 1;
                ecMap.insert(ecType,ecCount);
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_SURFACE)
        {
            for (uint j=0;j&lt;pModel-&gt;getSurface(entityIDs[i].getEid()).getNEnvironmentConditions();j++)
            {
                ecType = pModel-&gt;getSurface(entityIDs[i].getEid()).getEnvironmentCondition(j).getType();
                ecCount = ecMap.value(ecType,0) + 1;
                ecMap.insert(ecType,ecCount);
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_VOLUME)
        {
            for (uint j=0;j&lt;pModel-&gt;getVolume(entityIDs[i].getEid()).getNEnvironmentConditions();j++)
            {
                ecType = pModel-&gt;getVolume(entityIDs[i].getEid()).getEnvironmentCondition(j).getType();
                ecCount = ecMap.value(ecType,0) + 1;
                ecMap.insert(ecType,ecCount);
            }
        }
    }

    return ecMap;
}

</t>
<t tx="leo.20201108101520.20">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   find_sliver_elements_dialog.cpp                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th April 2018                                          *
 *                                                                   *
 *  DESCRIPTION: Find sliver elements dialog class definition        *
 *********************************************************************/

#include &lt;QIcon&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "find_sliver_elements_dialog.h"
#include "session.h"
#include "model_action.h"
#include "job_manager.h"

FindSliverElementsDialog::FindSliverElementsDialog(uint modelID, QWidget *parent)
    : QDialog(parent)
    , modelID(modelID)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Find sliver elements"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *label = new QLabel(tr("Find sliver elements for model") + " &lt;b&gt;" + Session::getInstance().getModel(this-&gt;modelID).getName() + "&lt;/b&gt;");
    mainLayout-&gt;addWidget(label);

    QHBoxLayout *toleranceLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(toleranceLayout);

    QLabel *toleranceLabel = new QLabel(tr("Edge length ratio:"));
    toleranceLayout-&gt;addWidget(toleranceLabel);

    this-&gt;edgeRatioEdit = new ValueLineEdit(1.0,1e10);
    this-&gt;edgeRatioEdit-&gt;setValue(Model::SliverElementEdgeRatio);
    toleranceLayout-&gt;addWidget(this-&gt;edgeRatioEdit);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;FindSliverElementsDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;FindSliverElementsDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.21">int FindSliverElementsDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        ModelActionInput modelActionInput(this-&gt;modelID);
        modelActionInput.setFindSliverElements(this-&gt;edgeRatioEdit-&gt;getValue());

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }

    return retVal;
}
</t>
<t tx="leo.20201108101520.22">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   first_run_dialog.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   16-th November 2017                                      *
 *                                                                   *
 *  DESCRIPTION: First run dialog class definition                   *
 *********************************************************************/

#include &lt;QHBoxLayout&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QCheckBox&gt;
#include &lt;QLabel&gt;
#include &lt;QIcon&gt;

#include "first_run_dialog.h"
#include "main_settings.h"

FirstRunDialog::FirstRunDialog(QWidget *parent)
    : QDialog(parent)
{
    QIcon preferencesIcon(":/icons/file/pixmaps/range-application_settings.svg");
    QIcon startIcon(":/icons/file/pixmaps/range-startup.svg");
    QIcon rangeIcon(":/icons/logos/pixmaps/range-logo-128.png");

    this-&gt;setWindowTitle(tr("First run"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QHBoxLayout *logoLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(logoLayout);

    QLabel *logoLabel = new QLabel;
    logoLabel-&gt;setPixmap(rangeIcon.pixmap(QSize(128,128)));
    logoLayout-&gt;addWidget(logoLabel);

    QString labelMsg = "&lt;h2&gt;" + RVendor::name + "&lt;/h2&gt;"
                     + "&lt;h3&gt;" + RVendor::description + "&lt;/h3&gt;"
                     + "&lt;p&gt;" + tr("version") + ": " + RVendor::version.toString() + "&lt;/p&gt;"
                     + "&lt;p&gt;&lt;strong&gt;" + tr("Welcome") + "!&lt;/strong&gt;&lt;/p&gt;";

    QLabel *label = new QLabel(labelMsg);
    logoLayout-&gt;addWidget(label);

    QLabel *sendUsageInfoLabel = new QLabel(tr("You can allow the sending of usage info from your computer so that Range Software can receive bug reports and statistics that help improve our software. None of the information gathered includes personal data."));
    sendUsageInfoLabel-&gt;setWordWrap(true);
    mainLayout-&gt;addWidget(sendUsageInfoLabel);

    QCheckBox *sendUsageInfoCheck = new QCheckBox(tr("Send usage info"));
    sendUsageInfoCheck-&gt;setCheckState(MainSettings::getInstance().getApplicationSettings()-&gt;getSendUsageInfo()?Qt::Checked:Qt::Unchecked);
    mainLayout-&gt;addWidget(sendUsageInfoCheck);

    QObject::connect(sendUsageInfoCheck,&amp;QCheckBox::toggled,this,&amp;FirstRunDialog::onSendUsageInfoToggled);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(buttonsLayout);

    buttonsLayout-&gt;addStretch(1);

    QPushButton *closeButton = new QPushButton(startIcon, tr("Start"));
    buttonsLayout-&gt;addWidget(closeButton);
    QObject::connect(closeButton,&amp;QPushButton::clicked,this,&amp;FirstRunDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.23">void FirstRunDialog::onSendUsageInfoToggled(bool checked)
{
    MainSettings::getInstance().getApplicationSettings()-&gt;setSendUsageInfo(checked);
    MainSettings::getInstance().getApplicationSettings()-&gt;setRangeApiAllowed(true);
}
</t>
<t tx="leo.20201108101520.24">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   fix_sliver_elements_dialog.cpp                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   1-st December 2016                                       *
 *                                                                   *
 *  DESCRIPTION: Fix sliver elements dialog class definition         *
 *********************************************************************/

#include &lt;QIcon&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "fix_sliver_elements_dialog.h"
#include "session.h"
#include "model_action.h"
#include "job_manager.h"

FixSliverElementsDialog::FixSliverElementsDialog(uint modelID, QWidget *parent)
    : QDialog(parent)
    , modelID(modelID)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Fix sliver elements"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *label = new QLabel(tr("Fix sliver elements for model") + " &lt;b&gt;" + Session::getInstance().getModel(this-&gt;modelID).getName() + "&lt;/b&gt;");
    mainLayout-&gt;addWidget(label);

    QHBoxLayout *toleranceLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(toleranceLayout);

    QLabel *toleranceLabel = new QLabel(tr("Edge length ratio:"));
    toleranceLayout-&gt;addWidget(toleranceLabel);

    this-&gt;edgeRatioEdit = new ValueLineEdit(1.0,1e10);
    this-&gt;edgeRatioEdit-&gt;setValue(Model::SliverElementEdgeRatio);
    toleranceLayout-&gt;addWidget(this-&gt;edgeRatioEdit);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;FixSliverElementsDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;FixSliverElementsDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.25">int FixSliverElementsDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        ModelActionInput modelActionInput(this-&gt;modelID);
        modelActionInput.setFixSliverElements(this-&gt;edgeRatioEdit-&gt;getValue());

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }

    return retVal;
}
</t>
<t tx="leo.20201108101520.26">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   geometry_rotate_widget.cpp                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th November 2014                                       *
 *                                                                   *
 *  DESCRIPTION: Geometry rotate widget class definition             *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QGroupBox&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "geometry_rotate_widget.h"
#include "session.h"

const RR3Vector GeometryRotateWidget::defaultAngles = RR3Vector(0.0,0.0,0.0);

GeometryRotateWidget::GeometryRotateWidget(const RR3Vector &amp;center, const RR3Vector &amp;rotation, QWidget *parent) :
    QWidget(parent)
{
    QVBoxLayout *vBoxLayout = new QVBoxLayout;
    this-&gt;setLayout(vBoxLayout);

    QGroupBox *groupBox = new QGroupBox(tr("Rotation angles"));
    vBoxLayout-&gt;addWidget(groupBox);

    QGridLayout *layout = new QGridLayout;
    groupBox-&gt;setLayout(layout);

    QLabel *xAngleLabel = new QLabel("X:");
    layout-&gt;addWidget(xAngleLabel,0,0,1,1);

    double maxAngle = R_RAD_TO_DEG(2.0*RConstants::pi);

    this-&gt;xAngleLineEdit = new ValueLineEdit;
    this-&gt;xAngleLineEdit-&gt;setDoubleValidator();
    this-&gt;xAngleLineEdit-&gt;setRange(-maxAngle,maxAngle);
    this-&gt;xAngleLineEdit-&gt;setValue(rotation[0]);
    layout-&gt;addWidget(this-&gt;xAngleLineEdit,0,1,1,1);

    QLabel *xAngleUnit = new QLabel(QString::fromUtf8("[°]"));
    layout-&gt;addWidget(xAngleUnit,0,2,1,1);

    QLabel *yAngleLabel = new QLabel("Y:");
    layout-&gt;addWidget(yAngleLabel,1,0,1,1);

    this-&gt;yAngleLineEdit = new ValueLineEdit;
    this-&gt;yAngleLineEdit-&gt;setDoubleValidator();
    this-&gt;yAngleLineEdit-&gt;setRange(-maxAngle,maxAngle);
    this-&gt;yAngleLineEdit-&gt;setValue(rotation[1]);
    layout-&gt;addWidget(this-&gt;yAngleLineEdit,1,1,1,1);

    QLabel *yAngleUnit = new QLabel(QString::fromUtf8("[°]"));
    layout-&gt;addWidget(yAngleUnit,1,2,1,1);

    QLabel *zAngleLabel = new QLabel("Z:");
    layout-&gt;addWidget(zAngleLabel,2,0,1,1);

    this-&gt;zAngleLineEdit = new ValueLineEdit;
    this-&gt;zAngleLineEdit-&gt;setDoubleValidator();
    this-&gt;zAngleLineEdit-&gt;setRange(-maxAngle,maxAngle);
    this-&gt;zAngleLineEdit-&gt;setValue(rotation[2]);
    layout-&gt;addWidget(this-&gt;zAngleLineEdit,2,1,1,1);

    QLabel *zAngleUnit = new QLabel(QString::fromUtf8("[°]"));
    layout-&gt;addWidget(zAngleUnit,2,2,1,1);

    QPushButton *anglesResetButton = new QPushButton(QIcon(":/icons/file/pixmaps/range-undo.svg"),tr("Reset"));
    layout-&gt;addWidget(anglesResetButton,2,3,1,1);

    this-&gt;rotationCenter = new PositionWidget(tr("Rotation center"),center,false);
    this-&gt;rotationCenter-&gt;hideButtons();
    this-&gt;rotationCenter-&gt;hideSliders();
    vBoxLayout-&gt;addWidget(this-&gt;rotationCenter);

    QObject::connect(anglesResetButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;GeometryRotateWidget::resetAngles);

    QObject::connect(this-&gt;xAngleLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;GeometryRotateWidget::onAngleValueChanged);

    QObject::connect(this-&gt;yAngleLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;GeometryRotateWidget::onAngleValueChanged);

    QObject::connect(this-&gt;zAngleLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;GeometryRotateWidget::onAngleValueChanged);

    QObject::connect(this-&gt;rotationCenter,
                     &amp;PositionWidget::changed,
                     this,
                     &amp;GeometryRotateWidget::onPositionChanged);

    this-&gt;resetAngles();

    vBoxLayout-&gt;addStretch(10);

    Session::getInstance().setBeginDrawRotationOrigin(center);
}

GeometryRotateWidget::~GeometryRotateWidget()
{
    Session::getInstance().setEndDrawRotationOrigin();
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.27">void GeometryRotateWidget::resetAngles(void)
{
    this-&gt;xAngleLineEdit-&gt;setValue(this-&gt;defaultAngles[0]);
    this-&gt;yAngleLineEdit-&gt;setValue(this-&gt;defaultAngles[1]);
    this-&gt;zAngleLineEdit-&gt;setValue(this-&gt;defaultAngles[2]);
}

</t>
<t tx="leo.20201108101520.28">void GeometryRotateWidget::onAngleValueChanged(double)
{
    emit this-&gt;rotationChanged(this-&gt;rotationCenter-&gt;getPosition(),
                               RR3Vector(this-&gt;xAngleLineEdit-&gt;getValue(),
                                         this-&gt;yAngleLineEdit-&gt;getValue(),
                                         this-&gt;zAngleLineEdit-&gt;getValue()));
}

</t>
<t tx="leo.20201108101520.29">void GeometryRotateWidget::onPositionChanged(const RR3Vector &amp;)
{
    emit this-&gt;rotationChanged(this-&gt;rotationCenter-&gt;getPosition(),
                               RR3Vector(this-&gt;xAngleLineEdit-&gt;getValue(),
                                         this-&gt;yAngleLineEdit-&gt;getValue(),
                                         this-&gt;zAngleLineEdit-&gt;getValue()));
    Session::getInstance().setBeginDrawRotationOrigin(this-&gt;rotationCenter-&gt;getPosition());
}
</t>
<t tx="leo.20201108101520.3">void ECManagerTree::onItemChanged(QTreeWidgetItem *item, int column)
{
    Qt::CheckState checkState = item-&gt;checkState(column);
    REnvironmentConditionType ecType = (REnvironmentConditionType) item-&gt;data(EC_TREE_COLUMN_NAME,Qt::UserRole).toInt();
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(entityIDs[i].getMid());
        if (entityIDs[i].getType() == R_ENTITY_GROUP_POINT)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getPoint(entityIDs[i].getEid()).addEnvironmentCondition(REnvironmentCondition(ecType));
            }
            else
            {
                if (pModel-&gt;getPoint(entityIDs[i].getEid()).hasEnvironmentCondition(ecType))
                {
                    pModel-&gt;getPoint(entityIDs[i].getEid()).removeEnvironmentCondition(ecType);
                }
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_LINE)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getLine(entityIDs[i].getEid()).addEnvironmentCondition(REnvironmentCondition(ecType));
            }
            else
            {
                if (pModel-&gt;getLine(entityIDs[i].getEid()).hasEnvironmentCondition(ecType))
                {
                    pModel-&gt;getLine(entityIDs[i].getEid()).removeEnvironmentCondition(ecType);
                }
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_SURFACE)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getSurface(entityIDs[i].getEid()).addEnvironmentCondition(REnvironmentCondition(ecType));
            }
            else
            {
                if (pModel-&gt;getSurface(entityIDs[i].getEid()).hasEnvironmentCondition(ecType))
                {
                    pModel-&gt;getSurface(entityIDs[i].getEid()).removeEnvironmentCondition(ecType);
                }
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_VOLUME)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getVolume(entityIDs[i].getEid()).addEnvironmentCondition(REnvironmentCondition(ecType));
            }
            else
            {
                if (pModel-&gt;getVolume(entityIDs[i].getEid()).hasEnvironmentCondition(ecType))
                {
                    pModel-&gt;getVolume(entityIDs[i].getEid()).removeEnvironmentCondition(ecType);
                }
            }
        }
    }

    if (item-&gt;isSelected())
    {
        emit this-&gt;ecSelected(ecType,(checkState != Qt::Unchecked));
    }
    else
    {
        emit this-&gt;ecSelected(R_ENVIRONMENT_CONDITION_NONE,false);
    }
}

</t>
<t tx="leo.20201108101520.30">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   geometry_scale_widget.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th November 2014                                       *
 *                                                                   *
 *  DESCRIPTION: Geometry scale widget class definition              *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "geometry_scale_widget.h"
#include "session.h"

GeometryScaleWidget::GeometryScaleWidget(const RR3Vector &amp;center, const RR3Vector &amp;scale, QWidget *parent)
    : QWidget(parent)
    , defaultScale(scale)
{
    QVBoxLayout *vBoxLayout = new QVBoxLayout;
    this-&gt;setLayout(vBoxLayout);

    this-&gt;sameScaleGroupBox = new QGroupBox(tr("Same scale in all directions"));
    this-&gt;sameScaleGroupBox-&gt;setCheckable(true);
    this-&gt;sameScaleGroupBox-&gt;setChecked(true);
    vBoxLayout-&gt;addWidget(this-&gt;sameScaleGroupBox);

    QGridLayout *sameLayout = new QGridLayout;
    this-&gt;sameScaleGroupBox-&gt;setLayout(sameLayout);

    QLabel *sameScaleLabel = new QLabel(tr("Scale")+":");
    sameLayout-&gt;addWidget(sameScaleLabel,0,0,1,1);

    this-&gt;sameScaleLineEdit = new ValueLineEdit;
    this-&gt;sameScaleLineEdit-&gt;setDoubleValidator();
    this-&gt;sameScaleLineEdit-&gt;setValue(this-&gt;defaultScale[0]);
    sameLayout-&gt;addWidget(this-&gt;sameScaleLineEdit,0,1,1,1);

    QPushButton *sameScaleResetButton = new QPushButton(QIcon(":/icons/file/pixmaps/range-undo.svg"),tr("Reset"));
    sameLayout-&gt;addWidget(sameScaleResetButton,0,2,1,1);

    QObject::connect(sameScaleResetButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;GeometryScaleWidget::resetSameScale);

    this-&gt;differentScaleGroupBox = new QGroupBox(tr("Different scale in each directions"));
    this-&gt;differentScaleGroupBox-&gt;setCheckable(true);
    this-&gt;differentScaleGroupBox-&gt;setChecked(false);
    vBoxLayout-&gt;addWidget(this-&gt;differentScaleGroupBox);

    QGridLayout *differentLayout = new QGridLayout;
    this-&gt;differentScaleGroupBox-&gt;setLayout(differentLayout);

    QLabel *xScaleLabel = new QLabel(tr("X scale")+":");
    differentLayout-&gt;addWidget(xScaleLabel,0,0,1,1);

    this-&gt;xScaleLineEdit = new ValueLineEdit;
    this-&gt;xScaleLineEdit-&gt;setDoubleValidator();
    differentLayout-&gt;addWidget(this-&gt;xScaleLineEdit,0,1,1,1);

    QLabel *yScaleLabel = new QLabel(tr("Y scale")+":");
    differentLayout-&gt;addWidget(yScaleLabel,1,0,1,1);

    this-&gt;yScaleLineEdit = new ValueLineEdit;
    this-&gt;yScaleLineEdit-&gt;setDoubleValidator();
    differentLayout-&gt;addWidget(this-&gt;yScaleLineEdit,1,1,1,1);

    QLabel *zScaleLabel = new QLabel(tr("Z scale")+":");
    differentLayout-&gt;addWidget(zScaleLabel,2,0,1,1);

    this-&gt;zScaleLineEdit = new ValueLineEdit;
    this-&gt;zScaleLineEdit-&gt;setDoubleValidator();
    differentLayout-&gt;addWidget(this-&gt;zScaleLineEdit,2,1,1,1);

    this-&gt;scaleCenter = new PositionWidget(tr("Scale center"),center,false);
    this-&gt;scaleCenter-&gt;hideButtons();
    this-&gt;scaleCenter-&gt;hideSliders();
    vBoxLayout-&gt;addWidget(this-&gt;scaleCenter);

    QPushButton *differentScaleResetButton = new QPushButton(QIcon(":/icons/file/pixmaps/range-undo.svg"),tr("Reset"));
    differentLayout-&gt;addWidget(differentScaleResetButton,2,2,1,1);

    QObject::connect(differentScaleResetButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;GeometryScaleWidget::resetDifferentScale);

    this-&gt;resetSameScale();
    this-&gt;resetDifferentScale();

    QObject::connect(this-&gt;sameScaleGroupBox,
                     &amp;QGroupBox::toggled,
                     this,
                     &amp;GeometryScaleWidget::onSameScaleToggled);

    QObject::connect(this-&gt;differentScaleGroupBox,
                     &amp;QGroupBox::toggled,
                     this,
                     &amp;GeometryScaleWidget::onDifferentScaleToggled);

    QObject::connect(this-&gt;sameScaleLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;GeometryScaleWidget::onScaleValueChanged);
    QObject::connect(this-&gt;xScaleLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;GeometryScaleWidget::onScaleValueChanged);
    QObject::connect(this-&gt;yScaleLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;GeometryScaleWidget::onScaleValueChanged);
    QObject::connect(this-&gt;zScaleLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;GeometryScaleWidget::onScaleValueChanged);

    QObject::connect(this-&gt;scaleCenter,
                     &amp;PositionWidget::changed,
                     this,
                     &amp;GeometryScaleWidget::onPositionChanged);

    vBoxLayout-&gt;addStretch(10);

    Session::getInstance().setBeginDrawScaleOrigin(center);
}

GeometryScaleWidget::~GeometryScaleWidget()
{
    Session::getInstance().setEndDrawScaleOrigin();
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.31">void GeometryScaleWidget::onSameScaleToggled(bool checked)
{
    this-&gt;differentScaleGroupBox-&gt;setChecked(!checked);
}

</t>
<t tx="leo.20201108101520.32">void GeometryScaleWidget::onDifferentScaleToggled(bool checked)
{
    this-&gt;sameScaleGroupBox-&gt;setChecked(!checked);
}

</t>
<t tx="leo.20201108101520.33">void GeometryScaleWidget::resetSameScale(void)
{
    this-&gt;sameScaleLineEdit-&gt;setValue(this-&gt;defaultScale[0]);
}

</t>
<t tx="leo.20201108101520.34">void GeometryScaleWidget::resetDifferentScale(void)
{
    this-&gt;xScaleLineEdit-&gt;setValue(this-&gt;defaultScale[0]);
    this-&gt;yScaleLineEdit-&gt;setValue(this-&gt;defaultScale[1]);
    this-&gt;zScaleLineEdit-&gt;setValue(this-&gt;defaultScale[2]);
}

</t>
<t tx="leo.20201108101520.35">void GeometryScaleWidget::onScaleValueChanged(double)
{
    if (this-&gt;sameScaleGroupBox-&gt;isChecked())
    {
        emit this-&gt;scaleChanged(this-&gt;scaleCenter-&gt;getPosition(),
                                RR3Vector(this-&gt;sameScaleLineEdit-&gt;getValue(),
                                          this-&gt;sameScaleLineEdit-&gt;getValue(),
                                          this-&gt;sameScaleLineEdit-&gt;getValue()));
    }
    if (this-&gt;differentScaleGroupBox-&gt;isChecked())
    {
        emit this-&gt;scaleChanged(this-&gt;scaleCenter-&gt;getPosition(),
                                RR3Vector(this-&gt;xScaleLineEdit-&gt;getValue(),
                                          this-&gt;yScaleLineEdit-&gt;getValue(),
                                          this-&gt;zScaleLineEdit-&gt;getValue()));
    }
}

</t>
<t tx="leo.20201108101520.36">void GeometryScaleWidget::onPositionChanged(const RR3Vector &amp;)
{
    RR3Vector scaleVector(this-&gt;xScaleLineEdit-&gt;getValue(),
                          this-&gt;yScaleLineEdit-&gt;getValue(),
                          this-&gt;zScaleLineEdit-&gt;getValue());
    if (this-&gt;sameScaleGroupBox-&gt;isChecked())
    {
        scaleVector.fill(this-&gt;sameScaleLineEdit-&gt;getValue());
    }
    emit this-&gt;scaleChanged(this-&gt;scaleCenter-&gt;getPosition(),scaleVector);

    Session::getInstance().setBeginDrawScaleOrigin(this-&gt;scaleCenter-&gt;getPosition());
}
</t>
<t tx="leo.20201108101520.37">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   geometry_transform_input.cpp                             *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   7-th November 2014                                       *
 *                                                                   *
 *  DESCRIPTION: Geometry transform input class definition           *
 *********************************************************************/

#include "geometry_transform_input.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.38">void GeometryTransformInput::_init(const GeometryTransformInput *pGeometryTransformInput)
{
    if (pGeometryTransformInput)
    {
        this-&gt;translation = pGeometryTransformInput-&gt;translation;
        this-&gt;rotation = pGeometryTransformInput-&gt;rotation;
        this-&gt;rotationCenter = pGeometryTransformInput-&gt;rotationCenter;
        this-&gt;scale = pGeometryTransformInput-&gt;scale;
        this-&gt;scaleCenter = pGeometryTransformInput-&gt;scaleCenter;
        this-&gt;applyTo = pGeometryTransformInput-&gt;applyTo;
        this-&gt;includeSharedNodes = pGeometryTransformInput-&gt;includeSharedNodes;
        this-&gt;splitSharedNodes = pGeometryTransformInput-&gt;splitSharedNodes;
        this-&gt;sweepSharedNodes = pGeometryTransformInput-&gt;sweepSharedNodes;
        this-&gt;nSweepSteps = pGeometryTransformInput-&gt;nSweepSteps;
    }
}

GeometryTransformInput::GeometryTransformInput()
    : translation(0.0,0.0,0.0)
    , rotation(0.0,0.0,0.0)
    , rotationCenter(0.0,0.0,0.0)
    , scale(1.0,1.0,1.0)
    , scaleCenter(0.0,0.0,0.0)
    , applyTo(GeometryTransformInput::ApplyToAll)
    , includeSharedNodes(true)
    , splitSharedNodes(true)
    , sweepSharedNodes(true)
    , nSweepSteps(1)
{
    this-&gt;_init();
}

GeometryTransformInput::GeometryTransformInput(const GeometryTransformInput &amp;geometryTransformInput)
{
    this-&gt;_init(&amp;geometryTransformInput);
}

GeometryTransformInput::~GeometryTransformInput()
{

}

GeometryTransformInput &amp;GeometryTransformInput::operator =(const GeometryTransformInput &amp;geometryTransformInput)
{
    this-&gt;_init(&amp;geometryTransformInput);
    return (*this);
}

</t>
<t tx="leo.20201108101520.39">const RR3Vector &amp;GeometryTransformInput::getTranslation(void) const
{
    return this-&gt;translation;
}

RR3Vector &amp;GeometryTransformInput::getTranslation(void)
{
    return this-&gt;translation;
}

</t>
<t tx="leo.20201108101520.4">void ECManagerTree::onItemSelectionChanged(void)
{
    QList&lt;QTreeWidgetItem *&gt; items = this-&gt;selectedItems();
    emit this-&gt;ecSelected(R_ENVIRONMENT_CONDITION_NONE,false);
    for (int i=0;i&lt;items.size();i++)
    {
        REnvironmentConditionType ecType = (REnvironmentConditionType)items[i]-&gt;data(EC_TREE_COLUMN_NAME,Qt::UserRole).toInt();
//        bool applied = (items[i]-&gt;checkState(EC_TREE_COLUMN_NAME) == Qt::Checked);
        emit this-&gt;ecSelected(ecType,true);
    }
}

</t>
<t tx="leo.20201108101520.40">void GeometryTransformInput::setTranslation(const RR3Vector &amp;translation)
{
    this-&gt;translation = translation;
}

</t>
<t tx="leo.20201108101520.41">const RR3Vector &amp;GeometryTransformInput::getRotation(void) const
{
    return this-&gt;rotation;
}

RR3Vector &amp;GeometryTransformInput::getRotation(void)
{
    return this-&gt;rotation;
}

</t>
<t tx="leo.20201108101520.42">void GeometryTransformInput::setRotation(const RR3Vector &amp;rotation)
{
    this-&gt;rotation = rotation;
}

</t>
<t tx="leo.20201108101520.43">const RR3Vector &amp;GeometryTransformInput::getRotationCenter(void) const
{
    return this-&gt;rotationCenter;
}

RR3Vector &amp;GeometryTransformInput::getRotationCenter(void)
{
    return this-&gt;rotationCenter;
}

</t>
<t tx="leo.20201108101520.44">void GeometryTransformInput::setRotationCenter(const RR3Vector &amp;rotationCenter)
{
    this-&gt;rotationCenter = rotationCenter;
}

</t>
<t tx="leo.20201108101520.45">const RR3Vector &amp;GeometryTransformInput::getScale(void) const
{
    return this-&gt;scale;
}

RR3Vector &amp;GeometryTransformInput::getScale(void)
{
    return this-&gt;scale;
}

</t>
<t tx="leo.20201108101520.46">void GeometryTransformInput::setScale(const RR3Vector &amp;scale)
{
    this-&gt;scale = scale;
}

</t>
<t tx="leo.20201108101520.47">const RR3Vector &amp;GeometryTransformInput::getScaleCenter(void) const
{
    return this-&gt;scaleCenter;
}

RR3Vector &amp;GeometryTransformInput::getScaleCenter(void)
{
    return this-&gt;scaleCenter;
}

</t>
<t tx="leo.20201108101520.48">void GeometryTransformInput::setScaleCenter(const RR3Vector &amp;scaleCenter)
{
    this-&gt;scaleCenter = scaleCenter;
}

GeometryTransformInput::ApplyTo GeometryTransformInput::getApplyTo(void) const
{
    return applyTo;
}

</t>
<t tx="leo.20201108101520.49">void GeometryTransformInput::setApplyTo(const ApplyTo &amp;applyTo)
{
    this-&gt;applyTo = applyTo;
}

</t>
<t tx="leo.20201108101520.5">void ECManagerTree::onEcSelected(void)
{
    this-&gt;doNotPopulate = true;
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
    this-&gt;doNotPopulate = false;
}
</t>
<t tx="leo.20201108101520.50">bool GeometryTransformInput::getIncludeSharedNodes(void) const
{
    return this-&gt;includeSharedNodes;
}

</t>
<t tx="leo.20201108101520.51">void GeometryTransformInput::setIncludeSharedNodes(bool includeSharedNodes)
{
    this-&gt;includeSharedNodes = includeSharedNodes;
}

</t>
<t tx="leo.20201108101520.52">bool GeometryTransformInput::getSplitSharedNodes(void) const
{
    return this-&gt;splitSharedNodes;
}

</t>
<t tx="leo.20201108101520.53">void GeometryTransformInput::setSplitSharedNodes(bool splitSharedNodes)
{
    this-&gt;splitSharedNodes = splitSharedNodes;
}

</t>
<t tx="leo.20201108101520.54">bool GeometryTransformInput::getSweepSharedNodes(void) const
{
    return this-&gt;sweepSharedNodes;
}

</t>
<t tx="leo.20201108101520.55">void GeometryTransformInput::setSweepSharedNodes(bool sweepSharedNodes)
{
    this-&gt;sweepSharedNodes = sweepSharedNodes;
}

uint GeometryTransformInput::getNSweepSteps(void) const
{
    return this-&gt;nSweepSteps;
}

</t>
<t tx="leo.20201108101520.56">void GeometryTransformInput::setNSweepSteps(uint nSweepSteps)
{
    this-&gt;nSweepSteps = nSweepSteps;
}

</t>
<t tx="leo.20201108101520.57">bool GeometryTransformInput::isTranslateActive(void) const
{
    return (this-&gt;translation[0] != 0.0 || this-&gt;translation[1] != 0.0 || this-&gt;translation[2] != 0.0);
}

</t>
<t tx="leo.20201108101520.58">bool GeometryTransformInput::isRotateActive(void) const
{
    return (this-&gt;rotation[0] != 0.0 || this-&gt;rotation[1] != 0.0 || this-&gt;rotation[2] != 0.0);
}

</t>
<t tx="leo.20201108101520.59">bool GeometryTransformInput::isScaleActive(void) const
{
    return (this-&gt;scale[0] != 1.0 || this-&gt;scale[1] != 1.0 || this-&gt;scale[2] != 1.0);
}
</t>
<t tx="leo.20201108101520.6">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   ec_tree.cpp                                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   7-th August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Environment condition tree class definition         *
 *********************************************************************/

#include &lt;QStandardItemModel&gt;
#include &lt;QLineEdit&gt;
#include &lt;QPushButton&gt;

#include "component_edit_dialog.h"
#include "session.h"
#include "ec_tree.h"
#include "variable_value_edit.h"
#include "push_button.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.60">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   geometry_transform_widget.cpp                            *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th November 2014                                       *
 *                                                                   *
 *  DESCRIPTION: Geometry transform widget class definition          *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QTabWidget&gt;
#include &lt;QCheckBox&gt;
#include &lt;QScrollArea&gt;

#include "geometry_transform_widget.h"
#include "model_action.h"
#include "job_manager.h"
#include "session.h"

GeometryTransformWidget::GeometryTransformWidget(QWidget *parent) :
    QWidget(parent)
{
    QVBoxLayout *vBoxLayout = new QVBoxLayout;
    this-&gt;setLayout(vBoxLayout);

    QScrollArea *scrollArea = new QScrollArea;
    scrollArea-&gt;setWidgetResizable(true);
    vBoxLayout-&gt;addWidget(scrollArea);

    QWidget *containerWidget = new QWidget;
    scrollArea-&gt;setWidget(containerWidget);

    QVBoxLayout *containerLayout = new QVBoxLayout(containerWidget);

    QTabWidget *tabWidget = new QTabWidget;
    containerLayout-&gt;addWidget(tabWidget);

    this-&gt;scaleWidget = new GeometryScaleWidget(this-&gt;input.getScaleCenter(),this-&gt;input.getScale());
    tabWidget-&gt;addTab(this-&gt;scaleWidget,tr("Scale"));

    this-&gt;rotateWidget = new GeometryRotateWidget(this-&gt;input.getRotationCenter(),this-&gt;input.getRotation());
    tabWidget-&gt;addTab(this-&gt;rotateWidget,tr("Rotate"));

    this-&gt;translateWidget = new GeometryTranslateWidget(this-&gt;input.getTranslation());
    tabWidget-&gt;addTab(this-&gt;translateWidget,tr("Translate"));

    QGroupBox *applyToGroupBox = new QGroupBox(tr("Apply to"));
    containerLayout-&gt;addWidget(applyToGroupBox);

    QVBoxLayout *applyToLayout = new QVBoxLayout;
    applyToGroupBox-&gt;setLayout(applyToLayout);

    this-&gt;applyToAllRadio = new QRadioButton(tr("All"));
    this-&gt;applyToAllRadio-&gt;setChecked(this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToAll);
    applyToLayout-&gt;addWidget(this-&gt;applyToAllRadio);

    this-&gt;applyToSelectedRadio = new QRadioButton(tr("Selected entities"));
    this-&gt;applyToSelectedRadio-&gt;setChecked(this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToSelected);
    this-&gt;applyToSelectedRadio-&gt;setEnabled(Session::getInstance().getSelectedEntityIDs().size() &gt; 0);
    applyToLayout-&gt;addWidget(this-&gt;applyToSelectedRadio);

    this-&gt;applyToPickedRadio = new QRadioButton(tr("Picked entities"));
    this-&gt;applyToPickedRadio-&gt;setChecked(this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToPicked);
    this-&gt;applyToPickedRadio-&gt;setEnabled(!Session::getInstance().getPickList().isEmpty());
    applyToLayout-&gt;addWidget(this-&gt;applyToPickedRadio);

    this-&gt;applyToVisibleRadio = new QRadioButton(tr("Visible entities"));
    this-&gt;applyToVisibleRadio-&gt;setChecked(this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToVisible);
    applyToLayout-&gt;addWidget(this-&gt;applyToVisibleRadio);

    this-&gt;includeSharedNodesCheck = new QGroupBox(tr("Include shared nodes"));
    this-&gt;includeSharedNodesCheck-&gt;setCheckable(true);
    this-&gt;includeSharedNodesCheck-&gt;setChecked(this-&gt;input.getIncludeSharedNodes());
    containerLayout-&gt;addWidget(this-&gt;includeSharedNodesCheck);
    this-&gt;includeSharedNodesCheck-&gt;setDisabled(this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToAll);

    QVBoxLayout *includeSharedNodesLayout = new QVBoxLayout;
    this-&gt;includeSharedNodesCheck-&gt;setLayout(includeSharedNodesLayout);

    this-&gt;splitSharedNodesCheck = new QGroupBox(tr("Detach/split shared nodes"));
    this-&gt;splitSharedNodesCheck-&gt;setCheckable(true);
    this-&gt;splitSharedNodesCheck-&gt;setChecked(this-&gt;input.getSplitSharedNodes());
    includeSharedNodesLayout-&gt;addWidget(this-&gt;splitSharedNodesCheck);

    QVBoxLayout *splitSharedNodesLayout = new QVBoxLayout;
    this-&gt;splitSharedNodesCheck-&gt;setLayout(splitSharedNodesLayout);

    this-&gt;sweepNodesCheck = new QGroupBox(tr("Sweep nodes"));
    this-&gt;sweepNodesCheck-&gt;setCheckable(true);
    this-&gt;sweepNodesCheck-&gt;setChecked(this-&gt;input.getSweepSharedNodes());
    splitSharedNodesLayout-&gt;addWidget(this-&gt;sweepNodesCheck);

    QVBoxLayout *sweepNodesLayout = new QVBoxLayout;
    this-&gt;sweepNodesCheck-&gt;setLayout(sweepNodesLayout);

    this-&gt;sweepNStepsSpin = new QSpinBox;
    this-&gt;sweepNStepsSpin-&gt;setPrefix(tr("Sweep steps") + ": ");
    this-&gt;sweepNStepsSpin-&gt;setMinimum(1);
    this-&gt;sweepNStepsSpin-&gt;setValue(this-&gt;input.getNSweepSteps());
    sweepNodesLayout-&gt;addWidget(this-&gt;sweepNStepsSpin);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    vBoxLayout-&gt;addLayout(buttonsLayout);

    this-&gt;cancelButton = new QPushButton(QIcon(":/icons/file/pixmaps/range-cancel.svg"),tr("Cancel"));
    buttonsLayout-&gt;addWidget(this-&gt;cancelButton);

    this-&gt;okButton = new QPushButton(QIcon(":/icons/file/pixmaps/range-ok.svg"),tr("Ok"));
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    this-&gt;enableOkButton();

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelSelectionChanged,
                     this,
                     &amp;GeometryTransformWidget::onModelSelectionChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::pickListChanged,
                     this,
                     &amp;GeometryTransformWidget::onPickListChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelVisibilityChanged,
                     this,
                     &amp;GeometryTransformWidget::onModelVisibilityChanged);

    QObject::connect(scaleWidget,
                     &amp;GeometryScaleWidget::scaleChanged,
                     this,
                     &amp;GeometryTransformWidget::onScaleChanged);
    QObject::connect(rotateWidget,
                     &amp;GeometryRotateWidget::rotationChanged,
                     this,
                     &amp;GeometryTransformWidget::onRotationChanged);
    QObject::connect(translateWidget,
                     &amp;GeometryTranslateWidget::translationChanged,
                     this,
                     &amp;GeometryTransformWidget::onTranslationChanged);

    QObject::connect(this-&gt;applyToAllRadio,
                     &amp;QRadioButton::clicked,
                     this,
                     &amp;GeometryTransformWidget::onApplyToAllClicked);
    QObject::connect(this-&gt;applyToSelectedRadio,
                     &amp;QRadioButton::clicked,
                     this,
                     &amp;GeometryTransformWidget::onApplyToSelectedClicked);
    QObject::connect(this-&gt;applyToPickedRadio,
                     &amp;QRadioButton::clicked,
                     this,
                     &amp;GeometryTransformWidget::onApplyToPickedClicked);
    QObject::connect(this-&gt;applyToVisibleRadio,
                     &amp;QRadioButton::clicked,
                     this,
                     &amp;GeometryTransformWidget::onApplyToVisibleClicked);

    QObject::connect(this-&gt;includeSharedNodesCheck,
                     &amp;QGroupBox::clicked,
                     this,
                     &amp;GeometryTransformWidget::onIncludeSharedNodesClicked);
    QObject::connect(this-&gt;splitSharedNodesCheck,
                     &amp;QGroupBox::clicked,
                     this,
                     &amp;GeometryTransformWidget::onSplitSharedNodesClicked);
    QObject::connect(this-&gt;sweepNodesCheck,
                     &amp;QGroupBox::clicked,
                     this,
                     &amp;GeometryTransformWidget::onSweepSharedNodesClicked);
    this-&gt;connect(this-&gt;sweepNStepsSpin,SIGNAL(valueChanged(int)),SLOT(onSweepNStepsSpinChanged(int)));

    QObject::connect(this-&gt;cancelButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;GeometryTransformWidget::onCancelClicked);
    QObject::connect(this-&gt;okButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;GeometryTransformWidget::onOkClicked);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.61">void GeometryTransformWidget::enableOkButton(void)
{
    bool entityIsSelected = true;

    if (this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToSelected)
    {
        entityIsSelected = !Session::getInstance().getSelectedModelIDs().isEmpty();
    }
    else if (this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToPicked)
    {
        entityIsSelected = !Session::getInstance().getPickList().getModelIDs().isEmpty();
    }
    else if (this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToVisible)
    {
        entityIsSelected = !Session::getInstance().getVisibleEntityIDs().isEmpty();
    }

    this-&gt;okButton-&gt;setEnabled(entityIsSelected &amp;&amp; (this-&gt;input.isRotateActive() || this-&gt;input.isScaleActive() || this-&gt;input.isTranslateActive()));
}

</t>
<t tx="leo.20201108101520.62">void GeometryTransformWidget::onModelSelectionChanged(uint)
{
    this-&gt;applyToSelectedRadio-&gt;setEnabled(!Session::getInstance().getSelectedEntityIDs().isEmpty());
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.63">void GeometryTransformWidget::onModelVisibilityChanged(uint)
{
    this-&gt;applyToVisibleRadio-&gt;setEnabled(!Session::getInstance().getVisibleEntityIDs().isEmpty());
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.64">void GeometryTransformWidget::onPickListChanged(void)
{
    this-&gt;applyToPickedRadio-&gt;setEnabled(!Session::getInstance().getPickList().isEmpty());
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.65">void GeometryTransformWidget::onScaleChanged(const RR3Vector &amp;center, const RR3Vector &amp;scales)
{
    this-&gt;input.setScale(scales);
    this-&gt;input.setScaleCenter(center);
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.66">void GeometryTransformWidget::onRotationChanged(const RR3Vector &amp;center, const RR3Vector &amp;rotations)
{
    this-&gt;input.setRotation(rotations);
    this-&gt;input.setRotationCenter(center);
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.67">void GeometryTransformWidget::onTranslationChanged(const RR3Vector &amp;distances)
{
    this-&gt;input.setTranslation(distances);
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.68">void GeometryTransformWidget::onApplyToAllClicked(bool checked)
{
    if (checked)
    {
        this-&gt;input.setApplyTo(GeometryTransformInput::ApplyToAll);
    }
    this-&gt;includeSharedNodesCheck-&gt;setDisabled(checked);
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.69">void GeometryTransformWidget::onApplyToSelectedClicked(bool checked)
{
    if (checked)
    {
        this-&gt;input.setApplyTo(GeometryTransformInput::ApplyToSelected);
    }
    this-&gt;includeSharedNodesCheck-&gt;setEnabled(checked);
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.7">typedef enum _ECTreeColumn
{
    EC_TREE_PROPERTY_NAME = 0,
    EC_TREE_PROPERTY_VALUE,
    EC_TREE_PROPERTY_UNITS,
    EC_TREE_PROPERTY_TYPE,
    EC_TREE_N_COLUMNS
} ECTreeColumn;

ECTree::ECTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setRootIsDecorated(false);
    this-&gt;setSelectionMode(QAbstractItemView::NoSelection);

    this-&gt;setColumnCount(EC_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(EC_TREE_PROPERTY_TYPE,QString("Property type"));
    headerItem-&gt;setText(EC_TREE_PROPERTY_NAME,QString("Property name"));
    headerItem-&gt;setText(EC_TREE_PROPERTY_VALUE,QString("Value"));
    headerItem-&gt;setText(EC_TREE_PROPERTY_UNITS,QString("Units"));
    this-&gt;setHeaderItem(headerItem);

    this-&gt;setColumnHidden(EC_TREE_PROPERTY_TYPE,true);

    this-&gt;populate();
}

</t>
<t tx="leo.20201108101520.70">void GeometryTransformWidget::onApplyToPickedClicked(bool checked)
{
    if (checked)
    {
        this-&gt;input.setApplyTo(GeometryTransformInput::ApplyToPicked);
    }
    this-&gt;includeSharedNodesCheck-&gt;setEnabled(checked);
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.71">void GeometryTransformWidget::onApplyToVisibleClicked(bool checked)
{
    if (checked)
    {
        this-&gt;input.setApplyTo(GeometryTransformInput::ApplyToVisible);
    }
    this-&gt;includeSharedNodesCheck-&gt;setEnabled(checked);
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.72">void GeometryTransformWidget::onIncludeSharedNodesClicked(bool checked)
{
    this-&gt;input.setIncludeSharedNodes(checked);
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.73">void GeometryTransformWidget::onSplitSharedNodesClicked(bool checked)
{
    this-&gt;input.setSplitSharedNodes(checked);
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.74">void GeometryTransformWidget::onSweepSharedNodesClicked(bool checked)
{
    this-&gt;input.setSweepSharedNodes(checked);
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.75">void GeometryTransformWidget::onSweepNStepsSpinChanged(int nSweepSteps)
{
    this-&gt;input.setNSweepSteps(uint(nSweepSteps));
    this-&gt;enableOkButton();
}

</t>
<t tx="leo.20201108101520.76">void GeometryTransformWidget::onCancelClicked(void)
{
    emit this-&gt;finalize();
}

</t>
<t tx="leo.20201108101520.77">void GeometryTransformWidget::onOkClicked(void)
{
    QList&lt;uint&gt; modelIDs;

    if (this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToAll)
    {
        for (uint i=0;i&lt;Session::getInstance().getNModels();i++)
        {
            modelIDs.push_back(i);
        }
    }
    else if (this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToSelected)
    {
        modelIDs = Session::getInstance().getSelectedModelIDs();
    }
    else if (this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToPicked)
    {
        modelIDs = Session::getInstance().getPickList().getModelIDs();
    }
    else if (this-&gt;input.getApplyTo() == GeometryTransformInput::ApplyToVisible)
    {
        modelIDs = Session::getInstance().getVisibleModelIDs();
    }

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        ModelActionInput modelActionInput(modelIDs.at(i));
        modelActionInput.setGeometryTransform(this-&gt;input);
        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }

    emit this-&gt;finalize();
}
</t>
<t tx="leo.20201108101520.78">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   geometry_translate_widget.cpp                            *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th November 2014                                       *
 *                                                                   *
 *  DESCRIPTION: Geometry translate widget class definition          *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QGroupBox&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "geometry_translate_widget.h"
#include "session.h"

const RR3Vector GeometryTranslateWidget::defaultTranslation = RR3Vector(0.0,0.0,0.0);

GeometryTranslateWidget::GeometryTranslateWidget(const RR3Vector &amp;translation, QWidget *parent) :
    QWidget(parent)
{
    QVBoxLayout *vBoxLayout = new QVBoxLayout;
    this-&gt;setLayout(vBoxLayout);

    QGroupBox *groupBox = new QGroupBox(tr("Distance"));
    vBoxLayout-&gt;addWidget(groupBox);

    QGridLayout *layout = new QGridLayout;
    groupBox-&gt;setLayout(layout);

    QLabel *xDistanceLabel = new QLabel("X:");
    layout-&gt;addWidget(xDistanceLabel,0,0,1,1);

    this-&gt;xDistanceLineEdit = new ValueLineEdit;
    this-&gt;xDistanceLineEdit-&gt;setDoubleValidator();
    this-&gt;xDistanceLineEdit-&gt;setValue(translation[0]);
    layout-&gt;addWidget(this-&gt;xDistanceLineEdit,0,1,1,1);

    QLabel *xDistanceUnit = new QLabel("[m]");
    layout-&gt;addWidget(xDistanceUnit,0,2,1,1);

    QLabel *yDistanceLabel = new QLabel("Y:");
    layout-&gt;addWidget(yDistanceLabel,1,0,1,1);

    this-&gt;yDistanceLineEdit = new ValueLineEdit;
    this-&gt;yDistanceLineEdit-&gt;setDoubleValidator();
    this-&gt;yDistanceLineEdit-&gt;setValue(translation[1]);
    layout-&gt;addWidget(this-&gt;yDistanceLineEdit,1,1,1,1);

    QLabel *yDistanceUnit = new QLabel("[m]");
    layout-&gt;addWidget(yDistanceUnit,1,2,1,1);

    QLabel *zDistanceLabel = new QLabel("Z:");
    layout-&gt;addWidget(zDistanceLabel,2,0,1,1);

    this-&gt;zDistanceLineEdit = new ValueLineEdit;
    this-&gt;zDistanceLineEdit-&gt;setDoubleValidator();
    this-&gt;zDistanceLineEdit-&gt;setValue(translation[2]);
    layout-&gt;addWidget(this-&gt;zDistanceLineEdit,2,1,1,1);

    QLabel *zDistanceUnit = new QLabel("[m]");
    layout-&gt;addWidget(zDistanceUnit,2,2,1,1);

    QPushButton *originButton = new QPushButton(QIcon(":/icons/file/pixmaps/range-undo.svg"),tr("Origin"));
    layout-&gt;addWidget(originButton,3,0,1,3);

    QObject::connect(originButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;GeometryTranslateWidget::setOrigin);

    QPushButton *centerButton = new QPushButton(QIcon(":/icons/file/pixmaps/range-undo.svg"),tr("Center"));
    layout-&gt;addWidget(centerButton,4,0,1,3);

    QObject::connect(centerButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;GeometryTranslateWidget::setCenter);

    QPushButton *resetButton = new QPushButton(QIcon(":/icons/file/pixmaps/range-undo.svg"),tr("Reset"));
    layout-&gt;addWidget(resetButton,5,0,1,3);

    QObject::connect(resetButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;GeometryTranslateWidget::resetDistances);

    this-&gt;resetDistances();

    QObject::connect(this-&gt;xDistanceLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;GeometryTranslateWidget::onDistanceValueChanged);
    QObject::connect(this-&gt;yDistanceLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;GeometryTranslateWidget::onDistanceValueChanged);
    QObject::connect(this-&gt;zDistanceLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;GeometryTranslateWidget::onDistanceValueChanged);

    vBoxLayout-&gt;addStretch(10);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.79">void GeometryTranslateWidget::setOrigin(void)
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();
    double x = 0.0, y = 0.0, z = 0.0;
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        double xmin, xmax, ymin, ymax, zmin, zmax;
        Session::getInstance().getModel(selectedModelIDs[i]).findNodeLimits(xmin,xmax,ymin,ymax,zmin,zmax);
        if (i == 0)
        {
            x = xmin;
            y = ymin;
            z = zmin;
        }
        x = std::min(x,xmin);
        y = std::min(y,ymin);
        z = std::min(z,zmin);
    }
    this-&gt;xDistanceLineEdit-&gt;setValue(-x);
    this-&gt;yDistanceLineEdit-&gt;setValue(-y);
    this-&gt;zDistanceLineEdit-&gt;setValue(-z);
}

</t>
<t tx="leo.20201108101520.8">void ECTree::populate(void)
{
    this-&gt;clear();

    for (uint i=0;i&lt;this-&gt;ec.size();i++)
    {
        RConditionComponent component = this-&gt;ec.getComponent(i);

        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setData(EC_TREE_PROPERTY_TYPE,Qt::DisplayRole,QVariant(component.getType()));
        item-&gt;setText(EC_TREE_PROPERTY_NAME,component.getName());
        item-&gt;setText(EC_TREE_PROPERTY_UNITS,component.getUnits());
        VariableValueEdit *lineEdit = new VariableValueEdit(component.getType());
        lineEdit-&gt;setValue(component.getValue(0));
        this-&gt;setItemWidget(item,EC_TREE_PROPERTY_VALUE,lineEdit);

        QObject::connect(lineEdit,&amp;VariableValueEdit::valueChanged,this,&amp;ECTree::onEcValueChanged);
    }

    this-&gt;resizeColumnToContents(EC_TREE_PROPERTY_NAME);
    this-&gt;resizeColumnToContents(EC_TREE_PROPERTY_VALUE);
    this-&gt;resizeColumnToContents(EC_TREE_PROPERTY_UNITS);
}

</t>
<t tx="leo.20201108101520.80">void GeometryTranslateWidget::setCenter(void)
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();
    double x = 0.0, y = 0.0, z = 0.0;
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        double xc, yc, zc;
        Session::getInstance().getModel(selectedModelIDs[i]).findNodeCenter(xc,yc,zc);
        x += xc;
        y += yc;
        z += zc;
    }
    if (selectedModelIDs.size())
    {
        x /= double(selectedModelIDs.size());
        y /= double(selectedModelIDs.size());
        z /= double(selectedModelIDs.size());
    }
    this-&gt;xDistanceLineEdit-&gt;setValue(-x);
    this-&gt;yDistanceLineEdit-&gt;setValue(-y);
    this-&gt;zDistanceLineEdit-&gt;setValue(-z);
}

</t>
<t tx="leo.20201108101520.81">void GeometryTranslateWidget::resetDistances(void)
{
    this-&gt;xDistanceLineEdit-&gt;setValue(this-&gt;defaultTranslation[0]);
    this-&gt;yDistanceLineEdit-&gt;setValue(this-&gt;defaultTranslation[1]);
    this-&gt;zDistanceLineEdit-&gt;setValue(this-&gt;defaultTranslation[2]);
}

</t>
<t tx="leo.20201108101520.82">void GeometryTranslateWidget::onDistanceValueChanged(double)
{
    emit this-&gt;translationChanged(RR3Vector(this-&gt;xDistanceLineEdit-&gt;getValue(),
                                            this-&gt;yDistanceLineEdit-&gt;getValue(),
                                            this-&gt;zDistanceLineEdit-&gt;getValue()));
}
</t>
<t tx="leo.20201108101520.83">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_acion_event.cpp                                       *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   21-st February 2012                                      *
 *                                                                   *
 *  DESCRIPTION: OpenGL acion event class definition                 *
 *********************************************************************/

#include &lt;QGuiApplication&gt;

#include "gl_acion_event.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.84">typedef struct _GLActionCombination
{
    //! Key modifier.
    Qt::KeyboardModifiers keyModifiers;
    //! Key.
    int key;
    //! Mouse buttons flag.
    Qt::MouseButtons buttons;
    //! Wheel scroll phase.
    Qt::ScrollPhase scrollPhase;
    //! OpenGL action event type.
    GLActionEventType eventType;
} GLActionCombination;

</t>
<t tx="leo.20201108101520.85">static std::vector&lt;GLActionCombination&gt; glActionCombinations =
{
    { Qt::NoModifier,                          0, Qt::NoButton,                     Qt::NoScrollPhase, GL_ACTION_EVENT_NONE              },
    { Qt::NoModifier,                          0, Qt::LeftButton,                   Qt::NoScrollPhase, GL_ACTION_EVENT_TRANSLATE         },
    { Qt::ControlModifier,                     0, Qt::MiddleButton,                 Qt::NoScrollPhase, GL_ACTION_EVENT_TRANSLATE_Z       },
    { Qt::ControlModifier,                     0, Qt::LeftButton | Qt::RightButton, Qt::NoScrollPhase, GL_ACTION_EVENT_TRANSLATE_Z       },
    { Qt::ControlModifier,                     0, Qt::NoButton,                     Qt::ScrollUpdate,  GL_ACTION_EVENT_TRANSLATE_Z       },
    { Qt::NoModifier,                          0, Qt::MiddleButton,                 Qt::NoScrollPhase, GL_ACTION_EVENT_ROTATE            },
    { Qt::NoModifier,                          0, Qt::LeftButton | Qt::RightButton, Qt::NoScrollPhase, GL_ACTION_EVENT_ROTATE            },
    { Qt::NoModifier,                          0, Qt::RightButton,                  Qt::NoScrollPhase, GL_ACTION_EVENT_ZOOM              },
    { Qt::NoModifier,                          0, Qt::NoButton,                     Qt::ScrollUpdate,  GL_ACTION_EVENT_ZOOM              },
    { Qt::ControlModifier,                     0, Qt::LeftButton,                   Qt::NoScrollPhase, GL_ACTION_EVENT_PICK_ELEMENT      },
    { Qt::ControlModifier | Qt::AltModifier,   0, Qt::LeftButton,                   Qt::NoScrollPhase, GL_ACTION_EVENT_PICK_NODE         },
    { Qt::ControlModifier | Qt::ShiftModifier, 0, Qt::LeftButton,                   Qt::NoScrollPhase, GL_ACTION_EVENT_PICK_HOLE_ELEMENT },
    { Qt::ControlModifier,                     0, Qt::RightButton,                  Qt::NoScrollPhase, GL_ACTION_EVENT_PICK_CLEAR        }
};

GLActionEvent::GLActionEvent(QObject *parent)
    : QObject(parent)
    , keyModifiers(Qt::NoModifier)
    , key(0)
    , buttons(Qt::NoButton)
    , scrollPhase(Qt::NoScrollPhase)
    , actionChanged(false)
{
}

GLActionEventType GLActionEvent::getType(void) const
{
    for (auto &amp;glActionCombination : glActionCombinations)
    {
        if (this-&gt;buttons      == glActionCombination.buttons &amp;&amp;
            this-&gt;keyModifiers == glActionCombination.keyModifiers &amp;&amp;
            this-&gt;scrollPhase  == glActionCombination.scrollPhase)
        {
            return glActionCombination.eventType;
        }
    }

    return GL_ACTION_EVENT_NONE;
}

</t>
<t tx="leo.20201108101520.86">bool GLActionEvent::getChanged(void) const
{
    return actionChanged;
}

</t>
<t tx="leo.20201108101520.87">void GLActionEvent::setKeyEvent(QKeyEvent *keyEvent, bool release)
{
    GLActionEventType prevType = this-&gt;getType();
    this-&gt;key = release ? 0 : keyEvent-&gt;key();
    this-&gt;keyModifiers = QGuiApplication::queryKeyboardModifiers();
    GLActionEventType currType = this-&gt;getType();
    this-&gt;actionChanged = (prevType != currType);
    emit this-&gt;changed(currType);
}

</t>
<t tx="leo.20201108101520.88">void GLActionEvent::setMouseEvent(QMouseEvent *mouseEvent, bool release)
{
    GLActionEventType prevType = this-&gt;getType();
    this-&gt;buttons = release ? Qt::NoButton : mouseEvent-&gt;buttons();
    GLActionEventType currType = this-&gt;getType();
    this-&gt;actionChanged = (prevType != currType);
    emit this-&gt;changed(currType);
}

</t>
<t tx="leo.20201108101520.89">void GLActionEvent::setScrollPhase(Qt::ScrollPhase srcollPhase)
{
    GLActionEventType prevType = this-&gt;getType();
    this-&gt;scrollPhase = srcollPhase;
    GLActionEventType currType = this-&gt;getType();
    this-&gt;actionChanged = (prevType != currType);
    emit this-&gt;changed(currType);
}

</t>
<t tx="leo.20201108101520.9">void ECTree::updateSelectedEntities(void) const
{
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        switch (entityIDs[i].getType())
        {
            case R_ENTITY_GROUP_POINT:
                Session::getInstance().getModel(entityIDs[i].getMid()).getPoint(entityIDs[i].getEid()).addEnvironmentCondition(this-&gt;ec);
                break;
            case R_ENTITY_GROUP_LINE:
                Session::getInstance().getModel(entityIDs[i].getMid()).getLine(entityIDs[i].getEid()).addEnvironmentCondition(this-&gt;ec);
                break;
            case R_ENTITY_GROUP_SURFACE:
                Session::getInstance().getModel(entityIDs[i].getMid()).getSurface(entityIDs[i].getEid()).addEnvironmentCondition(this-&gt;ec);
                break;
            case R_ENTITY_GROUP_VOLUME:
                Session::getInstance().getModel(entityIDs[i].getMid()).getVolume(entityIDs[i].getEid()).addEnvironmentCondition(this-&gt;ec);
                break;
            default:
                break;
        }
        Session::getInstance().setEnvironmentConditionChanged(entityIDs[i].getMid(),
                                                           entityIDs[i].getType(),
                                                           entityIDs[i].getEid());
    }

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
}

</t>
<t tx="leo.20201108101520.90">void GLActionEvent::clear(void)
{
    GLActionEventType prevType = this-&gt;getType();
    this-&gt;buttons = Qt::NoButton;
    this-&gt;keyModifiers = Qt::NoModifier;
    this-&gt;key = 0;
    this-&gt;scrollPhase = Qt::NoScrollPhase;
    GLActionEventType currType = this-&gt;getType();
    this-&gt;actionChanged = (prevType != currType);
    emit this-&gt;changed(currType);
}

QString GLActionEvent::getKeyMouseCombination(void) const
{
    int _key = this-&gt;key;
    if (_key == Qt::Key_Alt     ||
        _key == Qt::Key_AltGr   ||
        _key == Qt::Key_Control ||
        _key == Qt::Key_Shift   ||
        _key == Qt::Key_Meta)
    {
        _key = 0;
    }
    QString keyString(QKeySequence(int(this-&gt;keyModifiers)+_key).toString(QKeySequence::NativeText));
    QString mouseButtonString;

    if (this-&gt;buttons &amp; Qt::LeftButton)
    {
        mouseButtonString = (mouseButtonString.length() &gt; 0 ? " + " : "") + tr("Left mouse button");
    }
    if (this-&gt;buttons &amp; Qt::MiddleButton)
    {
        mouseButtonString = (mouseButtonString.length() &gt; 0 ? " + " : "") + tr("Middle mouse button");
    }
    if (this-&gt;buttons &amp; Qt::RightButton)
    {
        mouseButtonString = (mouseButtonString.length() &gt; 0 ? " + " : "") + tr("Right mouse button");
    }

    return keyString + mouseButtonString;
}

QString GLActionEvent::findKeyMouseCombination(GLActionEventType type)
{
    for (auto &amp;glActionCombination : glActionCombinations)
    {
        if (glActionCombination.eventType == type)
        {
            QString keyString(QKeySequence(int(glActionCombination.keyModifiers) + glActionCombination.key).toString(QKeySequence::NativeText));

            QString mouseButtonString;

            if (glActionCombination.buttons &amp; Qt::LeftButton)
            {
                mouseButtonString = (mouseButtonString.length() &gt; 0 ? " + " : "") + tr("Left mouse button");
            }
            if (glActionCombination.buttons &amp; Qt::MiddleButton)
            {
                mouseButtonString = (mouseButtonString.length() &gt; 0 ? " + " : "") + tr("Middle mouse button");
            }
            if (glActionCombination.buttons &amp; Qt::RightButton)
            {
                mouseButtonString = (mouseButtonString.length() &gt; 0 ? " + " : "") + tr("Right mouse button");
            }

            return keyString + mouseButtonString;
        }
    }
    return QString();
}

QString GLActionEvent::toString(GLActionEventType type)
{
    switch (type)
    {
        case GL_ACTION_EVENT_NONE:
            return QString();
        case GL_ACTION_EVENT_TRANSLATE:
            return tr("Translate");
        case GL_ACTION_EVENT_TRANSLATE_Z:
            return tr("Translate in Z direction");
        case GL_ACTION_EVENT_ROTATE:
            return tr("Rotate");
        case GL_ACTION_EVENT_ZOOM:
            return tr("Zoom");
        case GL_ACTION_EVENT_PICK_ELEMENT:
            return tr("Pick element");
        case GL_ACTION_EVENT_PICK_NODE:
            return tr("Pick node");
        case GL_ACTION_EVENT_PICK_HOLE_ELEMENT:
            return tr("Pick hole element");
        case GL_ACTION_EVENT_PICK_CLEAR:
            return tr("Clear pick information");
        default:
            return QString();
    }
}
</t>
<t tx="leo.20201108101520.91">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_arrow.cpp                                             *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   30-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: OpenGL arrow class definition                       *
 *********************************************************************/

#include "gl_arrow.h"
#include "gl_line.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.92">void GLArrow::_init(const GLArrow *pGlArrow)
{
    if (pGlArrow)
    {
        this-&gt;position = pGlArrow-&gt;position;
        this-&gt;direction = pGlArrow-&gt;direction;
        this-&gt;showHead = pGlArrow-&gt;showHead;
        this-&gt;drawFrom = pGlArrow-&gt;drawFrom;
        this-&gt;scale = pGlArrow-&gt;scale;
    }
}

GLArrow::GLArrow(GLWidget *glWidget, const RR3Vector &amp;position, const RR3Vector &amp;direction, bool showHead, bool drawFrom, double scale)
    : GLObject(glWidget)
    , position(position)
    , direction(direction)
    , showHead(showHead)
    , drawFrom(drawFrom)
    , scale(scale)
{
    this-&gt;_init();
}

GLArrow::GLArrow(const GLArrow &amp;glArrow)
    : GLObject(glArrow)
{
    this-&gt;_init(&amp;glArrow);
}

GLArrow &amp;GLArrow::operator =(const GLArrow &amp;glArrow)
{
    this-&gt;GLObject::operator =(glArrow);
    this-&gt;_init(&amp;glArrow);
    return (*this);
}

</t>
<t tx="leo.20201108101520.93">void GLArrow::initialize(void)
{
    // Save current settings
    GL_SAFE_CALL(glGetBooleanv(GL_NORMALIZE, &amp;this-&gt;normalizeEnabled));
    GL_SAFE_CALL(glGetFloatv(GL_LINE_WIDTH, &amp;this-&gt;lineWidth));
    GL_SAFE_CALL(glGetBooleanv(GL_CULL_FACE, &amp;this-&gt;cullFaceEnabled));
    // Initialize environment
    GL_SAFE_CALL(glEnable(GL_NORMALIZE));
    GL_SAFE_CALL(glDisable(GL_CULL_FACE));
    GL_SAFE_CALL(glLineWidth(1.0f));
}

</t>
<t tx="leo.20201108101520.94">void GLArrow::finalize(void)
{
    this-&gt;normalizeEnabled ? glEnable(GL_NORMALIZE) :glDisable(GL_NORMALIZE);
    this-&gt;cullFaceEnabled ? glEnable(GL_CULL_FACE) : glDisable(GL_CULL_FACE);
    GL_SAFE_CALL(glLineWidth(this-&gt;lineWidth));
}

</t>
<t tx="leo.20201108101520.95">void GLArrow::draw(void)
{
    this-&gt;showHead ? this-&gt;drawHead() : this-&gt;drawShaft();
}

</t>
<t tx="leo.20201108101520.96">void GLArrow::drawShaft(void) const
{
    double dirScalar = this-&gt;drawFrom ? 1.0 : -1.0;

    GLLine line(this-&gt;getGLWidget(),
                this-&gt;position,
                RR3Vector(this-&gt;position[0] + this-&gt;direction[0] * dirScalar,
                          this-&gt;position[1] + this-&gt;direction[1] * dirScalar,
                          this-&gt;position[2] + this-&gt;direction[2] * dirScalar),
                1.0);
    line.paint();
}

</t>
<t tx="leo.20201108101520.97">void GLArrow::drawHead(void)
{
    RR3Vector v1;
    RR3Vector v2;

    if (this-&gt;drawFrom)
    {
        v1 = this-&gt;position;
        v2[0] = this-&gt;position[0] + this-&gt;direction[0];
        v2[1] = this-&gt;position[1] + this-&gt;direction[1];
        v2[2] = this-&gt;position[2] + this-&gt;direction[2];
    }
    else
    {
        v1[0] = this-&gt;position[0] - this-&gt;direction[0];
        v1[1] = this-&gt;position[1] - this-&gt;direction[1];
        v1[2] = this-&gt;position[2] - this-&gt;direction[2];
        v2 = this-&gt;position;
    }

    RModelRaw raw = RShapeGenerator::generateArrow(v1,v2,this-&gt;scale);
    for (uint i=0;i&lt;raw.getNElements();i++)
    {
        const RElement &amp;rElement = raw.getElement(i);
        if (RElementGroup::getGroupType(rElement.getType()) == R_ENTITY_GROUP_LINE)
        {
            GLboolean lightingEnabled;
            GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));
            GL_SAFE_CALL(glDisable(GL_LIGHTING));

            GLFunctions::begin(GL_LINES);
            GL_SAFE_CALL(glVertex3d(raw.getNode(rElement.getNodeId(0)).getX(),
                                    raw.getNode(rElement.getNodeId(0)).getY(),
                                    raw.getNode(rElement.getNodeId(0)).getZ()));
            GL_SAFE_CALL(glVertex3d(raw.getNode(rElement.getNodeId(1)).getX(),
                                    raw.getNode(rElement.getNodeId(1)).getY(),
                                    raw.getNode(rElement.getNodeId(1)).getZ()));
            GLFunctions::end();

            if (lightingEnabled)
            {
                GL_SAFE_CALL(glEnable(GL_LIGHTING));
            }
        }
        if (RElementGroup::getGroupType(rElement.getType()) == R_ENTITY_GROUP_SURFACE)
        {
            RTriangle triangle(raw.getNode(rElement.getNodeId(0)),
                               raw.getNode(rElement.getNodeId(1)),
                               raw.getNode(rElement.getNodeId(2)));
            GL_SAFE_CALL(glNormal3d(triangle.getNormal()[0],triangle.getNormal()[1],triangle.getNormal()[2]));
            GLFunctions::begin(GL_TRIANGLES);
            GL_SAFE_CALL(glVertex3d(raw.getNode(rElement.getNodeId(0)).getX(),
                                    raw.getNode(rElement.getNodeId(0)).getY(),
                                    raw.getNode(rElement.getNodeId(0)).getZ()));
            GL_SAFE_CALL(glVertex3d(raw.getNode(rElement.getNodeId(1)).getX(),
                                    raw.getNode(rElement.getNodeId(1)).getY(),
                                    raw.getNode(rElement.getNodeId(1)).getZ()));
            GL_SAFE_CALL(glVertex3d(raw.getNode(rElement.getNodeId(2)).getX(),
                                    raw.getNode(rElement.getNodeId(2)).getY(),
                                    raw.getNode(rElement.getNodeId(2)).getZ()));
            GLFunctions::end();
        }
    }
}
</t>
<t tx="leo.20201108101520.98">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_axis.cpp                                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   23-rd February 2012                                      *
 *                                                                   *
 *  DESCRIPTION: OpenGL axis class definition                        *
 *********************************************************************/

#include "gl_axis.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101520.99">void GLAxis::_init(const GLAxis *pGlAxis)
{
    if (pGlAxis)
    {
        this-&gt;type = pGlAxis-&gt;type;
        this-&gt;size = pGlAxis-&gt;size;
        this-&gt;name = pGlAxis-&gt;name;
    }
}

GLAxis::GLAxis(GLWidget *glWidget, GLAxisType type, const QString &amp;name)
    : GLObject(glWidget)
    , type(type)
    , size(1.0)
    , name(name)
{
    this-&gt;_init();
}

GLAxis::GLAxis(const GLAxis &amp;glAxis) : GLObject(glAxis)
{
    this-&gt;_init(&amp;glAxis);
}

GLAxis::~GLAxis()
{
}

GLAxis &amp; GLAxis::operator =(const GLAxis &amp;glAxis)
{
    this-&gt;GLObject::operator =(glAxis);
    this-&gt;_init(&amp;glAxis);
    return (*this);
}

GLAxisType GLAxis::getType(void) const
{
    return this-&gt;type;
}

</t>
<t tx="leo.20201108101521.1">void GLDisplayPropertiesDialog::onShowModelEdgesClicked(bool checked)
{
    this-&gt;pGlWidget-&gt;getGLDisplayProperties().setShowModelEdges(checked);
    this-&gt;pGlWidget-&gt;update();
}

</t>
<t tx="leo.20201108101521.10">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_element.cpp                                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   2-nd March 2012                                          *
 *                                                                   *
 *  DESCRIPTION: OpenGL element class definition                     *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "gl_element.h"
#include "gl_texture.h"
#include "gl_simplex_point.h"
#include "gl_simplex_segment.h"
#include "gl_simplex_polygon.h"
#include "gl_simplex_tetrahedra.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.100">void GLModelList::setNGlStreamLineLists(uint nGlEntityLists)
{
    if (this-&gt;glStreamLineList.size() != int(nGlEntityLists))
    {
        this-&gt;glStreamLineList.clear();
        this-&gt;glStreamLineList.resize(GLsizei(nGlEntityLists));
    }
}

</t>
<t tx="leo.20201108101521.101">const GLEntityList &amp;GLModelList::getGlStreamLineList(uint entityID) const
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlStreamLineLists());
    return this-&gt;glStreamLineList[int(entityID)];
}

GLEntityList &amp;GLModelList::getGlStreamLineList(uint entityID)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlStreamLineLists());
    return this-&gt;glStreamLineList[int(entityID)];
}

</t>
<t tx="leo.20201108101521.102">void GLModelList::setGlStreamLineList(uint entityID, const GLEntityList &amp;glEntityList)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlStreamLineLists());
    this-&gt;glStreamLineList[int(entityID)] = glEntityList;
}

uint GLModelList::getNGlCutLists(void) const
{
    return uint(this-&gt;glCutList.size());
}

</t>
<t tx="leo.20201108101521.103">void GLModelList::setNGlCutLists(uint nGlEntityLists)
{
    if (this-&gt;glCutList.size() != int(nGlEntityLists))
    {
        this-&gt;glCutList.clear();
        this-&gt;glCutList.resize(GLsizei(nGlEntityLists));
    }
}

</t>
<t tx="leo.20201108101521.104">const GLEntityList &amp;GLModelList::getGlCutList(uint entityID) const
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlCutLists());
    return this-&gt;glCutList[int(entityID)];
}

GLEntityList &amp;GLModelList::getGlCutList(uint entityID)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlCutLists());
    return this-&gt;glCutList[int(entityID)];
}

</t>
<t tx="leo.20201108101521.105">void GLModelList::setGlCutList(uint entityID, const GLEntityList &amp;glEntityList)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlCutLists());
    this-&gt;glCutList[int(entityID)] = glEntityList;
}

uint GLModelList::getNGlIsoLists(void) const
{
    return this-&gt;glIsoList.size();
}

</t>
<t tx="leo.20201108101521.106">void GLModelList::setNGlIsoLists(uint nGlEntityLists)
{
    if (this-&gt;glIsoList.size() != int(nGlEntityLists))
    {
        this-&gt;glIsoList.clear();
        this-&gt;glIsoList.resize(GLsizei(nGlEntityLists));
    }
}

</t>
<t tx="leo.20201108101521.107">const GLEntityList &amp;GLModelList::getGlIsoList(uint entityID) const
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlIsoLists());
    return this-&gt;glIsoList[int(entityID)];
}

GLEntityList &amp;GLModelList::getGlIsoList(uint entityID)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlIsoLists());
    return this-&gt;glIsoList[int(entityID)];
}

</t>
<t tx="leo.20201108101521.108">void GLModelList::setGlIsoList(uint entityID, const GLEntityList &amp;glEntityList)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlIsoLists());
    this-&gt;glIsoList[int(entityID)] = glEntityList;
}
</t>
<t tx="leo.20201108101521.109">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_node.cpp                                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   2-nd March 2012                                          *
 *                                                                   *
 *  DESCRIPTION: OpenGL node class definition                        *
 *********************************************************************/

#include "gl_node.h"

GLNode::GLNode(GLWidget *glWidget) : GLObject(glWidget)
{
    this-&gt;_init();
}

GLNode::GLNode(const GLNode &amp;glNode)
    : GLObject(glNode)
    , RNode(glNode)
{
    this-&gt;_init(&amp;glNode);
}

GLNode::~GLNode()
{
}

GLNode &amp;GLNode::operator =(const GLNode &amp;glNode)
{
    this-&gt;GLObject::operator =(glNode);
    this-&gt;RNode::operator =(glNode);
    this-&gt;_init(&amp;glNode);
    return (*this);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.11">void GLElement::_init(const GLElement *pGlElement)
{
    if (pGlElement)
    {
        this-&gt;pointVolume = pGlElement-&gt;pointVolume;
        this-&gt;lineCrossArea = pGlElement-&gt;lineCrossArea;
        this-&gt;surfaceThickness = pGlElement-&gt;surfaceThickness;
    }
}

GLElement::GLElement(GLWidget *glWidget, const Model *pModel, uint elementID, const REntityGroupData &amp;elementGroupData, const QColor &amp;color, GLElementDrawMode drawMode)
    : GLElementBase(glWidget,pModel,elementID,elementGroupData,color,drawMode)
    , RElement(pModel-&gt;getElement(elementID))
    , pointVolume(0.0)
    , lineCrossArea(0.0)
    , surfaceThickness(0.0)
{
    this-&gt;_init();
}

GLElement::GLElement(const GLElement &amp;glElement)
    : GLElementBase(glElement)
    , RElement(glElement)
{
    this-&gt;_init(&amp;glElement);
}

GLElement::~GLElement()
{
}

GLElement &amp;GLElement::operator =(const GLElement &amp;glElement)
{
    this-&gt;GLElementBase::operator =(glElement);
    this-&gt;RElement::operator =(glElement);
    this-&gt;_init(&amp;glElement);
    return (*this);
}

</t>
<t tx="leo.20201108101521.110">void GLNode::_init(const GLNode *pGlNode)
{
    if (pGlNode)
    {

    }
}

</t>
<t tx="leo.20201108101521.111">void GLNode::initialize(void)
{
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    GL_SAFE_CALL(glGetFloatv(GL_POINT_SIZE, &amp;this-&gt;pointSize));

    GL_SAFE_CALL(glDisable(GL_LIGHTING));
    GL_SAFE_CALL(glPointSize(10.0f));
}

</t>
<t tx="leo.20201108101521.112">void GLNode::finalize(void)
{
    if (this-&gt;lightingEnabled)
    {
        GL_SAFE_CALL(glEnable(GL_LIGHTING));
    }
    GL_SAFE_CALL(glPointSize(this-&gt;pointSize));
}

</t>
<t tx="leo.20201108101521.113">void GLNode::draw(void)
{
    GLFunctions::begin(GL_POINTS);
    GL_SAFE_CALL(glVertex3d(this-&gt;getX(),this-&gt;getY(),this-&gt;getZ()));
    GLFunctions::end();
}
</t>
<t tx="leo.20201108101521.114">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_object.cpp                                            *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   23-rd February 2012                                      *
 *                                                                   *
 *  DESCRIPTION: OpenGL object class definition                      *
 *********************************************************************/

#include "gl_object.h"

GLObject::GLObject(GLWidget *glWidget) :
    pParentModel(nullptr),
    glWidget(glWidget),
    applyEnvSettings(true),
    useGlList(true),
    useGlCullFace(true)
{
    this-&gt;_init();
}

GLObject::GLObject(const GLObject &amp;glObject)
{
    this-&gt;_init(&amp;glObject);
}

GLObject::~GLObject()
{
}

GLObject &amp; GLObject::operator =(const GLObject &amp;glObject)
{
    this-&gt;_init(&amp;glObject);
    return (*this);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.115">void GLObject::_init(const GLObject *pGlObject)
{
    if (pGlObject)
    {
        this-&gt;pParentModel = pGlObject-&gt;pParentModel;
        this-&gt;glWidget = pGlObject-&gt;getGLWidget();
        this-&gt;applyEnvSettings = pGlObject-&gt;applyEnvSettings;
        this-&gt;useGlList = pGlObject-&gt;useGlList;
        this-&gt;useGlCullFace = pGlObject-&gt;useGlCullFace;
    }
}

GLWidget *GLObject::getGLWidget(void) const
{
    return this-&gt;glWidget;
}

</t>
<t tx="leo.20201108101521.116">void GLObject::setParentModel(const Model *pParentModel)
{
    this-&gt;pParentModel = pParentModel;
}

</t>
<t tx="leo.20201108101521.117">bool GLObject::getApplyEnvironmentSettings() const
{
    return this-&gt;applyEnvSettings;
}

</t>
<t tx="leo.20201108101521.118">void GLObject::setApplyEnvironmentSettings(bool applyEnvSettings)
{
    this-&gt;applyEnvSettings = applyEnvSettings;
}

</t>
<t tx="leo.20201108101521.119">bool GLObject::getUseGlList(void) const
{
    return this-&gt;useGlList;
}

</t>
<t tx="leo.20201108101521.12">void GLElement::setPointVolume(double pointVolume)
{
    this-&gt;pointVolume = pointVolume;
}

</t>
<t tx="leo.20201108101521.120">void GLObject::setUseGlList(bool useGlList)
{
    this-&gt;useGlList = useGlList;
}

</t>
<t tx="leo.20201108101521.121">bool GLObject::getUseGlCullFace(void) const
{
    return this-&gt;useGlCullFace;
}

</t>
<t tx="leo.20201108101521.122">void GLObject::setUseGlCullFace(bool useGlCullFace)
{
    this-&gt;useGlCullFace = useGlCullFace;
}

</t>
<t tx="leo.20201108101521.123">void GLObject::paint(PaintActionMask paintActionMask)
{
    if (paintActionMask &amp; GLObject::Initialize)
    {
        this-&gt;initialize();
    }
    if (paintActionMask &amp; GLObject::Draw)
    {
        this-&gt;draw();
    }
    if (paintActionMask &amp; GLObject::Finalize)
    {
        this-&gt;finalize();
    }
}

</t>
<t tx="leo.20201108101521.124">void GLObject::glNormalVector(const RR3Vector &amp;vector)
{
    GL_SAFE_CALL(glNormal3d(vector[0],vector[1],vector[2]));
}

</t>
<t tx="leo.20201108101521.125">void GLObject::glVertexVector(const RR3Vector &amp;vector)
{
    GL_SAFE_CALL(glVertex3d(vector[0],vector[1],vector[2]));
}

</t>
<t tx="leo.20201108101521.126">void GLObject::glVertexNode(const RNode &amp;node)
{
    GL_SAFE_CALL(glVertex3d(node.getX(),node.getY(),node.getZ()));
}

</t>
<t tx="leo.20201108101521.127">void GLObject::initialize(void)
{
}

</t>
<t tx="leo.20201108101521.128">void GLObject::finalize(void)
{
}

</t>
<t tx="leo.20201108101521.129">void GLObject::draw(void)
{
}
</t>
<t tx="leo.20201108101521.13">void GLElement::setLineCrossArea(double lineCrossArea)
{
    this-&gt;lineCrossArea = lineCrossArea;
}

</t>
<t tx="leo.20201108101521.130">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_point.cpp                                             *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   18-th February 2014                                      *
 *                                                                   *
 *  DESCRIPTION: OpenGL point class definition                       *
 *********************************************************************/

#include "gl_point.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.131">void GLPoint::_init(const GLPoint *pGlPoint)
{
    if (pGlPoint)
    {
        this-&gt;position = pGlPoint-&gt;position;
        this-&gt;pointSize = pGlPoint-&gt;pointSize;
    }
}

GLPoint::GLPoint(GLWidget *glWidget, const RR3Vector &amp;position, float pointSize)
    : GLObject(glWidget)
    , position(position)
    , pointSize(pointSize)
{
    this-&gt;_init();
}

GLPoint::GLPoint(const GLPoint &amp;glPoint)
    : GLObject(glPoint)
{
    this-&gt;_init(&amp;glPoint);
}

GLPoint::~GLPoint()
{
}

GLPoint &amp;GLPoint::operator =(const GLPoint &amp;glPoint)
{
    this-&gt;GLObject::operator =(glPoint);
    this-&gt;_init(&amp;glPoint);
    return (*this);
}

</t>
<t tx="leo.20201108101521.132">void GLPoint::initialize(void)
{
    // Save current settings
    GL_SAFE_CALL(glGetFloatv(GL_POINT_SIZE, &amp;this-&gt;prevPointSize));
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    // Initialize environment
    GL_SAFE_CALL(glPointSize(this-&gt;pointSize));
    GL_SAFE_CALL(glDisable(GL_LIGHTING));
}

</t>
<t tx="leo.20201108101521.133">void GLPoint::finalize(void)
{
    GL_SAFE_CALL(glPointSize(this-&gt;prevPointSize));

    if (this-&gt;lightingEnabled)
    {
        GL_SAFE_CALL(glEnable(GL_LIGHTING));
    }
    else
    {
        GL_SAFE_CALL(glDisable(GL_LIGHTING));
    }
}

</t>
<t tx="leo.20201108101521.134">void GLPoint::draw(void)
{
    GLFunctions::begin(GL_POINTS);
    GL_SAFE_CALL(glVertex3d(this-&gt;position[0],this-&gt;position[1],this-&gt;position[2]));
    GLFunctions::end();
}
</t>
<t tx="leo.20201108101521.135">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_rotation_sphere.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   29-th June 2017                                          *
 *                                                                   *
 *  DESCRIPTION: OpenGL rotation sphere class definition             *
 *********************************************************************/

#include "gl_rotation_sphere.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.136">void GLRotationSphere::_init(const GLRotationSphere *pGlRotationSphere)
{
    if (pGlRotationSphere)
    {
        this-&gt;position = pGlRotationSphere-&gt;position;
        this-&gt;scale = pGlRotationSphere-&gt;scale;
    }
}

GLRotationSphere::GLRotationSphere(GLWidget *glWidget, const RR3Vector &amp;position, double scale)
    : GLObject(glWidget)
    , position(position)
    , scale(scale)
{
    this-&gt;_init();
}

GLRotationSphere::GLRotationSphere(const GLRotationSphere &amp;glRotationSphere)
    : GLObject(glRotationSphere)
{
    this-&gt;_init(&amp;glRotationSphere);
}

GLRotationSphere::~GLRotationSphere()
{

}

GLRotationSphere &amp;GLRotationSphere::operator =(const GLRotationSphere &amp;glRotationSphere)
{
    this-&gt;GLObject::operator =(glRotationSphere);
    this-&gt;_init(&amp;glRotationSphere);
    return (*this);
}

</t>
<t tx="leo.20201108101521.137">void GLRotationSphere::initialize(void)
{
    // Save current settings
    GL_SAFE_CALL(glGetBooleanv(GL_DEPTH_TEST, &amp;this-&gt;depthTestEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_LINE_SMOOTH, &amp;this-&gt;lineSmoothEnabled));
    GL_SAFE_CALL(glGetIntegerv(GL_LINE_SMOOTH_HINT, &amp;this-&gt;lineSmoothHint));
    GL_SAFE_CALL(glGetBooleanv(GL_NORMALIZE, &amp;this-&gt;normalizeEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    GL_SAFE_CALL(glGetFloatv(GL_LINE_WIDTH, &amp;this-&gt;lineWidth));
    GL_SAFE_CALL(glGetBooleanv(GL_CULL_FACE, &amp;this-&gt;cullFaceEnabled));
    // Initialize environment
    GL_SAFE_CALL(glEnable(GL_DEPTH_TEST));
    GL_SAFE_CALL(glEnable(GL_LINE_SMOOTH));
    GL_SAFE_CALL(glHint(GL_LINE_SMOOTH_HINT, GL_DONT_CARE));
    GL_SAFE_CALL(glEnable(GL_NORMALIZE));
    GL_SAFE_CALL(glDisable(GL_LIGHTING));
    GL_SAFE_CALL(glDisable(GL_CULL_FACE));
    GL_SAFE_CALL(glLineWidth(1.0f));
}

</t>
<t tx="leo.20201108101521.138">void GLRotationSphere::finalize(void)
{
    GL_SAFE_CALL(this-&gt;depthTestEnabled ? glEnable(GL_DEPTH_TEST) : glDisable(GL_DEPTH_TEST));
    GL_SAFE_CALL(this-&gt;lineSmoothEnabled ? glEnable(GL_LINE_SMOOTH) : glDisable(GL_LINE_SMOOTH));
    GL_SAFE_CALL(this-&gt;normalizeEnabled ? glEnable(GL_NORMALIZE) :glDisable(GL_NORMALIZE));
    GL_SAFE_CALL(this-&gt;lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
    GL_SAFE_CALL(this-&gt;cullFaceEnabled ? glEnable(GL_CULL_FACE) : glDisable(GL_CULL_FACE));
    GL_SAFE_CALL(glLineWidth(this-&gt;lineWidth));
    GL_SAFE_CALL(glHint(GL_LINE_SMOOTH_HINT, GLenum(this-&gt;lineSmoothHint)));
}

</t>
<t tx="leo.20201108101521.139">void GLRotationSphere::draw(void)
{
    GLboolean stipple;
    GL_SAFE_CALL(glGetBooleanv(GL_LINE_STIPPLE,&amp;stipple));
    GL_SAFE_CALL(glPushAttrib(GL_ENABLE_BIT));
    GL_SAFE_CALL(glLineStipple(6, 0xAAAA));
    GL_SAFE_CALL(glEnable(GL_LINE_STIPPLE));

    GLFunctions::begin(GL_LINE_LOOP);
    for (uint i=0;i&lt;360;i++)
    {
        double ang = R_DEG_TO_RAD(i);
        double r1 = cos(ang)*this-&gt;scale;
        double r2 = sin(ang)*this-&gt;scale;

        double x = r1 + this-&gt;position[0];
        double y = r2 + this-&gt;position[1];
        double z = this-&gt;position[2];

        GL_SAFE_CALL(glVertex3d(x,y,z));
    }
    GLFunctions::end();

    GLFunctions::begin(GL_LINE_LOOP);
    for (uint i=0;i&lt;360;i++)
    {
        double ang = R_DEG_TO_RAD(i);
        double r1 = cos(ang)*this-&gt;scale;
        double r2 = sin(ang)*this-&gt;scale;

        double x = r1 + this-&gt;position[0];
        double y = this-&gt;position[1];
        double z = r2 + this-&gt;position[2];

        GL_SAFE_CALL(glVertex3d(x,y,z));
    }
    GLFunctions::end();

    GLFunctions::begin(GL_LINE_LOOP);
    for (uint i=0;i&lt;360;i++)
    {
        double ang = R_DEG_TO_RAD(i);
        double r1 = cos(ang)*this-&gt;scale;
        double r2 = sin(ang)*this-&gt;scale;

        double x = this-&gt;position[0];
        double y = r1 + this-&gt;position[1];
        double z = r2 + this-&gt;position[2];

        GL_SAFE_CALL(glVertex3d(x,y,z));
    }
    GLFunctions::end();

    GLFunctions::begin(GL_LINES);

    GL_SAFE_CALL(glVertex3d(-this-&gt;scale+this-&gt;position[0],this-&gt;position[1],this-&gt;position[2]));
    GL_SAFE_CALL(glVertex3d( this-&gt;scale+this-&gt;position[0],this-&gt;position[1],this-&gt;position[2]));

    GL_SAFE_CALL(glVertex3d(this-&gt;position[0],-this-&gt;scale+this-&gt;position[1],this-&gt;position[2]));
    GL_SAFE_CALL(glVertex3d(this-&gt;position[0], this-&gt;scale+this-&gt;position[1],this-&gt;position[2]));

    GL_SAFE_CALL(glVertex3d(this-&gt;position[0],this-&gt;position[1],-this-&gt;scale+this-&gt;position[2]));
    GL_SAFE_CALL(glVertex3d(this-&gt;position[0],this-&gt;position[1], this-&gt;scale+this-&gt;position[2]));

    GLFunctions::end();

    GL_SAFE_CALL(glPopAttrib());
    if (!stipple)
    {
        GL_SAFE_CALL(glDisable(GL_LINE_STIPPLE));
    }
}
</t>
<t tx="leo.20201108101521.14">void GLElement::setSurfaceThickness(double surfaceThickness)
{
    this-&gt;surfaceThickness = surfaceThickness;
}

</t>
<t tx="leo.20201108101521.140">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_scalar_field.cpp                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th February 2014                                      *
 *                                                                   *
 *  DESCRIPTION: OpenGL scalar field class definition         *
 *********************************************************************/

#include &lt;cmath&gt;
#include &lt;omp.h&gt;

#include &lt;rmlib.h&gt;

#include "gl_scalar_field.h"
#include "gl_point.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.141">class ScalarFieldItem
{
    public:

        ScalarFieldItem (const RR3Vector &amp;position,
                         @others
};

</t>
<t tx="leo.20201108101521.142">                 double scalarRate,
                 bool validScaleValue,
                 double scaleValue)
    : position(position)
    , scalarRate(scalarRate)
    , validScaleValue(validScaleValue)
    , scaleValue(scaleValue)
{

}

RR3Vector position;
double scalarRate;
bool validScaleValue;
double scaleValue;
</t>
<t tx="leo.20201108101521.143">void GLScalarField::_init(const GLScalarField *pGlScalarField)
{
    if (pGlScalarField)
    {
        this-&gt;entityID = pGlScalarField-&gt;entityID;
        this-&gt;lightingEnabled = pGlScalarField-&gt;lightingEnabled;
    }
}

GLScalarField::GLScalarField(GLWidget *glWidget, const RScalarField &amp;scalarField, const SessionEntityID &amp;entityID)
    : GLObject(glWidget)
    , RScalarField(scalarField)
    , entityID(entityID)
{
    this-&gt;_init();
}

GLScalarField::GLScalarField(const GLScalarField &amp;glScalarField)
    : GLObject(glScalarField)
    , RScalarField(glScalarField)
{
    this-&gt;_init(&amp;glScalarField);
}

GLScalarField::~GLScalarField()
{

}

GLScalarField &amp;GLScalarField::operator =(const GLScalarField &amp;glScalarField)
{
    this-&gt;GLObject::operator =(glScalarField);
    this-&gt;RScalarField::operator =(glScalarField);
    this-&gt;_init(&amp;glScalarField);
    return (*this);
}

</t>
<t tx="leo.20201108101521.144">const SessionEntityID &amp;GLScalarField::getEntityID(void) const
{
    return this-&gt;entityID;
}

</t>
<t tx="leo.20201108101521.145">void GLScalarField::initialize(void)
{
    if (this-&gt;getApplyEnvironmentSettings())
    {
        return;
    }

    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_NORMALIZE, &amp;this-&gt;normalize));

    GL_SAFE_CALL(glDisable(GL_LIGHTING));
    GL_SAFE_CALL(glDisable(GL_NORMALIZE));
}

</t>
<t tx="leo.20201108101521.146">void GLScalarField::finalize(void)
{
    if (this-&gt;getApplyEnvironmentSettings())
    {
        return;
    }

    GL_SAFE_CALL(this-&gt;lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
    GL_SAFE_CALL(this-&gt;normalize ? glEnable(GL_NORMALIZE) : glDisable(GL_NORMALIZE));
}

</t>
<t tx="leo.20201108101521.147">void GLScalarField::draw(void)
{
    if (!this-&gt;getData().getVisible())
    {
        return;
    }

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());

    RVariableType scalarVariableType = this-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_SCALAR);
    uint scalarVariablePosition = rModel.findVariable(scalarVariableType);
    const RVariable *pScalarVariable = nullptr;
    GLTexture texture;
    if (scalarVariablePosition != RConstants::eod)
    {
        pScalarVariable = &amp;rModel.getVariable(scalarVariablePosition);
        texture.load(pScalarVariable-&gt;getVariableData().getValueRangeName());
    }

    RVariableType displacementVariableType = this-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT);
    uint displacementVariablePosition = rModel.findVariable(displacementVariableType);
    const RVariable *pDisplacementVariable = nullptr;
    if (displacementVariablePosition != RConstants::eod)
    {
        pDisplacementVariable = &amp;rModel.getVariable(displacementVariablePosition);
    }

    GLEntityList *pGlEntityList = &amp;this-&gt;getGLWidget()-&gt;getGLModelList().getGlScalarFieldList(this-&gt;getEntityID().getEid());

    if (!pGlEntityList-&gt;getListValid(GL_ENTITY_LIST_ITEM_NORMAL))
    {
        pGlEntityList-&gt;newList(GL_ENTITY_LIST_ITEM_NORMAL);

        std::vector&lt;ScalarFieldItem&gt; scalarField = this-&gt;calculateField(pScalarVariable,pDisplacementVariable);

        for (uint i=0;i&lt;scalarField.size();i++)
        {
            float pointSize = float(scalarField[i].scalarRate * (this-&gt;maxPointSize - this-&gt;minPointSize) + this-&gt;minPointSize);

            if (pointSize &lt;= 0.0f)
            {
                continue;
            }

            if (scalarField[i].validScaleValue)
            {
                GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
                this-&gt;getGLWidget()-&gt;qglColor(QColor(255,255,255,255));
                GL_SAFE_CALL(glTexCoord1d(scalarField[i].scaleValue));
            }
            else
            {
                int r,g,b,a;
                this-&gt;getData().getColor(r,g,b,a);
                this-&gt;getGLWidget()-&gt;qglColor(QColor(r,g,b,a));
            }

            GLPoint point(this-&gt;glWidget,scalarField[i].position,pointSize);
            point.paint();

            if (scalarField[i].validScaleValue)
            {
                GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
            }
        }

        pGlEntityList-&gt;endList(GL_ENTITY_LIST_ITEM_NORMAL);
    }

    pGlEntityList-&gt;callList(GL_ENTITY_LIST_ITEM_NORMAL);

    if (scalarVariablePosition != RConstants::eod)
    {
        texture.unload();
    }
}

std::vector&lt;ScalarFieldItem&gt; GLScalarField::calculateField(const RVariable *pScalarVariable, const RVariable *pDisplacementVariable) const
{
    std::vector&lt;ScalarFieldItem&gt; field;

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());

    uint variablePosition = rModel.findVariable(this-&gt;variableType);

    if (variablePosition == RConstants::eod)
    {
        return field;
    }

    const RVariable &amp;rVariable = rModel.getVariable(variablePosition);

    std::vector&lt;bool&gt; nodeBook;
    if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        nodeBook.resize(rModel.getNNodes(),false);
    }

//    double minValue = rVariable.getMinValue();
//    double maxValue = rVariable.getMaxValue();
    double minValue = rVariable.getVariableData().getMinDisplayValue();
    double maxValue = rVariable.getVariableData().getMaxDisplayValue();

#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(this-&gt;elementGroupIDs.size());i++)
    {
        REntityGroupType entityType;
        uint entityID;

        if (!rModel.getEntityID(this-&gt;elementGroupIDs[uint(i)],entityType,entityID))
        {
            continue;
        }
        if (REntityGroup::typeIsElementGroup(entityType))
        {
            const RElementGroup *pElementGroup = rModel.getElementGroupPtr(this-&gt;elementGroupIDs[uint(i)]);
            if (!pElementGroup)
            {
                continue;
            }

            for (uint j=0;j&lt;pElementGroup-&gt;size();j++)
            {
                uint elementID = pElementGroup-&gt;get(j);
                const RElement &amp;rElement = rModel.getElement(elementID);

                std::vector&lt;double&gt; scalarValues = this-&gt;getScalarValues(elementID,rVariable.getApplyType(),pScalarVariable);
                std::vector&lt;RR3Vector&gt; displacementValues = this-&gt;getDisplacementValues(elementID,rVariable.getApplyType(),pDisplacementVariable);

                if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
                {
                    RR3Vector position;
                    rElement.findCenter(rModel.getNodes(),position[0],position[1],position[2]);

                    if (displacementValues.size() == 1)
                    {
                        position[0] += displacementValues[0][0];
                        position[1] += displacementValues[0][1];
                        position[2] += displacementValues[0][2];
                    }

                    double scalarRate = 0.0;
                    if (std::abs(maxValue - minValue) &gt; RConstants::eps)
                    {
                        scalarRate = (rVariable.getValue(elementID) - minValue)/(maxValue - minValue);
                    }

                    bool validScalarValue = (scalarValues.size() == 1);
                    double scalarValue = validScalarValue ? scalarValues[0] : 0.0;

#pragma omp critical
                    {
                        field.push_back(ScalarFieldItem(position,scalarRate,validScalarValue,scalarValue));
                    }
                }
                else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
                {
                    for (uint k=0;k&lt;rElement.size();k++)
                    {
                        uint nodeID = rElement.getNodeId(k);

                        bool nodeSet = false;
#pragma omp flush(nodeBook)
#pragma omp critical
                        {
                            if (nodeBook[nodeID])
                            {
                                nodeSet = true;
                            }
                            else
                            {
                                nodeBook[nodeID] = true;
                            }
                        }
                        if (nodeSet)
                        {
                            continue;
                        }

                        RR3Vector position;
                        position[0] = rModel.getNode(nodeID).getX();
                        position[1] = rModel.getNode(nodeID).getY();
                        position[2] = rModel.getNode(nodeID).getZ();

                        if (displacementValues.size() == rElement.size())
                        {
                            position[0] += displacementValues[k][0];
                            position[1] += displacementValues[k][1];
                            position[2] += displacementValues[k][2];
                        }

                        double scalarRate = 0.0;
                        if (std::abs(maxValue - minValue) &gt; RConstants::eps)
                        {
                            scalarRate = (rVariable.getValue(nodeID) - minValue)/(maxValue - minValue);
                        }

                        bool validScalarValue = (scalarValues.size() == rElement.size());
                        double scalarValue = validScalarValue ? scalarValues[k] : 0.0;

#pragma omp critical
                        {
                            field.push_back(ScalarFieldItem(position,scalarRate,validScalarValue,scalarValue));
                        }
                    }
                }
            }
        }
        else
        {
            const RInterpolatedEntity *pIEntity = nullptr;
            switch (entityType)
            {
                case R_ENTITY_GROUP_CUT:
                    pIEntity = rModel.getCutPtr(entityID);
                    break;
                case R_ENTITY_GROUP_ISO:
                    pIEntity = rModel.getIsoPtr(entityID);
                    break;
                case R_ENTITY_GROUP_STREAM_LINE:
                    pIEntity = rModel.getStreamLinePtr(entityID);
                    break;
                default:
                    RLogger::warning("Non element-type entities are not implemented for scalar fields.\n");
                    continue;
            }

            if (!pIEntity)
            {
                continue;
            }

            for (uint j=0;j&lt;pIEntity-&gt;size();j++)
            {
                const RInterpolatedElement &amp;rIElement = pIEntity-&gt;at(j);
                if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
                {
                    uint elementID = rIElement.at(0).getElementID();

                    RR3Vector position;
                    rIElement.findCenter(position[0],position[1],position[2]);

                    std::vector&lt;RR3Vector&gt; displacementValues = this-&gt;getDisplacementValues(elementID,rVariable.getApplyType(),pDisplacementVariable);
                    if (displacementValues.size() == 1)
                    {
                        position[0] += displacementValues[0][0];
                        position[1] += displacementValues[0][1];
                        position[2] += displacementValues[0][2];
                    }

                    double scalarRate = 0.0;
                    if (std::abs(maxValue - minValue) &gt; RConstants::eps)
                    {
                        scalarRate = (rVariable.getValue(elementID) - minValue)/(maxValue - minValue);
                    }

                    std::vector&lt;double&gt; scalarValues = this-&gt;getScalarValues(elementID,rVariable.getApplyType(),pScalarVariable);

                    bool validScalarValue = (scalarValues.size() == 1);
                    double scalarValue = validScalarValue ? scalarValues[0] : 0.0;

#pragma omp critical
                    {
                        field.push_back(ScalarFieldItem(position,scalarRate,validScalarValue,scalarValue));
                    }

                }
                else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
                {
                    for (uint k=0;k&lt;rIElement.size();k++)
                    {
                        const RElement &amp;rElement = rModel.getElement(rIElement[k].getElementID());

                        RR3Vector position = rIElement[k].toVector();

                        double scalarRate = 0.0;
                        if (std::abs(maxValue - minValue) &gt; RConstants::eps)
                        {
                            std::vector&lt;double&gt; elementNodeValues;
                            elementNodeValues.resize(rElement.size(),0.0);

                            for (uint l=0;l&lt;rElement.size();l++)
                            {
                                elementNodeValues[l] = rVariable.getValue(rElement.getNodeId(l));
                            }

                            scalarRate = rElement.interpolate(rModel.getNodes(),rIElement[k],elementNodeValues);
                            scalarRate = (scalarRate - minValue)/(maxValue - minValue);
                        }

                        std::vector&lt;double&gt; elementScalarValues = this-&gt;getScalarValues(rIElement[k].getElementID(),rVariable.getApplyType(),pScalarVariable);

                        bool validScalarValue = false;
                        double scalarValue = 0.0;

                        if (elementScalarValues.size() == rElement.size())
                        {
                            validScalarValue = true;
                            scalarValue = rElement.interpolate(rModel.getNodes(),rIElement[k],elementScalarValues);
                        }

                        std::vector&lt;RR3Vector&gt; displacementValues = this-&gt;getDisplacementValues(rIElement[k].getElementID(),rVariable.getApplyType(),pDisplacementVariable);
                        if (displacementValues.size() == rElement.size())
                        {
                            std::vector&lt;double&gt; xDisplacementValues;
                            std::vector&lt;double&gt; yDisplacementValues;
                            std::vector&lt;double&gt; zDisplacementValues;

                            xDisplacementValues.resize(displacementValues.size());
                            yDisplacementValues.resize(displacementValues.size());
                            zDisplacementValues.resize(displacementValues.size());

                            for (uint l=0;l&lt;displacementValues.size();l++)
                            {
                                xDisplacementValues[l] = displacementValues[l][0];
                                yDisplacementValues[l] = displacementValues[l][1];
                                zDisplacementValues[l] = displacementValues[l][2];
                            }

                            position[0] += rElement.interpolate(rModel.getNodes(),rIElement[k],xDisplacementValues);
                            position[1] += rElement.interpolate(rModel.getNodes(),rIElement[k],yDisplacementValues);
                            position[2] += rElement.interpolate(rModel.getNodes(),rIElement[k],zDisplacementValues);
                        }

#pragma omp critical
                        {
                            field.push_back(ScalarFieldItem(position,scalarRate,validScalarValue,scalarValue));
                        }
                    }
                }
            }
        }
    }

    return field;
}

std::vector&lt;double&gt; GLScalarField::getScalarValues(uint elementID, RVariableApplyType variableApplyType, const RVariable *pVariable) const
{
    std::vector&lt;double&gt; scalarValues;

    if (!pVariable)
    {
        return scalarValues;
    }

    double minValue = pVariable-&gt;getVariableData().getMinDisplayValue();
    double maxValue = pVariable-&gt;getVariableData().getMaxDisplayValue();

    std::vector&lt;double&gt; values;

    if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());
        const RElement &amp;rElement = rModel.getElement(elementID);

        values.resize(rElement.size());
        for (uint i=0;i&lt;rElement.size();i++)
        {
            values[i] = pVariable-&gt;getValue(rElement.getNodeId(i));
        }
    }
    else if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        values.resize(1);
        values[0] = pVariable-&gt;getValue(elementID);
    }

    if (variableApplyType == R_VARIABLE_APPLY_NODE)
    {
        const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());
        scalarValues.resize(rModel.getElement(elementID).size());
        if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            for (uint i=0;i&lt;values.size();i++)
            {
                scalarValues[i] = values[i];
            }
        }
        else if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            for (uint i=0;i&lt;values.size();i++)
            {
                scalarValues[i] = values[0];
            }
        }
    }
    else if (variableApplyType == R_VARIABLE_APPLY_ELEMENT)
    {
        scalarValues.resize(1,0.0);
        for (uint i=0;i&lt;values.size();i++)
        {
            scalarValues[0] += values[i];
        }
        if (values.size() &gt; 0)
        {
            scalarValues[0] /= values.size();
        }
    }

    for (uint i=0;i&lt;scalarValues.size();i++)
    {
        scalarValues[i] = (scalarValues[i] - minValue) / (maxValue - minValue);

        scalarValues[i] = std::min(scalarValues[i],0.99);
        scalarValues[i] = std::max(scalarValues[i],0.01);
    }

    return scalarValues;
}

std::vector&lt;RR3Vector&gt; GLScalarField::getDisplacementValues(uint elementID, RVariableApplyType variableApplyType, const RVariable *pVariable) const
{
    std::vector&lt;RR3Vector&gt; displacementValues;

    if (!pVariable)
    {
        return displacementValues;
    }

    std::vector&lt;RR3Vector&gt; values;

    if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());
        const RElement &amp;rElement = rModel.getElement(elementID);

        values.resize(rElement.size());
        for (uint i=0;i&lt;rElement.size();i++)
        {
            values[i][0] = pVariable-&gt;getValue(0,rElement.getNodeId(i));
            values[i][1] = pVariable-&gt;getValue(1,rElement.getNodeId(i));
            values[i][2] = pVariable-&gt;getValue(2,rElement.getNodeId(i));
        }
    }
    else if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        values.resize(1);
        values[0][0] = pVariable-&gt;getValue(0,elementID);
        values[0][1] = pVariable-&gt;getValue(1,elementID);
        values[0][2] = pVariable-&gt;getValue(2,elementID);
    }

    if (variableApplyType == R_VARIABLE_APPLY_NODE)
    {
        const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());
        displacementValues.resize(rModel.getElement(elementID).size());
        if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            for (uint i=0;i&lt;values.size();i++)
            {
                displacementValues[i][0] = values[i][0];
                displacementValues[i][1] = values[i][1];
                displacementValues[i][2] = values[i][2];
            }
        }
        else if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            for (uint i=0;i&lt;values.size();i++)
            {
                displacementValues[i][0] = values[0][0];
                displacementValues[i][1] = values[0][1];
                displacementValues[i][2] = values[0][2];
            }
        }
    }
    else if (variableApplyType == R_VARIABLE_APPLY_ELEMENT)
    {
        displacementValues.resize(1,RR3Vector(0.0,0.0,0.0));
        for (uint i=0;i&lt;values.size();i++)
        {
            displacementValues[0][0] += values[i][0];
            displacementValues[0][1] += values[i][1];
            displacementValues[0][2] += values[i][2];
        }
        if (values.size() &gt; 0)
        {
            displacementValues[0][0] /= values.size();
            displacementValues[0][1] /= values.size();
            displacementValues[0][2] /= values.size();
        }
    }

    double scale = pVariable-&gt;getVariableData().getScale();

    for (uint i=0;i&lt;displacementValues.size();i++)
    {
        displacementValues[i] *= scale;
    }

    return displacementValues;
}
</t>
<t tx="leo.20201108101521.148">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_simplex.cpp                                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th August 2015                                        *
 *                                                                   *
 *  DESCRIPTION: OpenGL simplex class definition                     *
 *********************************************************************/

#include "gl_simplex.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.149">void GLSimplex::_init(const GLSimplex *pGlSimplex)
{
    if (pGlSimplex)
    {
        this-&gt;nodes = pGlSimplex-&gt;nodes;
        this-&gt;edgeNodes = pGlSimplex-&gt;edgeNodes;
        this-&gt;nodeTextureCoordinates = pGlSimplex-&gt;nodeTextureCoordinates;
        this-&gt;nodeIds = pGlSimplex-&gt;nodeIds;
        this-&gt;id = pGlSimplex-&gt;id;
        this-&gt;color = pGlSimplex-&gt;color;
        this-&gt;drawTypeMask = pGlSimplex-&gt;drawTypeMask;
    }
    else
    {
        this-&gt;edgeNodes.resize(this-&gt;nodes.size());
        std::fill(this-&gt;edgeNodes.begin(),this-&gt;edgeNodes.end(),true);
    }
}

GLSimplex::GLSimplex(GLWidget *glWidget, const std::vector&lt;RR3Vector&gt; &amp;nodes)
    : GLObject(glWidget)
    , nodes(nodes)
    , color(Qt::white)
    , drawTypeMask(GLSimplex::Normal)
{
    this-&gt;_init();
}

GLSimplex::GLSimplex(const GLSimplex &amp;glSimplex)
    : GLObject(glSimplex)
{
    this-&gt;_init(&amp;glSimplex);
}

GLSimplex::~GLSimplex()
{

}

GLSimplex &amp;GLSimplex::operator =(const GLSimplex &amp;glSimplex)
{
    this-&gt;GLObject::operator =(glSimplex);
    this-&gt;_init(&amp;glSimplex);
    return (*this);
}

</t>
<t tx="leo.20201108101521.15">void GLElement::draw(void)
{
    if (!this-&gt;pModel)
    {
        return;
    }
    switch (this-&gt;getType())
    {
        case R_ELEMENT_POINT:
            this-&gt;drawPoint();
            break;
        case R_ELEMENT_TRUSS1:
            this-&gt;drawLine();
            break;
        case R_ELEMENT_TRI1:
            this-&gt;drawTriangle();
            break;
        case R_ELEMENT_QUAD1:
            this-&gt;drawQuadrilateral();
            break;
        case R_ELEMENT_TETRA1:
            this-&gt;drawTetrahedra();
            break;
        default:
            break;
    }
}

</t>
<t tx="leo.20201108101521.150">void GLSimplex::setEdgeNodes(const std::vector&lt;bool&gt; &amp;edgeNodes)
{
    this-&gt;edgeNodes = edgeNodes;
}

</t>
<t tx="leo.20201108101521.151">void GLSimplex::setNodeTextureCoordinates(const std::vector&lt;double&gt; &amp;nodeTextureCoordinates)
{
    this-&gt;nodeTextureCoordinates = nodeTextureCoordinates;
}

</t>
<t tx="leo.20201108101521.152">void GLSimplex::setNodeIds(const std::vector&lt;uint&gt; &amp;nodeIds)
{
    this-&gt;nodeIds = nodeIds;
}

</t>
<t tx="leo.20201108101521.153">void GLSimplex::setId(uint id)
{
    this-&gt;id = id;
}

</t>
<t tx="leo.20201108101521.154">void GLSimplex::setColor(const QColor &amp;color)
{
    this-&gt;color = color;
}

</t>
<t tx="leo.20201108101521.155">void GLSimplex::setDrawType(int drawTypeMask)
{
    this-&gt;drawTypeMask = drawTypeMask;
}
</t>
<t tx="leo.20201108101521.156">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_simplex_point.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th August 2015                                        *
 *                                                                   *
 *  DESCRIPTION: OpenGL simplex point class definition               *
 *********************************************************************/

#include "gl_simplex_point.h"
#include "draw_engine_sphere.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.157">void GLSimplexPoint::_init(const GLSimplexPoint *pGlPoint)
{
    if (pGlPoint)
    {
        this-&gt;volume = pGlPoint-&gt;volume;
    }
}

GLSimplexPoint::GLSimplexPoint(GLWidget *glWidget, const std::vector&lt;RR3Vector&gt; &amp;nodes, double volume)
    : GLSimplex(glWidget,nodes)
    , volume(volume)
{
    this-&gt;_init();
}

GLSimplexPoint::GLSimplexPoint(const GLSimplexPoint &amp;glPoint)
    : GLSimplex(glPoint)
{
    this-&gt;_init(&amp;glPoint);
}

GLSimplexPoint::~GLSimplexPoint()
{

}

GLSimplexPoint &amp;GLSimplexPoint::operator =(const GLSimplexPoint &amp;glPoint)
{
    this-&gt;GLSimplex::operator =(glPoint);
    this-&gt;_init(&amp;glPoint);
    return (*this);
}

</t>
<t tx="leo.20201108101521.158">void GLSimplexPoint::initialize(void)
{

}

</t>
<t tx="leo.20201108101521.159">void GLSimplexPoint::finalize(void)
{

}

</t>
<t tx="leo.20201108101521.16">void GLElement::drawPoint(void)
{
    RNode node1 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(0));

    std::vector&lt;RR3Vector&gt; displacementValues;
    bool validDisplacementValues = (this-&gt;pDisplacementVariable != 0);
    if (validDisplacementValues)
    {
        this-&gt;findDisplacementNodeValues(this-&gt;elementID,*this-&gt;pDisplacementVariable,displacementValues);
    }

    if (validDisplacementValues &amp;&amp; displacementValues.size() == this-&gt;size())
    {
        node1.move(displacementValues[0]);
    }

    std::vector&lt;RR3Vector&gt; nodes;
    nodes.push_back(node1.toVector());

    GLSimplexPoint point(this-&gt;getGLWidget(),nodes,this-&gt;pointVolume);

    int drawMask = 0;

    switch (this-&gt;getDrawMode())
    {
        case GL_ELEMENT_DRAW_TEXT:
            if (this-&gt;elementGroupData.getDrawNodeNumbers())
            {
                drawMask |= GLSimplex::NodeIds;
                point.setNodeIds(this-&gt;nodeIDs);
            }
            if (this-&gt;elementGroupData.getDrawElementNumbers())
            {
                drawMask |= GLSimplex::ElementId;
                point.setId(this-&gt;getElementID());
            }
            break;
        case GL_ELEMENT_DRAW_NORMAL:
        default:
        {
            if (this-&gt;pScalarVariable != 0)
            {
                std::vector&lt;double&gt; scalarValues;
                this-&gt;findScalarNodeValues(this-&gt;elementID,*this-&gt;pScalarVariable,scalarValues);
                point.setNodeTextureCoordinates(scalarValues);
            }
            if (this-&gt;elementGroupData.getDrawWire())
            {
                drawMask |= GLSimplex::Wired;
            }
            else
            {
                drawMask |= GLSimplex::Normal;
            }
            if (this-&gt;elementGroupData.getDrawEdges())
            {
                drawMask |= GLSimplex::ElementEdges;
            }
            if (this-&gt;elementGroupData.getDrawNodes())
            {
                drawMask |= GLSimplex::ElementNodes;
            }
            break;
        }
    }
    point.setDrawType(drawMask);
    point.setColor(this-&gt;color);
    point.paint();
}

</t>
<t tx="leo.20201108101521.160">void GLSimplexPoint::draw(void)
{
    RModelRaw sphereModel;

    bool volumeElement = (this-&gt;volume &gt; RConstants::eps);
    bool useTexture = (this-&gt;nodeTextureCoordinates.size() == 1);

    if (volumeElement)
    {
        double r = std::pow((3.0/4.0) * this-&gt;volume / RConstants::pi,1.0/3.0);
        sphereModel = DrawEngineSphere::generate(this-&gt;nodes[0],r,2);
    }

    if (drawTypeMask &amp; GLSimplex::NodeIds)
    {
        this-&gt;getGLWidget()-&gt;qglColor(QColor(Qt::black));

        this-&gt;getGLWidget()-&gt;renderText(this-&gt;nodes[0][0],
                                        this-&gt;nodes[0][1],
                                        this-&gt;nodes[0][2],
                                        QString::number(this-&gt;nodeIds[0]),
                                        QFont("Courier",8));
    }
    if (drawTypeMask &amp; GLSimplex::ElementId)
    {
        this-&gt;getGLWidget()-&gt;qglColor(QColor(Qt::black));

        this-&gt;getGLWidget()-&gt;renderText(this-&gt;nodes[0][0],
                                        this-&gt;nodes[0][1],
                                        this-&gt;nodes[0][2],
                                        QString::number(this-&gt;id),
                                        QFont("Courier",8));
    }
//    if (drawTypeMask &amp; GLSimplex::ElementEdges)
//    {
//        this-&gt;getGLWidget()-&gt;qglColor(Qt::black);
//        this-&gt;drawWired(sphereModel,volumeElement,useTexture);
//    }
    if (drawTypeMask &amp; GLSimplex::ElementNodes)
    {
        this-&gt;getGLWidget()-&gt;qglColor(Qt::black);
        this-&gt;drawNodes(sphereModel,volumeElement);
    }
    if (drawTypeMask &amp; GLSimplex::Wired)
    {
        this-&gt;getGLWidget()-&gt;qglColor(useTexture ? Qt::white : this-&gt;color);
        this-&gt;drawWired(sphereModel,volumeElement,useTexture);
    }
    if (drawTypeMask &amp; GLSimplex::Normal)
    {
        this-&gt;getGLWidget()-&gt;qglColor(useTexture ? Qt::white : this-&gt;color);
        this-&gt;drawNormal(sphereModel,volumeElement,useTexture);
    }
}

</t>
<t tx="leo.20201108101521.161">void GLSimplexPoint::drawNormal(const RModelRaw &amp;sphereModel, bool volumeElement, bool useTexture)
{
    GLboolean lightingEnabled;
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));

    if (useTexture)
    {
        GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
        GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
    }

    if (volumeElement)
    {
        GLFunctions::begin(GL_TRIANGLES);
        for (uint i=0;i&lt;sphereModel.getNElements();i++)
        {
            const RElement &amp;rElement = sphereModel.getElement(i);
            if (rElement.getType() != R_ELEMENT_TRI1 &amp;&amp; rElement.getType() != R_ELEMENT_TRI2)
            {
                continue;
            }
            RNode n1(sphereModel.getNode(rElement.getNodeId(0)));
            RNode n2(sphereModel.getNode(rElement.getNodeId(1)));
            RNode n3(sphereModel.getNode(rElement.getNodeId(2)));
            GLObject::glNormalVector(RTriangle(n1,n2,n3).getNormal());
            GLObject::glVertexNode(n1);
            GLObject::glVertexNode(n2);
            GLObject::glVertexNode(n3);
        }
        GLFunctions::end();
    }
    else
    {
        GL_SAFE_CALL(glDisable(GL_LIGHTING));

        GLFunctions::begin(GL_POINTS);
        GLObject::glVertexNode(this-&gt;nodes[0]);
        GLFunctions::end();
    }

    if (useTexture)
    {
        GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
    }

    GL_SAFE_CALL(lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
}

</t>
<t tx="leo.20201108101521.162">void GLSimplexPoint::drawWired(const RModelRaw &amp;sphereModel, bool volumeElement, bool useTexture)
{
    GLboolean lightingEnabled;
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));

    GL_SAFE_CALL(glDisable(GL_LIGHTING));

    if (useTexture)
    {
        GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
        GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
    }

    if (volumeElement)
    {
        for (uint i=0;i&lt;sphereModel.getNElements();i++)
        {
            const RElement &amp;rElement = sphereModel.getElement(i);
            if (rElement.getType() != R_ELEMENT_TRI1 &amp;&amp; rElement.getType() != R_ELEMENT_TRI2)
            {
                continue;
            }
            GLFunctions::begin(GL_LINE_LOOP);
            GLObject::glVertexNode(sphereModel.getNode(rElement.getNodeId(0)));
            GLObject::glVertexNode(sphereModel.getNode(rElement.getNodeId(1)));
            GLObject::glVertexNode(sphereModel.getNode(rElement.getNodeId(2)));
            GLFunctions::end();
        }
    }
    else
    {
        GL_SAFE_CALL(glDisable(GL_LIGHTING));

        GLFunctions::begin(GL_POINTS);
        GLObject::glVertexNode(this-&gt;nodes[0]);
        GLFunctions::end();
    }

    if (useTexture)
    {
        GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
    }

    GL_SAFE_CALL(lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
}

</t>
<t tx="leo.20201108101521.163">void GLSimplexPoint::drawNodes(const RModelRaw &amp;, bool)
{
    GLFunctions::begin(GL_POINTS);
    GLObject::glVertexNode(this-&gt;nodes[0]);
    GLFunctions::end();
}
</t>
<t tx="leo.20201108101521.164">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_simplex_polygon.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   7-th August 2015                                         *
 *                                                                   *
 *  DESCRIPTION: OpenGL simplex polygon class definition             *
 *********************************************************************/

#include "gl_simplex_polygon.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.17">void GLElement::drawLine(void)
{
    RNode node1 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(0));
    RNode node2 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(1));

    std::vector&lt;RR3Vector&gt; displacementValues;
    bool validDisplacementValues = (this-&gt;pDisplacementVariable != 0);
    if (validDisplacementValues)
    {
        this-&gt;findDisplacementNodeValues(this-&gt;elementID,*this-&gt;pDisplacementVariable,displacementValues);
    }

    if (validDisplacementValues &amp;&amp; displacementValues.size() == this-&gt;size())
    {
        node1.move(displacementValues[0]);
        node2.move(displacementValues[1]);
    }

    std::vector&lt;RR3Vector&gt; nodes;
    nodes.push_back(node1.toVector());
    nodes.push_back(node2.toVector());

    GLSimplexSegment segment(this-&gt;getGLWidget(),nodes,this-&gt;lineCrossArea);

    int drawMask = 0;

    switch (this-&gt;getDrawMode())
    {
        case GL_ELEMENT_DRAW_TEXT:
            if (this-&gt;elementGroupData.getDrawNodeNumbers())
            {
                drawMask |= GLSimplex::NodeIds;
                segment.setNodeIds(this-&gt;nodeIDs);
            }
            if (this-&gt;elementGroupData.getDrawElementNumbers())
            {
                drawMask |= GLSimplex::ElementId;
                segment.setId(this-&gt;getElementID());
            }
            break;
        case GL_ELEMENT_DRAW_NORMAL:
        default:
        {
            if (this-&gt;pScalarVariable != 0)
            {
                std::vector&lt;double&gt; scalarValues;
                this-&gt;findScalarNodeValues(this-&gt;elementID,*this-&gt;pScalarVariable,scalarValues);
                segment.setNodeTextureCoordinates(scalarValues);
            }
            if (this-&gt;elementGroupData.getDrawWire())
            {
                drawMask |= GLSimplex::Wired;
            }
            else
            {
                drawMask |= GLSimplex::Normal;
            }
            if (this-&gt;elementGroupData.getDrawEdges())
            {
                drawMask |= GLSimplex::ElementEdges;
            }
            if (this-&gt;elementGroupData.getDrawNodes())
            {
                drawMask |= GLSimplex::ElementNodes;
            }
            break;
        }
    }
    segment.setDrawType(drawMask);
    segment.setColor(this-&gt;color);
    segment.paint();
}

</t>
<t tx="leo.20201108101521.18">void GLElement::drawTriangle(void)
{
    RNode node1 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(0));
    RNode node2 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(1));
    RNode node3 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(2));

    std::vector&lt;RR3Vector&gt; displacementValues;
    bool validDisplacementValues = (this-&gt;pDisplacementVariable != 0);
    if (validDisplacementValues)
    {
        this-&gt;findDisplacementNodeValues(this-&gt;elementID,*this-&gt;pDisplacementVariable,displacementValues);
    }

    if (validDisplacementValues &amp;&amp; displacementValues.size() == this-&gt;size())
    {
        node1.move(displacementValues[0]);
        node2.move(displacementValues[1]);
        node3.move(displacementValues[2]);
    }

    std::vector&lt;RR3Vector&gt; nodes;
    nodes.push_back(node1.toVector());
    nodes.push_back(node2.toVector());
    nodes.push_back(node3.toVector());

    GLSimplexPolygon polygon(this-&gt;getGLWidget(),nodes,this-&gt;surfaceThickness);
    polygon.setUseGlCullFace(this-&gt;getUseGlCullFace());

    int drawMask = 0;

    switch (this-&gt;getDrawMode())
    {
        case GL_ELEMENT_DRAW_TEXT:
            if (this-&gt;elementGroupData.getDrawNodeNumbers())
            {
                drawMask |= GLSimplex::NodeIds;
                polygon.setNodeIds(this-&gt;nodeIDs);
            }
            if (this-&gt;elementGroupData.getDrawElementNumbers())
            {
                drawMask |= GLSimplex::ElementId;
                polygon.setId(this-&gt;getElementID());
            }
            break;
        case GL_ELEMENT_DRAW_NORMAL:
        default:
        {
            if (this-&gt;pScalarVariable != 0)
            {
                std::vector&lt;double&gt; scalarValues;
                this-&gt;findScalarNodeValues(this-&gt;elementID,*this-&gt;pScalarVariable,scalarValues);
                polygon.setNodeTextureCoordinates(scalarValues);
            }
            if (this-&gt;elementGroupData.getDrawWire())
            {
                drawMask |= GLSimplex::Wired;
            }
            else
            {
                drawMask |= GLSimplex::Normal;
            }
            if (this-&gt;elementGroupData.getDrawEdges())
            {
                drawMask |= GLSimplex::ElementEdges;
            }
            if (this-&gt;elementGroupData.getDrawNodes())
            {
                drawMask |= GLSimplex::ElementNodes;
            }
            break;
        }
    }
    polygon.setDrawType(drawMask);
    polygon.setColor(this-&gt;color);
    polygon.paint();
}

</t>
<t tx="leo.20201108101521.19">void GLElement::drawQuadrilateral(void)
{
    RNode node1 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(0));
    RNode node2 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(1));
    RNode node3 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(2));
    RNode node4 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(3));

    std::vector&lt;RR3Vector&gt; displacementValues;
    bool validDisplacementValues = (this-&gt;pDisplacementVariable != 0);
    if (validDisplacementValues)
    {
        this-&gt;findDisplacementNodeValues(this-&gt;elementID,*this-&gt;pDisplacementVariable,displacementValues);
    }

    if (validDisplacementValues &amp;&amp; displacementValues.size() == this-&gt;size())
    {
        node1.move(displacementValues[0]);
        node2.move(displacementValues[1]);
        node3.move(displacementValues[2]);
        node4.move(displacementValues[3]);
    }

    std::vector&lt;RR3Vector&gt; nodes;
    nodes.push_back(node1.toVector());
    nodes.push_back(node2.toVector());
    nodes.push_back(node3.toVector());
    nodes.push_back(node4.toVector());

    GLSimplexPolygon polygon(this-&gt;getGLWidget(),nodes,this-&gt;surfaceThickness);
    polygon.setUseGlCullFace(this-&gt;getUseGlCullFace());

    int drawMask = 0;

    switch (this-&gt;getDrawMode())
    {
        case GL_ELEMENT_DRAW_TEXT:
            if (this-&gt;elementGroupData.getDrawNodeNumbers())
            {
                drawMask |= GLSimplex::NodeIds;
                polygon.setNodeIds(this-&gt;nodeIDs);
            }
            if (this-&gt;elementGroupData.getDrawElementNumbers())
            {
                drawMask |= GLSimplex::ElementId;
                polygon.setId(this-&gt;getElementID());
            }
            break;
        case GL_ELEMENT_DRAW_NORMAL:
        default:
        {
            if (this-&gt;pScalarVariable != 0)
            {
                std::vector&lt;double&gt; scalarValues;
                this-&gt;findScalarNodeValues(this-&gt;elementID,*this-&gt;pScalarVariable,scalarValues);
                polygon.setNodeTextureCoordinates(scalarValues);
            }
            if (this-&gt;elementGroupData.getDrawWire())
            {
                drawMask |= GLSimplex::Wired;
            }
            else
            {
                drawMask |= GLSimplex::Normal;
            }
            if (this-&gt;elementGroupData.getDrawEdges())
            {
                drawMask |= GLSimplex::ElementEdges;
            }
            if (this-&gt;elementGroupData.getDrawNodes())
            {
                drawMask |= GLSimplex::ElementNodes;
            }
            break;
        }
    }
    polygon.setDrawType(drawMask);
    polygon.setColor(this-&gt;color);
    polygon.paint();
}

</t>
<t tx="leo.20201108101521.2">void GLDisplayPropertiesDialog::onShowModelDimensionsClicked(bool checked)
{
    this-&gt;pGlWidget-&gt;getGLDisplayProperties().setShowModelDimensions(checked);
    this-&gt;pGlWidget-&gt;update();
}

</t>
<t tx="leo.20201108101521.20">void GLElement::drawTetrahedra(void)
{
    RNode node1 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(0));
    RNode node2 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(1));
    RNode node3 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(2));
    RNode node4 = this-&gt;pModel-&gt;getNode(this-&gt;getNodeId(3));

    std::vector&lt;RR3Vector&gt; displacementValues;
    bool validDisplacementValues = (this-&gt;pDisplacementVariable != 0);
    if (validDisplacementValues)
    {
        this-&gt;findDisplacementNodeValues(this-&gt;elementID,*this-&gt;pDisplacementVariable,displacementValues);
    }

    if (validDisplacementValues &amp;&amp; displacementValues.size() == this-&gt;size())
    {
        node1.move(displacementValues[0]);
        node2.move(displacementValues[1]);
        node3.move(displacementValues[2]);
        node4.move(displacementValues[3]);
    }

    std::vector&lt;RR3Vector&gt; nodes;
    nodes.push_back(node1.toVector());
    nodes.push_back(node2.toVector());
    nodes.push_back(node3.toVector());
    nodes.push_back(node4.toVector());

    GLSimplexTetrahedra tetrahedra(this-&gt;getGLWidget(),nodes);
    std::vector&lt;bool&gt; edgeNodes(this-&gt;size());
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        edgeNodes[i] = this-&gt;pModel-&gt;nodeIsOnEdge(this-&gt;getNodeId(i));
    }
    tetrahedra.setEdgeNodes(edgeNodes);

    int drawMask = 0;

    switch (this-&gt;getDrawMode())
    {
        case GL_ELEMENT_DRAW_TEXT:
            if (this-&gt;elementGroupData.getDrawNodeNumbers())
            {
                drawMask |= GLSimplex::NodeIds;
                tetrahedra.setNodeIds(this-&gt;nodeIDs);
            }
            if (this-&gt;elementGroupData.getDrawElementNumbers())
            {
                drawMask |= GLSimplex::ElementId;
                tetrahedra.setId(this-&gt;getElementID());
            }
            break;
        case GL_ELEMENT_DRAW_NORMAL:
        default:
        {
            if (this-&gt;pScalarVariable != 0)
            {
                std::vector&lt;double&gt; scalarValues;
                this-&gt;findScalarNodeValues(this-&gt;elementID,*this-&gt;pScalarVariable,scalarValues);
                tetrahedra.setNodeTextureCoordinates(scalarValues);
            }
            if (this-&gt;elementGroupData.getDrawWire())
            {
                drawMask |= GLSimplex::Wired;
            }
            else
            {
                drawMask |= GLSimplex::Normal;
            }
            if (this-&gt;elementGroupData.getDrawEdges())
            {
                drawMask |= GLSimplex::ElementEdges;
            }
            if (this-&gt;elementGroupData.getDrawNodes())
            {
                drawMask |= GLSimplex::ElementNodes;
            }
            break;
        }
    }
    tetrahedra.setDrawType(drawMask);
    tetrahedra.setColor(this-&gt;color);
    tetrahedra.paint();
}
</t>
<t tx="leo.20201108101521.21">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_element_base.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th June 2013                                          *
 *                                                                   *
 *  DESCRIPTION: OpenGL element base class definition                *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "gl_element_base.h"
#include "gl_texture.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.22">void GLElementBase::_init(const GLElementBase *pGlElement)
{
    if (pGlElement)
    {
        this-&gt;drawMode = pGlElement-&gt;drawMode;
        this-&gt;elementGroupData = pGlElement-&gt;elementGroupData;
        this-&gt;color = pGlElement-&gt;color;
        this-&gt;setModelPtr(pGlElement-&gt;getModelPtr());
        this-&gt;setElementID(pGlElement-&gt;getElementID());
        this-&gt;setApplyEnvironmentSettings(pGlElement-&gt;getApplyEnvironmentSettings());
        this-&gt;pScalarVariable = pGlElement-&gt;pScalarVariable;
        this-&gt;pDisplacementVariable = pGlElement-&gt;pDisplacementVariable;
        this-&gt;nodePointSize = pGlElement-&gt;nodePointSize;
        this-&gt;edgeLineWidth = pGlElement-&gt;edgeLineWidth;
    }
}

GLElementBase::GLElementBase(GLWidget *glWidget, const Model *pModel, uint elementID, const REntityGroupData &amp;elementGroupData, const QColor &amp;color, GLElementDrawMode drawMode)
    : GLObject(glWidget)
    , drawMode(drawMode)
    , elementGroupData(elementGroupData)
    , color(color)
    , pModel(pModel)
    , elementID(elementID)
    , pScalarVariable(nullptr)
    , pDisplacementVariable(nullptr)
    , nodePointSize(10.0f)
    , edgeLineWidth(1.0f)
{
    this-&gt;_init();
}

GLElementBase::GLElementBase(const GLElementBase &amp;glElement)
    : GLObject(glElement)
{
    this-&gt;_init(&amp;glElement);
}

GLElementBase::~GLElementBase()
{
}

GLElementBase &amp;GLElementBase::operator =(const GLElementBase &amp;glElement)
{
    this-&gt;GLObject::operator =(glElement);
    this-&gt;_init(&amp;glElement);
    return (*this);
}

GLElementDrawMode GLElementBase::getDrawMode(void) const
{
    return this-&gt;drawMode;
}

</t>
<t tx="leo.20201108101521.23">const REntityGroupData &amp;GLElementBase::getElementGroupData(void) const
{
    return this-&gt;elementGroupData;
}

</t>
<t tx="leo.20201108101521.24">const QColor &amp;GLElementBase::getColor(void) const
{
    return color;
}

</t>
<t tx="leo.20201108101521.25">const Model *GLElementBase::getModelPtr(void) const
{
    return this-&gt;pModel;
}

</t>
<t tx="leo.20201108101521.26">void GLElementBase::setModelPtr(const Model *pModel)
{
    this-&gt;pModel = pModel;
}

uint GLElementBase::getElementID(void) const
{
    return this-&gt;elementID;
}

</t>
<t tx="leo.20201108101521.27">void GLElementBase::setElementID(uint elementID)
{
    this-&gt;elementID = elementID;
}

</t>
<t tx="leo.20201108101521.28">void GLElementBase::setScalarVariable(const RVariable *pScalarVariable)
{
    this-&gt;pScalarVariable = pScalarVariable;
}

</t>
<t tx="leo.20201108101521.29">void GLElementBase::setDisplacementVariable(const RVariable *pDisplacementVariable)
{
    this-&gt;pDisplacementVariable = pDisplacementVariable;
}

</t>
<t tx="leo.20201108101521.3">void GLDisplayPropertiesDialog::onShowModelErrorsClicked(bool checked)
{
    this-&gt;pGlWidget-&gt;getGLDisplayProperties().setShowErrors(checked);
    this-&gt;pGlWidget-&gt;update();
}

</t>
<t tx="leo.20201108101521.30">void GLElementBase::setNodePointSize(GLfloat nodePointSize)
{
    this-&gt;nodePointSize = nodePointSize;
}

</t>
<t tx="leo.20201108101521.31">void GLElementBase::setEdgeLineWidth(GLfloat edgeLineWidth)
{
    this-&gt;edgeLineWidth = edgeLineWidth;
}

</t>
<t tx="leo.20201108101521.32">void GLElementBase::initialize(void)
{
    if (this-&gt;getApplyEnvironmentSettings())
    {
        return;
    }

    GL_SAFE_CALL(glGetBooleanv(GL_LINE_SMOOTH, &amp;this-&gt;lineSmoothEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_NORMALIZE, &amp;this-&gt;normalize));
    GL_SAFE_CALL(glGetFloatv(GL_POINT_SIZE, &amp;this-&gt;pointSize));
    GL_SAFE_CALL(glGetFloatv(GL_LINE_WIDTH, &amp;this-&gt;lineWidth));

    switch (this-&gt;getDrawMode())
    {
        case GL_ELEMENT_DRAW_TEXT:
        {
            GL_SAFE_CALL(glDisable(GL_NORMALIZE));
            GL_SAFE_CALL(glPointSize(15.0f));
            GL_SAFE_CALL(glLineWidth(2.0f));
            GL_SAFE_CALL(glDisable(GL_LIGHTING));
            break;
        }
        case GL_ELEMENT_DRAW_NORMAL:
        default:
        {
            GL_SAFE_CALL(glEnable(GL_NORMALIZE));
            GL_SAFE_CALL(glPointSize(this-&gt;nodePointSize));
            GL_SAFE_CALL(glLineWidth(this-&gt;edgeLineWidth));
            if (this-&gt;elementGroupData.getDrawWire())
            {
                GL_SAFE_CALL(glDisable(GL_LIGHTING));
            }
            break;
        }
    }
}

</t>
<t tx="leo.20201108101521.33">void GLElementBase::finalize(void)
{
    if (this-&gt;getApplyEnvironmentSettings())
    {
        return;
    }

    GL_SAFE_CALL(this-&gt;lineSmoothEnabled ? glEnable(GL_LINE_SMOOTH) : glDisable(GL_LINE_SMOOTH));
    GL_SAFE_CALL(this-&gt;lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
    GL_SAFE_CALL(this-&gt;normalize ? glEnable(GL_NORMALIZE) : glDisable(GL_NORMALIZE));
    GL_SAFE_CALL(glPointSize(this-&gt;pointSize));
    GL_SAFE_CALL(glLineWidth(this-&gt;lineWidth));
}

</t>
<t tx="leo.20201108101521.34">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_element_group.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th March 2012                                         *
 *                                                                   *
 *  DESCRIPTION: OpenGL element group class definition               *
 *********************************************************************/

#include "gl_element_group.h"
#include "gl_element.h"
#include "model.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.35">void GLElementGroup::_init(const GLElementGroup *pGlElementGroup)
{
    if (pGlElementGroup)
    {
        this-&gt;pointVolume = pGlElementGroup-&gt;pointVolume;
        this-&gt;lineCrossArea = pGlElementGroup-&gt;lineCrossArea;
        this-&gt;surfaceThickness = pGlElementGroup-&gt;surfaceThickness;
        this-&gt;lightingEnabled = pGlElementGroup-&gt;lightingEnabled;
        this-&gt;normalize = pGlElementGroup-&gt;normalize;
        this-&gt;pointSize = pGlElementGroup-&gt;pointSize;
        this-&gt;lineWidth = pGlElementGroup-&gt;lineWidth;
    }
}

GLElementGroup::GLElementGroup(GLWidget *glWidget, const RElementGroup &amp;elementGroup, const SessionEntityID &amp;entityID)
    : GLEntity(glWidget,entityID)
    , RElementGroup(elementGroup)
    , pointVolume(0.0)
    , lineCrossArea(0.0)
    , surfaceThickness(0.0)
{
    this-&gt;_init();
}

GLElementGroup::GLElementGroup(const GLElementGroup &amp;glElementGroup)
    : GLEntity(glElementGroup)
    , RElementGroup(glElementGroup)
{
    this-&gt;_init(&amp;glElementGroup);
}

GLElementGroup::~GLElementGroup()
{
}

GLElementGroup &amp;GLElementGroup::operator =(const GLElementGroup &amp;glElementGroup)
{
    this-&gt;GLEntity::operator =(glElementGroup);
    this-&gt;RElementGroup::operator =(glElementGroup);
    this-&gt;_init(&amp;glElementGroup);
    return (*this);
}

</t>
<t tx="leo.20201108101521.36">void GLElementGroup::setPointVolume(double pointVolume)
{
    this-&gt;pointVolume = pointVolume;
}

</t>
<t tx="leo.20201108101521.37">void GLElementGroup::setLineCrossArea(double lineCrossArea)
{
    this-&gt;lineCrossArea = lineCrossArea;
}

</t>
<t tx="leo.20201108101521.38">void GLElementGroup::setSurfaceThickness(double surfaceThickness)
{
    this-&gt;surfaceThickness = surfaceThickness;
}

</t>
<t tx="leo.20201108101521.39">void GLElementGroup::initialize(void)
{
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_NORMALIZE, &amp;this-&gt;normalize));
    GL_SAFE_CALL(glGetFloatv(GL_POINT_SIZE, &amp;this-&gt;pointSize));
    GL_SAFE_CALL(glGetFloatv(GL_LINE_WIDTH, &amp;this-&gt;lineWidth));

    GL_SAFE_CALL(glEnable(GL_NORMALIZE));
    GL_SAFE_CALL(glPointSize(10.0f));
    GL_SAFE_CALL(glLineWidth(1.0f));

    if (this-&gt;getData().getDrawWire())
    {
        GL_SAFE_CALL(glDisable(GL_LIGHTING));
    }

    const Model *pModel = this-&gt;pParentModel ? this-&gt;pParentModel : &amp;Session::getInstance().getModel(this-&gt;getEntityID().getMid());

    RVariableType scalarVariableType = this-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_SCALAR);
    unsigned int scalarVarPos = pModel-&gt;findVariable(scalarVariableType);
    if (scalarVarPos != RConstants::eod)
    {
        const RVariable &amp;variable = pModel-&gt;getVariable(scalarVarPos);
        this-&gt;texture.load(variable.getVariableData().getValueRangeName());
    }
}

</t>
<t tx="leo.20201108101521.4">void GLDisplayPropertiesDialog::onShowGlobalAxisClicked(bool checked)
{
    this-&gt;pGlWidget-&gt;getGLDisplayProperties().setDrawGlobalAxis(checked);
    this-&gt;pGlWidget-&gt;update();
}

</t>
<t tx="leo.20201108101521.40">void GLElementGroup::finalize(void)
{
    GL_SAFE_CALL(this-&gt;lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
    GL_SAFE_CALL(this-&gt;normalize ? glEnable(GL_NORMALIZE) : glDisable(GL_NORMALIZE));
    GL_SAFE_CALL(glPointSize(this-&gt;pointSize));
    GL_SAFE_CALL(glLineWidth(this-&gt;lineWidth));

    this-&gt;texture.unload();
}

</t>
<t tx="leo.20201108101521.41">void GLElementGroup::draw(void)
{
    if (!this-&gt;getData().getVisible())
    {
        return;
    }

    GLEntityList *pGlEntityList = nullptr;

    switch (this-&gt;getEntityID().getType())
    {
        case R_ENTITY_GROUP_POINT:
            pGlEntityList = &amp;this-&gt;getGLWidget()-&gt;getGLModelList().getGlPointList(this-&gt;getEntityID().getEid());
            break;
        case R_ENTITY_GROUP_LINE:
            pGlEntityList = &amp;this-&gt;getGLWidget()-&gt;getGLModelList().getGlLineList(this-&gt;getEntityID().getEid());
            break;
        case R_ENTITY_GROUP_SURFACE:
            pGlEntityList = &amp;this-&gt;getGLWidget()-&gt;getGLModelList().getGlSurfaceList(this-&gt;getEntityID().getEid());
            break;
        case R_ENTITY_GROUP_VOLUME:
            pGlEntityList = &amp;this-&gt;getGLWidget()-&gt;getGLModelList().getGlVolumeList(this-&gt;getEntityID().getEid());
            break;
        default:
            return;
    }

    if (!pGlEntityList-&gt;getListValid(GL_ENTITY_LIST_ITEM_NORMAL))
    {
        const Model *pModel = this-&gt;pParentModel ? this-&gt;pParentModel : &amp;Session::getInstance().getModel(this-&gt;getEntityID().getMid());

        RVariableType scalarVariableType = this-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_SCALAR);
        uint scalarVariablePosition = pModel-&gt;findVariable(scalarVariableType);
        const RVariable *pScalarVariable = nullptr;
        if (scalarVariablePosition != RConstants::eod)
        {
            pScalarVariable = &amp;pModel-&gt;getVariable(scalarVariablePosition);
        }

        RVariableType displacementVariableType = this-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT);
        uint displacementVarPosition = pModel-&gt;findVariable(displacementVariableType);
        const RVariable *pDisplacementVariable = nullptr;
        if (displacementVarPosition != RConstants::eod)
        {
            pDisplacementVariable = &amp;pModel-&gt;getVariable(displacementVarPosition);
        }

        bool colorByViewFactor = false;
        bool colorByPatch = false;
        QList&lt;QColor&gt; patchColors = pModel-&gt;getPatchColors();

        RViewFactorMatrixHeader viewFactorMatrixHeader;
        pModel-&gt;generateViewFactorMatrixHeader(viewFactorMatrixHeader);

        if (pModel-&gt;getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_RADIATIVE_HEAT)
        {
            const RPatchBook &amp;rPatchBook = pModel-&gt;getViewFactorMatrix().getPatchBook();

            if (uint(patchColors.size()) != rPatchBook.getNPatches())
            {
                Session::getInstance().getModel(this-&gt;entityID.getMid()).generatePatchColors();
                patchColors = pModel-&gt;getPatchColors();
            }

            if (this-&gt;getData().getColorByPatch() &amp;&amp; pModel-&gt;canColorByPatch())
            {
                colorByPatch = true;
            }
            if (this-&gt;getData().getColorByViewFactor() &amp;&amp; pModel-&gt;canColorByViewFactor())
            {
                colorByViewFactor = true;
            }

            if (colorByViewFactor)
            {
                QVector&lt;PickItem&gt; pickList = Session::getInstance().getPickList().getItems(this-&gt;getEntityID().getMid());

                RRVector patchViewFactors(rPatchBook.getNPatches());
                patchViewFactors.fill(0.0);

                std::set&lt;uint&gt; pickedPatches;

                for (int i=0;i&lt;pickList.size();i++)
                {
                    if (pickList[i].getEntityID().getType() != R_ENTITY_GROUP_SURFACE)
                    {
                        continue;
                    }

                    uint patchID = rPatchBook.findPatchID(pickList[i].getElementID());
                    if (patchID == RConstants::eod)
                    {
                        RLogger::error("Reffering to a nonexistent patch ID #%u\n",patchID);
                        continue;
                    }
                    pickedPatches.insert(patchID);
                }

                std::set&lt;uint&gt;::const_iterator it;
                for (it=pickedPatches.begin();it!=pickedPatches.end();++it)
                {
                    uint patchID = uint(*it);
                    const RSparseVector&lt;double&gt; &amp;viewFactorRow = pModel-&gt;getViewFactorMatrix().getRow(patchID).getViewFactors();
                    std::vector&lt;uint&gt; indexes = viewFactorRow.getIndexes();
                    for (uint i=0;i&lt;indexes.size();i++)
                    {
                        patchViewFactors[indexes[i]] += viewFactorRow.getValue(i);
                    }
                }

                double maxViewFactor = RStatistics::findMaximumValue(patchViewFactors);
                maxViewFactor = std::min(1.0,maxViewFactor);
                maxViewFactor = std::max(0.0,maxViewFactor);

                int r,g,b,a;

                this-&gt;getData().getColor(r,g,b,a);

                for (uint i=0;i&lt;rPatchBook.getNPatches();i++)
                {
                    if (colorByPatch)
                    {
                        r = patchColors[int(i)].red();
                        g = patchColors[int(i)].green();
                        b = patchColors[int(i)].blue();
                        a = patchColors[int(i)].alpha();
                    }
                    double viewFactor = patchViewFactors[i];
                    if (maxViewFactor &gt; RConstants::eps)
                    {
                        viewFactor /= maxViewFactor;
                    }
                    patchColors[int(i)] = QColor(qRound(r*viewFactor),
                                                 qRound(g*viewFactor),
                                                 qRound(b*viewFactor),a);
                }
            }
        } // R_PROBLEM_RADIATIVE_HEAT

        RUVector edgeElements;
        edgeElements.reserve(this-&gt;size());

        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            uint elementID = this-&gt;get(i);
            if (pModel-&gt;elementIsOnEdge(elementID))
            {
                edgeElements.push_back(elementID);
            }
        }

        if (this-&gt;getUseGlList())
        {
            pGlEntityList-&gt;newList(GL_ENTITY_LIST_ITEM_NORMAL);
        }
        for (uint i=0;i&lt;edgeElements.size();i++)
        {
            GLObject::PaintActionMask paintAction = GLObject::Draw;
            paintAction = (i == 0) ? paintAction | GLObject::Initialize : paintAction;
            paintAction = (i+1 == edgeElements.size()) ? paintAction | GLObject::Finalize : paintAction;

            if (i+1 &lt; edgeElements.size())
            {
                if (i &gt; 0)
                {
                    if (pModel-&gt;getElement(edgeElements[i-1]).getType() != pModel-&gt;getElement(edgeElements[i]).getType())
                    {
                        paintAction |= GLObject::Initialize;
                    }
                }
                if (pModel-&gt;getElement(edgeElements[i]).getType() != pModel-&gt;getElement(edgeElements[i+1]).getType())
                {
                    paintAction |= GLObject::Finalize;
                }
            }

            uint elementID = edgeElements[i];

            QColor color;
            if (colorByPatch || colorByViewFactor)
            {
                const RPatchBook &amp;rPatchBook = pModel-&gt;getViewFactorMatrix().getPatchBook();
                uint patchID = rPatchBook.findPatchID(elementID);
                if (patchID == RConstants::eod)
                {
                    continue;
                }
                color = patchColors[int(patchID)];
            }
            else
            {
                int r,g,b,a;
                this-&gt;getData().getColor(r,g,b,a);
                color.setRgb(r,g,b,a);
            }
            GLElement glElement(this-&gt;getGLWidget(),
                                pModel,
                                elementID,
                                this-&gt;getData(),
                                color,
                                GL_ELEMENT_DRAW_NORMAL);
            glElement.setApplyEnvironmentSettings(false);
            glElement.setScalarVariable(pScalarVariable);
            glElement.setDisplacementVariable(pDisplacementVariable);
            glElement.setPointVolume(this-&gt;pointVolume);
            glElement.setLineCrossArea(this-&gt;lineCrossArea);
            glElement.setSurfaceThickness(this-&gt;surfaceThickness);
            glElement.setUseGlCullFace(this-&gt;getUseGlCullFace());
            glElement.paint(paintAction);
        }
        if (this-&gt;getUseGlList())
        {
            pGlEntityList-&gt;endList(GL_ENTITY_LIST_ITEM_NORMAL);
        }
    }
    if (this-&gt;getUseGlList())
    {
        pGlEntityList-&gt;callList(GL_ENTITY_LIST_ITEM_NORMAL);
    }

    if (this-&gt;getData().getDrawElementNumbers() || this-&gt;getData().getDrawNodeNumbers())
    {
        const Model *pModel = this-&gt;pParentModel ? this-&gt;pParentModel : &amp;Session::getInstance().getModel(this-&gt;getEntityID().getMid());

        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            uint elementID = this-&gt;get(i);
            if (!pModel-&gt;elementIsOnEdge(elementID))
            {
                continue;
            }
            int r,g,b,a;
            this-&gt;getData().getColor(r,g,b,a);
            GLElement glElement(this-&gt;getGLWidget(),
                                pModel,
                                elementID,
                                this-&gt;getData(),
                                QColor(r,g,b,a),
                                GL_ELEMENT_DRAW_TEXT);
            glElement.setApplyEnvironmentSettings(false);
            glElement.setPointVolume(this-&gt;pointVolume);
            glElement.setLineCrossArea(this-&gt;lineCrossArea);
            glElement.setSurfaceThickness(this-&gt;surfaceThickness);
            glElement.paint();
        }
    }
}
</t>
<t tx="leo.20201108101521.42">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_entity.cpp                                            *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th June 2013                                           *
 *                                                                   *
 *  DESCRIPTION: OpenGL entity class declaration                     *
 *********************************************************************/

#include "gl_entity.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.43">void GLEntity::_init(const GLEntity *pGLEntity)
{
    if (pGLEntity)
    {
        this-&gt;entityID = pGLEntity-&gt;entityID;
    }
}

GLEntity::GLEntity(GLWidget *glWidget, const SessionEntityID &amp;entityID)
    : GLObject(glWidget)
    , entityID(entityID)
{
    this-&gt;_init();
}

GLEntity::GLEntity(const GLEntity &amp;gLEntity)
    : GLObject(gLEntity)
{
    this-&gt;_init(&amp;gLEntity);
}

GLEntity::~GLEntity()
{
}

GLEntity &amp;GLEntity::operator =(const GLEntity &amp;gLEntity)
{
    this-&gt;GLObject::operator =(gLEntity);
    this-&gt;_init(&amp;gLEntity);
    return (*this);
}

</t>
<t tx="leo.20201108101521.44">const SessionEntityID &amp; GLEntity::getEntityID(void) const
{
    return this-&gt;entityID;
}

</t>
<t tx="leo.20201108101521.45">void GLEntity::initialize(void)
{
}

</t>
<t tx="leo.20201108101521.46">void GLEntity::finalize(void)
{
}

</t>
<t tx="leo.20201108101521.47">void GLEntity::draw(void)
{
}
</t>
<t tx="leo.20201108101521.48">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_entity_list.cpp                                       *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th March 2012                                         *
 *                                                                   *
 *  DESCRIPTION: OpenGL entity list class definition                 *
 *********************************************************************/

#include "gl_entity_list.h"

GLEntityList::GLEntityList()
    : GLList(GL_ENTITY_LIST_ITEM_N_LISTS)
{
    this-&gt;_init();
}

GLEntityList::GLEntityList(const GLEntityList &amp;glEntityList)
    : GLList(glEntityList)
{
    this-&gt;_init(&amp;glEntityList);
}

GLEntityList::~GLEntityList()
{
}

GLList &amp;GLEntityList::operator =(const GLEntityList &amp;glEntityList)
{
    this-&gt;GLList::operator =(glEntityList);
    this-&gt;_init(&amp;glEntityList);
    return (*this);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.49">void GLEntityList::_init(const GLEntityList *pGlEntityList)
{
    if (pGlEntityList)
    {

    }
}
</t>
<t tx="leo.20201108101521.5">void GLDisplayPropertiesDialog::onShowLocalAxisClicked(bool checked)
{
    this-&gt;pGlWidget-&gt;getGLDisplayProperties().setDrawLocalAxis(checked);
    this-&gt;pGlWidget-&gt;update();
}

</t>
<t tx="leo.20201108101521.50">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_functions.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   3-rd March 2016                                          *
 *                                                                   *
 *  DESCRIPTION: OpenGL functions definitions                        *
 *********************************************************************/

#include &lt;QOpenGLFunctions&gt;
#include &lt;QString&gt;

#include &lt;rblib.h&gt;

#include "gl_functions.h"

static bool insideBeginEnd = false;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.51">void GLFunctions::printError(const char *command, const char *file, unsigned int line)
{
    if (insideBeginEnd)
    {
        return;
    }

    GLenum glErrorNum = glGetError();

    QString errorMessage;

    switch (glErrorNum)
    {
        case GL_NO_ERROR:
        {
//            No error has been recorded.
            break;
        }
        case GL_INVALID_ENUM:
        {
            errorMessage += "An unacceptable value is specified for an enumerated argument. The offending command is ignored and has no other side effect than to set the error flag.";
            break;
        }
        case GL_INVALID_VALUE:
        {
            errorMessage += "A numeric argument is out of range. The offending command is ignored and has no other side effect than to set the error flag.";
            break;
        }
        case GL_INVALID_OPERATION:
        {
            errorMessage += "The specified operation is not allowed in the current state. The offending command is ignored and has no other side effect than to set the error flag.";
            break;
        }
        case GL_INVALID_FRAMEBUFFER_OPERATION:
        {
            errorMessage += "The framebuffer object is not complete. The offending command is ignored and has no other side effect than to set the error flag.";
            break;
        }
        case GL_OUT_OF_MEMORY:
        {
            errorMessage += "There is not enough memory left to execute the command. The state of the GL is undefined, except for the state of the error flags, after this error is recorded.";
            break;
        }
        case GL_STACK_UNDERFLOW:
        {
            errorMessage += "An attempt has been made to perform an operation that would cause an internal stack to underflow.";
            break;
        }
        case GL_STACK_OVERFLOW:
        {
            errorMessage += "An attempt has been made to perform an operation that would cause an internal stack to overflow.";
            break;
        }
        default:
        {
            errorMessage += "Unknown OpenGL error";
            break;
        }
    }

    if (errorMessage.length() &gt; 0)
    {
        RLogger::warning("OpenGL call \'%s\' failed at %s:%d &gt; %s\n",command,file,line,errorMessage.toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101521.52">void GLFunctions::begin(GLenum mode)
{
    insideBeginEnd = true;
    glBegin(mode);
}

</t>
<t tx="leo.20201108101521.53">void GLFunctions::end()
{
    GL_SAFE_CALL(glEnd());
    insideBeginEnd = false;
}
</t>
<t tx="leo.20201108101521.54">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_interpolated_element.cpp                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th June 2013                                          *
 *                                                                   *
 *  DESCRIPTION: OpenGL interpolated element class definition        *
 *********************************************************************/

#include "gl_interpolated_element.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.55">void GLInterpolatedElement::_init(const GLInterpolatedElement *pGlElement)
{
    if (pGlElement)
    {

    }
}

GLInterpolatedElement::GLInterpolatedElement(GLWidget *glWidget,
</t>
<t tx="leo.20201108101521.56">                                             const Model *pModel,
                                             const RInterpolatedElement &amp;iElement,
                                             uint elementID,
                                             const REntityGroupData &amp;elementGroupData,
                                             GLElementDrawMode drawMode)
    : GLElementBase(glWidget,pModel,elementID,elementGroupData,Qt::white,drawMode)
    , RInterpolatedElement(iElement)
{
    this-&gt;_init();
}

GLInterpolatedElement::GLInterpolatedElement(const GLInterpolatedElement &amp;glElement)
    : GLElementBase(glElement)
    , RInterpolatedElement(glElement)
{
    this-&gt;_init(&amp;glElement);
}

GLInterpolatedElement::~GLInterpolatedElement()
{
}

GLInterpolatedElement &amp;GLInterpolatedElement::operator =(const GLInterpolatedElement &amp;glElement)
{
    this-&gt;GLElementBase::operator =(glElement);
    this-&gt;RInterpolatedElement::operator =(glElement);
    this-&gt;_init(&amp;glElement);
    return (*this);
}

</t>
<t tx="leo.20201108101521.57">void GLInterpolatedElement::draw(void)
{
    if (!this-&gt;pModel)
    {
        return;
    }
    switch (this-&gt;drawMode)
    {
        case GL_ELEMENT_DRAW_NORMAL:
            this-&gt;drawNormal();
            break;
        case GL_ELEMENT_DRAW_TEXT:
            break;
        default:
            break;
    }
}

</t>
<t tx="leo.20201108101521.58">void GLInterpolatedElement::drawNormal(void)
{
    std::vector&lt;double&gt; scalarValues;
    std::vector&lt;RR3Vector&gt; displacementValues;

    bool validScalarValues = (this-&gt;pScalarVariable != 0);
    bool validDisplacementValues = (this-&gt;pDisplacementVariable != 0);

    if (validScalarValues)
    {
        this-&gt;findScalarNodeValues(this-&gt;pModel-&gt;getNodes(),this-&gt;pModel-&gt;getElements(),*this-&gt;pScalarVariable,scalarValues);
    }

    if (validDisplacementValues)
    {
        this-&gt;findDisplacementNodeValues(this-&gt;pModel-&gt;getNodes(),this-&gt;pModel-&gt;getElements(),*this-&gt;pDisplacementVariable,displacementValues);
    }

    std::vector&lt;RInterpolatedNode&gt; nodes;
    nodes.resize(this-&gt;size());

    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        nodes[i] = this-&gt;at(i);
    }

    if (validDisplacementValues &amp;&amp; this-&gt;size() == displacementValues.size())
    {
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            nodes[i].move(displacementValues[i]);
        }
    }

    int r = 255, g = 255, b = 255, a = 255;
    if (validScalarValues)
    {
        GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
    }
    else
    {
        this-&gt;getElementGroupData().getColor(r,g,b,a);
    }
    this-&gt;getGLWidget()-&gt;qglColor(QColor(r,g,b,a));

    if (this-&gt;size() == 1)
    {
        // Points.
        GLboolean lightingEnabled;
        GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));
        GL_SAFE_CALL(glDisable(GL_LIGHTING));
        GLFunctions::begin(GL_LINE_LOOP);
        for (uint j=0;j&lt;this-&gt;size();j++)
        {
            if (validScalarValues)
            {
                GL_SAFE_CALL(glTexCoord1d(scalarValues[j]));
            }
            GL_SAFE_CALL(glVertex3d(nodes[j].getX(),nodes[j].getY(),nodes[j].getZ()));
        }
        GLFunctions::end();
        GL_SAFE_CALL(lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));

    }
    else if (this-&gt;size() == 2)
    {
        // Lines.
        GLboolean lightingEnabled;
        GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));
        GL_SAFE_CALL(glDisable(GL_LIGHTING));
        GLFunctions::begin(GL_LINE_STRIP);
        for (uint j=0;j&lt;this-&gt;size();j++)
        {
            if (validScalarValues)
            {
                GL_SAFE_CALL(glTexCoord1d(scalarValues[j]));
            }
            GL_SAFE_CALL(glVertex3d(nodes[j].getX(),nodes[j].getY(),nodes[j].getZ()));
        }
        GLFunctions::end();
        GL_SAFE_CALL(lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
    }
    else if (this-&gt;size() &gt; 2)
    {
        // Polygons.
        if (this-&gt;getElementGroupData().getDrawWire())
        {
            GLboolean lightingEnabled;
            GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));
            GL_SAFE_CALL(glDisable(GL_LIGHTING));
            GLFunctions::begin(GL_LINE_LOOP);
            for (uint j=0;j&lt;this-&gt;size();j++)
            {
                if (validScalarValues)
                {
                    GL_SAFE_CALL(glTexCoord1d(scalarValues[j]));
                }
                GL_SAFE_CALL(glVertex3d(nodes[j].getX(),nodes[j].getY(),nodes[j].getZ()));
            }
            GLFunctions::end();
            GL_SAFE_CALL(lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
        }
        else
        {
            RTriangle triangle(this-&gt;at(0),this-&gt;at(1),this-&gt;at(2));
            GL_SAFE_CALL(glNormal3d(triangle.getNormal()[0],triangle.getNormal()[1],triangle.getNormal()[2]));

            GLFunctions::begin(GL_POLYGON);
            for (uint j=0;j&lt;this-&gt;size();j++)
            {
                if (validScalarValues)
                {
                    GL_SAFE_CALL(glTexCoord1d(scalarValues[j]));
                }
                GL_SAFE_CALL(glVertex3d(nodes[j].getX(),nodes[j].getY(),nodes[j].getZ()));
            }
            GLFunctions::end();
        }
    }

    if (validScalarValues)
    {
        GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
    }

    if (this-&gt;size() &gt; 2)
    {
        if (this-&gt;getElementGroupData().getDrawEdges() &amp;&amp; !this-&gt;getElementGroupData().getDrawWire())
        {
            GLboolean lightingEnabled;
            GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));
            GL_SAFE_CALL(glDisable(GL_LIGHTING));
            this-&gt;getGLWidget()-&gt;qglColor(QColor(Qt::black));
            GLFunctions::begin(GL_LINE_LOOP);
            for (uint j=0;j&lt;this-&gt;size();j++)
            {
                GL_SAFE_CALL(glVertex3d(nodes[j].getX(),nodes[j].getY(),nodes[j].getZ()));
            }
            GLFunctions::end();
            GL_SAFE_CALL(lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
        }
    }

    if (this-&gt;getElementGroupData().getDrawNodes())
    {
        GLboolean lightingEnabled;
        GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));
        GL_SAFE_CALL(glDisable(GL_LIGHTING));
        this-&gt;getGLWidget()-&gt;qglColor(QColor(Qt::black));
        GLFunctions::begin(GL_POINTS);
        for (uint j=0;j&lt;this-&gt;size();j++)
        {
            GL_SAFE_CALL(glVertex3d(nodes[j].getX(),nodes[j].getY(),nodes[j].getZ()));
        }
        GLFunctions::end();
        GL_SAFE_CALL(lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
    }
}
</t>
<t tx="leo.20201108101521.59">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_interpolated_entity.cpp                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   11-th June 2013                                          *
 *                                                                   *
 *  DESCRIPTION: OpenGL interpolated entity class definition         *
 *********************************************************************/

#include "gl_interpolated_entity.h"
#include "gl_interpolated_element.h"
#include "session.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.6">void GLDisplayPropertiesDialog::onBgColorChanged(const QColor &amp;color)
{
    this-&gt;pGlWidget-&gt;getGLDisplayProperties().setBgColor(color);
    this-&gt;pGlWidget-&gt;update();
}

</t>
<t tx="leo.20201108101521.60">void GLInterpolatedEntity::_init(const GLInterpolatedEntity *pGLInterpolatedEntity)
{
    if (pGLInterpolatedEntity)
    {
        this-&gt;lightingEnabled = pGLInterpolatedEntity-&gt;lightingEnabled;
        this-&gt;normalize = pGLInterpolatedEntity-&gt;normalize;
        this-&gt;lineWidth = pGLInterpolatedEntity-&gt;lineWidth;
    }
}

GLInterpolatedEntity::GLInterpolatedEntity(GLWidget *glWidget, const RInterpolatedEntity &amp;iEntity, const SessionEntityID &amp;entityID)
    : GLEntity(glWidget,entityID)
    , RInterpolatedEntity(iEntity)

{
    this-&gt;_init();
}

GLInterpolatedEntity::GLInterpolatedEntity(const GLInterpolatedEntity &amp;glInterpolatedEntity)
    : GLEntity(glInterpolatedEntity)
    , RInterpolatedEntity(glInterpolatedEntity)
{
    this-&gt;_init(&amp;glInterpolatedEntity);
}

GLInterpolatedEntity::~GLInterpolatedEntity()
{
}

GLInterpolatedEntity &amp;GLInterpolatedEntity::operator =(const GLInterpolatedEntity &amp;glInterpolatedEntity)
{
    this-&gt;GLEntity::operator =(glInterpolatedEntity);
    this-&gt;RInterpolatedEntity::operator =(glInterpolatedEntity);
    this-&gt;REntityGroup::operator =(glInterpolatedEntity);
    this-&gt;_init(&amp;glInterpolatedEntity);
    return (*this);
}

</t>
<t tx="leo.20201108101521.61">void GLInterpolatedEntity::initialize(void)
{
    if (this-&gt;getApplyEnvironmentSettings())
    {
        return;
    }

    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_NORMALIZE, &amp;this-&gt;normalize));
    GL_SAFE_CALL(glGetFloatv(GL_POINT_SIZE, &amp;this-&gt;pointSize));
    GL_SAFE_CALL(glGetFloatv(GL_LINE_WIDTH, &amp;this-&gt;lineWidth));

    GL_SAFE_CALL(glEnable(GL_NORMALIZE));
    GL_SAFE_CALL(glEnable(GL_LIGHTING));
    GL_SAFE_CALL(glPointSize(10.0f));
    GL_SAFE_CALL(glLineWidth(1.0f));
}

</t>
<t tx="leo.20201108101521.62">void GLInterpolatedEntity::finalize(void)
{
    if (this-&gt;getApplyEnvironmentSettings())
    {
        return;
    }

    GL_SAFE_CALL(this-&gt;lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
    GL_SAFE_CALL(this-&gt;normalize ? glEnable(GL_NORMALIZE) : glDisable(GL_NORMALIZE));
    GL_SAFE_CALL(glPointSize(this-&gt;pointSize));
    GL_SAFE_CALL(glLineWidth(this-&gt;lineWidth));
}

</t>
<t tx="leo.20201108101521.63">void GLInterpolatedEntity::draw(void)
{
    if (!this-&gt;getData().getVisible())
    {
        return;
    }

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());

    RVariableType scalarVariableType = this-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_SCALAR);
    uint scalarVariablePosition = rModel.findVariable(scalarVariableType);
    const RVariable *pScalarVariable = nullptr;
    if (scalarVariablePosition != RConstants::eod)
    {
        pScalarVariable = &amp;rModel.getVariable(scalarVariablePosition);
        this-&gt;texture.load(pScalarVariable-&gt;getVariableData().getValueRangeName());
    }

    RVariableType displacementVariableType = this-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT);
    uint displacementVarPosition = rModel.findVariable(displacementVariableType);
    const RVariable *pDisplacementVariable = nullptr;
    if (displacementVarPosition != RConstants::eod)
    {
        pDisplacementVariable = &amp;rModel.getVariable(displacementVarPosition);
    }

    GLEntityList *pGlEntityList = nullptr;

    switch (this-&gt;getEntityID().getType())
    {
        case R_ENTITY_GROUP_STREAM_LINE:
            pGlEntityList = &amp;this-&gt;getGLWidget()-&gt;getGLModelList().getGlStreamLineList(this-&gt;getEntityID().getEid());
            break;
        case R_ENTITY_GROUP_CUT:
            pGlEntityList = &amp;this-&gt;getGLWidget()-&gt;getGLModelList().getGlCutList(this-&gt;getEntityID().getEid());
            break;
        case R_ENTITY_GROUP_ISO:
            pGlEntityList = &amp;this-&gt;getGLWidget()-&gt;getGLModelList().getGlIsoList(this-&gt;getEntityID().getEid());
            break;
        default:
            return;
    }

    if (!pGlEntityList-&gt;getListValid(GL_ENTITY_LIST_ITEM_NORMAL))
    {
        pGlEntityList-&gt;newList(GL_ENTITY_LIST_ITEM_NORMAL);

        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            GLObject::PaintActionMask paintAction = GLObject::Draw;
            paintAction = (i == 0) ? paintAction | GLObject::Initialize : paintAction;
            paintAction = (i+1 == this-&gt;size()) ? paintAction | GLObject::Finalize : paintAction;

            GLInterpolatedElement glIElement(this-&gt;getGLWidget(),
                                             &amp;rModel,
                                             this-&gt;at(i),
                                             i,
                                             this-&gt;getData(),
                                             GL_ELEMENT_DRAW_NORMAL);
            glIElement.setScalarVariable(pScalarVariable);
            glIElement.setDisplacementVariable(pDisplacementVariable);
            glIElement.setApplyEnvironmentSettings(false);
            glIElement.paint(paintAction);
        }

        pGlEntityList-&gt;endList(GL_ENTITY_LIST_ITEM_NORMAL);
    }

    pGlEntityList-&gt;callList(GL_ENTITY_LIST_ITEM_NORMAL);

    this-&gt;texture.unload();
}
</t>
<t tx="leo.20201108101521.64">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_line.cpp                                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th February 2015                                       *
 *                                                                   *
 *  DESCRIPTION: OpenGL line class definition                        *
 *********************************************************************/

#include "gl_line.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.65">void GLLine::_init(const GLLine *pGlLine)
{
    if (pGlLine)
    {
        this-&gt;start = pGlLine-&gt;start;
        this-&gt;end = pGlLine-&gt;end;
    }
}

GLLine::GLLine(GLWidget *glWidget, const RR3Vector &amp;start, const RR3Vector &amp;end, GLfloat width)
    : GLObject(glWidget)
    , start(start)
    , end(end)
    , width(width)
{
    this-&gt;_init();
}

GLLine::GLLine(const GLLine &amp;glLine)
    : GLObject(glLine)
{
    this-&gt;_init(&amp;glLine);
}

GLLine::~GLLine()
{

}

GLLine &amp;GLLine::operator =(const GLLine &amp;glLine)
{
    this-&gt;GLObject::operator =(glLine);
    this-&gt;_init(&amp;glLine);
    return (*this);
}

</t>
<t tx="leo.20201108101521.66">void GLLine::initialize(void)
{
    // Save current settings
    GL_SAFE_CALL(glGetBooleanv(GL_NORMALIZE, &amp;this-&gt;normalizeEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    GL_SAFE_CALL(glGetFloatv(GL_LINE_WIDTH, &amp;this-&gt;lineWidth));
    // Initialize environment
    GL_SAFE_CALL(glDisable(GL_NORMALIZE));
    GL_SAFE_CALL(glDisable(GL_LIGHTING));
    GL_SAFE_CALL(glLineWidth(this-&gt;width));
}

</t>
<t tx="leo.20201108101521.67">void GLLine::finalize(void)
{
    GL_SAFE_CALL(this-&gt;normalizeEnabled ? glEnable(GL_NORMALIZE) :glDisable(GL_NORMALIZE));
    GL_SAFE_CALL(this-&gt;lightingEnabled ? glEnable(GL_LIGHTING) :glDisable(GL_LIGHTING));
    GL_SAFE_CALL(glLineWidth(this-&gt;lineWidth));
}

</t>
<t tx="leo.20201108101521.68">void GLLine::draw(void)
{
    GLFunctions::begin(GL_LINES);
    GL_SAFE_CALL(glVertex3d(this-&gt;start[0],this-&gt;start[1],this-&gt;start[2]));
    GL_SAFE_CALL(glVertex3d(this-&gt;end[0],this-&gt;end[1],this-&gt;end[2]));
    GLFunctions::end();
}
</t>
<t tx="leo.20201108101521.69">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_list.cpp                                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th March 2012                                         *
 *                                                                   *
 *  DESCRIPTION: OpenGL list class definition                        *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "gl_list.h"

GLList::GLList(GLuint nLists)
    : listBase(0)
    , nLists(0)
{
    this-&gt;setNLists(nLists);
    this-&gt;_init();
}

GLList::GLList(const GLList &amp;glList)
{
    this-&gt;_init(&amp;glList);
}

GLList::~GLList()
{
    GL_SAFE_CALL(glDeleteLists(this-&gt;getBase(),GLsizei(this-&gt;getNLists())));
}

GLList &amp;GLList::operator =(const GLList &amp;glList)
{
    this-&gt;_init(&amp;glList);
    return (*this);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.7">void GLDisplayPropertiesDialog::onBgGradientStateChanged(int state)
{
    this-&gt;pGlWidget-&gt;getGLDisplayProperties().setBgGradient(state == Qt::Checked);
    this-&gt;pGlWidget-&gt;update();
}

</t>
<t tx="leo.20201108101521.70">void GLList::_init(const GLList *pGlList)
{
    if (pGlList)
    {
        this-&gt;listBase = pGlList-&gt;listBase;
        this-&gt;nLists = pGlList-&gt;nLists;
        this-&gt;listValid = pGlList-&gt;listValid;
    }
}

GLuint GLList::getBase(void) const
{
    return this-&gt;listBase;
}

GLuint GLList::getNLists(void) const
{
    return GLuint(this-&gt;nLists);
}

</t>
<t tx="leo.20201108101521.71">void GLList::setNLists(GLuint nLists)
{
    if (this-&gt;getBase() &gt; 0)
    {
        GL_SAFE_CALL(glDeleteLists(this-&gt;getBase(),GLsizei(this-&gt;getNLists())));
    }
    GL_SAFE_CALL(this-&gt;listBase = glGenLists(GLsizei(nLists)));
    if (!glIsList(this-&gt;listBase))
    {
        RLogger::error("Failed to generate openGL lists\n");
    }
    this-&gt;listValid.resize(nLists,false);
    std::fill(this-&gt;listValid.begin(),this-&gt;listValid.end(),false);
    this-&gt;nLists = nLists;
}

</t>
<t tx="leo.20201108101521.72">bool GLList::getListValid(GLuint listPosition) const
{
    R_ERROR_ASSERT(listPosition &lt; this-&gt;getNLists());
    return this-&gt;listValid[listPosition];
}

</t>
<t tx="leo.20201108101521.73">void GLList::setListInvalid(GLuint listPosition)
{
    R_ERROR_ASSERT(listPosition &lt; this-&gt;getNLists());
    this-&gt;listValid[listPosition] = false;
}

</t>
<t tx="leo.20201108101521.74">bool GLList::getValid(void) const
{
    if (this-&gt;getBase() == 0)
    {
        return false;
    }
    else
    {
        return true;
    }
}

</t>
<t tx="leo.20201108101521.75">void GLList::newList(GLuint listPosition, GLenum mode)
{
    R_ERROR_ASSERT(listPosition &lt; this-&gt;getNLists());
    this-&gt;listValid[listPosition] = false;
    GL_SAFE_CALL(glNewList(this-&gt;getBase() + listPosition, mode));
}

</t>
<t tx="leo.20201108101521.76">void GLList::endList(GLuint listPosition)
{
    GL_SAFE_CALL(glEndList());
    this-&gt;listValid[listPosition] = true;
}

</t>
<t tx="leo.20201108101521.77">void GLList::callList(GLuint listPosition) const
{
    R_ERROR_ASSERT(listPosition &lt; this-&gt;getNLists());
    if (this-&gt;getListValid(listPosition))
    {
        R_ERROR_ASSERT(glIsList(this-&gt;getBase() + listPosition));
        GL_SAFE_CALL(glCallList(this-&gt;getBase() + listPosition));
    }
}

</t>
<t tx="leo.20201108101521.78">void GLList::callLists(void) const
{
    for (GLuint i=0;i&lt;this-&gt;getNLists();i++)
    {
        this-&gt;callList(i);
    }
}
</t>
<t tx="leo.20201108101521.79">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_model_list.cpp                                        *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th May 2012                                           *
 *                                                                   *
 *  DESCRIPTION: OpenGL Model list class definition                  *
 *********************************************************************/

#include "gl_model_list.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101521.8">void GLDisplayPropertiesDialog::onLightChanged(const RGLLight &amp;light, uint id)
{
    this-&gt;pGlWidget-&gt;getGLDisplayProperties().getLight(id) = light;
    this-&gt;pGlWidget-&gt;update();
}

</t>
<t tx="leo.20201108101521.80">void GLModelList::_init(const GLModelList *pGlModelList)
{
    this-&gt;clear();

    if (pGlModelList)
    {
        this-&gt;glPointList = pGlModelList-&gt;glPointList;
        this-&gt;glLineList = pGlModelList-&gt;glLineList;
        this-&gt;glSurfaceList = pGlModelList-&gt;glSurfaceList;
        this-&gt;glVolumeList = pGlModelList-&gt;glVolumeList;
        this-&gt;glVectorFieldList = pGlModelList-&gt;glVectorFieldList;
        this-&gt;glScalarFieldList = pGlModelList-&gt;glScalarFieldList;
        this-&gt;glStreamLineList = pGlModelList-&gt;glStreamLineList;
        this-&gt;glCutList = pGlModelList-&gt;glCutList;
        this-&gt;glIsoList = pGlModelList-&gt;glIsoList;
    }
}

GLModelList::GLModelList()
{
    this-&gt;_init();
}

GLModelList::GLModelList(const GLModelList &amp;glModelList)
{
    this-&gt;_init(&amp;glModelList);
}

GLModelList::~GLModelList()
{
}

GLModelList &amp; GLModelList::operator =(const GLModelList &amp;glModelList)
{
    this-&gt;_init(&amp;glModelList);
    return (*this);
}

</t>
<t tx="leo.20201108101521.81">void GLModelList::clear(void)
{
    this-&gt;glPointList.clear();
    this-&gt;glLineList.clear();
    this-&gt;glSurfaceList.clear();
    this-&gt;glVolumeList.clear();
    this-&gt;glVectorFieldList.clear();
    this-&gt;glScalarFieldList.clear();
    this-&gt;glStreamLineList.clear();
    this-&gt;glCutList.clear();
    this-&gt;glIsoList.clear();
}

uint GLModelList::getNGlPointLists(void) const
{
    return uint(this-&gt;glPointList.size());
}

</t>
<t tx="leo.20201108101521.82">void GLModelList::setNGlPointLists(uint nGlEntityLists)
{
    if (this-&gt;glPointList.size() != int(nGlEntityLists))
    {
        this-&gt;glPointList.clear();
        this-&gt;glPointList.resize(GLsizei(nGlEntityLists));
    }
}

</t>
<t tx="leo.20201108101521.83">const GLEntityList &amp; GLModelList::getGlPointList(uint entityID) const
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlPointLists());
    return this-&gt;glPointList[int(entityID)];
}

GLEntityList &amp;GLModelList::getGlPointList(uint entityID)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlPointLists());
    return this-&gt;glPointList[int(entityID)];
}

</t>
<t tx="leo.20201108101521.84">void GLModelList::setGlPointList(uint entityID, const GLEntityList &amp;glEntityList)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlPointLists());
    this-&gt;glPointList[int(entityID)] = glEntityList;
}

uint GLModelList::getNGlLineLists(void) const
{
    return uint(this-&gt;glLineList.size());
}

</t>
<t tx="leo.20201108101521.85">void GLModelList::setNGlLineLists(uint nGlEntityLists)
{
    if (this-&gt;glLineList.size() != int(nGlEntityLists))
    {
        this-&gt;glLineList.clear();
        this-&gt;glLineList.resize(GLsizei(nGlEntityLists));
    }
}

</t>
<t tx="leo.20201108101521.86">const GLEntityList &amp;GLModelList::getGlLineList(uint entityID) const
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlLineLists());
    return this-&gt;glLineList[int(entityID)];
}

GLEntityList &amp;GLModelList::getGlLineList(uint entityID)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlLineLists());
    return this-&gt;glLineList[int(entityID)];
}

</t>
<t tx="leo.20201108101521.87">void GLModelList::setGlLineList(uint entityID, const GLEntityList &amp;glEntityList)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlLineLists());
    this-&gt;glLineList[int(entityID)] = glEntityList;
}

uint GLModelList::getNGlSurfaceLists(void) const
{
    return uint(this-&gt;glSurfaceList.size());
}

</t>
<t tx="leo.20201108101521.88">void GLModelList::setNGlSurfaceLists(uint nGlEntityLists)
{
    if (this-&gt;glSurfaceList.size() != int(nGlEntityLists))
    {
        this-&gt;glSurfaceList.clear();
        this-&gt;glSurfaceList.resize(GLsizei(nGlEntityLists));
    }
}

</t>
<t tx="leo.20201108101521.89">const GLEntityList &amp;GLModelList::getGlSurfaceList(uint entityID) const
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlSurfaceLists());
    return this-&gt;glSurfaceList[int(entityID)];
}

GLEntityList &amp;GLModelList::getGlSurfaceList(uint entityID)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlSurfaceLists());
    return this-&gt;glSurfaceList[int(entityID)];
}

</t>
<t tx="leo.20201108101521.9">void GLDisplayPropertiesDialog::onDefaultClicked(void)
{
    this-&gt;propertyTree-&gt;clear();
    QString fileName = this-&gt;pGlWidget-&gt;getGLDisplayProperties().getFileName();
    this-&gt;pGlWidget-&gt;getGLDisplayProperties().operator =(GLDisplayProperties());
    this-&gt;pGlWidget-&gt;getGLDisplayProperties().setFileName(fileName);
    this-&gt;populate();
    this-&gt;pGlWidget-&gt;update();
}

</t>
<t tx="leo.20201108101521.90">void GLModelList::setGlSurfaceList(uint entityID, const GLEntityList &amp;glEntityList)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlSurfaceLists());
    this-&gt;glSurfaceList[int(entityID)] = glEntityList;
}

uint GLModelList::getNGlVolumeLists(void) const
{
    return uint(this-&gt;glVolumeList.size());
}

</t>
<t tx="leo.20201108101521.91">void GLModelList::setNGlVolumeLists(uint nGlEntityLists)
{
    if (this-&gt;glVolumeList.size() != int(nGlEntityLists))
    {
        this-&gt;glVolumeList.clear();
        this-&gt;glVolumeList.resize(GLsizei(nGlEntityLists));
    }
}

</t>
<t tx="leo.20201108101521.92">const GLEntityList &amp;GLModelList::getGlVolumeList(uint entityID) const
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlVolumeLists());
    return this-&gt;glVolumeList[int(entityID)];
}

GLEntityList &amp;GLModelList::getGlVolumeList(uint entityID)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlVolumeLists());
    return this-&gt;glVolumeList[int(entityID)];
}

</t>
<t tx="leo.20201108101521.93">void GLModelList::setGlVolumeList(uint entityID, const GLEntityList &amp;glEntityList)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlVolumeLists());
    this-&gt;glVolumeList[int(entityID)] = glEntityList;
}

uint GLModelList::getNGlVectorFieldLists(void) const
{
    return uint(this-&gt;glVectorFieldList.size());
}

</t>
<t tx="leo.20201108101521.94">void GLModelList::setNGlVectorFieldLists(uint nGlEntityLists)
{
    if (this-&gt;glVectorFieldList.size() != int(nGlEntityLists))
    {
        this-&gt;glVectorFieldList.clear();
        this-&gt;glVectorFieldList.resize(GLsizei(nGlEntityLists));
    }
}

</t>
<t tx="leo.20201108101521.95">const GLEntityList &amp;GLModelList::getGlVectorFieldList(uint entityID) const
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlVectorFieldLists());
    return this-&gt;glVectorFieldList[int(entityID)];
}

GLEntityList &amp;GLModelList::getGlVectorFieldList(uint entityID)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlVectorFieldLists());
    return this-&gt;glVectorFieldList[int(entityID)];
}

</t>
<t tx="leo.20201108101521.96">void GLModelList::setGlVectorFieldList(uint entityID, const GLEntityList &amp;glEntityList)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlVectorFieldLists());
    this-&gt;glVectorFieldList[int(entityID)] = glEntityList;
}

uint GLModelList::getNGlScalarFieldLists(void) const
{
    return uint(this-&gt;glScalarFieldList.size());
}

</t>
<t tx="leo.20201108101521.97">void GLModelList::setNGlScalarFieldLists(uint nGlEntityLists)
{
    if (this-&gt;glScalarFieldList.size() != int(nGlEntityLists))
    {
        this-&gt;glScalarFieldList.clear();
        this-&gt;glScalarFieldList.resize(GLsizei(nGlEntityLists));
    }
}

</t>
<t tx="leo.20201108101521.98">const GLEntityList &amp;GLModelList::getGlScalarFieldList(uint entityID) const
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlScalarFieldLists());
    return this-&gt;glScalarFieldList[int(entityID)];
}

GLEntityList &amp;GLModelList::getGlScalarFieldList(uint entityID)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlScalarFieldLists());
    return this-&gt;glScalarFieldList[int(entityID)];
}

</t>
<t tx="leo.20201108101521.99">void GLModelList::setGlScalarFieldList(uint entityID, const GLEntityList &amp;glEntityList)
{
    R_ERROR_ASSERT(entityID &lt; this-&gt;getNGlScalarFieldLists());
    this-&gt;glScalarFieldList[int(entityID)] = glEntityList;
}

uint GLModelList::getNGlStreamLineLists(void) const
{
    return uint(this-&gt;glStreamLineList.size());
}

</t>
<t tx="leo.20201108101522.1">void GLSimplexPolygon::_init(const GLSimplexPolygon *pGlPolygon)
{
    if (pGlPolygon)
    {
        this-&gt;thickness = pGlPolygon-&gt;thickness;
    }
}

GLSimplexPolygon::GLSimplexPolygon(GLWidget *glWidget, const std::vector&lt;RR3Vector&gt; &amp;nodes, double thickness)
    : GLSimplex(glWidget,nodes)
    , thickness(thickness)
{
    this-&gt;_init();
}

GLSimplexPolygon::GLSimplexPolygon(const GLSimplexPolygon &amp;glPolygon)
    : GLSimplex(glPolygon)
{
    this-&gt;_init(&amp;glPolygon);
}

GLSimplexPolygon::~GLSimplexPolygon()
{

}

GLSimplexPolygon &amp;GLSimplexPolygon::operator =(const GLSimplexPolygon &amp;glPolygon)
{
    this-&gt;GLSimplex::operator =(glPolygon);
    this-&gt;_init(&amp;glPolygon);
    return (*this);
}

</t>
<t tx="leo.20201108101522.10">void GLSimplexSegment::initialize(void)
{

}

</t>
<t tx="leo.20201108101522.100">void GLWidget::qglColor(const QColor &amp;color)
{
    GL_SAFE_CALL(glColor4d(color.redF(),color.greenF(),color.blueF(),color.alphaF()));
}

</t>
<t tx="leo.20201108101522.101">void GLWidget::qglClearColor(const QColor &amp;clearColor)
{
    GL_SAFE_CALL(glClearColor(GLclampf(clearColor.redF()),
                              GLclampf(clearColor.greenF()),
                              GLclampf(clearColor.blueF()),
                              GLclampf(clearColor.alphaF())));
}

</t>
<t tx="leo.20201108101522.102">void GLWidget::renderText(double x, double y, double z, const QString &amp;str, const QFont &amp;font)
{
    // Identify x and y locations to render text within widget
    int height = this-&gt;height();
    GLdouble model[4][4], proj[4][4];
    GLint view[4];
    GL_SAFE_CALL(glGetDoublev(GL_MODELVIEW_MATRIX, &amp;model[0][0]));
    GL_SAFE_CALL(glGetDoublev(GL_PROJECTION_MATRIX, &amp;proj[0][0]));
    GL_SAFE_CALL(glGetIntegerv(GL_VIEWPORT, &amp;view[0]));
    GLdouble textPosX = 0, textPosY = 0, textPosZ = 0;
    this-&gt;project(x, y, z,
                  &amp;model[0][0], &amp;proj[0][0], &amp;view[0],
                  &amp;textPosX, &amp;textPosY, &amp;textPosZ);
    textPosY = height - textPosY; // y is inverted

    // Retrieve last OpenGL color to use as a font color
    GLdouble glColor[4];
    GL_SAFE_CALL(glGetDoublev(GL_CURRENT_COLOR, glColor));
    QColor fontColor;
    fontColor.setRedF(qreal(glColor[0]));
    fontColor.setGreenF(qreal(glColor[1]));
    fontColor.setBlueF(qreal(glColor[2]));
    fontColor.setAlphaF(qreal(glColor[3]));

    this-&gt;glTextRenderer.add(GLTextRendererItem(fontColor,font,QPointF(textPosX, textPosY)," " + str));
}
</t>
<t tx="leo.20201108101522.103">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   graph_data.cpp                                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th March 2013                                         *
 *                                                                   *
 *  DESCRIPTION: Graph data class definition                         *
 *********************************************************************/

#include &lt;algorithm&gt;

#include "graph_data.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.104">void GraphData::_init(const GraphData *pGraphData)
{
    if (pGraphData)
    {
        this-&gt;typeMask = pGraphData-&gt;typeMask;
        this-&gt;title = pGraphData-&gt;title;
        this-&gt;xlabel = pGraphData-&gt;xlabel;
        this-&gt;ylabel = pGraphData-&gt;ylabel;
        this-&gt;lLimit = pGraphData-&gt;lLimit;
        this-&gt;uLimit = pGraphData-&gt;uLimit;
    }
}

GraphData::GraphData()
    : lLimit(0.0)
    , uLimit(0.0)
{
    this-&gt;_init();
}

GraphData::GraphData(const GraphData &amp;graphData) : QMap&lt;double,RRVector&gt;(graphData)
{
    this-&gt;_init(&amp;graphData);
}

GraphData &amp;GraphData::operator =(const GraphData &amp;graphData)
{
    QMap::operator =(graphData);
    this-&gt;_init(&amp;graphData);
    return (*this);
}

GraphTypeMask GraphData::getTypeMask(void) const
{
    return this-&gt;typeMask;
}

</t>
<t tx="leo.20201108101522.105">void GraphData::setTypeMask(GraphTypeMask typeMask)
{
    this-&gt;typeMask = typeMask;
}

</t>
<t tx="leo.20201108101522.106">const QString &amp;GraphData::getTitle(void) const
{
    return this-&gt;title;
}

</t>
<t tx="leo.20201108101522.107">void GraphData::setTitle(const QString &amp;title)
{
    this-&gt;title = title;
}

</t>
<t tx="leo.20201108101522.108">const QString &amp;GraphData::getXLabel(void) const
{
    return this-&gt;xlabel;
}

</t>
<t tx="leo.20201108101522.109">void GraphData::setXLabel(const QString &amp;xlabel)
{
    this-&gt;xlabel = xlabel;
}

</t>
<t tx="leo.20201108101522.11">void GLSimplexSegment::finalize(void)
{

}

</t>
<t tx="leo.20201108101522.110">const QString &amp;GraphData::getYLabel(void) const
{
    return this-&gt;ylabel;
}

</t>
<t tx="leo.20201108101522.111">void GraphData::setYLabel(const QString &amp;ylabel)
{
    this-&gt;ylabel = ylabel;
}

double GraphData::getLLimit() const
{
    return this-&gt;lLimit;
}

double GraphData::getULimit() const
{
    return this-&gt;uLimit;
}

</t>
<t tx="leo.20201108101522.112">void GraphData::setLimits(double lLimit, double uLimit)
{
    this-&gt;lLimit = lLimit;
    this-&gt;uLimit = uLimit;
}

double GraphData::findXMin(void) const
{
    double value = 0.0;
    bool firstValue = true;

    GraphData::const_iterator iter = this-&gt;constBegin();
    while (iter != this-&gt;constEnd()) {
        if (firstValue)
        {
            value = iter.key();
            firstValue = false;
        }
        else
        {
            value = std::min(value,iter.key());
        }
        ++iter;
    }

    return value;
}

double GraphData::findXMax(void) const
{
    double value = 0.0;
    bool firstValue = true;

    GraphData::const_iterator iter = this-&gt;constBegin();
    while (iter != this-&gt;constEnd()) {
        if (firstValue)
        {
            value = iter.key();
            firstValue = false;
        }
        else
        {
            value = std::max(value,iter.key());
        }
        ++iter;
    }

    return value;
}

double GraphData::findYMin(void) const
{
    double value = 0.0;
    bool firstValue = true;

    GraphData::const_iterator iter = this-&gt;constBegin();
    while (iter != this-&gt;constEnd())
    {
        const RRVector &amp;rValues = iter.value();
        for (unsigned int i=0;i&lt;rValues.size();i++)
        {
            if (firstValue)
            {
                value = rValues[i];
                firstValue = false;
            }
            else
            {
                value = std::min(value,rValues[i]);
            }
        }
        ++iter;
    }

    return value;
}

double GraphData::findYMax(void) const
{
    double value = 0.0;
    bool firstValue = true;

    GraphData::const_iterator iter = this-&gt;constBegin();
    while (iter != this-&gt;constEnd())
    {
        const RRVector &amp;rValues = iter.value();
        for (unsigned int i=0;i&lt;rValues.size();i++)
        {
            if (firstValue)
            {
                value = rValues[i];
                firstValue = false;
            }
            else
            {
                value = std::max(value,rValues[i]);
            }
        }
        ++iter;
    }

    return value;
}

double GraphData::roundKey(double x) const
{
    double x1 = 0.0;
    double x2 = 0.0;
    bool firstValue = true;

    double xmin = this-&gt;findXMin();
    double xmax = this-&gt;findXMax();

    x = (x &lt; xmin) ? xmin : x;
    x = (x &gt; xmax) ? xmax : x;

    GraphData::const_iterator iter = this-&gt;constBegin();
    while (iter != this-&gt;constEnd())
    {
        if (firstValue)
        {
            x1 = iter.key();
            x2 = x1;
            firstValue = false;
        }
        else
        {
            x2 = iter.key();
        }
        if (x1 &lt;= x &amp;&amp; x &lt;= x2)
        {
            if (x-x1 &lt; x2-x)
            {
                return x1;
            }
            else
            {
                return x2;
            }
        }
        x1 = x2;
        ++iter;
    }
    return x;
}

RRVector GraphData::findValue(double x) const
{
    double x1 = 0.0;
    double x2 = 0.0;
    RRVector y1;
    RRVector y2;
    double ratio = 0.0;
    bool firstValue = true;

    double xmin = this-&gt;findXMin();
    double xmax = this-&gt;findXMax();

    x = (x &lt; xmin) ? xmin : x;
    x = (x &gt; xmax) ? xmax : x;

    GraphData::const_iterator iter = this-&gt;constBegin();
    while (iter != this-&gt;constEnd())
    {
        if (firstValue)
        {
            x1 = iter.key();
            y1 = iter.value();
            x2 = x1;
            y2 = y1;
            firstValue = false;
        }
        else
        {
            x2 = iter.key();
            y2 = iter.value();
        }
        if (x1 &lt;= x &amp;&amp; x &lt;= x2)
        {
            if (std::abs(x1-x2) &lt; RConstants::eps)
            {
                ratio = 0.0;
            }
            else
            {
                ratio = (x-x1)/(x2-x1);
            }
            break;
        }
        x1 = x2;
        y1 = y2;
        ++iter;
    }

    ratio = ratio &lt; 0.5 ? 0.0 : 1.0;

    RRVector values(uint(y1.size() &gt; y2.size() ? y1.size() : y2.size()));
    values.fill(0.0);
    for (unsigned int i=0;i&lt;values.size();i++)
    {
        if (i &lt; y1.size() &amp;&amp; i &lt; y2.size())
        {
            values[i] = ratio*(y2[i]-y1[i])+y1[i];
        }
    }

    return values;
}

uint GraphData::getNDataFields(void) const
{
    GraphData::const_iterator iter = this-&gt;constBegin();
    uint nData = 0;
    while (iter != this-&gt;constEnd())
    {
        nData = std::max(nData,uint(iter.value().size()));
        ++iter;
    }
    return nData;
}
</t>
<t tx="leo.20201108101522.113">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   graph_dialog.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   22-nd March 2013                                         *
 *                                                                   *
 *  DESCRIPTION: Graph dialog class definition                       *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;

#include "graph_dialog.h"

GraphDialog::GraphDialog(GraphObject *graphObject, QWidget *parent) :
    QDialog(parent)
{
    QIcon closeIcon(":/icons/file/pixmaps/range-close.svg");

    this-&gt;setWindowTitle(tr("Graph"));
    this-&gt;resize(600,400);

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    this-&gt;graphWidget = new GraphWidget(graphObject,true,this);
    mainLayout-&gt;addWidget(this-&gt;graphWidget);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(buttonsLayout);

    buttonsLayout-&gt;addStretch(1);

    QPushButton *closeButton = new QPushButton(closeIcon, tr("Close"));
    closeButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(closeButton);

    QObject::connect(closeButton,&amp;QPushButton::clicked,this,&amp;QDialog::reject);
}

GraphWidget *GraphDialog::getGraphWidget(void)
{
    return this-&gt;graphWidget;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.114">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   graph_object.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th March 2014                                          *
 *                                                                   *
 *  DESCRIPTION: Graph object class definition                       *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "graph_object.h"

GraphObject::GraphObject(QObject *parent) :
    QObject(parent)
{
    this-&gt;sourceReadTimer = new QTimer(this);
    this-&gt;sourceReadTimer-&gt;setSingleShot(false);
    QObject::connect(this-&gt;sourceReadTimer,
                     &amp;QTimer::timeout,
                     this,
                     &amp;GraphObject::loadData);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.115">const GraphData &amp;GraphObject::getData(void) const
{
    return this-&gt;graphData;
}

GraphData &amp;GraphObject::getData(void)
{
    return this-&gt;graphData;
}

</t>
<t tx="leo.20201108101522.116">void GraphObject::setData(const GraphData &amp;graphData)
{
    this-&gt;graphData = graphData;
    this-&gt;setDataChanged();
}

</t>
<t tx="leo.20201108101522.117">void GraphObject::setDataChanged(void)
{
    emit this-&gt;dataChanged();
}

uint GraphObject::getSourceReadInterval(void) const
{
    return this-&gt;sourceReadInterval;
}

</t>
<t tx="leo.20201108101522.118">void GraphObject::setSourceReadInterval(uint sourceReadInterval)
{
    this-&gt;sourceReadInterval = sourceReadInterval;
    this-&gt;sourceReadTimer-&gt;stop();
    if (this-&gt;sourceReadInterval &gt; 0)
    {
        this-&gt;sourceReadTimer-&gt;start(int(this-&gt;sourceReadInterval));
    }
}

</t>
<t tx="leo.20201108101522.119">void GraphObject::readSource(void)
{

}

</t>
<t tx="leo.20201108101522.12">void GLSimplexSegment::draw(void)
{
    uint nn = uint(this-&gt;nodes.size());
    uint nd = 0;

    // Currently only line with two nodes is supported
    if (nn != 2)
    {
        return;
    }

    bool volumeElement = (this-&gt;crossArea &gt; RConstants::eps);
    bool useTexture = (this-&gt;nodeTextureCoordinates.size() == nn);

    if (volumeElement)
    {
        nd = 4*4;
    }

    std::vector&lt;RNode&gt; nodes1;
    std::vector&lt;RNode&gt; nodes2;

    if (volumeElement)
    {
        nodes1.resize(nd);
        nodes2.resize(nd);

        RR3Vector v1(this-&gt;nodes[0]);
        RR3Vector direction(this-&gt;nodes[1][0]-this-&gt;nodes[0][0],
                            this-&gt;nodes[1][1]-this-&gt;nodes[0][1],
                            this-&gt;nodes[1][2]-this-&gt;nodes[0][2]);
        double distance = direction.length();
        direction.normalize();

        RR3Vector orth1(direction.findOrthogonal());

        RR3Vector orth2;
        RR3Vector::cross(direction,orth1,orth2);

        double r = std::sqrt(this-&gt;crossArea / RConstants::pi);
        orth1 *= r;
        orth2 *= r;

        RR3Vector start, end;
        RRVector::add(v1,orth1,start);
        RRVector::add(v1,orth2,end);

        RRMatrix R;
        RTriangle(v1,start,end).findRotationMatrix(R);

        direction *= distance;

        double da = 2.0 * RConstants::pi / double(nd);
        for (uint i=0;i&lt;nd;i++)
        {
            double x = std::sin(da*i);
            double y = std::cos(da*i);
            RR3Vector lp(x,y,0.0);
            lp *= r;

            RR3Vector gp1;
            RRMatrix::mlt(R,lp,gp1);
            RRVector::add(gp1,v1,gp1);

            RR3Vector gp2;
            RRVector::add(gp1,direction,gp2);

            nodes1[i] = RNode(gp1);
            nodes2[i] = RNode(gp2);
        }
    }

    if (this-&gt;drawTypeMask &amp; GLSimplex::NodeIds)
    {
        this-&gt;getGLWidget()-&gt;qglColor(QColor(Qt::black));

        for (uint i=0;i&lt;nn;i++)
        {
            this-&gt;getGLWidget()-&gt;renderText(this-&gt;nodes[i][0],
                                            this-&gt;nodes[i][1],
                                            this-&gt;nodes[i][2],
                                            QString::number(this-&gt;nodeIds[i]),
                                            QFont("Courier",8));
        }
    }
    if (this-&gt;drawTypeMask &amp; GLSimplex::ElementId)
    {
        this-&gt;getGLWidget()-&gt;qglColor(QColor(Qt::black));

        double x = 0.0, y = 0.0, z = 0.0;

        for (uint i=0;i&lt;nn;i++)
        {
            x += this-&gt;nodes[i][0];
            y += this-&gt;nodes[i][1];
            z += this-&gt;nodes[i][2];
        }

        x /= double(nn);
        y /= double(nn);
        z /= double(nn);

        this-&gt;getGLWidget()-&gt;renderText(x,y,z,QString::number(this-&gt;id),QFont("Courier",8));
    }
//    if (drawTypeMask &amp; GLSimplex::ElementEdges)
//    {
//        this-&gt;getGLWidget()-&gt;qglColor(Qt::black);
//        this-&gt;drawWired(nodes1,nodes2,volumeElement,useTexture);
//    }
    if (this-&gt;drawTypeMask &amp; GLSimplex::ElementNodes)
    {
        this-&gt;getGLWidget()-&gt;qglColor(Qt::black);
        this-&gt;drawNodes();
    }
    if (this-&gt;drawTypeMask &amp; GLSimplex::Wired)
    {
        this-&gt;getGLWidget()-&gt;qglColor(useTexture ? Qt::white : this-&gt;color);
        this-&gt;drawWired(nodes1,nodes2,volumeElement,useTexture);
    }
    if (this-&gt;drawTypeMask &amp; GLSimplex::Normal)
    {
        this-&gt;getGLWidget()-&gt;qglColor(useTexture ? Qt::white : this-&gt;color);
        this-&gt;drawNormal(nodes1,nodes2,volumeElement,useTexture);
    }
}

</t>
<t tx="leo.20201108101522.120">void GraphObject::loadData(void)
{
    try
    {
        this-&gt;readSource();
    }
    catch (RError &amp;error)
    {
        RLogger::error("Failed to read graph source. %s\n",error.getMessage().toUtf8().constData());
        return;
    }

    this-&gt;setDataChanged();
}
</t>
<t tx="leo.20201108101522.121">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   graph_widget.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   header file (*.cpp)                                      *
 *  DATE:   20-th March 2013                                         *
 *                                                                   *
 *  DESCRIPTION: Graph widget class definition                       *
 *********************************************************************/

#include &lt;cmath&gt;
#include &lt;QPainter&gt;
#include &lt;QPaintEvent&gt;

#include "color.h"
#include "graph_widget.h"

GraphWidget::GraphWidget(GraphObject *graphObject, bool editLimits, QWidget *parent) :
    QWidget(parent),
    graphObject(graphObject),
    xMargin(5.0),
    yMargin(5.0),
    pointWidth(5.0),
    lineWidth(5.0),
    barWidth(0.0),
    spacing(2.0),
    titleFontSize(14),
    labelFontSize(12),
    labelSpace(this-&gt;labelFontSize*2.0),
    xAxisSpace(this-&gt;labelFontSize*2.0),
    yAxisSpace(this-&gt;labelFontSize*2.),
    showPointer(true),
    snapPointerX(true),
    snapPointerY(true),
    editLimits(editLimits),
    paintGraphLimits(false),
    paintX0(false),
    paintY0(false)
{
    this-&gt;graphObject-&gt;setParent(this);

    QObject::connect(this-&gt;graphObject,
                     &amp;GraphObject::dataChanged,
                     this,
                     &amp;GraphWidget::onGraphDataChanged);

    this-&gt;setSizePolicy(QSizePolicy(QSizePolicy::Expanding,QSizePolicy::Expanding));
    this-&gt;setFocusPolicy(Qt::StrongFocus);
    if (this-&gt;showPointer)
    {
        this-&gt;setMouseTracking(true);
    }

    this-&gt;xMin = this-&gt;graphObject-&gt;getData().findXMin();
    this-&gt;xMax = this-&gt;graphObject-&gt;getData().findXMax();
    this-&gt;yMin = this-&gt;graphObject-&gt;getData().findYMin();
    this-&gt;yMax = this-&gt;graphObject-&gt;getData().findYMax();
}

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20201108101522.122">void GraphWidget::setShowPointer(bool showPointer, bool snapPointerX, bool snapPointerY)
{
    this-&gt;showPointer = showPointer;
    this-&gt;snapPointerX = snapPointerX;
    this-&gt;snapPointerY = snapPointerY;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.123">void GraphWidget::setPaintGraphLimits(bool paintGraphLimits)
{
    this-&gt;paintGraphLimits = paintGraphLimits;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.124">void GraphWidget::setPaintX0(bool paintX0)
{
    this-&gt;paintX0 = paintX0;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.125">void GraphWidget::setPaintY0(bool paintY0)
{
    this-&gt;paintY0 = paintY0;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.126">void GraphWidget::paintEvent(QPaintEvent *event)
{
    this-&gt;paintSetup();

    QPainter painter;
    painter.begin(this);
    painter.setRenderHint(QPainter::Antialiasing);

    painter.fillRect(event-&gt;rect(), QBrush(Qt::white));

    if (this-&gt;paintX0)
    {
        this-&gt;paintXLine(painter,0.0);
    }
    if (this-&gt;paintY0)
    {
        this-&gt;paintYLine(painter,0.0);
    }

    uint nDataFields = this-&gt;graphObject-&gt;getData().getNDataFields();
    for (uint i=0;i&lt;nDataFields;i++)
    {
        if (this-&gt;graphObject-&gt;getData().getTypeMask() &amp; GRAPH_BARS)
        {
            this-&gt;paintBars(painter,i);
        }

        if (this-&gt;graphObject-&gt;getData().getTypeMask() &amp; GRAPH_LINES)
        {
            this-&gt;paintLines(painter,i);
        }

        if (this-&gt;graphObject-&gt;getData().getTypeMask() &amp; GRAPH_POINTS)
        {
            this-&gt;paintPoints(painter,i);
        }

        if (this-&gt;showPointer)
        {
            this-&gt;paintPointer(painter,i);
            this-&gt;paintPosition(painter,i);
        }
    }

    if (this-&gt;paintGraphLimits)
    {
        this-&gt;paintLimits(painter);
    }
    this-&gt;paintTitle(painter);
    this-&gt;paintXLabel(painter);
    this-&gt;paintYLabel(painter);
    this-&gt;paintXAxis(painter);
    this-&gt;paintYAxis(painter);

    painter.end();
}

</t>
<t tx="leo.20201108101522.127">void GraphWidget::mousePressEvent(QMouseEvent *mouseEvent)
{
    this-&gt;mousePosition = mouseEvent-&gt;pos();


    if (mouseEvent-&gt;buttons() &amp; Qt::LeftButton)
    {
        if (this-&gt;editLimits)
        {
            this-&gt;updateLimits();
        }
    }

    if (this-&gt;showPointer)
    {
        this-&gt;update();
    }
}

</t>
<t tx="leo.20201108101522.128">void GraphWidget::mouseMoveEvent(QMouseEvent *mouseEvent)
{
    this-&gt;mousePosition = mouseEvent-&gt;pos();

    if (mouseEvent-&gt;buttons() &amp; Qt::LeftButton)
    {
        if (this-&gt;editLimits)
        {
            this-&gt;updateLimits();
        }
    }

    if (this-&gt;showPointer)
    {
        this-&gt;update();
    }
}

</t>
<t tx="leo.20201108101522.129">void GraphWidget::enterEvent(QEvent *)
{
    this-&gt;setFocus();
}

</t>
<t tx="leo.20201108101522.13">void GLSimplexSegment::drawNormal(const std::vector&lt;RNode&gt; &amp;nodes1, const std::vector&lt;RNode&gt; &amp;nodes2, bool volumeElement, bool useTexture)
{
    GLboolean lightingEnabled;
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));

    if (useTexture)
    {
        GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
    }

    if (volumeElement)
    {
        uint nn = uint(nodes1.size());

        GLObject::glNormalVector(RTriangle(this-&gt;nodes[0],nodes1[0],nodes1[1]).getNormal());

        if (useTexture)
        {
            GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
        }
        GLFunctions::begin(GL_POLYGON);
        for (uint i=0;i&lt;nn;i++)
        {
            GLObject::glVertexNode(nodes1[i]);
        }
        GLFunctions::end();

        if (useTexture)
        {
            GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
        }
        GLFunctions::begin(GL_POLYGON);
        for (uint i=0;i&lt;nn;i++)
        {
            GLObject::glVertexNode(nodes2[i]);
        }
        GLFunctions::end();

        GLFunctions::begin(GL_QUADS);
        for (uint i=0;i&lt;nn;i++)
        {
            uint n1 = i;
            uint n2 = (i==nn-1) ? 0 : (i+1);

            GLObject::glNormalVector(RTriangle(nodes1[n1],nodes1[n2],nodes2[n2]).getNormal());

            if (useTexture)
            {
                GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
            }
            GLObject::glVertexNode(nodes1[n1]);
            GLObject::glVertexNode(nodes1[n2]);
            if (useTexture)
            {
                GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
            }
            GLObject::glVertexNode(nodes2[n2]);
            GLObject::glVertexNode(nodes2[n1]);
        }
        GLFunctions::end();
    }
    else
    {
        GL_SAFE_CALL(glDisable(GL_LIGHTING));

        GLFunctions::begin(GL_LINES);
        if (useTexture)
        {
            GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
        }
        GLObject::glVertexNode(this-&gt;nodes[0]);
        if (useTexture)
        {
            GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
        }
        GLObject::glVertexNode(this-&gt;nodes[1]);
        GLFunctions::end();
    }

    if (useTexture)
    {
        GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
    }

    GL_SAFE_CALL(lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
}

</t>
<t tx="leo.20201108101522.130">void GraphWidget::leaveEvent(QEvent *)
{
}

</t>
<t tx="leo.20201108101522.131">void GraphWidget::paintSetup(void)
{
    if (this-&gt;graphObject-&gt;getData().getTypeMask() &amp; GRAPH_BARS)
    {
        this-&gt;barWidth = (this-&gt;getDrawingWidth()/(this-&gt;graphObject-&gt;getData().size())) - this-&gt;spacing;
    }
    else
    {
        this-&gt;barWidth = 0.0;
    }
}

</t>
<t tx="leo.20201108101522.132">void GraphWidget::paintPoints(QPainter &amp;painter, uint dataFieldID)
{
    QVector&lt;QRect&gt; rectangles;

    GraphData::const_iterator iter = this-&gt;graphObject-&gt;getData().constBegin();
    while (iter != this-&gt;graphObject-&gt;getData().constEnd())
    {
        int x = int(std::round(this-&gt;getX(iter.key(),this-&gt;xMin,this-&gt;xMax) - this-&gt;pointWidth/2.0));
        int y = int(std::round(this-&gt;getY(iter.value()[dataFieldID],this-&gt;yMin,this-&gt;yMax) - this-&gt;pointWidth/2.0));
        int pw  = int(std::round(this-&gt;pointWidth));
        int ph = int(std::round(this-&gt;pointWidth));

        rectangles.append(QRect(x,y,pw,ph));

        ++iter;
    }

    painter.save();

    painter.setBrush(QBrush(Qt::green));
    painter.setPen(QPen(Qt::red));

    painter.drawRects(rectangles);

    painter.restore();
}

</t>
<t tx="leo.20201108101522.133">void GraphWidget::paintLines(QPainter &amp;painter, uint dataFieldID)
{
    QVector&lt;QLine&gt; lines;

    GraphData::const_iterator iter = this-&gt;graphObject-&gt;getData().constBegin();
    while (iter != this-&gt;graphObject-&gt;getData().constEnd())
    {
        int x1 = int(std::round(this-&gt;getX(iter.key(),this-&gt;xMin,this-&gt;xMax)));
        int y1 = int(std::round(this-&gt;getY(iter.value()[dataFieldID],this-&gt;yMin,this-&gt;yMax)));
        ++iter;
        if (iter == this-&gt;graphObject-&gt;getData().constEnd())
        {
            break;
        }
        int x2 = int(std::round(this-&gt;getX(iter.key(),this-&gt;xMin,this-&gt;xMax)));
        int y2 = int(std::round(this-&gt;getY(iter.value()[dataFieldID],this-&gt;yMin,this-&gt;yMax)));

        lines.append(QLine(x1,y1,x2,y2));
    }

    painter.save();

    painter.setBrush(QBrush(Qt::green));

    QList&lt;Qt::GlobalColor&gt; colorList = Color::getPaintColors();
    int colorIndex = int(dataFieldID);
    if (colorIndex &gt; colorList.size())
    {
        colorIndex = int(std::floor((std::rand()/RAND_MAX)*double(colorList.size()-1)));
    }

    painter.setPen(QPen(colorList[colorIndex]));

    painter.drawLines(lines);

    painter.restore();
}

</t>
<t tx="leo.20201108101522.134">void GraphWidget::paintBars(QPainter &amp;painter, uint dataFieldID)
{
    QVector&lt;QRect&gt; rectangles;

    GraphData::const_iterator iter = this-&gt;graphObject-&gt;getData().constBegin();
    while (iter != this-&gt;graphObject-&gt;getData().constEnd()) {
        int x = int(std::round(this-&gt;getX(iter.key(),this-&gt;xMin,this-&gt;xMax) - this-&gt;barWidth/2.0));
        int y = int(std::round(this-&gt;getY(iter.value()[dataFieldID],this-&gt;yMin,this-&gt;yMax)));
        int bh = int(std::round(this-&gt;getY(0,this-&gt;yMin,this-&gt;yMax)-y));

        rectangles.append(QRect(x,y,int(std::round(this-&gt;barWidth)),bh));

        ++iter;
    }

    painter.save();

    painter.setBrush(QBrush(QColor(50,100,200)));
    painter.setPen(QPen(QColor(50,100,200)));

    painter.drawRects(rectangles);

    painter.restore();
}

</t>
<t tx="leo.20201108101522.135">void GraphWidget::paintTitle(QPainter &amp;painter)
{
    int fontSize = this-&gt;titleFontSize;

    QFont textFont;
    textFont.setPointSize(fontSize);

    painter.save();

    painter.setPen(QPen(Qt::black));
    painter.setFont(textFont);
    int x = int(std::round(this-&gt;getX(0.0,0.0,1.0)));
    int y = int(std::round(this-&gt;getY(1.0,0.0,1.0)));
    int w = int(std::round(this-&gt;getX(1.0,0.0,1.0) - x));
    int h = int(std::round(2.0*fontSize));

    painter.drawText(QRect(x, y, w, h), Qt::AlignCenter, this-&gt;graphObject-&gt;getData().getTitle());

    painter.restore();
}

</t>
<t tx="leo.20201108101522.136">void GraphWidget::paintPointer(QPainter &amp;painter, uint dataFieldID)
{
    int xmin = int(std::round(this-&gt;getX(0.0,0.0,1.0) - this-&gt;barWidth));
    int xmax = int(std::round(this-&gt;getX(1.0,0.0,1.0) + this-&gt;barWidth));
    int ymin = int(std::round(this-&gt;getY(0.0,0.0,1.0)));
    int ymax = int(std::round(this-&gt;getY(1.0,0.0,1.0)));
    int xp = int(std::round(this-&gt;mousePosition.x()));
    int yp = int(std::round(this-&gt;mousePosition.y()));

    if (this-&gt;snapPointerX)
    {
        xp = int(std::round(this-&gt;getX(this-&gt;graphObject-&gt;getData().roundKey(this-&gt;getXValue(xp)),
                            this-&gt;xMin,
                            this-&gt;xMax)));
    }
    if (this-&gt;snapPointerY)
    {
        yp = int(std::round(this-&gt;getY(this-&gt;graphObject-&gt;getData().findValue(this-&gt;getXValue(xp))[dataFieldID],
                            this-&gt;yMin,
                            this-&gt;yMax)));
    }

    QVector&lt;QLine&gt; lines;

    if (yp &lt;= ymin &amp;&amp; yp &gt;= ymax)
    {
        lines.append(QLine(xmin,yp,xmax,yp));
    }
    if (xp &gt;= xmin &amp;&amp; xp &lt;= xmax)
    {
        lines.append(QLine(xp,ymin,xp,ymax));
    }

    painter.save();

    painter.setPen(QPen(Qt::gray));

    painter.drawLines(lines);

    painter.restore();
}

</t>
<t tx="leo.20201108101522.137">void GraphWidget::paintLimits(QPainter &amp;painter)
{
    int xl = int(std::round(this-&gt;getX(this-&gt;graphObject-&gt;getData().getLLimit(),this-&gt;xMin,this-&gt;xMax)));
    int xu = int(std::round(this-&gt;getX(this-&gt;graphObject-&gt;getData().getULimit(),this-&gt;xMin,this-&gt;xMax)));
    int xmin = int(std::round(this-&gt;getX(0.0,0.0,1.0)));
    int xmax = int(std::round(this-&gt;getX(1.0,0.0,1.0)));
    int ymin = int(std::round(this-&gt;getY(0.0,0.0,1.0)));
    int ymax = int(std::round(this-&gt;getY(1.0,0.0,1.0)));

    QVector&lt;QLine&gt; lines;
    lines.append(QLine(xl,ymin,xl,ymax));
    lines.append(QLine(xu,ymin,xu,ymax));

    QPolygon pl;

    pl.append(QPoint(xmin,ymin));
    pl.append(QPoint(xl,ymin));
    pl.append(QPoint(xl,ymax));
    pl.append(QPoint(xmin,ymax));

    QPolygon pu;

    pu.append(QPoint(xmax,ymin));
    pu.append(QPoint(xu,ymin));
    pu.append(QPoint(xu,ymax));
    pu.append(QPoint(xmax,ymax));

    painter.save();

    painter.setPen(QPen(Qt::gray));
    painter.setBrush(QBrush(QColor(100,100,100,50)));

    painter.drawPolygon(pl);
    painter.drawPolygon(pu);

    painter.setPen(QPen(Qt::black,2.0));
    painter.drawLines(lines);

    painter.restore();
}

</t>
<t tx="leo.20201108101522.138">void GraphWidget::paintXLine(QPainter &amp;painter, double value)
{
    int x = int(std::round(this-&gt;getX(value,this-&gt;xMin,this-&gt;xMax)));
    int ymin = int(std::round(this-&gt;getY(0.0,0.0,1.0)));
    int ymax = int(std::round(this-&gt;getY(1.0,0.0,1.0)));

    QVector&lt;QLine&gt; lines;
    lines.append(QLine(x,ymin,x,ymax));

    painter.save();

    painter.setPen(QPen(Qt::darkGray,1.0));
    painter.drawLines(lines);

    painter.restore();
}

</t>
<t tx="leo.20201108101522.139">void GraphWidget::paintYLine(QPainter &amp;painter, double value)
{
    int y = int(std::round(this-&gt;getY(value,this-&gt;yMin,this-&gt;yMax)));
    int xmin = int(std::round(this-&gt;getX(0.0,0.0,1.0)));
    int xmax = int(std::round(this-&gt;getX(1.0,0.0,1.0)));

    QVector&lt;QLine&gt; lines;
    lines.append(QLine(xmin,y,xmax,y));

    painter.save();

    painter.setPen(QPen(Qt::darkGray,1.0));
    painter.drawLines(lines);

    painter.restore();
}

</t>
<t tx="leo.20201108101522.14">void GLSimplexSegment::drawWired(const std::vector&lt;RNode&gt; &amp;nodes1, const std::vector&lt;RNode&gt; &amp;nodes2, bool volumeElement, bool useTexture)
{
    GLboolean lightingEnabled;
    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));

    GL_SAFE_CALL(glDisable(GL_LIGHTING));

    if (useTexture)
    {
        GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
    }

    if (volumeElement)
    {
        uint nn = uint(nodes1.size());

        if (useTexture)
        {
            GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
        }
        GLFunctions::begin(GL_LINES);
        for (uint i=0;i&lt;nn;i++)
        {
            uint n1 = i;
            uint n2 = (i==nn-1) ? 0 : (i+1);

            GLObject::glVertexNode(this-&gt;nodes[0]);
            GLObject::glVertexNode(nodes1[n1]);

            GLObject::glVertexNode(nodes1[n1]);
            GLObject::glVertexNode(nodes1[n2]);
        }
        GLFunctions::end();

        if (useTexture)
        {
            GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
        }
        GLFunctions::begin(GL_LINES);
        for (uint i=0;i&lt;nn;i++)
        {
            uint n1 = i;
            uint n2 = (i==nn-1) ? 0 : (i+1);

            GLObject::glVertexNode(this-&gt;nodes[1]);
            GLObject::glVertexNode(nodes2[n1]);

            GLObject::glVertexNode(nodes2[n1]);
            GLObject::glVertexNode(nodes2[n2]);
        }
        GLFunctions::end();

        GLFunctions::begin(GL_LINES);
        for (uint i=0;i&lt;nn;i++)
        {
            if (useTexture)
            {
                GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
            }
            GLObject::glVertexNode(nodes1[i]);
            if (useTexture)
            {
                GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
            }
            GLObject::glVertexNode(nodes2[i]);
        }
        GLFunctions::end();
    }
    else
    {
        GLFunctions::begin(GL_LINES);
        if (useTexture)
        {
            GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
        }
        GLObject::glVertexNode(this-&gt;nodes[0]);
        if (useTexture)
        {
            GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
        }
        GLObject::glVertexNode(this-&gt;nodes[1]);
        GLFunctions::end();
    }

    if (useTexture)
    {
        GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
    }

    GL_SAFE_CALL(lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
}

</t>
<t tx="leo.20201108101522.140">void GraphWidget::paintXLabel(QPainter &amp;painter)
{
    int fontSize = this-&gt;labelFontSize;

    QFont textFont;
    textFont.setPointSize(fontSize);

    painter.save();

    painter.setPen(QPen(Qt::black));
    painter.setFont(textFont);
    int x = int(std::round(this-&gt;getX(0.0,0.0,1.0)));
    int y = int(std::round(this-&gt;height() - this-&gt;labelSpace));
    int h = int(std::round(this-&gt;labelSpace));
    int w = int(std::round(this-&gt;getX(1.0,0.0,1.0) - x));

    painter.drawText(QRect(x, y, w, h), Qt::AlignCenter, this-&gt;graphObject-&gt;getData().getXLabel());

    painter.restore();
}

</t>
<t tx="leo.20201108101522.141">void GraphWidget::paintYLabel(QPainter &amp;painter)
{
    int fontSize = this-&gt;labelFontSize;

    QFont textFont;
    textFont.setPointSize(fontSize);

    painter.save();

    painter.setPen(QPen(Qt::black));
    painter.setBrush(QBrush(Qt::red));
    painter.setFont(textFont);
    int x = int(std::round(-this-&gt;getY(0.0,0.0,1.0)));
    int y = 1;
    int w = int(std::round(this-&gt;getY(0.0,0.0,1.0) - this-&gt;getY(1.0,0.0,1.0)));
    int h = int(std::round(this-&gt;labelSpace));
    painter.rotate(-90);
    painter.drawText(QRect(x, y, w, h), Qt::AlignCenter, this-&gt;graphObject-&gt;getData().getYLabel());

    painter.restore();
}

</t>
<t tx="leo.20201108101522.142">void GraphWidget::paintXAxis(QPainter &amp;painter)
{
    int fontSize = this-&gt;labelFontSize;

    QFont textFont;
    textFont.setPointSize(fontSize);

    painter.save();

    painter.setPen(QPen(Qt::black));
    painter.setFont(textFont);
    int x = int(std::round(this-&gt;getX(0.0,0.0,1.0)));
    int y = int(std::round(this-&gt;height() - (this-&gt;labelSpace + this-&gt;xAxisSpace)));
    int h = int(std::round(this-&gt;xAxisSpace));
    int w = int(std::round(this-&gt;getX(1.0,0.0,1.0) - x));

    painter.drawText(QRect(x, y, w, h), Qt::AlignLeft, QString::number(this-&gt;xMin));
    painter.drawText(QRect(x, y, w, h), Qt::AlignRight, QString::number(this-&gt;xMax));

    painter.restore();
}

</t>
<t tx="leo.20201108101522.143">void GraphWidget::paintYAxis(QPainter &amp;painter)
{
    int fontSize = this-&gt;labelFontSize;

    QFont textFont;
    textFont.setPointSize(fontSize);

    painter.save();

    painter.setPen(QPen(Qt::black));
    painter.setBrush(QBrush(Qt::red));
    painter.setFont(textFont);
    int x = int(std::round(-this-&gt;getY(0.0,0.0,1.0)));
    int y = int(std::round(this-&gt;labelSpace));
    int w = int(std::round(this-&gt;getY(0.0,0.0,1.0) - this-&gt;getY(1.0,0.0,1.0)));
    int h = int(std::round(this-&gt;yAxisSpace));
    painter.rotate(-90);

    painter.drawText(QRect(x, y, w, h), Qt::AlignLeft, QString::number(this-&gt;graphObject-&gt;getData().findYMin()));
    painter.drawText(QRect(x, y, w, h), Qt::AlignRight, QString::number(this-&gt;graphObject-&gt;getData().findYMax()));

    painter.restore();
}

</t>
<t tx="leo.20201108101522.144">void GraphWidget::paintPosition(QPainter &amp;painter,uint dataFieldID)
{
    double xValue = this-&gt;getXValue(this-&gt;mousePosition.x());
    double yValue = this-&gt;getYValue(this-&gt;mousePosition.y());

    if (this-&gt;snapPointerX)
    {
        xValue = this-&gt;graphObject-&gt;getData().roundKey(this-&gt;getXValue(this-&gt;mousePosition.x()));
    }
    if (this-&gt;snapPointerY)
    {
        yValue = this-&gt;graphObject-&gt;getData().findValue(xValue)[dataFieldID];
    }

    QString labelText = this-&gt;graphObject-&gt;getData().getXLabel() + QString(":\n")
                      + this-&gt;graphObject-&gt;getData().getYLabel() + QString(":");
    QString valueText = QString::number(xValue) + QString("\n")
                      + QString::number(yValue);

    int fontSize = this-&gt;labelFontSize;

    QFont textFont;
    textFont.setPointSize(fontSize);

    painter.save();

    painter.setPen(QPen(Qt::black));
    painter.setFont(textFont);

    QFontMetrics fm = painter.fontMetrics();
    double lw = std::max(fm.width(this-&gt;graphObject-&gt;getData().getXLabel() + QString(": ")),
    painter.drawText(QRect(x + int(std::round(lw)), y, w - int(std::round(lw)), h), Qt::AlignLeft, valueText);

    painter.restore();
}

</t>
<t tx="leo.20201108101522.145">void GraphWidget::updateLimits(void)
{
    double xp = this-&gt;getXValue(this-&gt;mousePosition.x());

    xp = (xp &lt; this-&gt;xMin) ? this-&gt;xMin : xp;
    xp = (xp &gt; this-&gt;xMax) ? this-&gt;xMax : xp;

    double dxl = std::abs(xp - this-&gt;graphObject-&gt;getData().getLLimit());
    double dxu = std::abs(xp - this-&gt;graphObject-&gt;getData().getULimit());

    if (dxl &lt; dxu)
    {
        this-&gt;graphObject-&gt;getData().setLimits(xp,this-&gt;graphObject-&gt;getData().getULimit());
    }
    else
    {
        this-&gt;graphObject-&gt;getData().setLimits(this-&gt;graphObject-&gt;getData().getLLimit(),xp);
    }
}

double GraphWidget::getDrawingWidth(void) const
{
    return this-&gt;width() - 2.0 * this-&gt;xMargin - this-&gt;labelSpace - this-&gt;yAxisSpace;
}

double GraphWidget::getDrawingHeight(void) const
{
    return this-&gt;height() - 2.0 * this-&gt;yMargin - this-&gt;labelSpace - this-&gt;xAxisSpace;
}

double GraphWidget::getX(double xValue, double xMin, double xMax) const
{
    if (std::fabs(xMax-xMin) &lt; RConstants::eps)
    {
        return 0.0;
    }

    double x = 0.0;
    double offset = this-&gt;xMargin + this-&gt;barWidth/2.0;

    x = this-&gt;width() * (xValue - xMin) / (xMax - xMin);
    x = x * (1.0 - (2.0 * offset  + this-&gt;labelSpace + this-&gt;yAxisSpace) / this-&gt;width()) + offset + this-&gt;labelSpace + this-&gt;yAxisSpace;

    return x;
}

double GraphWidget::getY(double yValue, double yMin, double yMax) const
{
    double y = 0.0;
    if (std::fabs(yMax-yMin) &gt; RConstants::eps)
    {
        y = this-&gt;height() * (1.0 - (yValue - yMin) / (yMax - yMin));
        y = y * (1.0 - (2.0 * this-&gt;yMargin + this-&gt;labelSpace + this-&gt;xAxisSpace) / this-&gt;height()) + this-&gt;yMargin;
    }
    return y;
}

double GraphWidget::getXValue(int x) const
{
    double xp = double(x);
    double x1 = this-&gt;xMargin + this-&gt;labelSpace + this-&gt;yAxisSpace + this-&gt;barWidth/2.0;
    double x2 = this-&gt;width() - this-&gt;xMargin - this-&gt;barWidth/2.0;

    if (xp &lt; x1)
    {
        xp = x1;
    }
    if (xp &gt; x2)
    {
        xp = x2;
    }

    double xr = (xp - x1)/(x2-x1);

    return this-&gt;xMin + xr * (this-&gt;xMax - this-&gt;xMin);
}

double GraphWidget::getYValue(int y) const
{
    double yp = double(y);
    double y1 = this-&gt;yMargin;
    double y2 = this-&gt;height() - this-&gt;yMargin - this-&gt;labelSpace - this-&gt;xAxisSpace;

    if (yp &lt; y1)
    {
        yp = y1;
    }
    if (yp &gt; y2)
    {
        yp = y2;
    }

    double yr = 1.0 - (yp - y1)/(y2-y1);

    return this-&gt;yMin + yr * (this-&gt;yMax - this-&gt;yMin);
}

</t>
<t tx="leo.20201108101522.146">void GraphWidget::onGraphDataChanged(void)
{
    this-&gt;xMin = this-&gt;graphObject-&gt;getData().findXMin();
    this-&gt;xMax = this-&gt;graphObject-&gt;getData().findXMax();
    this-&gt;yMin = this-&gt;graphObject-&gt;getData().findYMin();
    this-&gt;yMax = this-&gt;graphObject-&gt;getData().findYMax();

    this-&gt;update();
}
</t>
<t tx="leo.20201108101522.147">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   help_actions_widget.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th November 2017                                      *
 *                                                                   *
 *  DESCRIPTION: Help actions widget class definition                *
 *********************************************************************/

#include &lt;QSplitter&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QListWidget&gt;
#include &lt;QTextBrowser&gt;

#include &lt;rmlib.h&gt;

#include "help_actions_widget.h"
#include "main_settings.h"

HelpActionsWidget::HelpActionsWidget(const ActionDefinition *actionDefinition, QWidget *parent)
    : DocumentWidget(RFileManager::buildPath(MainSettings::getInstance().getApplicationSettings()-&gt;getHelpDir(),"action_index.html"),parent)
{
    QList&lt;ActionGroupType&gt; actionGroupTypes = ActionDefinitionItem::getGroupTypes();

    for (int i=0;i&lt;actionGroupTypes.size();i++)
    {
        QList&lt;ActionType&gt; actionTypes = actionDefinition-&gt;getActionTypes(actionGroupTypes[i]);
        for (int j=0;j&lt;actionTypes.size();j++)
        {
            if (!ACTION_TYPE_IS_ACTION(actionTypes[j]))
            {
                continue;
            }
            QString iconName(actionDefinition-&gt;getIcon(actionTypes[j]));
            if (iconName.isEmpty())
            {
                iconName = ":/icons/general/pixmaps/range-generic_action.svg";
            }
            const QString &amp;actionText(actionDefinition-&gt;getText(actionTypes[j]));
            this-&gt;addListItem(QIcon(iconName),
                              ActionDefinitionItem::getGroupName(actionGroupTypes[i]) + " &gt;&gt; " + actionText,
                              RFileManager::buildPath(MainSettings::getInstance().getApplicationSettings()-&gt;getHelpDir(),"action_" + actionText + ".html"));
        }
    }
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.148">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   help_center_dialog.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th November 2017                                      *
 *                                                                   *
 *  DESCRIPTION: Help center dialog class definition                 *
 *********************************************************************/

#include &lt;QHBoxLayout&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QTabWidget&gt;
#include &lt;QPushButton&gt;

#include "help_center_dialog.h"
#include "help_general_widget.h"
#include "help_actions_widget.h"
#include "help_tutorial_widget.h"
#include "help_tips_widget.h"
#include "main_settings.h"

HelpCenterDialog::HelpCenterDialog(QWidget *parent)
    : QDialog(parent)
{
    QIcon closeIcon(":/icons/file/pixmaps/range-close.svg");

    this-&gt;setWindowTitle(tr("Help"));
    this-&gt;resize(1300,700);

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QTabWidget *tabWidget = new QTabWidget;
    mainLayout-&gt;addWidget(tabWidget);

    HelpGeneralWidget *helpGeneralWidget = new HelpGeneralWidget;
    tabWidget-&gt;addTab(helpGeneralWidget,tr("General"));

    HelpActionsWidget *helpActionsWidget = new HelpActionsWidget(MainSettings::getInstance().getApplicationSettings()-&gt;getActionDefinition());
    tabWidget-&gt;addTab(helpActionsWidget,tr("Actions"));

    HelpTutorialWidget *helpTutorialWidget = new HelpTutorialWidget;
    tabWidget-&gt;addTab(helpTutorialWidget,tr("Tutorials"));

    HelpTipsWidget *helpTipsWidget = new HelpTipsWidget;
    tabWidget-&gt;addTab(helpTipsWidget,tr("Tips and tricks"));

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(buttonsLayout);
    buttonsLayout-&gt;addStretch(1);

    QPushButton *closeButton = new QPushButton(closeIcon, tr("Close"));
    closeButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(closeButton);

    QObject::connect(closeButton,&amp;QPushButton::clicked,this,&amp;HelpCenterDialog::close);
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.15">void GLSimplexSegment::drawNodes(void)
{
    GLFunctions::begin(GL_POINTS);
    GLObject::glVertexNode(this-&gt;nodes[0]);
    GLFunctions::end();
    GLFunctions::begin(GL_POINTS);
    GLObject::glVertexNode(this-&gt;nodes[1]);
    GLFunctions::end();
}
</t>
<t tx="leo.20201108101522.16">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_simplex_tetrahedra.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th August 2015                                        *
 *                                                                   *
 *  DESCRIPTION: OpenGL simplex tetrahedra class definition          *
 *********************************************************************/

#include "gl_simplex_tetrahedra.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.17">void GLSimplexTetrahedra::_init(const GLSimplexTetrahedra *pGlTetrahedra)
{
    if (pGlTetrahedra)
    {

    }
}

GLSimplexTetrahedra::GLSimplexTetrahedra(GLWidget *glWidget, const std::vector&lt;RR3Vector&gt; &amp;nodes)
    : GLSimplex(glWidget,nodes)
{
    this-&gt;_init();
}

GLSimplexTetrahedra::GLSimplexTetrahedra(const GLSimplexTetrahedra &amp;glTetrahedra)
    : GLSimplex(glTetrahedra)
{
    this-&gt;_init(&amp;glTetrahedra);
}

GLSimplexTetrahedra::~GLSimplexTetrahedra()
{

}

GLSimplexTetrahedra &amp;GLSimplexTetrahedra::operator =(const GLSimplexTetrahedra &amp;glTetrahedra)
{
    this-&gt;GLSimplex::operator =(glTetrahedra);
    this-&gt;_init(&amp;glTetrahedra);
    return (*this);
}

</t>
<t tx="leo.20201108101522.18">void GLSimplexTetrahedra::initialize(void)
{

}

</t>
<t tx="leo.20201108101522.19">void GLSimplexTetrahedra::finalize(void)
{

}

</t>
<t tx="leo.20201108101522.2">void GLSimplexPolygon::initialize(void)
{

}

</t>
<t tx="leo.20201108101522.20">void GLSimplexTetrahedra::draw(void)
{
    uint nn = uint(this-&gt;nodes.size());

    if (nn &lt; 4)
    {
        return;
    }

    bool useTexture = (this-&gt;nodeTextureCoordinates.size() == nn);

    if (drawTypeMask &amp; GLSimplex::NodeIds)
    {
        this-&gt;getGLWidget()-&gt;qglColor(QColor(Qt::black));

        for (uint i=0;i&lt;nn;i++)
        {
            this-&gt;getGLWidget()-&gt;renderText(this-&gt;nodes[i][0],
                                            this-&gt;nodes[i][1],
                                            this-&gt;nodes[i][2],
                                            QString::number(this-&gt;nodeIds[i]),
                                            QFont("Courier",8));
        }
    }
    if (drawTypeMask &amp; GLSimplex::ElementId)
    {
        this-&gt;getGLWidget()-&gt;qglColor(QColor(Qt::black));

        double x = 0.0, y = 0.0, z = 0.0;

        for (uint i=0;i&lt;nn;i++)
        {
            x += this-&gt;nodes[i][0];
            y += this-&gt;nodes[i][1];
            z += this-&gt;nodes[i][2];
        }

        x /= double(nn);
        y /= double(nn);
        z /= double(nn);

        this-&gt;getGLWidget()-&gt;renderText(x,y,z,QString::number(this-&gt;id),QFont("Courier",8));
    }
    if (drawTypeMask &amp; GLSimplex::ElementEdges)
    {
        this-&gt;getGLWidget()-&gt;qglColor(Qt::black);
        this-&gt;drawWired(useTexture);
    }
    if (drawTypeMask &amp; GLSimplex::ElementNodes)
    {
        this-&gt;getGLWidget()-&gt;qglColor(Qt::black);
        this-&gt;drawNodes();
    }
    if (drawTypeMask &amp; GLSimplex::Wired)
    {
        this-&gt;getGLWidget()-&gt;qglColor(useTexture ? Qt::white : this-&gt;color);
        this-&gt;drawWired(useTexture);
    }
    if (drawTypeMask &amp; GLSimplex::Normal)
    {
        this-&gt;getGLWidget()-&gt;qglColor(useTexture ? Qt::white : this-&gt;color);
        this-&gt;drawNormal(useTexture);
    }
}

</t>
<t tx="leo.20201108101522.21">void GLSimplexTetrahedra::drawNormal(bool useTexture)
{
    if (!this-&gt;edgeNodes[0] &amp;&amp; !this-&gt;edgeNodes[1] &amp;&amp; !this-&gt;edgeNodes[2] &amp;&amp; !this-&gt;edgeNodes[3])
    {
        return;
    }
    if (useTexture)
    {
        GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
    }

    GLboolean cullState;

    GL_SAFE_CALL(glGetBooleanv(GL_CULL_FACE,&amp;cullState));
    GL_SAFE_CALL(glDisable(GL_CULL_FACE));

    GLFunctions::begin(GL_TRIANGLES);
    // 021
    if (this-&gt;edgeNodes[0] &amp;&amp; this-&gt;edgeNodes[2] &amp;&amp; this-&gt;edgeNodes[1])
    {
        GLObject::glNormalVector(RR3Vector(RTriangle(RNode(this-&gt;nodes[0]),RNode(this-&gt;nodes[2]),RNode(this-&gt;nodes[1])).getNormal()));
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
        GLObject::glVertexNode(this-&gt;nodes[0]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[2]));
        GLObject::glVertexNode(this-&gt;nodes[2]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
        GLObject::glVertexNode(this-&gt;nodes[1]);
    }
    // 013
    if (this-&gt;edgeNodes[0] &amp;&amp; this-&gt;edgeNodes[1] &amp;&amp; this-&gt;edgeNodes[3])
    {
        GLObject::glNormalVector(RR3Vector(RTriangle(RNode(this-&gt;nodes[0]),RNode(this-&gt;nodes[1]),RNode(this-&gt;nodes[3])).getNormal()));
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
        GLObject::glVertexNode(this-&gt;nodes[0]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
        GLObject::glVertexNode(this-&gt;nodes[1]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[3]));
        GLObject::glVertexNode(this-&gt;nodes[3]);
    }
    // 032
    if (this-&gt;edgeNodes[0] &amp;&amp; this-&gt;edgeNodes[3] &amp;&amp; this-&gt;edgeNodes[2])
    {
        GLObject::glNormalVector(RR3Vector(RTriangle(RNode(this-&gt;nodes[0]),RNode(this-&gt;nodes[3]),RNode(this-&gt;nodes[2])).getNormal()));
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
        GLObject::glVertexNode(this-&gt;nodes[0]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[3]));
        GLObject::glVertexNode(this-&gt;nodes[3]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[2]));
        GLObject::glVertexNode(this-&gt;nodes[2]);
    }
    // 123
    if (this-&gt;edgeNodes[1] &amp;&amp; this-&gt;edgeNodes[2] &amp;&amp; this-&gt;edgeNodes[3])
    {
        GLObject::glNormalVector(RR3Vector(RTriangle(RNode(this-&gt;nodes[1]),RNode(this-&gt;nodes[2]),RNode(this-&gt;nodes[3])).getNormal()));
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
        GLObject::glVertexNode(this-&gt;nodes[1]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[2]));
        GLObject::glVertexNode(this-&gt;nodes[2]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[3]));
        GLObject::glVertexNode(this-&gt;nodes[3]);
    }
    GLFunctions::end();

    if (useTexture)
    {
        GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
    }

    GL_SAFE_CALL(cullState ? glEnable(GL_CULL_FACE) : glDisable(GL_CULL_FACE));
}

</t>
<t tx="leo.20201108101522.22">void GLSimplexTetrahedra::drawWired(bool useTexture)
{
    if (!this-&gt;edgeNodes[0] &amp;&amp; !this-&gt;edgeNodes[1] &amp;&amp; !this-&gt;edgeNodes[2] &amp;&amp; !this-&gt;edgeNodes[3])
    {
        return;
    }
    if (useTexture)
    {
        GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
    }

    GLFunctions::begin(GL_LINES);
    // 01
    if (this-&gt;edgeNodes[0] &amp;&amp; this-&gt;edgeNodes[1])
    {
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
        GLObject::glVertexNode(this-&gt;nodes[0]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
        GLObject::glVertexNode(this-&gt;nodes[1]);
    }
    // 12
    if (this-&gt;edgeNodes[1] &amp;&amp; this-&gt;edgeNodes[2])
    {
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
        GLObject::glVertexNode(this-&gt;nodes[1]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[2]));
        GLObject::glVertexNode(this-&gt;nodes[2]);
    }
    // 20
    if (this-&gt;edgeNodes[2] &amp;&amp; this-&gt;edgeNodes[0])
    {
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[2]));
        GLObject::glVertexNode(this-&gt;nodes[2]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
        GLObject::glVertexNode(this-&gt;nodes[0]);
    }
    // 30
    if (this-&gt;edgeNodes[3] &amp;&amp; this-&gt;edgeNodes[0])
    {
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[3]));
        GLObject::glVertexNode(this-&gt;nodes[3]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[0]));
        GLObject::glVertexNode(this-&gt;nodes[0]);
    }
    // 31
    if (this-&gt;edgeNodes[3] &amp;&amp; this-&gt;edgeNodes[1])
    {
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[3]));
        GLObject::glVertexNode(this-&gt;nodes[3]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[1]));
        GLObject::glVertexNode(this-&gt;nodes[1]);
    }
    // 32
    if (this-&gt;edgeNodes[3] &amp;&amp; this-&gt;edgeNodes[2])
    {
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[3]));
        GLObject::glVertexNode(this-&gt;nodes[3]);
        if (useTexture) GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[2]));
        GLObject::glVertexNode(this-&gt;nodes[2]);
    }
    GLFunctions::end();

    if (useTexture)
    {
        GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
    }
}

</t>
<t tx="leo.20201108101522.23">void GLSimplexTetrahedra::drawNodes(void)
{
    uint nn = uint(this-&gt;nodes.size());

    for (uint i=0;i&lt;nn;i++)
    {
        if (this-&gt;edgeNodes[i])
        {
            GLFunctions::begin(GL_POINTS);
            GLObject::glVertexNode(this-&gt;nodes[i]);
            GLFunctions::end();
        }
    }
}
</t>
<t tx="leo.20201108101522.24">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_texture.cpp                                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th May 2013                                            *
 *                                                                   *
 *  DESCRIPTION: OpenGL texture class definition                     *
 *********************************************************************/

#include &lt;rmlib.h&gt;

#include "gl_texture.h"

GLTexture::GLTexture()
    : texture(nullptr)
    , loaded(false)
{
}

GLTexture::~GLTexture()
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.25">void GLTexture::load(const QString &amp;file)
{
    QImage image;
    if (!image.load(file))
    {
        RLogger::warning("Failed to load texture file \'%s\'\n",file.toUtf8().constData());
        return;
    }

    this-&gt;texture = new QOpenGLTexture(QOpenGLTexture::Target1D);
    this-&gt;texture-&gt;setData(image.mirrored());

    this-&gt;texture-&gt;setMinMagFilters(QOpenGLTexture::LinearMipMapNearest,QOpenGLTexture::Linear);
    this-&gt;texture-&gt;setWrapMode(QOpenGLTexture::Repeat);

    this-&gt;texture-&gt;bind();

    this-&gt;loaded = true;
}

</t>
<t tx="leo.20201108101522.26">void GLTexture::unload(void)
{
    if (this-&gt;loaded)
    {
        this-&gt;texture-&gt;release();
        delete this-&gt;texture;
    }
    this-&gt;loaded = false;
}
</t>
<t tx="leo.20201108101522.27">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_text_renderer.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th March 2016                                         *
 *                                                                   *
 *  DESCRIPTION: OpenGL text renderer class definition               *
 *********************************************************************/

#include "gl_text_renderer.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.28">void GLTextRenderer::_init(const GLTextRenderer *pGlTextRenderer)
{
    if (pGlTextRenderer)
    {
        this-&gt;list = pGlTextRenderer-&gt;list;
    }
}

GLTextRenderer::GLTextRenderer()
{
    this-&gt;_init();
}

GLTextRenderer::GLTextRenderer(const GLTextRenderer &amp;glTextRenderer)
{
    this-&gt;_init(&amp;glTextRenderer);
}

GLTextRenderer::~GLTextRenderer()
{

}

GLTextRenderer &amp;GLTextRenderer::operator =(const GLTextRenderer &amp;glTextRenderer)
{
    this-&gt;_init(&amp;glTextRenderer);
    return (*this);
}

</t>
<t tx="leo.20201108101522.29">void GLTextRenderer::add(const GLTextRendererItem &amp;item)
{
    this-&gt;list.append(item);
}

</t>
<t tx="leo.20201108101522.3">void GLSimplexPolygon::finalize(void)
{

}

</t>
<t tx="leo.20201108101522.30">void GLTextRenderer::clear(void)
{
    this-&gt;list.clear();
}

</t>
<t tx="leo.20201108101522.31">void GLTextRenderer::render(QPainter &amp;painter) const
{
    foreach (GLTextRendererItem item, this-&gt;list)
    {
        painter.setPen(item.color);
        painter.setFont(item.font);
        painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing);
        painter.drawText(item.position,item.text);
    }
}
</t>
<t tx="leo.20201108101522.32">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_text_renderer_item.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th March 2016                                         *
 *                                                                   *
 *  DESCRIPTION: OpenGL text renderer item class definition          *
 *********************************************************************/

#include "gl_text_renderer_item.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.33">void GLTextRendererItem::_init(const GLTextRendererItem *pGlTextRendererItem)
{
    if (pGlTextRendererItem)
    {
        this-&gt;color = pGlTextRendererItem-&gt;color;
        this-&gt;font = pGlTextRendererItem-&gt;font;
        this-&gt;position = pGlTextRendererItem-&gt;position;
        this-&gt;text = pGlTextRendererItem-&gt;text;
    }
}

GLTextRendererItem::GLTextRendererItem(const QColor &amp;color, const QFont &amp;font, const QPointF &amp;position, const QString &amp;text)
    : color(color)
    , font(font)
    , position(position)
    , text(text)
{
    this-&gt;_init();
}

GLTextRendererItem::GLTextRendererItem(const GLTextRendererItem &amp;glTextRendererItem)
{
    this-&gt;_init(&amp;glTextRendererItem);
}

GLTextRendererItem::~GLTextRendererItem()
{

}

GLTextRendererItem &amp;GLTextRendererItem::operator =(const GLTextRendererItem &amp;glTextRendererItem)
{
    this-&gt;_init(&amp;glTextRendererItem);
    return (*this);
}
</t>
<t tx="leo.20201108101522.34">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_vector_field.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: OpenGL vector field class definition                *
 *********************************************************************/

#include &lt;omp.h&gt;

#include &lt;rmlib.h&gt;

#include "gl_vector_field.h"
#include "gl_arrow.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.35">class VectorFieldItem
{
    public:

        VectorFieldItem (const RR3Vector &amp;v1,
                         @others
};

</t>
<t tx="leo.20201108101522.36">                 const RR3Vector &amp;v2,
                 bool validScaleValue,
                 double scaleValue)
    : v1(v1)
    , v2(v2)
    , validScaleValue(validScaleValue)
    , scaleValue(scaleValue)
{

}

RR3Vector v1;
RR3Vector v2;
bool validScaleValue;
double scaleValue;
</t>
<t tx="leo.20201108101522.37">void GLVectorField::_init(const GLVectorField *pGlVectorField)
{
    if (pGlVectorField)
    {
        this-&gt;entityID = pGlVectorField-&gt;entityID;
        this-&gt;lightingEnabled = pGlVectorField-&gt;lightingEnabled;
        this-&gt;normalize = pGlVectorField-&gt;normalize;
        this-&gt;lineWidth = pGlVectorField-&gt;lineWidth;
    }
}

GLVectorField::GLVectorField(GLWidget *glWidget, const RVectorField &amp;vectorFied, const SessionEntityID &amp;entityID)
    : GLObject(glWidget)
    , RVectorField(vectorFied)
    , entityID(entityID)
{
    this-&gt;_init();
}

GLVectorField::GLVectorField(const GLVectorField &amp;glVectorField)
    : GLObject(glVectorField)
    , RVectorField(glVectorField)
{
    this-&gt;_init(&amp;glVectorField);
}

GLVectorField &amp;GLVectorField::operator =(const GLVectorField &amp;glVectorField)
{
    this-&gt;GLObject::operator =(glVectorField);
    this-&gt;RVectorField::operator =(glVectorField);
    this-&gt;_init(&amp;glVectorField);
    return (*this);
}

</t>
<t tx="leo.20201108101522.38">const SessionEntityID &amp;GLVectorField::getEntityID(void) const
{
    return this-&gt;entityID;
}

</t>
<t tx="leo.20201108101522.39">void GLVectorField::initialize(void)
{
    if (this-&gt;getApplyEnvironmentSettings())
    {
        return;
    }

    GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;this-&gt;lightingEnabled));
    GL_SAFE_CALL(glGetBooleanv(GL_NORMALIZE, &amp;this-&gt;normalize));
    GL_SAFE_CALL(glGetFloatv(GL_LINE_WIDTH, &amp;this-&gt;lineWidth));

    GL_SAFE_CALL(glLineWidth(1.0f));
    if (this-&gt;getData().getDrawArrowHeads())
    {
        GL_SAFE_CALL(glEnable(GL_NORMALIZE));
    }
    else
    {
        GL_SAFE_CALL(glDisable(GL_LIGHTING));
        GL_SAFE_CALL(glDisable(GL_NORMALIZE));
    }
}

</t>
<t tx="leo.20201108101522.4">void GLSimplexPolygon::draw(void)
{
    uint nn = uint(this-&gt;nodes.size());

    if (nn &lt; 3)
    {
        return;
    }

    bool volumeElement = (this-&gt;thickness &gt; RConstants::eps);
    bool useTexture = (this-&gt;nodeTextureCoordinates.size() == nn);

    std::vector&lt;RNode&gt; nodes1;
    std::vector&lt;RNode&gt; nodes2;

    nodes1.resize(nn);
    nodes2.resize(nn);

    for (uint i=0;i&lt;nn;i++)
    {
        nodes1[i] = RNode(this-&gt;nodes[i]);
        nodes2[i] = RNode(this-&gt;nodes[i]);
    }

    if (volumeElement)
    {
        RR3Vector offset(0.0,0.0,0.0);
        offset = RPolygon(nodes1).getNormal();
        offset *= this-&gt;thickness;

        for (uint i=0;i&lt;nn;i++)
        {
            nodes1[i].move(offset);
        }

        offset *= -1.0;

        for (uint i=0;i&lt;nn;i++)
        {
            nodes2[i].move(offset);
        }
    }

    if (drawTypeMask &amp; GLSimplex::NodeIds)
    {
        this-&gt;getGLWidget()-&gt;qglColor(QColor(Qt::black));

        for (uint i=0;i&lt;nn;i++)
        {
            this-&gt;getGLWidget()-&gt;renderText(nodes1[i].getX(),
                                            nodes1[i].getY(),
                                            nodes1[i].getZ(),
                                            QString::number(this-&gt;nodeIds[i]),
                                            QFont("Courier",8));
        }
    }
    if (drawTypeMask &amp; GLSimplex::ElementId)
    {
        this-&gt;getGLWidget()-&gt;qglColor(QColor(Qt::black));

        double x = 0.0, y = 0.0, z = 0.0;

        for (uint i=0;i&lt;nn;i++)
        {
            x += nodes1[i].getX();
            y += nodes1[i].getY();
            z += nodes1[i].getZ();
        }

        x /= double(nn);
        y /= double(nn);
        z /= double(nn);

        this-&gt;getGLWidget()-&gt;renderText(x,y,z,QString::number(this-&gt;id),QFont("Courier",8));
    }
    if (drawTypeMask &amp; GLSimplex::ElementEdges)
    {
        this-&gt;getGLWidget()-&gt;qglColor(Qt::black);
        this-&gt;drawWired(nodes1,nodes2,volumeElement,useTexture);
    }
    if (drawTypeMask &amp; GLSimplex::ElementNodes)
    {
        this-&gt;getGLWidget()-&gt;qglColor(Qt::black);
        this-&gt;drawNodes(nodes1,nodes2,volumeElement);
    }
    if (drawTypeMask &amp; GLSimplex::Wired)
    {
        this-&gt;getGLWidget()-&gt;qglColor(useTexture ? Qt::white : this-&gt;color);
        this-&gt;drawWired(nodes1,nodes2,volumeElement,useTexture);
    }
    if (drawTypeMask &amp; GLSimplex::Normal)
    {
        this-&gt;getGLWidget()-&gt;qglColor(useTexture ? Qt::white : this-&gt;color);
        this-&gt;drawNormal(nodes1,nodes2,volumeElement,useTexture);
    }
}

</t>
<t tx="leo.20201108101522.40">void GLVectorField::finalize(void)
{
    if (this-&gt;getApplyEnvironmentSettings())
    {
        return;
    }

    GL_SAFE_CALL(this-&gt;lightingEnabled ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING));
    GL_SAFE_CALL(this-&gt;normalize ? glEnable(GL_NORMALIZE) : glDisable(GL_NORMALIZE));
    GL_SAFE_CALL(glLineWidth(this-&gt;lineWidth));
}

</t>
<t tx="leo.20201108101522.41">void GLVectorField::draw(void)
{
    if (!this-&gt;getData().getVisible())
    {
        return;
    }

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());

    RVariableType scalarVariableType = this-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_SCALAR);
    uint scalarVariablePosition = rModel.findVariable(scalarVariableType);
    const RVariable *pScalarVariable = nullptr;
    GLTexture texture;
    if (scalarVariablePosition != RConstants::eod)
    {
        pScalarVariable = &amp;rModel.getVariable(scalarVariablePosition);
        texture.load(pScalarVariable-&gt;getVariableData().getValueRangeName());
    }

    RVariableType displacementVariableType = this-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT);
    uint displacementVariablePosition = rModel.findVariable(displacementVariableType);
    const RVariable *pDisplacementVariable = nullptr;
    if (displacementVariablePosition != RConstants::eod)
    {
        pDisplacementVariable = &amp;rModel.getVariable(displacementVariablePosition);
    }

    GLEntityList *pGlEntityList = &amp;this-&gt;getGLWidget()-&gt;getGLModelList().getGlVectorFieldList(this-&gt;getEntityID().getEid());

    if (!pGlEntityList-&gt;getListValid(GL_ENTITY_LIST_ITEM_NORMAL))
    {
        pGlEntityList-&gt;newList(GL_ENTITY_LIST_ITEM_NORMAL);

        std::vector&lt;VectorFieldItem&gt; vectorField = this-&gt;calculateField(pScalarVariable,pDisplacementVariable);

        for (uint i=0;i&lt;vectorField.size();i++)
        {
            if (vectorField[i].validScaleValue)
            {
                GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
                this-&gt;getGLWidget()-&gt;qglColor(QColor(255,255,255,255));
                GL_SAFE_CALL(glTexCoord1d(vectorField[i].scaleValue));
            }
            else
            {
                int r,g,b,a;
                this-&gt;getData().getColor(r,g,b,a);
                this-&gt;getGLWidget()-&gt;qglColor(QColor(r,g,b,a));
            }
            GLArrow arrow(this-&gt;glWidget,vectorField[i].v1,vectorField[i].v2,this-&gt;getData().getDrawArrowHeads(),this-&gt;getData().getDrawArrowFrom());
            arrow.paint();
            if (vectorField[i].validScaleValue)
            {
                GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
            }
        }

        pGlEntityList-&gt;endList(GL_ENTITY_LIST_ITEM_NORMAL);
    }

    pGlEntityList-&gt;callList(GL_ENTITY_LIST_ITEM_NORMAL);

    if (scalarVariablePosition != RConstants::eod)
    {
        texture.unload();
    }
}

std::vector&lt;VectorFieldItem&gt; GLVectorField::calculateField(const RVariable *pScalarVariable, const RVariable *pDisplacementVariable) const
{
    std::vector&lt;VectorFieldItem&gt; field;
    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());
    uint variablePosition = rModel.findVariable(this-&gt;variableType);

    if (variablePosition == RConstants::eod)
    {
        return field;
    }

    const RVariable &amp;rVariable = rModel.getVariable(variablePosition);
    double scale = rVariable.getVariableData().getScale()*0.01;

    if (!this-&gt;getData().getDrawEqualArrowLength())
    {
        double maxValue = rVariable.getMaxValue();
        if (maxValue != 0.0)
        {
            scale /= maxValue*0.5;
        }
    }

    std::vector&lt;bool&gt; nodeBook;
    if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        nodeBook.resize(rModel.getNNodes(),false);
    }

#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(this-&gt;elementGroupIDs.size());i++)
    {
        REntityGroupType entityType;
        uint entityID;

        if (!rModel.getEntityID(this-&gt;elementGroupIDs[uint(i)],entityType,entityID))
        {
            continue;
        }
        if (REntityGroup::typeIsElementGroup(entityType))
        {
            const RElementGroup *pElementGroup = rModel.getElementGroupPtr(this-&gt;elementGroupIDs[uint(i)]);
            if (!pElementGroup)
            {
                continue;
            }

            for (uint j=0;j&lt;pElementGroup-&gt;size();j++)
            {
                uint elementID = pElementGroup-&gt;get(j);
                const RElement &amp;rElement = rModel.getElement(elementID);

                std::vector&lt;double&gt; scalarValues = this-&gt;getScalarValues(elementID,rVariable.getApplyType(),pScalarVariable);
                std::vector&lt;RR3Vector&gt; displacementValues = this-&gt;getDisplacementValues(elementID,rVariable.getApplyType(),pDisplacementVariable);

                if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
                {
                    // 1. vector
                    RR3Vector v1;
                    rElement.findCenter(rModel.getNodes(),v1[0],v1[1],v1[2]);
                    if (displacementValues.size() == 1)
                    {
                        v1[0] += displacementValues[0][0];
                        v1[1] += displacementValues[0][1];
                        v1[2] += displacementValues[0][2];
                    }

                    // 2. vector
                    RR3Vector v2;

                    if (rVariable.getNVectors() &gt; 0)
                    {
                        v2[0] = rVariable.getValue(0,elementID);
                    }
                    if (rVariable.getNVectors() &gt; 1)
                    {
                        v2[1] = rVariable.getValue(1,elementID);
                    }
                    if (rVariable.getNVectors() &gt; 2)
                    {
                        v2[2] = rVariable.getValue(2,elementID);
                    }

                    if (!this-&gt;getType3D())
                    {
                        RR3Vector normal;
                        if (rElement.findNormal(rModel.getNodes(),normal[0],normal[1],normal[2]))
                        {
                            RR3Vector pv2;
                            RR3Vector::cross(normal,v2,pv2);
                            RR3Vector::cross(pv2,normal,v2);
                        }
                    }

                    if (this-&gt;getData().getDrawEqualArrowLength())
                    {
                        v2.normalize();
                    }
                    v2 *= scale;

                    bool validScalarValue = (scalarValues.size() == 1);
                    double scalarValue = validScalarValue ? scalarValues[0] : 0.0;

#pragma omp critical
                    {
                        field.push_back(VectorFieldItem(v1,v2,validScalarValue,scalarValue));
                    }
                }
                else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
                {
                    for (uint k=0;k&lt;rElement.size();k++)
                    {
                        uint nodeID = rElement.getNodeId(k);

                        bool nodeSet = false;
#pragma omp flush(nodeBook)
#pragma omp critical
                        {
                            if (nodeBook[nodeID])
                            {
                                nodeSet = true;
                            }
                            else
                            {
                                nodeBook[nodeID] = true;
                            }
                        }
                        if (nodeSet)
                        {
                            continue;
                        }

                        // 1. vector
                        RR3Vector v1;
                        v1[0] = rModel.getNode(nodeID).getX();
                        v1[1] = rModel.getNode(nodeID).getY();
                        v1[2] = rModel.getNode(nodeID).getZ();
                        if (displacementValues.size() == rElement.size())
                        {
                            v1[0] += displacementValues[k][0];
                            v1[1] += displacementValues[k][1];
                            v1[2] += displacementValues[k][2];
                        }

                        // 2. vector
                        RR3Vector v2;

                        if (rVariable.getNVectors() &gt; 0)
                        {
                            v2[0] = rVariable.getValue(0,nodeID);
                        }
                        if (rVariable.getNVectors() &gt; 1)
                        {
                            v2[1] = rVariable.getValue(1,nodeID);
                        }
                        if (rVariable.getNVectors() &gt; 2)
                        {
                            v2[2] = rVariable.getValue(2,nodeID);
                        }

                        if (!this-&gt;getType3D())
                        {
                            RR3Vector normal;
                            if (rElement.findNormal(rModel.getNodes(),normal[0],normal[1],normal[2]))
                            {
                                RR3Vector pv2;
                                RR3Vector::cross(normal,v2,pv2);
                                RR3Vector::cross(pv2,normal,v2);
                            }
                        }

                        if (this-&gt;getData().getDrawEqualArrowLength())
                        {
                            v2.normalize();
                        }
                        v2 *= scale;

                        bool validScalarValue = (scalarValues.size() == rElement.size());
                        double scalarValue = validScalarValue ? scalarValues[k] : 0.0;

#pragma omp critical
                        {
                            field.push_back(VectorFieldItem(v1,v2,validScalarValue,scalarValue));
                        }
                    }
                }
            }
        }
        else
        {
            const RInterpolatedEntity *pIEntity = nullptr;
            switch (entityType)
            {
                case R_ENTITY_GROUP_CUT:
                    pIEntity = rModel.getCutPtr(entityID);
                    break;
                case R_ENTITY_GROUP_ISO:
                    pIEntity = rModel.getIsoPtr(entityID);
                    break;
                case R_ENTITY_GROUP_STREAM_LINE:
                    pIEntity = rModel.getStreamLinePtr(entityID);
                    break;
                default:
                    RLogger::warning("Non element-type entities '%s' (%d) are not implemented for vector fields.\n",REntityGroup::getTypeName(entityType).toUtf8().constData(),entityType);
                    continue;
            }

            if (!pIEntity)
            {
                continue;
            }

            for (uint j=0;j&lt;pIEntity-&gt;size();j++)
            {
                const RInterpolatedElement &amp;rIElement = pIEntity-&gt;at(j);
                if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
                {
                    uint elementID = rIElement.at(0).getElementID();

                    // 1. vector
                    RR3Vector v1;
                    rIElement.findCenter(v1[0],v1[1],v1[2]);

                    std::vector&lt;RR3Vector&gt; displacementValues = this-&gt;getDisplacementValues(elementID,rVariable.getApplyType(),pDisplacementVariable);
                    if (displacementValues.size() == 1)
                    {
                        v1[0] += displacementValues[0][0];
                        v1[1] += displacementValues[0][1];
                        v1[2] += displacementValues[0][2];
                    }

                    // 2. vector
                    RR3Vector v2;

                    if (rVariable.getNVectors() &gt; 0)
                    {
                        v2[0] = rVariable.getValue(0,elementID);
                    }
                    if (rVariable.getNVectors() &gt; 1)
                    {
                        v2[1] = rVariable.getValue(1,elementID);
                    }
                    if (rVariable.getNVectors() &gt; 2)
                    {
                        v2[2] = rVariable.getValue(2,elementID);
                    }

                    if (!this-&gt;getType3D())
                    {
                        RR3Vector normal;
                        if (rIElement.findNormal(normal[0],normal[1],normal[2]))
                        {
                            RR3Vector pv2;
                            RR3Vector::cross(normal,v2,pv2);
                            RR3Vector::cross(pv2,normal,v2);
                        }
                    }

                    if (this-&gt;getData().getDrawEqualArrowLength())
                    {
                        v2.normalize();
                    }
                    v2 *= scale;

                    std::vector&lt;double&gt; scalarValues = this-&gt;getScalarValues(elementID,rVariable.getApplyType(),pScalarVariable);

                    bool validScalarValue = (scalarValues.size() == 1);
                    double scalarValue = validScalarValue ? scalarValues[0] : 0.0;

#pragma omp critical
                    {
                        field.push_back(VectorFieldItem(v1,v2,validScalarValue,scalarValue));
                    }

                }
                else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
                {
                    for (uint k=0;k&lt;rIElement.size();k++)
                    {
                        const RElement &amp;rElement = rModel.getElement(rIElement[k].getElementID());

                        // 1. vector
                        RR3Vector v1 = rIElement[k].toVector();

                        std::vector&lt;RR3Vector&gt; displacementValues = this-&gt;getDisplacementValues(rIElement[k].getElementID(),rVariable.getApplyType(),pDisplacementVariable);
                        if (displacementValues.size() == rElement.size())
                        {
                            std::vector&lt;double&gt; xDisplacementValues;
                            std::vector&lt;double&gt; yDisplacementValues;
                            std::vector&lt;double&gt; zDisplacementValues;

                            xDisplacementValues.resize(displacementValues.size());
                            yDisplacementValues.resize(displacementValues.size());
                            zDisplacementValues.resize(displacementValues.size());

                            for (uint l=0;l&lt;displacementValues.size();l++)
                            {
                                xDisplacementValues[l] = displacementValues[l][0];
                                yDisplacementValues[l] = displacementValues[l][1];
                                zDisplacementValues[l] = displacementValues[l][2];
                            }

                            v1[0] += rElement.interpolate(rModel.getNodes(),rIElement[k],xDisplacementValues);
                            v1[1] += rElement.interpolate(rModel.getNodes(),rIElement[k],yDisplacementValues);
                            v1[2] += rElement.interpolate(rModel.getNodes(),rIElement[k],zDisplacementValues);
                        }

                        // 2. vector
                        RR3Vector v2;

                        std::vector&lt;double&gt; elementNodeValues;
                        elementNodeValues.resize(rElement.size(),0.0);

                        for (uint l=0;l&lt;rElement.size();l++) elementNodeValues[l] = rVariable.getValue(0,rElement.getNodeId(l));
                        v2[0] = rElement.interpolate(rModel.getNodes(),rIElement[k],elementNodeValues);
                        for (uint l=0;l&lt;rElement.size();l++) elementNodeValues[l] = rVariable.getValue(1,rElement.getNodeId(l));
                        v2[1] = rElement.interpolate(rModel.getNodes(),rIElement[k],elementNodeValues);
                        for (uint l=0;l&lt;rElement.size();l++) elementNodeValues[l] = rVariable.getValue(2,rElement.getNodeId(l));
                        v2[2] = rElement.interpolate(rModel.getNodes(),rIElement[k],elementNodeValues);

                        std::vector&lt;double&gt; elementScalarValues = this-&gt;getScalarValues(rIElement[k].getElementID(),rVariable.getApplyType(),pScalarVariable);

                        bool validScalarValue = false;
                        double scalarValue = 0.0;

                        if (elementScalarValues.size() == rElement.size())
                        {
                            validScalarValue = true;
                            scalarValue = rElement.interpolate(rModel.getNodes(),rIElement[k],elementScalarValues);
                        }
                        if (!this-&gt;getType3D())
                        {
                            RR3Vector normal;
                            if (rIElement.findNormal(normal[0],normal[1],normal[2]))
                            {
                                RR3Vector pv2;
                                RR3Vector::cross(normal,v2,pv2);
                                RR3Vector::cross(pv2,normal,v2);
                            }
                        }

                        if (this-&gt;getData().getDrawEqualArrowLength())
                        {
                            v2.normalize();
                        }
                        v2 *= scale;

#pragma omp critical
                        {
                            field.push_back(VectorFieldItem(v1,v2,validScalarValue,scalarValue));
                        }
                    }
                }
            }
        }
    }

    return field;
}

std::vector&lt;double&gt; GLVectorField::getScalarValues(uint elementID, RVariableApplyType variableApplyType, const RVariable *pVariable) const
{
    std::vector&lt;double&gt; scalarValues;

    if (!pVariable)
    {
        return scalarValues;
    }

    double minValue = pVariable-&gt;getVariableData().getMinDisplayValue();
    double maxValue = pVariable-&gt;getVariableData().getMaxDisplayValue();

    std::vector&lt;double&gt; values;

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());

    if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        const RElement &amp;rElement = rModel.getElement(elementID);

        values.resize(rElement.size());
        for (uint i=0;i&lt;rElement.size();i++)
        {
            values[i] = pVariable-&gt;getValue(rElement.getNodeId(i));
        }
    }
    else if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        values.resize(1);
        values[0] = pVariable-&gt;getValue(elementID);
    }

    if (variableApplyType == R_VARIABLE_APPLY_NODE)
    {
        scalarValues.resize(rModel.getElement(elementID).size());
        if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            for (uint i=0;i&lt;values.size();i++)
            {
                scalarValues[i] = values[i];
            }
        }
        else if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            for (uint i=0;i&lt;values.size();i++)
            {
                scalarValues[i] = values[0];
            }
        }
    }
    else if (variableApplyType == R_VARIABLE_APPLY_ELEMENT)
    {
        scalarValues.resize(1,0.0);
        for (uint i=0;i&lt;values.size();i++)
        {
            scalarValues[0] += values[i];
        }
        if (values.size() &gt; 0)
        {
            scalarValues[0] /= values.size();
        }
    }

    for (uint i=0;i&lt;scalarValues.size();i++)
    {
        scalarValues[i] = (scalarValues[i] - minValue) / (maxValue - minValue);

        scalarValues[i] = std::min(scalarValues[i],0.99);
        scalarValues[i] = std::max(scalarValues[i],0.01);
    }

    return scalarValues;
}

std::vector&lt;RR3Vector&gt; GLVectorField::getDisplacementValues(uint elementID, RVariableApplyType variableApplyType, const RVariable *pVariable) const
{
    std::vector&lt;RR3Vector&gt; displacementValues;

    if (!pVariable)
    {
        return displacementValues;
    }

    std::vector&lt;RR3Vector&gt; values;

    if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());
        const RElement &amp;rElement = rModel.getElement(elementID);

        values.resize(rElement.size());
        for (uint i=0;i&lt;rElement.size();i++)
        {
            values[i][0] = pVariable-&gt;getValue(0,rElement.getNodeId(i));
            values[i][1] = pVariable-&gt;getValue(1,rElement.getNodeId(i));
            values[i][2] = pVariable-&gt;getValue(2,rElement.getNodeId(i));
        }
    }
    else if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        values.resize(1);
        values[0][0] = pVariable-&gt;getValue(0,elementID);
        values[0][1] = pVariable-&gt;getValue(1,elementID);
        values[0][2] = pVariable-&gt;getValue(2,elementID);
    }

    if (variableApplyType == R_VARIABLE_APPLY_NODE)
    {
        const Model &amp;rModel = Session::getInstance().getModel(this-&gt;entityID.getMid());
        displacementValues.resize(rModel.getElement(elementID).size());
        if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            for (uint i=0;i&lt;values.size();i++)
            {
                displacementValues[i][0] = values[i][0];
                displacementValues[i][1] = values[i][1];
                displacementValues[i][2] = values[i][2];
            }
        }
        else if (pVariable-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            for (uint i=0;i&lt;values.size();i++)
            {
                displacementValues[i][0] = values[0][0];
                displacementValues[i][1] = values[0][1];
                displacementValues[i][2] = values[0][2];
            }
        }
    }
    else if (variableApplyType == R_VARIABLE_APPLY_ELEMENT)
    {
        displacementValues.resize(1,RR3Vector(0.0,0.0,0.0));
        for (uint i=0;i&lt;values.size();i++)
        {
            displacementValues[0][0] += values[i][0];
            displacementValues[0][1] += values[i][1];
            displacementValues[0][2] += values[i][2];
        }
        if (values.size() &gt; 0)
        {
            displacementValues[0][0] /= values.size();
            displacementValues[0][1] /= values.size();
            displacementValues[0][2] /= values.size();
        }
    }

    double scale = pVariable-&gt;getVariableData().getScale();

    for (uint i=0;i&lt;displacementValues.size();i++)
    {
        displacementValues[i] *= scale;
    }

    return displacementValues;
}
</t>
<t tx="leo.20201108101522.42">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_widget.cpp                                            *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th January 2012                                        *
 *                                                                   *
 *  DESCRIPTION: OpenGL widget class definition                      *
 *********************************************************************/

#include &lt;QApplication&gt;
#include &lt;QDesktopWidget&gt;
#include &lt;QFileDialog&gt;
#include &lt;QPainter&gt;
#include &lt;QGuiApplication&gt;

#include &lt;rmlib.h&gt;

#include "gl_arrow.h"
#include "gl_axis.h"
#include "gl_dimension.h"
#include "gl_cut_plane.h"
#include "gl_line.h"
#include "gl_point.h"
#include "gl_rotation_sphere.h"
#include "gl_widget.h"
#include "gl_functions.h"
#include "pick_list.h"
#include "session.h"
#include "main_window.h"
#include "main_settings.h"

#ifndef GL_MULTISAMPLE
#define GL_MULTISAMPLE  0x809D
#endif

const GLsizei GLWidget::lAxisWpWidth = 100;
const GLsizei GLWidget::lAxisWpHeight = 100;
//static int GLWidget::dsktopDevicePixelRatio = 1;

GLWidget::GLWidget(uint modelID, QWidget *parent)
    : QOpenGLWidget(parent),
      modelID(modelID),
      drx(0.0),
      dry(0.0),
      dtx(0.0),
      dty(0.0),
      dtz(0.0),
      dscale(0.0),
      mscale(1.0),
      scale(1.0),
      drawStreamLinePosition(false),
      drawScaleOrigin(false),
      drawRotationOrigin(false),
      drawLocalDirections(false),
      drawCutPlane(false),
      drawMoveNodes(false),
      useGlVoidModelList(false),
      clippingPlaneEnabled(false),
      clippingPlaneDistance(0.5),
      showRotationSphere(false),
      useGlCullFace(true)
{
    this-&gt;desktopDevicePixelRatio = QApplication::desktop()-&gt;devicePixelRatio();

    this-&gt;setFocusPolicy(Qt::StrongFocus);
    this-&gt;setAutoFillBackground(false);

    QSurfaceFormat format = QSurfaceFormat::defaultFormat();
    this-&gt;setFormat(format);

    QString displayPropertiesFileName(Session::getInstance().getModel(this-&gt;modelID).buildDataFileName(RGLDisplayProperties::getDefaultFileExtension(true)));

    this-&gt;displayProperties.load(displayPropertiesFileName);

    QObject::connect(&amp;Session::getInstance(),&amp;Session::entityVisibilityChanged,this,&amp;GLWidget::onEntityVisibilityChanged);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::displayPropertiesChanged,this,&amp;GLWidget::onDisplayPropertiesChanged);
    this-&gt;connect(&amp;Session::getInstance(),
                  SIGNAL(variableDataChanged(uint,RVariableType)),
                  SLOT(onVariableDataChanged(uint,RVariableType)));
    this-&gt;connect(&amp;Session::getInstance(),
                  SIGNAL(variableDataChanged(SessionEntityID,RVariableType)),
                  SLOT(onVariableDataChanged(SessionEntityID,RVariableType)));
    QObject::connect(&amp;Session::getInstance(),&amp;Session::modelChanged,this,&amp;GLWidget::onModelChanged);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::resultsChanged,this,&amp;GLWidget::onResultsChanged);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::beginDrawStreamLinePosition,this,&amp;GLWidget::onBeginDrawStreamLinePosition);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::endDrawStreamLinePosition,this,&amp;GLWidget::onEndDrawStreamLinePosition);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::beginDrawScaleOrigin,this,&amp;GLWidget::onBeginDrawScaleOrigin);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::endDrawScaleOrigin,this,&amp;GLWidget::onEndDrawScaleOrigin);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::beginDrawRotationOrigin,this,&amp;GLWidget::onBeginDrawRotationOrigin);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::endDrawRotationOrigin,this,&amp;GLWidget::onEndDrawRotationOrigin);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::beginDrawLocalDirections,this,&amp;GLWidget::onBeginDrawLocalDirections);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::endDrawLocalDirections,this,&amp;GLWidget::onEndDrawLocalDirections);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::beginDrawCutPlane,this,&amp;GLWidget::onBeginDrawCutPlane);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::endDrawCutPlane,this,&amp;GLWidget::onEndDrawCutPlane);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::beginDrawMoveNodes,this,&amp;GLWidget::onBeginDrawMoveNodes);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::endDrawMoveNodes,this,&amp;GLWidget::onEndDrawMoveNodes);
    QObject::connect(Session::getInstance().getDrawEngine(),&amp;DrawEngine::objectAdded,this,&amp;GLWidget::onDrawObjectAdded);
    QObject::connect(Session::getInstance().getDrawEngine(),&amp;DrawEngine::objectRemoved,this,&amp;GLWidget::onDrawObjectRemoved);
    QObject::connect(Session::getInstance().getDrawEngine(),&amp;DrawEngine::objectChanged,this,&amp;GLWidget::onDrawObjectChanged);

    this-&gt;font = QPainter(this).font();
}

uint GLWidget::getModelID(void) const
{
    return this-&gt;modelID;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.43">void GLWidget::setModelID(uint modelID)
{
    this-&gt;modelID = modelID;
}

QSize GLWidget::minimumSizeHint(void) const
{
    return QSize(50, 50);
}

QSize GLWidget::sizeHint(void) const
{
    return QSize(400, 400);
}

</t>
<t tx="leo.20201108101522.44">void GLWidget::initializeGL(void)
{
    this-&gt;resetView(-45.0, 0.0, -135.0);
}

</t>
<t tx="leo.20201108101522.45">void GLWidget::resizeGL(int width, int height)
{
    GL_SAFE_CALL(glViewport(0, 0, GLsizei(width*this-&gt;desktopDevicePixelRatio), GLsizei(height*this-&gt;desktopDevicePixelRatio)));
    GL_SAFE_CALL(glMatrixMode(GL_PROJECTION));
    GL_SAFE_CALL(glLoadIdentity());

    GLdouble winRatio = GLdouble(height)/GLdouble(width);
    GLdouble winScale = this-&gt;calculateViewDepth();

    GL_SAFE_CALL(glOrtho(-1.0, 1.0, -winRatio, winRatio, -winScale, winScale));
    GL_SAFE_CALL(glMatrixMode(GL_MODELVIEW));
}

</t>
<t tx="leo.20201108101522.46">void GLWidget::paintGL(void)
{
    this-&gt;qglClearColor(this-&gt;displayProperties.getBgColor());

    GL_SAFE_CALL(glPushMatrix());
    GL_SAFE_CALL(glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT));

    if (this-&gt;displayProperties.getBgGradient())
    {
        this-&gt;drawBackgroundGradient();
    }

    GL_SAFE_CALL(glEnable(GL_DEPTH_TEST));
    GL_SAFE_CALL(glShadeModel(GL_SMOOTH));
    GL_SAFE_CALL(glEnable(GL_MULTISAMPLE));
    GL_SAFE_CALL(glDepthFunc(GL_LEQUAL));

    this-&gt;drawModel();

    GL_SAFE_CALL(glPopMatrix());
    GL_SAFE_CALL(glFlush());

    QPainter painter(this);

    this-&gt;glTextRenderer.render(painter);
    this-&gt;glTextRenderer.clear();

    painter.setFont(this-&gt;font);

    this-&gt;drawValueRanges(painter);
    this-&gt;drawMessageBox(painter,false);
    this-&gt;drawInfoBox(painter,false);

    painter.end();

    this-&gt;makeCurrent();
}

</t>
<t tx="leo.20201108101522.47">void GLWidget::drawBackgroundGradient(void)
{


    // MAIN VIEWPORT
    GL_SAFE_CALL(glViewport(0, 0, GLsizei(this-&gt;width()*this-&gt;desktopDevicePixelRatio), GLsizei(this-&gt;height()*this-&gt;desktopDevicePixelRatio)));

    GL_SAFE_CALL(glMatrixMode(GL_PROJECTION));
    GL_SAFE_CALL(glLoadIdentity());

    GL_SAFE_CALL(glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0));

    GL_SAFE_CALL(glMatrixMode(GL_MODELVIEW));
    GL_SAFE_CALL(glLoadIdentity());

    GL_SAFE_CALL(glClear(GL_DEPTH_BUFFER_BIT));

    GL_SAFE_CALL(glDisable(GL_LIGHTING));
    GL_SAFE_CALL(glEnable(GL_BLEND));
    GL_SAFE_CALL(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));
    GL_SAFE_CALL(glShadeModel(GL_SMOOTH));
    GL_SAFE_CALL(glEnable(GL_LINE_SMOOTH));
    GL_SAFE_CALL(glDepthFunc(GL_LEQUAL));

    GLFunctions::begin(GL_QUADS);

    this-&gt;qglColor(QColor(255,255,255,0));
    GL_SAFE_CALL(glVertex3d( 1.0,  0.3, 0.0));
    GL_SAFE_CALL(glVertex3d(-1.0,  0.3, 0.0));
    GL_SAFE_CALL(glColor4f(1.0f,1.0f,1.0f,0.4f));
    this-&gt;qglColor(QColor(255,255,255,100));
    GL_SAFE_CALL(glVertex3d(-1.0, -1.0, 0.0));
    GL_SAFE_CALL(glVertex3d( 1.0, -1.0, 0.0));

    GLFunctions::end();
}

</t>
<t tx="leo.20201108101522.48">void GLWidget::drawModel(void)
{
    // MAIN VIEWPORT
    GL_SAFE_CALL(glViewport(0, 0, GLsizei(this-&gt;width()*this-&gt;desktopDevicePixelRatio), GLsizei(this-&gt;height()*this-&gt;desktopDevicePixelRatio)));

    GL_SAFE_CALL(glMatrixMode(GL_PROJECTION));
    GL_SAFE_CALL(glLoadIdentity());

    GLdouble winRatio = GLdouble(this-&gt;height())/GLdouble(this-&gt;width());
    GLdouble winScale = this-&gt;calculateViewDepth();

    GL_SAFE_CALL(glOrtho(-1.0, 1.0, -winRatio, winRatio, -winScale, winScale));

    GL_SAFE_CALL(glMatrixMode(GL_MODELVIEW));
    GL_SAFE_CALL(glLoadIdentity());

    GL_SAFE_CALL(glClear(GL_DEPTH_BUFFER_BIT));

    if (this-&gt;clippingPlaneEnabled)
    {
        const GLdouble clippingPlane[4] = { 0.0, 0.0, -1.0, - GLdouble(this-&gt;scale)  + 2.0 * this-&gt;clippingPlaneDistance * GLdouble(this-&gt;scale) };
        GL_SAFE_CALL(glClipPlane(GL_CLIP_PLANE0,clippingPlane));
    }

    GL_SAFE_CALL(glEnable(GL_LIGHTING));
    for (uint i=0;i&lt;this-&gt;displayProperties.getNLights();i++)
    {
        this-&gt;showLight(this-&gt;displayProperties.getLight(i));
    }
    GL_SAFE_CALL(glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 1.0));

    GL_SAFE_CALL(glShadeModel(GL_SMOOTH));
    GL_SAFE_CALL(glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE));
    GL_SAFE_CALL(glEnable(GL_COLOR_MATERIAL));
    GL_SAFE_CALL(glMaterialf(GL_FRONT, GL_SHININESS, 1.0));

    this-&gt;applyTransformations();

    GL_SAFE_CALL(glMultMatrixd(this-&gt;gMatrix));
    GL_SAFE_CALL(glGetDoublev(GL_MODELVIEW_MATRIX, this-&gt;gMatrix));

    GL_SAFE_CALL(glEnable(GL_BLEND));
    GL_SAFE_CALL(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));
    GL_SAFE_CALL(glShadeModel(GL_SMOOTH));

    GL_SAFE_CALL(glHint(GL_POINT_SMOOTH_HINT,GL_DONT_CARE));
    GL_SAFE_CALL(glHint(GL_LINE_SMOOTH_HINT,GL_DONT_CARE));
    GL_SAFE_CALL(glHint(GL_POLYGON_SMOOTH_HINT,GL_FASTEST));

    if (this-&gt;displayProperties.getDrawGlobalAxis())
    {
        // Draw main axis
        GLAxis gAxis(this,GL_AXIS_GLOBAL);
        gAxis.setSize(0.8f/this-&gt;scale);
        gAxis.paint();
    }

    if (this-&gt;showRotationSphere)
    {
        // Draw rotation sphere
        int lineColorValue = qGray(this-&gt;getGLDisplayProperties().getBgColor().rgb()) &lt; 96 ? 255 : 0;
        this-&gt;qglColor(QColor(lineColorValue,lineColorValue,lineColorValue,255));

        RR3Vector p,d;
        this-&gt;calculatePickRay(QPoint(int(ceil(double(this-&gt;width())/2.0)),int(ceil(double(this-&gt;height())/2.0))),0.0,p,d,false);

        GLRotationSphere gRotationSphere(this,RR3Vector(p[0],p[1],p[2]),(0.5/double(this-&gt;scale)));
        gRotationSphere.paint();
    }

    GL_SAFE_CALL(glEnable(GL_DEPTH_TEST));
    GL_SAFE_CALL(glEnable(GL_NORMALIZE));
    GL_SAFE_CALL(glEnable(GL_POINT_SMOOTH));
    GL_SAFE_CALL(glEnable(GL_LINE_SMOOTH));
    GL_SAFE_CALL(glDisable(GL_POLYGON_SMOOTH));

    // Apply model scale
    GL_SAFE_CALL(glScaled(GLdouble(this-&gt;mscale),GLdouble(this-&gt;mscale),GLdouble(this-&gt;mscale)));

    if (this-&gt;clippingPlaneEnabled)
    {
        GL_SAFE_CALL(glEnable(GL_CLIP_PLANE0));
    }

    if (Session::getInstance().getModel(this-&gt;getModelID()).glDrawTrylock())
    {
        RStopWatch modelDrawStopWatch;
        modelDrawStopWatch.reset();

        // Draw model
        Session::getInstance().getModel(this-&gt;getModelID()).glDraw(this);
        // Draw picked elements
        Session::getInstance().getModel(this-&gt;getModelID()).glDraw(this,Session::getInstance().getPickList().getItems(this-&gt;getModelID()));
        // Unlock drawing lock
        Session::getInstance().getModel(this-&gt;getModelID()).glDrawUnlock();

        this-&gt;modelDrawTime = modelDrawStopWatch.getMiliSeconds();
    }

    if (this-&gt;clippingPlaneEnabled)
    {
        GL_SAFE_CALL(glDisable(GL_CLIP_PLANE0));
    }

    // Draw local directions
    if (this-&gt;drawLocalDirections)
    {
        int lineColorValue = qGray(this-&gt;getGLDisplayProperties().getBgColor().rgb()) &lt; 96 ? 255 : 0;
        this-&gt;qglColor(QColor(lineColorValue,lineColorValue,lineColorValue,255));

        foreach (const RLocalDirection &amp;localDirection, this-&gt;localDirections)
        {
            RR3Vector direction(localDirection.getDirection());
            direction *= 1.0/double(this-&gt;scale);
            GLArrow localRotationArrow(this,localDirection.getPosition(),direction,true,false,GLDimension::arrowScale/double(this-&gt;mscale));
            localRotationArrow.paint();
        }
    }

    // Draw model dimensions
    if (this-&gt;displayProperties.getShowModelDimensions())
    {
        double xMin=0.0,xMax=0.0,yMin=0.0,yMax=0.0,zMin=0.0,zMax=0.0;
        Session::getInstance().getModel(this-&gt;getModelID()).findNodeLimits(xMin,xMax,yMin,yMax,zMin,zMax);
        int lineColorValue = qGray(this-&gt;getGLDisplayProperties().getBgColor().rgb()) &lt; 96 ? 255 : 0;
        this-&gt;qglColor(QColor(lineColorValue,lineColorValue,lineColorValue,100));
        GLDimension gDimension(this,1.0/double(this-&gt;scale),xMin,xMax,yMin,yMax,zMin,zMax);
        gDimension.paint();
    }

    // Draw draw-engine objects
    const DrawEngine *pDrawEngine = Session::getInstance().getDrawEngine();
    for (uint i=0;i&lt;pDrawEngine-&gt;getNObjects();i++)
    {
        pDrawEngine-&gt;getObject(i)-&gt;glDraw(this);
    }

    // Draw nodes to move
    if (this-&gt;drawMoveNodes)
    {
        for (QMap&lt;SessionNodeID,RR3Vector&gt;::const_iterator it = this-&gt;nodesToMove.constBegin();
             it != this-&gt;nodesToMove.constEnd();
             ++it)
        {
            if (this-&gt;getModelID() != it.key().getMid())
            {
                continue;
            }
            this-&gt;qglColor(Qt::red);
            GLLine gLine(this,Session::getInstance().getModel(this-&gt;getModelID()).getNode(it.key().getNid()).toVector(),it.value(),3.0);
            gLine.paint();
            GLPoint gPoint(this,it.value(),8.0);
            gPoint.paint();
        }
    }

    // Draw stream line position
    if (this-&gt;drawStreamLinePosition &amp;&amp; this-&gt;streamLinePosition != RR3Vector(0.0,0.0,0.0))
    {
        glPushMatrix();

        glTranslated(this-&gt;streamLinePosition[0],this-&gt;streamLinePosition[1],this-&gt;streamLinePosition[2]);

        GLAxis gAxis(this,GL_AXIS_POSITION,tr("Stream line"));
        gAxis.setSize(0.8f);
        gAxis.paint();

        glPopMatrix();
    }

    // Draw geometry scale origin
    if (this-&gt;drawScaleOrigin &amp;&amp; this-&gt;scaleOrigin != RR3Vector(0.0,0.0,0.0))
    {
        glPushMatrix();

        glTranslated(this-&gt;scaleOrigin[0],this-&gt;scaleOrigin[1],this-&gt;scaleOrigin[2]);

        GLAxis gAxis(this,GL_AXIS_POSITION,tr("Scale"));
        gAxis.setSize(0.8f);
        gAxis.paint();

        glPopMatrix();
    }

    // Draw geometry rotation origin
    if (this-&gt;drawRotationOrigin &amp;&amp; this-&gt;rotationOrigin != RR3Vector(0.0,0.0,0.0))
    {
        glPushMatrix();

        glTranslated(this-&gt;rotationOrigin[0],this-&gt;rotationOrigin[1],this-&gt;rotationOrigin[2]);

        GLAxis gAxis(this,GL_AXIS_POSITION,tr("Rotation"));
        gAxis.setSize(0.8f);
        gAxis.paint();

        glPopMatrix();
    }

    // Draw cut plane.
    if (this-&gt;drawCutPlane)
    {
        GLCutPlane glCutPlane(this,this-&gt;cutPlane);
        glCutPlane.setSize(1.2f/this-&gt;mscale);
        glCutPlane.paint();
    }

    // Restore original scale.
    double invMscale = 1.0/double(this-&gt;mscale);
    GL_SAFE_CALL(glScaled(invMscale,invMscale,invMscale));

    if (this-&gt;displayProperties.getDrawLocalAxis())
    {
        // LOWER-LEFT CORNER VIEWPORT
        GL_SAFE_CALL(glViewport (0,0,GLWidget::lAxisWpWidth*this-&gt;desktopDevicePixelRatio,GLWidget::lAxisWpHeight*this-&gt;desktopDevicePixelRatio));

        GL_SAFE_CALL(glMatrixMode(GL_PROJECTION));
        GL_SAFE_CALL(glLoadIdentity());

        GL_SAFE_CALL(glOrtho(-1.0, 1.0, -1.0, 1.0, -winScale, winScale));

        GL_SAFE_CALL(glMatrixMode(GL_MODELVIEW));

        GL_SAFE_CALL(glClear(GL_DEPTH_BUFFER_BIT));
        GL_SAFE_CALL(glLoadIdentity());

        if (this-&gt;drx != 0.0f) {
            GL_SAFE_CALL(glRotatef(this-&gt;drx, 1.0f, 0.0f, 0.0f));
        }
        if (this-&gt;dry != 0.0f) {
            GL_SAFE_CALL(glRotatef(this-&gt;dry, 0.0f, 1.0f, 0.0f));
        }

        GL_SAFE_CALL(glMultMatrixd(this-&gt;lMatrix));
        GL_SAFE_CALL(glGetDoublev(GL_MODELVIEW_MATRIX, this-&gt;lMatrix));

        // Draw local axis.
        GLAxis lAxis(this,GL_AXIS_LOCAL);
        lAxis.setSize(0.7f);
        lAxis.paint();
    }

    this-&gt;dtx = this-&gt;dty = this-&gt;dtz = 0.0;
    this-&gt;drx = this-&gt;dry = 0.0;
    this-&gt;dscale = 0.0;
} // drawModel()

</t>
<t tx="leo.20201108101522.49">void GLWidget::drawValueRanges(QPainter &amp;painter)
{
    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;getModelID());
    uint nDisplayVariableRanges = 0;

    for (uint i=0;i&lt;rModel.getNVariables();i++)
    {
        const RVariable &amp;rVariable = rModel.getVariable(i);

        if (rVariable.getVariableData().getDisplayValueRange())
        {
            std::vector&lt;RR3Vector&gt; pickedPositions;
            std::vector&lt;double&gt; pickedValues;

            const QVector&lt;PickItem&gt; &amp;rPickItems = Session::getInstance().getPickList().getItems(this-&gt;getModelID());

            for (int j=0;j&lt;rPickItems.size();j++)
            {
                QList&lt;PickValue&gt; vectorList = rModel.getPickedResultsValues(rPickItems[j]).values(rVariable.getType());

                for (int k=0;k&lt;vectorList.size();k++)
                {
                    pickedPositions.push_back(vectorList.at(k).getPosition());
                    pickedValues.push_back(RRVector::norm(vectorList.at(k).getValues()));
                }
            }

            this-&gt;drawValueRange(painter,
                                 ++nDisplayVariableRanges,
                                 rVariable.getVariableData().getMinDisplayValue(),
                                 rVariable.getVariableData().getMaxDisplayValue(),
                                 pickedPositions,
                                 pickedValues,
                                 rVariable.getVariableData().getValueRangeName(),
                                 rVariable.getName(),
                                 rVariable.getUnits());
        }
    }
}

</t>
<t tx="leo.20201108101522.5">void GLSimplexPolygon::drawNormal(const std::vector&lt;RNode&gt; &amp;nodes1, const std::vector&lt;RNode&gt; &amp;nodes2, bool volumeElement, bool useTexture)
{
    uint nn = uint(nodes1.size());

    RR3Vector normal(RPolygon(nodes1).getNormal());

    GLObject::glNormalVector(normal);

    if (useTexture)
    {
        GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
    }

    GLboolean cullState;
    GLint cullMode;

    GL_SAFE_CALL(glGetBooleanv(GL_CULL_FACE,&amp;cullState));
    GL_SAFE_CALL(glGetIntegerv(GL_CULL_FACE_MODE,&amp;cullMode));

    if (this-&gt;useGlCullFace)
    {
        GL_SAFE_CALL(glEnable(GL_CULL_FACE));
        GL_SAFE_CALL(glCullFace(GL_BACK));
    }
    else
    {
        GL_SAFE_CALL(glDisable(GL_CULL_FACE));
    }

    GLFunctions::begin(GL_POLYGON);
    for (uint i=0;i&lt;nn;i++)
    {
        if (useTexture)
        {
            GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[i]));
        }
        GLObject::glVertexNode(nodes1[i]);
    }
    GLFunctions::end();

    if (volumeElement)
    {
        GLFunctions::begin(GL_QUADS);

        for (uint i=0;i&lt;nn;i++)
        {
            uint n1 = i;
            uint n2 = i+1;
            if (n2 == nn)
            {
                n2 = 0;
            }

            GLObject::glNormalVector(RTriangle(nodes1[n2],nodes1[n1],nodes2[n1]).getNormal());

            if (useTexture)
            {
                GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[n2]));
            }
            GLObject::glVertexNode(nodes1[n2]);
            if (useTexture)
            {
                GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[n1]));
            }
            GLObject::glVertexNode(nodes1[n1]);
            GLObject::glVertexNode(nodes2[n1]);
            if (useTexture)
            {
                GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[n2]));
            }
            GLObject::glVertexNode(nodes2[n2]);
        }

        GLFunctions::end();
    }

    if (this-&gt;useGlCullFace)
    {
        GL_SAFE_CALL(glCullFace(GL_FRONT));
    }

    if (useTexture)
    {
        GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
    }

    if (this-&gt;useGlCullFace)
    {
        this-&gt;getGLWidget()-&gt;qglColor(Qt::white);

        GLObject::glNormalVector(normal);

        GLFunctions::begin(GL_POLYGON);
        for (uint i=0;i&lt;nn;i++)
        {
            GLObject::glVertexNode(nodes2[i]);
        }
        GLFunctions::end();
    }

    GL_SAFE_CALL(glCullFace(GLenum(cullMode)));
    GL_SAFE_CALL(cullState ? glEnable(GL_CULL_FACE) : glDisable(GL_CULL_FACE));
}

</t>
<t tx="leo.20201108101522.50">void GLWidget::drawValueRange(QPainter &amp;painter,
                              unsigned int rangeCount,
                              double lowerValue,
                              double upperValue,
                              std::vector&lt;RR3Vector&gt; pickedPositions,
                              std::vector&lt;double&gt; pickedValues,
                              const QString &amp;valueRangeFile,
                              const QString &amp;valueRangeName,
                              const QString &amp;valueRangeUnits)
{
    int lineColorValue = qGray(this-&gt;getGLDisplayProperties().getBgColor().rgb()) &lt; 96 ? 255 : 0;

    int offset = 10;
    int padding = 2;

    int rangeWidth = 150;
    int rangeHeight = this-&gt;height() - 2*offset;
    int rangeX = this-&gt;width() - (rangeWidth + offset) * int(rangeCount);
    int rangeY = offset;

    int fontHeight = painter.fontMetrics().height();
    int fontAscent = painter.fontMetrics().ascent();
    int fontDescent = painter.fontMetrics().descent();
    int fontPixelHeight = painter.fontInfo().pixelSize();
    int fontPixelAscent = qRound(fontAscent*double(fontPixelHeight)/double(fontHeight));
    int fontPixelDescent = qRound(fontDescent*double(fontPixelHeight)/double(fontHeight));

    int headerWidth = rangeWidth;
    int headerHeight = 2*(fontPixelHeight + padding) + padding;
    int headerX = rangeX;
    int headerY = rangeY;

    int footerWidth = rangeWidth;
    int footerHeight = 2*(fontPixelHeight + padding) + padding;
    int footerX = rangeX;
    int footerY = rangeY + rangeHeight - footerHeight;

    int imageWidth = 20;
    int imageHeight = rangeHeight - headerHeight - footerHeight - 4*padding;
    int imageX = rangeX + rangeWidth - padding - imageWidth;
    int imageY = rangeY + headerHeight + 2*padding;

    painter.setRenderHint(QPainter::Antialiasing);

    // Outer box
    painter.setPen(QColor(lineColorValue,lineColorValue,lineColorValue,255));
    painter.drawRect(rangeX,rangeY,rangeWidth,rangeHeight);
    painter.fillRect(rangeX,rangeY,rangeWidth,rangeHeight,QColor(255,255,255,200));

    // Image
    QTransform t;
    t.rotate(-90.0);
    painter.drawImage(QRect(imageX,imageY,imageWidth,imageHeight),QImage(valueRangeFile).transformed(t));

    // Image box
    painter.setPen(QColor(lineColorValue,lineColorValue,lineColorValue,255));
    painter.drawRect(imageX,imageY,imageWidth,imageHeight);

    // Header box
    QLinearGradient headerGradient(headerX,headerY,headerX,headerY+headerHeight);
    headerGradient.setColorAt(0, Qt::white);
    headerGradient.setColorAt(1, Qt::lightGray);
    painter.fillRect(headerX,headerY,headerWidth,headerHeight,headerGradient);

    painter.setPen(QColor(0,0,0,255));
    painter.drawText(headerX+padding,headerY+fontPixelAscent+padding,QString(valueRangeName));
    painter.drawText(headerX+padding,headerY+fontPixelAscent+padding+fontPixelHeight+padding,"Units: [" + QString(valueRangeUnits) + "]");

    painter.setPen(QColor(lineColorValue,lineColorValue,lineColorValue,255));
    painter.drawRect(headerX,headerY,headerWidth,headerHeight);

    // Footer box
    QLinearGradient footerGradient(footerX,footerY,footerX,footerY+footerHeight);
    footerGradient.setColorAt(0, Qt::lightGray);
    footerGradient.setColorAt(1, Qt::white);
    painter.fillRect(footerX,footerY,footerWidth,footerHeight, footerGradient);

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;getModelID());

    QString recordNumberStr;
    QString recordValueStr;
    if (rModel.getTimeSolver().getEnabled())
    {
        recordNumberStr = tr("Time-step:") + " " + QString::number(rModel.getTimeSolver().getCurrentTimeStep()+1);
        recordValueStr = tr("Time:") + " " + QString::number(rModel.getTimeSolver().getComputedTime(),'e',3) + " [" + RVariable::getUnits(R_VARIABLE_TIME) + "]";
    }
    else
    {
        if (rModel.getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_STRESS_MODAL)
        {
            recordNumberStr = tr("Mode:") + " " + QString::number(rModel.getProblemSetup().getModalSetup().getMode()+1);
            recordValueStr = tr("Freq.:") + " " + QString::number(rModel.getProblemSetup().getModalSetup().getFrequency(),'e',3) + " [" + RVariable::getUnits(R_VARIABLE_FREQUENCY) + "]";
        }
        else
        {
            recordNumberStr = tr("Steady state");
            recordValueStr = "----------------------";
        }
    }

    painter.setPen(QColor(0,0,0,255));
    painter.drawText(footerX+padding,footerY+fontPixelAscent+padding,recordNumberStr);
    painter.drawText(footerX+padding,footerY+fontPixelAscent+padding+fontPixelHeight+padding,recordValueStr);

    painter.setPen(QColor(lineColorValue,lineColorValue,lineColorValue,255));
    painter.drawRect(footerX,footerY,footerWidth,footerHeight);

    // Min max values
    painter.setPen(QColor(0,0,0,255));
    painter.drawText(rangeX+padding,imageY+fontPixelAscent,QString::number(upperValue));
    painter.drawText(rangeX+padding,imageY+imageHeight-fontPixelDescent,QString::number(lowerValue));

    // Picked values
    for (uint i=0;i&lt;pickedValues.size();i++)
    {
        int pickedWidth = imageWidth;
        int pickedX = imageX - pickedWidth;
        int pickedY = imageY + imageHeight - qRound(double(imageHeight) * (pickedValues[i] - lowerValue)/ (upperValue - lowerValue));

        painter.setPen(QColor(lineColorValue,lineColorValue,lineColorValue,255));
        painter.drawLine(pickedX,pickedY,pickedX+pickedWidth,pickedY);
        QPoint pickPosition;
        this-&gt;convertModelToScreen(pickedPositions[i],pickPosition);
        painter.drawLine(pickedX,pickedY,pickPosition.x(),pickPosition.y());

        painter.setPen(QColor(200,0,0,255));
        painter.drawText(rangeX+padding,pickedY-fontPixelDescent+qRound(double(fontPixelHeight)*(pickedValues[i] - lowerValue)/ (upperValue - lowerValue)),QString::number(pickedValues[i]));
    }
}

</t>
<t tx="leo.20201108101522.51">void GLWidget::drawMessageBox(QPainter &amp;painter, bool drawBox)
{
    painter.setFont(QGuiApplication::font());

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;getModelID());

    QList&lt;QString&gt; messages;

    messages.push_back(rModel.getName() + " (" + rModel.getDescription() + ")");
    messages.push_back(QString());

    if (rModel.getNSlivers() &gt; 0)
    {
        messages.push_back(QString("W: Number of sliver elements: ") + QString::number(rModel.getNSlivers()));
    }
    if (rModel.getNIntersected() &gt; 0)
    {
        messages.push_back(QString("E: Number of intersected elements: ") + QString::number(rModel.getNIntersected()));
    }
    if (rModel.getNHoleElements() &gt; 0)
    {
        messages.push_back(QString("E: Number of hole elements: ") + QString::number(rModel.getNHoleElements()));
    }

    const PickList &amp;rPickList = Session::getInstance().getPickList();
    if (!rPickList.isEmpty())
    {
        messages.append("Picked entities:");

        const Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);
        QVector&lt;PickItem&gt; pickItems = rPickList.getItems(this-&gt;modelID);
        std::vector&lt;REntityGroupType&gt; entityTypes = REntityGroup::getAllTypes();
        for (uint i=0;i&lt;entityTypes.size();i++)
        {
            QMap&lt;QString,uint&gt; pickedEntities;
            for (int j=0;j&lt;pickItems.size();j++)
            {
                if (pickItems.at(j).getEntityID().getType() == entityTypes[i])
                {
                    if (pickItems.at(j).getItemType() == PICK_ITEM_HOLE_ELEMENT)
                    {
                        const QString eName = tr("Hole edge");
                        pickedEntities.insert(eName,pickedEntities.value(eName,0)+1);
                    }
                    else
                    {
                        if (pickItems.at(j).getEntityID().getType() != R_ENTITY_GROUP_NONE)
                        {
                            uint gid = rModel.getEntityGroupID(pickItems.at(j).getEntityID().getType(),pickItems.at(j).getEntityID().getEid());
                            const QString eName = rModel.getEntityGroupPtr(gid)-&gt;getName();
                            pickedEntities.insert(eName,pickedEntities.value(eName,0)+1);
                        }
                    }
                }
            }

            if (!pickedEntities.isEmpty())
            {
                QList&lt;QString&gt; pickedEntityNames = pickedEntities.uniqueKeys();

                foreach (const QString &amp;pickedEntityName, pickedEntityNames)
                {
                    messages.append("    " + REntityGroup::getTypeName(entityTypes[i]) + ":  " + pickedEntityName + "    (" + QString::number(pickedEntities.value(pickedEntityName)) + ")");
                }
            }
        }
    }

    if (messages.size() == 0)
    {
        return;
    }

    int offset = 10;
    int padding = 2;

    int fontPixelHeight = painter.fontInfo().pixelSize();

    int sizeX = this-&gt;width() - offset - offset;
    int sizeY = offset + (fontPixelHeight+padding)*messages.size();
    int posX = offset;
    int posY = offset;

    int colorValue = qGray(this-&gt;getGLDisplayProperties().getBgColor().rgb()) &lt; 96 ? 255 : 0;

    // Outer box
    if (drawBox)
    {
        colorValue = 255 - colorValue;
        int boxColorValue = 255 - colorValue;
        painter.setPen(QColor(boxColorValue,boxColorValue,boxColorValue,255));
        painter.drawRect(posX,posY,sizeX,sizeY);
        painter.fillRect(posX,posY,sizeX,sizeY,QColor(boxColorValue,boxColorValue,boxColorValue,200));
    }

    painter.setPen(QColor(colorValue,colorValue,colorValue,255));
    for (int i=0;i&lt;messages.size();i++)
    {
        painter.drawText(posX+padding,posY+(fontPixelHeight+padding)*(i+1),messages[i]);
    }
}

</t>
<t tx="leo.20201108101522.52">void GLWidget::drawInfoBox(QPainter &amp;painter, bool drawBox)
{
    painter.setFont(QGuiApplication::font());

    QList&lt;QString&gt; messages;

    QStringList actionMessage;
    QString keyMouseMessage(this-&gt;actionEvent.getKeyMouseCombination());
    QString eventMessage(GLActionEvent::toString(this-&gt;actionEvent.getType()));

    if (keyMouseMessage.length() != 0)
    {
        actionMessage.append(keyMouseMessage);
    }
    if (eventMessage.length() != 0)
    {
        actionMessage.append(eventMessage);
    }
    if (actionMessage.size() &gt; 0)
    {
        messages.append(tr("Action") + ": " + actionMessage.join(" - "));
    }

    messages.append(tr("Zoom") + ": " + QString::number(double(this-&gt;scale)));
    messages.append(tr("Model draw time") + ": " + QString::number(this-&gt;modelDrawTime) + " [ms]");

    if (messages.size() == 0)
    {
        return;
    }

    int offset = 10;
    int padding = 2;

    int fontPixelHeight = painter.fontInfo().pixelSize();

    int sizeX = GLWidget::lAxisWpWidth;
    int sizeY = offset + (fontPixelHeight+padding)*messages.size();
    int posX = offset;
    int posY = this-&gt;height() - offset - GLWidget::lAxisWpHeight - sizeY;

    int colorValue = qGray(this-&gt;getGLDisplayProperties().getBgColor().rgb()) &lt; 96 ? 255 : 0;

    // Outer box
    if (drawBox)
    {
        colorValue = 255 - colorValue;
        int boxColorValue = 255 - colorValue;
        painter.setPen(QColor(boxColorValue,boxColorValue,boxColorValue,255));
        painter.drawRect(posX,posY,sizeX,sizeY);
        painter.fillRect(posX,posY,sizeX,sizeY,QColor(boxColorValue,boxColorValue,boxColorValue,200));
    }
    painter.setPen(QColor(colorValue,colorValue,colorValue,255));
    for (int i=0;i&lt;messages.size();i++)
    {
        painter.drawText(posX+padding,posY+(fontPixelHeight+padding)*(i+1),messages[i]);
    }
}

</t>
<t tx="leo.20201108101522.53">void GLWidget::applyTransformations(void)
{
    if (this-&gt;dtx != 0.0f || this-&gt;dty != 0.0f || this-&gt;dtz != 0.0f)
    {
        glTranslatef(this-&gt;dtx, this-&gt;dty, this-&gt;dtz);
    }

    if (this-&gt;drx != 0.0f)
    {
        glRotatef(this-&gt;drx, 1.0f, 0.0f, 0.0f);
    }
    if (this-&gt;dry != 0.0f)
    {
        glRotatef(this-&gt;dry, 0.0f, 1.0f, 0.0f);
    }

    if (this-&gt;dscale != 0.0f &amp;&amp; this-&gt;dscale != 1.0f)
    {
        this-&gt;scale *= 1.0f+this-&gt;dscale;
        if (this-&gt;scale &lt; 1e4f)
        {
            glScalef(1.0f+this-&gt;dscale,1.0f+this-&gt;dscale,1.0f+this-&gt;dscale);
        }
        else
        {
            this-&gt;scale /= 1.0f+this-&gt;dscale;
        }
    }
}

</t>
<t tx="leo.20201108101522.54">void GLWidget::processActionEvent(void)
{
    RLogger::trace("GLWidget::processActionEvent(void)\n");

    GLActionEventType glActionEventType = this-&gt;actionEvent.getType();

    if (glActionEventType == GL_ACTION_EVENT_PICK_CLEAR)
    {
        Session::getInstance().getPickList().clear();
        if (Session::getInstance().getModel(this-&gt;modelID).getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_RADIATIVE_HEAT)
        {
            // If problem type is radiation surface normal list will be always regenerated if mouse pick happens.
            for (uint i=0;i&lt;Session::getInstance().getModel(this-&gt;modelID).getNSurfaces();i++)
            {
                this-&gt;getGLModelList().getGlSurfaceList(i).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
            }
        }
        return;
    }

    if (glActionEventType != GL_ACTION_EVENT_PICK_ELEMENT &amp;&amp;
        glActionEventType != GL_ACTION_EVENT_PICK_NODE &amp;&amp;
        glActionEventType != GL_ACTION_EVENT_PICK_HOLE_ELEMENT)
    {
        return;
    }

    RR3Vector pickRayPosition;
    RR3Vector pickRayDirection;

    this-&gt;calculatePickRay(this-&gt;bpStart,this-&gt;calculateViewDepth(),pickRayPosition,pickRayDirection,true);

    PickItem pickItem;
    bool pickFound = false;
    double pickTolerance = 0.01 / double((this-&gt;mscale * this-&gt;scale));

    if (glActionEventType == GL_ACTION_EVENT_PICK_ELEMENT)
    {
        pickFound = Session::getInstance().getModel(this-&gt;modelID).findPickedElement(pickRayPosition,pickRayDirection,pickTolerance,pickItem);
    }
    else if (glActionEventType == GL_ACTION_EVENT_PICK_NODE)
    {
        pickFound = Session::getInstance().getModel(this-&gt;modelID).findPickedNode(pickRayPosition,pickRayDirection,pickTolerance,pickItem);
    }
    else if (glActionEventType == GL_ACTION_EVENT_PICK_HOLE_ELEMENT)
    {
        pickFound = Session::getInstance().getModel(this-&gt;modelID).findPickedHoleElement(pickRayPosition,pickRayDirection,pickTolerance,pickItem);
    }

    if (pickFound)
    {
        static bool itemAdded = false;
        bool actionTypeChanged = this-&gt;actionEvent.getChanged();

        if (actionTypeChanged)
        {
            itemAdded = Session::getInstance().getPickList().registerItem(pickItem);
        }
        else
        {
            if (itemAdded)
            {
                Session::getInstance().getPickList().addItem(pickItem);
            }
            else
            {
                Session::getInstance().getPickList().removeItem(pickItem);
            }
        }

        if (Session::getInstance().getModel(this-&gt;modelID).getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_RADIATIVE_HEAT)
        {
            // If problem type is radiation surface normal list will be always regenerated if mouse pick happens.
            for (uint i=0;i&lt;Session::getInstance().getModel(this-&gt;modelID).getNSurfaces();i++)
            {
                this-&gt;getGLModelList().getGlSurfaceList(i).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
            }
        }
    }
}

</t>
<t tx="leo.20201108101522.55">void GLWidget::mousePressEvent(QMouseEvent *mouseEvent)
{
    this-&gt;actionEvent.setMouseEvent(mouseEvent,false);
    this-&gt;bpStart = mouseEvent-&gt;pos();

    this-&gt;processActionEvent();

    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.56">void GLWidget::mouseReleaseEvent(QMouseEvent *mouseEvent)
{
    this-&gt;actionEvent.setMouseEvent(mouseEvent,true);
    this-&gt;bpEnd = mouseEvent-&gt;pos();
    this-&gt;showRotationSphere = false;

    if (this-&gt;actionEvent.getType() == GL_ACTION_EVENT_TRANSLATE)
    {
        this-&gt;dtx =   2 * (this-&gt;bpEnd.x() - this-&gt;bpStart.x()) / float(this-&gt;width());
        this-&gt;dty = - 2 * (this-&gt;bpEnd.y() - this-&gt;bpStart.y()) / float(this-&gt;width());
        this-&gt;dtz = 0.0;
    }

    this-&gt;bpStart = this-&gt;bpEnd;

    this-&gt;processActionEvent();
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.57">void GLWidget::mouseMoveEvent(QMouseEvent *mouseEvent)
{
    this-&gt;actionEvent.setMouseEvent(mouseEvent,false);
    this-&gt;bpEnd = mouseEvent-&gt;pos();

    if (this-&gt;actionEvent.getType() == GL_ACTION_EVENT_TRANSLATE)
    {
        this-&gt;showRotationSphere = true;
        this-&gt;dtx =   2 * (this-&gt;bpEnd.x() - this-&gt;bpStart.x()) / float(this-&gt;width());
        this-&gt;dty = - 2 * (this-&gt;bpEnd.y() - this-&gt;bpStart.y()) / float(this-&gt;width());
        this-&gt;dtz = 0.0;
    }
    else if (this-&gt;actionEvent.getType() == GL_ACTION_EVENT_TRANSLATE_Z)
    {
        this-&gt;showRotationSphere = true;
        this-&gt;dtx = 0.0;
        this-&gt;dty = 0.0;
        this-&gt;dtz = this-&gt;scale * 2 * (this-&gt;bpEnd.y() - this-&gt;bpStart.y()) / float(this-&gt;width());
    }
    else if (this-&gt;actionEvent.getType() == GL_ACTION_EVENT_ROTATE)
    {
        this-&gt;showRotationSphere = true;
        this-&gt;drx = 500 * (this-&gt;bpEnd.y() - this-&gt;bpStart.y()) / float(this-&gt;width());
        this-&gt;dry = 500 * (this-&gt;bpEnd.x() - this-&gt;bpStart.x()) / float(this-&gt;width());
    }
    else if (this-&gt;actionEvent.getType() == GL_ACTION_EVENT_ZOOM)
    {
        this-&gt;showRotationSphere = true;
        this-&gt;dscale = (this-&gt;bpEnd.y() - this-&gt;bpStart.y()) / float(this-&gt;width());
    }
    this-&gt;bpStart = this-&gt;bpEnd;

    this-&gt;processActionEvent();
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.58">void GLWidget::enterEvent(QEvent *)
{
    this-&gt;setFocus();
}

</t>
<t tx="leo.20201108101522.59">void GLWidget::leaveEvent(QEvent *)
{
}

</t>
<t tx="leo.20201108101522.6">void GLSimplexPolygon::drawWired(const std::vector&lt;RNode&gt; &amp;nodes1, const std::vector&lt;RNode&gt; &amp;nodes2, bool volumeElement, bool useTexture)
{
    uint nn = uint(nodes1.size());

    RR3Vector normal(RPolygon(nodes1).getNormal());

    GLObject::glNormalVector(normal);

    if (useTexture)
    {
        GL_SAFE_CALL(glEnable(GL_TEXTURE_1D));
    }

    GLFunctions::begin(GL_LINE_LOOP);
    for (uint i=0;i&lt;nn;i++)
    {
        if (useTexture)
        {
            GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[i]));
        }
        GLObject::glVertexNode(nodes1[i]);
    }
    GLFunctions::end();

    if (volumeElement)
    {
        GLFunctions::begin(GL_LINE_LOOP);
        for (uint i=0;i&lt;nn;i++)
        {
            if (useTexture)
            {
                GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[i]));
            }
            GLObject::glVertexNode(nodes2[i]);
        }
        GLFunctions::end();

        GLFunctions::begin(GL_LINES);
        for (uint i=0;i&lt;nn;i++)
        {
            if (useTexture)
            {
                GL_SAFE_CALL(glTexCoord1d(this-&gt;nodeTextureCoordinates[i]));
            }
            GLObject::glVertexNode(nodes1[i]);
            GLObject::glVertexNode(nodes2[i]);
        }
        GLFunctions::end();
    }

    if (useTexture)
    {
        GL_SAFE_CALL(glDisable(GL_TEXTURE_1D));
    }
}

</t>
<t tx="leo.20201108101522.60">void GLWidget::wheelEvent(QWheelEvent *mouseEvent)
{
    this-&gt;actionEvent.setScrollPhase(Qt::ScrollUpdate);

    int numDegrees = mouseEvent-&gt;delta() / 8;
    int numSteps = numDegrees / 15;
    float x = float(mouseEvent-&gt;x());
    float y = float(mouseEvent-&gt;y());
    float w = float(this-&gt;width());
    float h = float(this-&gt;height());

    if (this-&gt;actionEvent.getType() == GL_ACTION_EVENT_TRANSLATE_Z)
    {
        this-&gt;showRotationSphere = true;
        this-&gt;dtx = 0.0;
        this-&gt;dty = 0.0;
        this-&gt;dtz = this-&gt;scale*float(numSteps)/100.0f;
    }
    else if (this-&gt;actionEvent.getType() == GL_ACTION_EVENT_ZOOM)
    {
        this-&gt;dtx = 2.0f*x/w - 1.0f;
        this-&gt;dty = 2.0f*y/h - 1.0f;
        this-&gt;dty = (0.5f - y/h)*2.0f*h/w;
        this-&gt;dtx *= numSteps/10.0f;
        this-&gt;dty *= numSteps/10.0f;
        this-&gt;dscale = -float(numSteps)/10.0f;
    }

    this-&gt;actionEvent.setScrollPhase(Qt::NoScrollPhase);

    this-&gt;processActionEvent();
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.61">void GLWidget::keyPressEvent(QKeyEvent *keyEvent)
{
    this-&gt;actionEvent.setKeyEvent(keyEvent,false);
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.62">void GLWidget::keyReleaseEvent(QKeyEvent *keyEvent)
{
    this-&gt;actionEvent.setKeyEvent(keyEvent,true);
    this-&gt;showRotationSphere = false;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.63">void GLWidget::calculateModelScale(void)
{
    this-&gt;mscale = float(Session::getInstance().getModel(this-&gt;getModelID()).findNodeScale());
    if (this-&gt;mscale &lt; float(RConstants::eps))
    {
        this-&gt;mscale = float(RConstants::eps);
    }
}

</t>
<t tx="leo.20201108101522.64">void GLWidget::calculatePickRay(const QPoint &amp;screenPosition, double viewDepth, RR3Vector &amp;position, RR3Vector &amp;direction, bool applyModelScale) const
{
    double wx = 1.0;
    double wy = double(this-&gt;height()) / double(this-&gt;width());
    double x = 2.0*wx*(double(screenPosition.x()) / double(this-&gt;width())) - wx;
    double y = 2.0*wy*(1.0 - double(screenPosition.y()) / double(this-&gt;height())) - wy;
    double vd = viewDepth;

    RRMatrix R(4,4);
    for (uint i=0;i&lt;4;i++)
    {
        for (uint j=0;j&lt;4;j++)
        {
            R[i][j] = this-&gt;gMatrix[4*j+i] * (applyModelScale ? double(this-&gt;mscale) : 1.0);
        }
    }
    R.invert();

    RRVector v1(4),v2(4);

    v1[0] = x;
    v1[1] = y;
    v1[2] = vd;
    v1[3] = 1.0;

    RRMatrix::mlt(R,v1,v2);

    position[0] = v2[0];
    position[1] = v2[1];
    position[2] = v2[2];

    v1[0] = x;
    v1[1] = y;
    v1[2] = 0.0;
    v1[3] = 1.0;

    RRMatrix::mlt(R,v1,v2);

    direction[0] = v2[0]-position[0];
    direction[1] = v2[1]-position[1];
    direction[2] = v2[2]-position[2];
    direction.normalize();
}

</t>
<t tx="leo.20201108101522.65">void GLWidget::convertModelToScreen(const RR3Vector &amp;realPosition, QPoint &amp;screenPosition) const
{
    RRMatrix R(4,4);
    for (uint i=0;i&lt;4;i++)
    {
        for (uint j=0;j&lt;4;j++)
        {
            R[i][j] = this-&gt;gMatrix[4*j+i] * double(this-&gt;mscale);
        }
    }

    RRVector v1(4),v2(4);

    v1[0] = realPosition[0];
    v1[1] = realPosition[1];
    v1[2] = realPosition[2];
    v1[3] = 1.0 / double(this-&gt;mscale);

    RRMatrix::mlt(R,v1,v2);

    double wx = 1.0;
    double wy = double(this-&gt;height()) / double(this-&gt;width());

    double x = double(this-&gt;width()) * (v2[0] + wx)/(2.0*wx);
    double y = double(this-&gt;height()) * (1.0 - (v2[1] + wy)/(2.0*wy));

    screenPosition.setX(qRound(x));
    screenPosition.setY(qRound(y));
}

</t>
<t tx="leo.20201108101522.66">void GLWidget::convertScreenToModel(const QPoint &amp;screenPosition, RR3Vector &amp;modelPosition)
{
    double wx = 1.0;
    double wy = double(this-&gt;height()) / double(this-&gt;width());
    double x = 2.0*wx*(double(screenPosition.x()) / double(this-&gt;width())) - wx;
    double y = 2.0*wy*(1.0 - double(screenPosition.y()) / double(this-&gt;height())) - wy;

    RRMatrix R(4,4);
    for (uint i=0;i&lt;4;i++)
    {
        for (uint j=0;j&lt;4;j++)
        {
            R[i][j] = this-&gt;gMatrix[4*j+i] * double(this-&gt;mscale);
        }
    }
    R.invert();

    RRVector v1(4),v2(4);

    v1[0] = x;
    v1[1] = y;
    v1[2] = 0.0;
    v1[3] = 1.0;

    RRMatrix::mlt(R,v1,v2);

    modelPosition[0] = v2[0];
    modelPosition[1] = v2[1];
    modelPosition[2] = v2[2];
}

double GLWidget::calculateViewDepth(void) const
{
    return 1000.0 * double(this-&gt;scale);
}

</t>
<t tx="leo.20201108101522.67">void GLWidget::showLight(const RGLLight &amp;rGlLight)
{
    GLenum lightNumber = GL_LIGHT0;

    switch (rGlLight.getLightNumber())
    {
        case 0:
        {
            lightNumber = GL_LIGHT0;
            break;
        }
        case 1:
        {
            lightNumber = GL_LIGHT1;
            break;
        }
        case 2:
        {
            lightNumber = GL_LIGHT2;
            break;
        }
        case 3:
        {
            lightNumber = GL_LIGHT3;
            break;
        }
        case 4:
        {
            lightNumber = GL_LIGHT4;
            break;
        }
        case 5:
        {
            lightNumber = GL_LIGHT5;
            break;
        }
        case 6:
        {
            lightNumber = GL_LIGHT6;
            break;
        }
        case 7:
        {
            lightNumber = GL_LIGHT7;
            break;
        }
        default:
        {
            lightNumber = GL_LIGHT0;
            break;
        }
    }

    if (!rGlLight.getEnabled())
    {
        GL_SAFE_CALL(glDisable(lightNumber));
        return;
    }

    GLfloat lightKa[4];
    GLfloat lightKs[4];
    GLfloat lightKd[4];
    GLfloat lightDr[3];
    GLfloat lightPs[4];

    lightKa[0] = GLfloat(rGlLight.getAmbient().redF());
    lightKa[1] = GLfloat(rGlLight.getAmbient().greenF());
    lightKa[2] = GLfloat(rGlLight.getAmbient().blueF());
    lightKa[3] = GLfloat(rGlLight.getAmbient().alphaF());

    lightKs[0] = GLfloat(rGlLight.getSpecular().redF());
    lightKs[1] = GLfloat(rGlLight.getSpecular().greenF());
    lightKs[2] = GLfloat(rGlLight.getSpecular().blueF());
    lightKs[3] = GLfloat(rGlLight.getSpecular().alphaF());

    lightKd[0] = GLfloat(rGlLight.getDiffuse().redF());
    lightKd[1] = GLfloat(rGlLight.getDiffuse().greenF());
    lightKd[2] = GLfloat(rGlLight.getDiffuse().blueF());
    lightKd[3] = GLfloat(rGlLight.getDiffuse().alphaF());

    lightDr[0] = GLfloat(rGlLight.getDirection()[0]);
    lightDr[1] = GLfloat(rGlLight.getDirection()[1]);
    lightDr[2] = GLfloat(rGlLight.getDirection()[2]);

    lightPs[0] = GLfloat(rGlLight.getPosition()[0]);
    lightPs[1] = GLfloat(rGlLight.getPosition()[1]);
    lightPs[2] = GLfloat(rGlLight.getPosition()[2]);
    lightPs[3] = 0.0;

    GL_SAFE_CALL(glEnable(lightNumber));

    GL_SAFE_CALL(glLightfv(lightNumber,GL_AMBIENT,lightKa));
    GL_SAFE_CALL(glLightfv(lightNumber,GL_SPECULAR,lightKs));
    GL_SAFE_CALL(glLightfv(lightNumber,GL_DIFFUSE,lightKd));
    GL_SAFE_CALL(glLightfv(lightNumber,GL_SPOT_DIRECTION,lightDr));
    GL_SAFE_CALL(glLightfv(lightNumber,GL_POSITION,lightPs));
}

GLint GLWidget::project(GLdouble objx, GLdouble objy, GLdouble objz, const GLdouble model[], const GLdouble proj[], const GLint viewport[], GLdouble *winx, GLdouble *winy, GLdouble *winz)
{
    GLdouble in[4], out[4];

    in[0] = objx;
    in[1] = objy;
    in[2] = objz;
    in[3] = 1.0;

    this-&gt;transformPoint(out, model, in);
    this-&gt;transformPoint(in, proj, out);

    if (in[3] == 0.0)
    {
        return GL_FALSE;
    }

    in[0] /= in[3];
    in[1] /= in[3];
    in[2] /= in[3];

    *winx = viewport[0] / this-&gt;desktopDevicePixelRatio + (1 + in[0]) * (viewport[2] / this-&gt;desktopDevicePixelRatio) / 2;
    *winy = viewport[1] / this-&gt;desktopDevicePixelRatio + (1 + in[1]) * (viewport[3] / this-&gt;desktopDevicePixelRatio) / 2;

    *winz = (1 + in[2]) / 2;
    return GL_TRUE;
}

</t>
<t tx="leo.20201108101522.68">void GLWidget::transformPoint(GLdouble out[], const GLdouble m[], const GLdouble in[])
{
    #define M(row,col)  m[col*4+row]
    out[0] = M(0, 0) * in[0] + M(0, 1) * in[1] + M(0, 2) * in[2] + M(0, 3) * in[3];
    out[1] = M(1, 0) * in[0] + M(1, 1) * in[1] + M(1, 2) * in[2] + M(1, 3) * in[3];
    out[2] = M(2, 0) * in[0] + M(2, 1) * in[1] + M(2, 2) * in[2] + M(2, 3) * in[3];
    out[3] = M(3, 0) * in[0] + M(3, 1) * in[1] + M(3, 2) * in[2] + M(3, 3) * in[3];
    #undef M
}

</t>
<t tx="leo.20201108101522.69">void GLWidget::resetView(float xRotation, float yRotation, float zRotation)
{
    this-&gt;scale = 1.0;

    this-&gt;calculateModelScale();

    double xPosition(0.0), yPosition(0.0), zPosition(0.0);

    Session::getInstance().getModel(this-&gt;getModelID()).findNodeCenter(xPosition,yPosition,zPosition);

    xPosition *= double(this-&gt;mscale);
    yPosition *= double(this-&gt;mscale);
    zPosition *= double(this-&gt;mscale);

    glLoadIdentity ();

    glRotatef (xRotation, 1.0f, 0.0f, 0.0f);
    glRotatef (yRotation, 0.0f, 1.0f, 0.0f);
    glRotatef (zRotation, 0.0f, 0.0f, 1.0f);

    glGetDoublev (GL_MODELVIEW_MATRIX, this-&gt;lMatrix);

    glTranslated (-xPosition,-yPosition,-zPosition);

    glGetDoublev (GL_MODELVIEW_MATRIX, this-&gt;gMatrix);

    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.7">void GLSimplexPolygon::drawNodes(const std::vector&lt;RNode&gt; &amp;nodes1, const std::vector&lt;RNode&gt; &amp;nodes2, bool volumeElement)
{
    uint nn = uint(nodes1.size());

    for (uint i=0;i&lt;nn;i++)
    {
        GLFunctions::begin(GL_POINTS);
        GLObject::glVertexNode(nodes1[i]);
        if (volumeElement)
        {
            GLObject::glVertexNode(nodes2[i]);
        }
        GLFunctions::end();
    }
}
</t>
<t tx="leo.20201108101522.70">void GLWidget::setClippingPlane(bool enabled, double distance)
{
    this-&gt;clippingPlaneEnabled = enabled;
    this-&gt;clippingPlaneDistance = distance;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.71">void GLWidget::onEntityVisibilityChanged(uint, REntityGroupType, uint, bool )
{
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.72">void GLWidget::onDisplayPropertiesChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)
{
    RLogger::trace("GLWidget::onDisplayPropertiesChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)\n");

    if (this-&gt;modelID != modelID)
    {
        return;
    }

    switch (elementGrpType)
    {
        case R_ENTITY_GROUP_POINT:
            if (this-&gt;glModelList.getNGlPointLists() &gt; entityID)
            {
                this-&gt;glModelList.getGlPointList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                this-&gt;glModelList.getGlPointList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                this-&gt;glModelList.getGlPointList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
            }
            break;
        case R_ENTITY_GROUP_LINE:
            if (this-&gt;glModelList.getNGlLineLists() &gt; entityID)
            {
                this-&gt;glModelList.getGlLineList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                this-&gt;glModelList.getGlLineList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                this-&gt;glModelList.getGlLineList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
            }
            break;
        case R_ENTITY_GROUP_SURFACE:
            if (this-&gt;glModelList.getNGlSurfaceLists() &gt; entityID)
            {
                this-&gt;glModelList.getGlSurfaceList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                this-&gt;glModelList.getGlSurfaceList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                this-&gt;glModelList.getGlSurfaceList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
            }
            break;
        case R_ENTITY_GROUP_VOLUME:
            if (this-&gt;glModelList.getNGlVolumeLists() &gt; entityID)
            {
                this-&gt;glModelList.getGlVolumeList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                this-&gt;glModelList.getGlVolumeList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                this-&gt;glModelList.getGlVolumeList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
            }
            break;
        case R_ENTITY_GROUP_VECTOR_FIELD:
            if (this-&gt;glModelList.getNGlVectorFieldLists() &gt; entityID)
            {
                this-&gt;glModelList.getGlVectorFieldList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
            }
            break;
        case R_ENTITY_GROUP_SCALAR_FIELD:
            if (this-&gt;glModelList.getNGlScalarFieldLists() &gt; entityID)
            {
                this-&gt;glModelList.getGlScalarFieldList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
            }
            break;
        case R_ENTITY_GROUP_STREAM_LINE:
            if (this-&gt;glModelList.getNGlStreamLineLists() &gt; entityID)
            {
                this-&gt;glModelList.getGlStreamLineList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
            }
            break;
        case R_ENTITY_GROUP_CUT:
            if (this-&gt;glModelList.getNGlCutLists() &gt; entityID)
            {
                this-&gt;glModelList.getGlCutList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
            }
            break;
        case R_ENTITY_GROUP_ISO:
            if (this-&gt;glModelList.getNGlIsoLists() &gt; entityID)
            {
                this-&gt;glModelList.getGlIsoList(entityID).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
            }
            break;
        default:
            break;
    }

    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.73">void GLWidget::onVariableDataChanged(uint modelID, RVariableType variableType)
{
    RLogger::trace("GLWidget::onVariableDataChanged(uint modelID, RVariableType variableType)\n");

    if (this-&gt;modelID != modelID)
    {
        return;
    }

    Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    try
    {

        if (this-&gt;glModelList.getNGlPointLists() &gt; 0)
        {
            for (uint j=0;j&lt;rModel.getNPoints();j++)
            {
                const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = rModel.getPoint(j).getData().getVariableData();
                if (egVarData.find(variableType) != egVarData.end())
                {
                    this-&gt;glModelList.getGlPointList(j).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                    this-&gt;glModelList.getGlPointList(j).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                    this-&gt;glModelList.getGlPointList(j).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
                }
            }
        }

        if (this-&gt;glModelList.getNGlLineLists() &gt; 0)
        {
            for (uint j=0;j&lt;rModel.getNLines();j++)
            {
                const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = rModel.getLine(j).getData().getVariableData();
                if (egVarData.find(variableType) != egVarData.end())
                {
                    this-&gt;glModelList.getGlLineList(j).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                    this-&gt;glModelList.getGlLineList(j).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                    this-&gt;glModelList.getGlLineList(j).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
                }
            }
        }

        if (this-&gt;glModelList.getNGlSurfaceLists() &gt; 0)
        {
            for (uint j=0;j&lt;rModel.getNSurfaces();j++)
            {
                const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = rModel.getSurface(j).getData().getVariableData();
                if (egVarData.find(variableType) != egVarData.end())
                {
                    this-&gt;glModelList.getGlSurfaceList(j).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                    this-&gt;glModelList.getGlSurfaceList(j).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                    this-&gt;glModelList.getGlSurfaceList(j).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
                }
            }
        }

        if (this-&gt;glModelList.getNGlVolumeLists() &gt; 0)
        {
            for (uint j=0;j&lt;rModel.getNVolumes();j++)
            {
                const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = rModel.getVolume(j).getData().getVariableData();
                if (egVarData.find(variableType) != egVarData.end())
                {
                    this-&gt;glModelList.getGlVolumeList(j).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                    this-&gt;glModelList.getGlVolumeList(j).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                    this-&gt;glModelList.getGlVolumeList(j).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
                }
            }
        }

        if (this-&gt;glModelList.getNGlVectorFieldLists() &gt; 0)
        {
            for (uint j=0;j&lt;rModel.getNVectorFields();j++)
            {
                const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = rModel.getVectorField(j).getData().getVariableData();
                if (egVarData.find(variableType) != egVarData.end() || rModel.getVectorField(j).getVariableType() == variableType)
                {
                    this-&gt;glModelList.getGlVectorFieldList(j).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                }
            }
        }

        if (this-&gt;glModelList.getNGlScalarFieldLists() &gt; 0)
        {
            for (uint j=0;j&lt;rModel.getNScalarFields();j++)
            {
                const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = rModel.getScalarField(j).getData().getVariableData();
                if (egVarData.find(variableType) != egVarData.end() || rModel.getScalarField(j).getVariableType() == variableType)
                {
                    this-&gt;glModelList.getGlScalarFieldList(j).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                }
            }
        }

        if (this-&gt;glModelList.getNGlStreamLineLists() &gt; 0)
        {
            for (uint j=0;j&lt;rModel.getNStreamLines();j++)
            {
                const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = rModel.getStreamLine(j).getData().getVariableData();
                if (egVarData.find(variableType) != egVarData.end() || rModel.getStreamLine(j).getVariableType() == variableType)
                {
                    this-&gt;glModelList.getGlStreamLineList(j).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                }
            }
        }

        if (this-&gt;glModelList.getNGlCutLists() &gt; 0)
        {
            for (uint j=0;j&lt;rModel.getNCuts();j++)
            {
                const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = rModel.getCut(j).getData().getVariableData();
                if (egVarData.find(variableType) != egVarData.end())
                {
                    this-&gt;glModelList.getGlCutList(j).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                }
            }
        }

        if (this-&gt;glModelList.getNGlIsoLists() &gt; 0)
        {
            for (uint j=0;j&lt;rModel.getNIsos();j++)
            {
                const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = rModel.getIso(j).getData().getVariableData();
                if (egVarData.find(variableType) != egVarData.end() || rModel.getIso(j).getVariableType() == variableType)
                {
                    this-&gt;glModelList.getGlIsoList(j).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                }
            }
        }
    }
    catch (const RError &amp;rError)
    {
        RLogger::error("Failed to handle event. %s",rError.getMessage().toUtf8().constData());
    }

    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.74">void GLWidget::onVariableDataChanged(const SessionEntityID &amp;entityID, RVariableType)
{
    RLogger::trace("GLWidget::onVariableDataChanged(const SessionEntityID &amp;entityID, RVariableType)\n");

    if (this-&gt;modelID != entityID.getMid())
    {
        return;
    }

    try
    {
        switch (entityID.getType())
        {
            case R_ENTITY_GROUP_POINT:
                if (this-&gt;glModelList.getNGlPointLists() &gt; entityID.getEid())
                {
                    this-&gt;glModelList.getGlPointList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                    this-&gt;glModelList.getGlPointList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                    this-&gt;glModelList.getGlPointList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
                }
                break;
            case R_ENTITY_GROUP_LINE:
                if (this-&gt;glModelList.getNGlLineLists() &gt; entityID.getEid())
                {
                    this-&gt;glModelList.getGlLineList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                    this-&gt;glModelList.getGlLineList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                    this-&gt;glModelList.getGlLineList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
                }
                break;
            case R_ENTITY_GROUP_SURFACE:
                if (this-&gt;glModelList.getNGlSurfaceLists() &gt; entityID.getEid())
                {
                    this-&gt;glModelList.getGlSurfaceList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                    this-&gt;glModelList.getGlSurfaceList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                    this-&gt;glModelList.getGlSurfaceList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
                }
                break;
            case R_ENTITY_GROUP_VOLUME:
                if (this-&gt;glModelList.getNGlVolumeLists() &gt; entityID.getEid())
                {
                    this-&gt;glModelList.getGlVolumeList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                    this-&gt;glModelList.getGlVolumeList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_ELEMENT);
                    this-&gt;glModelList.getGlVolumeList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_PICK_NODE);
                }
                break;
            case R_ENTITY_GROUP_VECTOR_FIELD:
                if (this-&gt;glModelList.getNGlVectorFieldLists() &gt; entityID.getEid())
                {
                    this-&gt;glModelList.getGlVectorFieldList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                }
                break;
            case R_ENTITY_GROUP_SCALAR_FIELD:
                if (this-&gt;glModelList.getNGlScalarFieldLists() &gt; entityID.getEid())
                {
                    this-&gt;glModelList.getGlScalarFieldList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                }
                break;
            case R_ENTITY_GROUP_STREAM_LINE:
                if (this-&gt;glModelList.getNGlStreamLineLists() &gt; entityID.getEid())
                {
                    this-&gt;glModelList.getGlStreamLineList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                }
                break;
            case R_ENTITY_GROUP_CUT:
                if (this-&gt;glModelList.getNGlCutLists() &gt; entityID.getEid())
                {
                    this-&gt;glModelList.getGlCutList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                }
                break;
            case R_ENTITY_GROUP_ISO:
                if (this-&gt;glModelList.getNGlIsoLists() &gt; entityID.getEid())
                {
                    this-&gt;glModelList.getGlIsoList(entityID.getEid()).setListInvalid(GL_ENTITY_LIST_ITEM_NORMAL);
                }
                break;
            default:
                break;
        }
    }
    catch (const RError &amp;rError)
    {
        RLogger::error("Failed to handle event. %s",rError.getMessage().toUtf8().constData());
    }

    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.75">void GLWidget::onModelChanged(uint modelID)
{
    if (this-&gt;modelID != modelID)
    {
        return;
    }
    this-&gt;calculateModelScale();
    this-&gt;glModelList.clear();
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.76">void GLWidget::onResultsChanged(uint modelID)
{
    if (this-&gt;modelID != modelID)
    {
        return;
    }
    this-&gt;glModelList.clear();
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.77">void GLWidget::onBeginDrawStreamLinePosition(const RR3Vector &amp;streamLinePosition)
{
    this-&gt;drawStreamLinePosition = true;
    this-&gt;streamLinePosition = streamLinePosition;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.78">void GLWidget::onEndDrawStreamLinePosition(void)
{
    this-&gt;drawStreamLinePosition = false;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.79">void GLWidget::onBeginDrawScaleOrigin(const RR3Vector &amp;scaleOrigin)
{
    this-&gt;drawScaleOrigin = true;
    this-&gt;scaleOrigin = scaleOrigin;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.8">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   gl_simplex_segment.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th August 2015                                        *
 *                                                                   *
 *  DESCRIPTION: OpenGL simplex segment class definition             *
 *********************************************************************/

#include "gl_simplex_segment.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101522.80">void GLWidget::onEndDrawScaleOrigin(void)
{
    this-&gt;drawScaleOrigin = false;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.81">void GLWidget::onBeginDrawRotationOrigin(const RR3Vector &amp;rotationOrigin)
{
    this-&gt;drawRotationOrigin = true;
    this-&gt;rotationOrigin = rotationOrigin;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.82">void GLWidget::onEndDrawRotationOrigin(void)
{
    this-&gt;drawRotationOrigin = false;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.83">void GLWidget::onBeginDrawLocalDirections(const QList&lt;RLocalDirection&gt; &amp;localDirections)
{
    this-&gt;drawLocalDirections = true;
    this-&gt;localDirections = localDirections;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.84">void GLWidget::onEndDrawLocalDirections()
{
    this-&gt;drawLocalDirections = false;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.85">void GLWidget::onBeginDrawCutPlane(const RPlane &amp;plane)
{
    this-&gt;drawCutPlane = true;
    this-&gt;cutPlane = plane;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.86">void GLWidget::onEndDrawCutPlane(void)
{
    this-&gt;drawCutPlane = false;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.87">void GLWidget::onBeginDrawMoveNodes(const QMap&lt;SessionNodeID, RR3Vector&gt; &amp;nodesToMove)
{
    this-&gt;nodesToMove = nodesToMove;
    this-&gt;drawMoveNodes = true;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.88">void GLWidget::onEndDrawMoveNodes(void)
{
    this-&gt;drawMoveNodes = false;
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.89">void GLWidget::onDrawObjectAdded(void)
{
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.9">void GLSimplexSegment::_init(const GLSimplexSegment *pGlSegment)
{
    if (pGlSegment)
    {
        this-&gt;crossArea = pGlSegment-&gt;crossArea;
    }
}

GLSimplexSegment::GLSimplexSegment(GLWidget *glWidget, const std::vector&lt;RR3Vector&gt; &amp;nodes, double crossArea)
    : GLSimplex(glWidget,nodes)
    , crossArea(crossArea)
{
    this-&gt;_init();
}

GLSimplexSegment::GLSimplexSegment(const GLSimplexSegment &amp;glSegment)
    : GLSimplex(glSegment)
{
    this-&gt;_init(&amp;glSegment);
}

GLSimplexSegment::~GLSimplexSegment()
{

}

GLSimplexSegment &amp;GLSimplexSegment::operator =(const GLSimplexSegment &amp;glSegment)
{
    this-&gt;GLSimplex::operator =(glSegment);
    this-&gt;_init(&amp;glSegment);
    return (*this);
}

</t>
<t tx="leo.20201108101522.90">void GLWidget::onDrawObjectRemoved(void)
{
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.91">void GLWidget::onDrawObjectChanged(uint)
{
    this-&gt;update();
}

</t>
<t tx="leo.20201108101522.92">const GLModelList &amp;GLWidget::getGLModelList(void) const
{
    return this-&gt;useGlVoidModelList ? this-&gt;glVoidModelList : this-&gt;glModelList;
}

GLModelList &amp;GLWidget::getGLModelList(void)
{
    return this-&gt;useGlVoidModelList ? this-&gt;glVoidModelList : this-&gt;glModelList;
}

</t>
<t tx="leo.20201108101522.93">const GLActionEvent &amp;GLWidget::getGLActionEvent(void) const
{
    return this-&gt;actionEvent;
}

</t>
<t tx="leo.20201108101522.94">const GLDisplayProperties &amp;GLWidget::getGLDisplayProperties(void) const
{
    return this-&gt;displayProperties;
}

GLDisplayProperties &amp;GLWidget::getGLDisplayProperties(void)
{
    return this-&gt;displayProperties;
}

</t>
<t tx="leo.20201108101522.95">bool GLWidget::getUseGLVoidModelList(void) const
{
    return this-&gt;useGlVoidModelList;
}

</t>
<t tx="leo.20201108101522.96">void GLWidget::setUseGLVoidModelList(bool useGlVoidModelList)
{
    this-&gt;useGlVoidModelList = useGlVoidModelList;
}

</t>
<t tx="leo.20201108101522.97">bool GLWidget::getUseGlCullFace(void) const
{
    return this-&gt;useGlCullFace;
}

</t>
<t tx="leo.20201108101522.98">void GLWidget::setUseGlCullFace(bool useGlCullFace)
{
    bool isDifferent = this-&gt;useGlCullFace != useGlCullFace;
    this-&gt;useGlCullFace = useGlCullFace;
    if (isDifferent)
    {
        Session::getInstance().setModelChanged(this-&gt;modelID);
    }
}

</t>
<t tx="leo.20201108101522.99">void GLWidget::takeScreenShot(const QString &amp;fileName)
{
    QPixmap screenShot(QPixmap::fromImage(this-&gt;grabFramebuffer()));
    QString format = "PNG";
    QString saveFileName(fileName);

    QList&lt;QString&gt; supportedFormats = MainSettings::getSupportedImageFormats();

    if (saveFileName.isEmpty())
    {
        QString filter;

        if (supportedFormats.size() &gt; 0)
        {
            filter = QString("Image files (");

            for (int i=0;i&lt;supportedFormats.size();i++)
            {
                filter += QString("*.%1 ").arg(supportedFormats[i].toLower());
            }

            filter += QString(");;");

            for (int i=0;i&lt;supportedFormats.size();i++)
            {
                filter += QString("%1 (*.%2);;").arg(supportedFormats[i].toUpper(),supportedFormats[i].toLower());
            }
        }
        filter += "All Files (*)";

        saveFileName = QFileDialog::getSaveFileName(MainWindow::getInstance(),
                                                    tr("Save screenshot as"),
                                                    Session::getInstance().getModel(this-&gt;modelID).buildScreenShotFileName(format.toLower()),
                                                    filter);
    }

    if (!saveFileName.isEmpty())
    {
        QFileInfo fi(saveFileName);
        QString suffix(fi.suffix().toUpper());

        for (int i=0;i&lt;supportedFormats.size();i++)
        {
            if (suffix == supportedFormats[i].toUpper())
            {
                format = suffix;
            }
        }

        RLogger::info("Saving screen-shot file \'%s\' in format \'%s\'.\n",saveFileName.toUtf8().constData(), format.toUtf8().constData());
        screenShot.save(saveFileName, format.toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101523.1">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   help_general_widget.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th January 2018                                       *
 *                                                                   *
 *  DESCRIPTION: Help general and tricks widget class definition     *
 *********************************************************************/

#include &lt;rmlib.h&gt;

#include "help_general_widget.h"
#include "main_settings.h"

HelpGeneralWidget::HelpGeneralWidget(QWidget *parent)
    : DocumentWidget(RFileManager::buildPath(MainSettings::getInstance().getApplicationSettings()-&gt;getHelpDir(),"general_index.html"),parent)
{
    QStringList general;

    general.append("Model");
    general.append("Problem");
    general.append("Problem type");
    general.append("Boundary condition");
    general.append("Initial condition");
    general.append("Environment condition");
    general.append("Material");
    general.append("Solver");
    general.append("Results");

    foreach (const QString &amp;tipName, general)
    {
        this-&gt;addListItem(tipName,
                          RFileManager::buildPath(MainSettings::getInstance().getApplicationSettings()-&gt;getHelpDir(),"general_" + tipName + ".html"));
    }
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.10">const QMap&lt;QString, QString&gt; &amp;HttpRequestInput::getVariableMap(void) const
{
    return this-&gt;variables;
}

QMap&lt;QString, QString&gt; &amp;HttpRequestInput::getVariableMap(void)
{
    return this-&gt;variables;
}

</t>
<t tx="leo.20201108101523.11">const QList&lt;HttpRequestInput::FileElement&gt; &amp;HttpRequestInput::getFileList(void) const
{
    return this-&gt;files;
}

QList&lt;HttpRequestInput::FileElement&gt; &amp;HttpRequestInput::getFileList(void)
{
    return this-&gt;files;
}

</t>
<t tx="leo.20201108101523.12">void HttpRequestInput::addVariable(QString key, QString value)
{
    variables[key] = value;
}

</t>
<t tx="leo.20201108101523.13">void HttpRequestInput::addFile(QString variable_name, QString local_filename, QString request_filename, QString mime_type)
{
    FileElement file;
    file.variableName = variable_name;
    file.localFilename = local_filename;
    file.requestFilename = request_filename;
    file.mimeType = mime_type;
    files.append(file);
}

</t>
<t tx="leo.20201108101523.14">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   http_request_worker.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th May 2016                                           *
 *                                                                   *
 *  DESCRIPTION: HTTP request worker class definition                *
 *********************************************************************/

#include &lt;QDateTime&gt;
#include &lt;QUrl&gt;
#include &lt;QFileInfo&gt;
#include &lt;QBuffer&gt;
#include &lt;QAuthenticator&gt;
#include &lt;QNetworkProxyFactory&gt;

#include &lt;rblib.h&gt;

#include "http_request_worker.h"

HttpRequestWorker::HttpRequestWorker(QNetworkAccessManager *networkAccessManager, QObject *parent)
    : QObject(parent)
    , manager(networkAccessManager)
{
    qsrand(QDateTime::currentDateTime().toTime_t());

    QNetworkProxyFactory *pProxyFactory = this-&gt;manager-&gt;proxyFactory();
    pProxyFactory-&gt;setUseSystemConfiguration(true);

    QObject::connect(this-&gt;manager,
                     &amp;QNetworkAccessManager::authenticationRequired,
                     this,
                     &amp;HttpRequestWorker::onManagerAuthenticationRequired);

    QObject::connect(this-&gt;manager,
                     &amp;QNetworkAccessManager::encrypted,
                     this,
                     &amp;HttpRequestWorker::onManagerEncrypted);

    QObject::connect(this-&gt;manager,
                     &amp;QNetworkAccessManager::finished,
                     this,
                     &amp;HttpRequestWorker::onManagerFinished);

    QObject::connect(this-&gt;manager,
                     &amp;QNetworkAccessManager::networkAccessibleChanged,
                     this,
                     &amp;HttpRequestWorker::onManagerNetworkAccessibleChanged);

    QObject::connect(this-&gt;manager,
                     &amp;QNetworkAccessManager::preSharedKeyAuthenticationRequired,
                     this,
                     &amp;HttpRequestWorker::onManagerPreSharedKeyAuthenticationRequired);

    QObject::connect(this-&gt;manager,
                     &amp;QNetworkAccessManager::proxyAuthenticationRequired,
                     this,
                     &amp;HttpRequestWorker::onManagerProxyAuthenticationRequired);

#ifndef QT_NO_SSL
    QObject::connect(this-&gt;manager,
                     &amp;QNetworkAccessManager::sslErrors,
                     this,
                     &amp;HttpRequestWorker::onSslErrors);
#endif
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.15">const QByteArray &amp;HttpRequestWorker::getResponse(void) const
{
    return this-&gt;response;
}

QNetworkReply::NetworkError HttpRequestWorker::getErrorType() const
{
    return this-&gt;errorType;
}

</t>
<t tx="leo.20201108101523.16">const QString &amp;HttpRequestWorker::getError(void) const
{
    return this-&gt;errorStr;
}

</t>
<t tx="leo.20201108101523.17">void HttpRequestWorker::execute(HttpRequestInput *pInput)
{
    this-&gt;pRequestInput = pInput;

    // reset variables

    QByteArray requestContent = "";
    this-&gt;response = "";
    this-&gt;errorType = QNetworkReply::NoError;
    this-&gt;errorStr = "";

    QMap&lt;QString, QString&gt; &amp;rVariables = this-&gt;pRequestInput-&gt;getVariableMap();
    QList&lt;HttpRequestInput::FileElement&gt; &amp;rFileList = this-&gt;pRequestInput-&gt;getFileList();

    // decide on the variable layout

    if (rFileList.length() &gt; 0)
    {
        this-&gt;pRequestInput-&gt;setVariableLayout(HttpRequestInput::MULTIPART);
    }
    if (this-&gt;pRequestInput-&gt;getVariableLayout() == HttpRequestInput::NOT_SET)
    {
        this-&gt;pRequestInput-&gt;setVariableLayout(this-&gt;pRequestInput-&gt;getHttpMethod() == "GET" || this-&gt;pRequestInput-&gt;getHttpMethod() == "HEAD" ? HttpRequestInput::ADDRESS : HttpRequestInput::URL_ENCODED);
    }


    // prepare request content

    QString boundary = "";

    if (this-&gt;pRequestInput-&gt;getVariableLayout() == HttpRequestInput::ADDRESS || this-&gt;pRequestInput-&gt;getVariableLayout() == HttpRequestInput::URL_ENCODED)
    {
        // variable layout is ADDRESS or URL_ENCODED

        if (rVariables.count() &gt; 0)
        {
            bool first = true;
            foreach (QString key, rVariables.keys())
            {
                if (!first)
                {
                    requestContent.append("&amp;");
                }
                first = false;

                requestContent.append(QUrl::toPercentEncoding(key));
                requestContent.append("=");
                requestContent.append(QUrl::toPercentEncoding(rVariables.value(key)));
            }

            if (this-&gt;pRequestInput-&gt;getVariableLayout() == HttpRequestInput::ADDRESS)
            {
                this-&gt;pRequestInput-&gt;getUrlStr() += "?" + requestContent;
                requestContent = "";
            }
        }
    }
    else
    {
        // variable layout is MULTIPART

        boundary = "__-----------------------"
            + QString::number(QDateTime::currentDateTime().toTime_t())
            + QString::number(qrand());
        QString boundary_delimiter = "--";
        QString new_line = "\r\n";

        // add variables
        foreach (QString key, rVariables.keys())
        {
            // add boundary
            requestContent.append(boundary_delimiter);
            requestContent.append(boundary);
            requestContent.append(new_line);

            // add header
            requestContent.append("Content-Disposition: form-data; ");
            requestContent.append(HttpRequestWorker::httpAttributeEncode("name", key));
            requestContent.append(new_line);
            requestContent.append("Content-Type: text/plain");
            requestContent.append(new_line);

            // add header to body splitter
            requestContent.append(new_line);

            // add variable content
            requestContent.append(rVariables.value(key));
            requestContent.append(new_line);
        }

        // add files
        for (QList&lt;HttpRequestInput::FileElement&gt;::iterator fileIterator = rFileList.begin(); fileIterator != rFileList.end(); fileIterator++)
        {
            QFileInfo fi(fileIterator-&gt;localFilename);

            // ensure necessary variables are available
            if (
                fileIterator-&gt;localFilename == nullptr || fileIterator-&gt;localFilename.isEmpty()
                || fileIterator-&gt;variableName == nullptr || fileIterator-&gt;variableName.isEmpty()
                || !fi.exists() || !fi.isFile() || !fi.isReadable()
            )
            {
                // silent abort for the current file
                continue;
            }

            QFile file(fileIterator-&gt;localFilename);
            if (!file.open(QIODevice::ReadOnly))
            {
                // silent abort for the current file
                continue;
            }

            // ensure filename for the request
            if (fileIterator-&gt;requestFilename == nullptr || fileIterator-&gt;requestFilename.isEmpty())
            {
                fileIterator-&gt;requestFilename = fi.fileName();
                if (fileIterator-&gt;requestFilename.isEmpty())
                {
                    fileIterator-&gt;requestFilename = "file";
                }
            }

            // add boundary
            requestContent.append(boundary_delimiter);
            requestContent.append(boundary);
            requestContent.append(new_line);

            // add header
            requestContent.append(QString("Content-Disposition: form-data; %1; %2").arg(
                HttpRequestWorker::httpAttributeEncode("name", fileIterator-&gt;variableName),
                HttpRequestWorker::httpAttributeEncode("filename", fileIterator-&gt;requestFilename)
            ));
            requestContent.append(new_line);

            if (fileIterator-&gt;mimeType != nullptr &amp;&amp; !fileIterator-&gt;mimeType.isEmpty())
            {
                requestContent.append("Content-Type: ");
                requestContent.append(fileIterator-&gt;mimeType);
                requestContent.append(new_line);
            }

            requestContent.append("Content-Transfer-Encoding: binary");
            requestContent.append(new_line);

            // add header to body splitter
            requestContent.append(new_line);

            // add file content
            requestContent.append(file.readAll());
            requestContent.append(new_line);

            file.close();
        }

        // add end of body
        requestContent.append(boundary_delimiter);
        requestContent.append(boundary);
        requestContent.append(boundary_delimiter);
    }

    // prepare connection
    QNetworkRequest request = QNetworkRequest(QUrl(this-&gt;pRequestInput-&gt;getUrlStr()));
    request.setRawHeader("User-Agent", "Agent name goes here");

    if (this-&gt;pRequestInput-&gt;getVariableLayout() == HttpRequestInput::URL_ENCODED)
    {
        request.setHeader(QNetworkRequest::ContentTypeHeader, "application/x-www-form-urlencoded");
    }
    else if (this-&gt;pRequestInput-&gt;getVariableLayout() == HttpRequestInput::MULTIPART)
    {
        request.setHeader(QNetworkRequest::ContentTypeHeader, "multipart/form-data; boundary=" + boundary);
    }

    if (this-&gt;pRequestInput-&gt;getHttpMethod() == "GET")
    {
        this-&gt;manager-&gt;get(request);
    }
    else if (this-&gt;pRequestInput-&gt;getHttpMethod() == "POST")
    {
        this-&gt;manager-&gt;post(request, requestContent);
    }
    else if (this-&gt;pRequestInput-&gt;getHttpMethod() == "PUT")
    {
        this-&gt;manager-&gt;put(request, requestContent);
    }
    else if (this-&gt;pRequestInput-&gt;getHttpMethod() == "HEAD")
    {
        this-&gt;manager-&gt;head(request);
    }
    else if (this-&gt;pRequestInput-&gt;getHttpMethod() == "DELETE")
    {
        this-&gt;manager-&gt;deleteResource(request);
    }
    else
    {
        QBuffer buff(&amp;requestContent);
        this-&gt;manager-&gt;sendCustomRequest(request, this-&gt;pRequestInput-&gt;getHttpMethod().toLatin1(), &amp;buff);
    }
}

QString HttpRequestWorker::httpAttributeEncode(QString attributeName, QString input)
{
    // result structure follows RFC 5987
    bool needUtfEncoding = false;
    QString result = "";
    QByteArray input_c = input.toLocal8Bit();
    char c;
    for (int i = 0; i &lt; input_c.length(); i++)
    {
        c = input_c.at(i);
        if (c == '\\' || c == '/' || c == '\0' || c &lt; ' ' || c &gt; '~')
        {
            // ignore and request utf-8 version
            needUtfEncoding = true;
        }
        else if (c == '"')
        {
            result += "\\\"";
        }
        else
        {
            result += c;
        }
    }

    if (result.length() == 0)
    {
        needUtfEncoding = true;
    }

    if (!needUtfEncoding)
    {
        // return simple version
        return QString("%1=\"%2\"").arg(attributeName, result);
    }

    QString resultUtf8 = "";
    for (int i = 0; i &lt; input_c.length(); i++)
    {
        c = input_c.at(i);
        if (
            (c &gt;= '0' &amp;&amp; c &lt;= '9')
            || (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
            || (c &gt;= 'a' &amp;&amp; c &lt;= 'z')
        )
        {
            resultUtf8 += c;
        }
        else
        {
            resultUtf8 += "%" + QString::number(static_cast&lt;unsigned char&gt;(input_c.at(i)), 16).toUpper();
        }
    }

    // return enhanced version with UTF-8 support
    return QString("%1=\"%2\"; %1*=utf-8''%3").arg(attributeName, result, resultUtf8);
}

</t>
<t tx="leo.20201108101523.18">void HttpRequestWorker::onManagerAuthenticationRequired(QNetworkReply *, QAuthenticator *)
{
    RLogger::warning("Authentication is required.\n");
}

</t>
<t tx="leo.20201108101523.19">void HttpRequestWorker::onManagerEncrypted(QNetworkReply *)
{
    RLogger::info("Encrypted connection.\n");
}

</t>
<t tx="leo.20201108101523.2">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   help_tips_widget.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th November 2017                                      *
 *                                                                   *
 *  DESCRIPTION: Help tips and tricks widget class definition        *
 *********************************************************************/

#include &lt;rmlib.h&gt;

#include "help_tips_widget.h"
#include "main_settings.h"

HelpTipsWidget::HelpTipsWidget(QWidget *parent)
    : DocumentWidget(RFileManager::buildPath(MainSettings::getInstance().getApplicationSettings()-&gt;getHelpDir(),"tip_index.html"),parent)
{
    QStringList tips;


    foreach (const QString &amp;tipName, tips)
    {
        this-&gt;addListItem(tipName,
                          RFileManager::buildPath(MainSettings::getInstance().getApplicationSettings()-&gt;getHelpDir(),"tip_" + tipName + ".html"));
    }
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.20">void HttpRequestWorker::onManagerFinished(QNetworkReply *reply)
{
    if (!reply)
    {
        // No reply provided
        RLogger::error("HTTP request without a reply.\n");
        this-&gt;errorType = QNetworkReply::UnknownServerError;
        delete this-&gt;pRequestInput;
        this-&gt;pRequestInput = nullptr;
        emit this-&gt;finished();
        return;
    }

    this-&gt;errorType = reply-&gt;error();

    if (this-&gt;errorType)
    {
        // Error occured
        this-&gt;errorStr = reply-&gt;errorString();

        reply-&gt;deleteLater();
        reply = nullptr;
        delete this-&gt;pRequestInput;
        this-&gt;pRequestInput = nullptr;
        emit this-&gt;finished();
        return;
    }

    const QVariant redirectionTarget = reply-&gt;attribute(QNetworkRequest::RedirectionTargetAttribute);
    if (!redirectionTarget.isNull())
    {
        // Redirection
        RLogger::info("HTTP request was redirected to: \'%s\'\n",redirectionTarget.toUrl().toString().toUtf8().constData());

        QUrl url(this-&gt;pRequestInput-&gt;getUrlStr());
        this-&gt;pRequestInput-&gt;setUrlStr(url.resolved(redirectionTarget.toUrl()).toString());

        this-&gt;execute(this-&gt;pRequestInput);

        reply-&gt;deleteLater();
        reply = nullptr;
        return;
    }

    // Success
    this-&gt;response = reply-&gt;readAll();
    reply-&gt;deleteLater();
    reply = nullptr;
    delete this-&gt;pRequestInput;
    this-&gt;pRequestInput = nullptr;
    emit this-&gt;finished();
}

</t>
<t tx="leo.20201108101523.21">void HttpRequestWorker::onManagerNetworkAccessibleChanged(QNetworkAccessManager::NetworkAccessibility accessible)
{
    RLogger::info("Network eccessibility has changed to .");
    switch (accessible)
    {
        case QNetworkAccessManager::UnknownAccessibility:
        {
            RLogger::warning("The network accessibility cannot be determined.\n");
            break;
        }
        case QNetworkAccessManager::NotAccessible:
        {
            RLogger::warning("The network is not currently accessible.\n");
            break;
        }
        case QNetworkAccessManager::Accessible:
        {
            RLogger::info("The network is accessible.\n");
            break;
        }
    }
}

</t>
<t tx="leo.20201108101523.22">void HttpRequestWorker::onManagerPreSharedKeyAuthenticationRequired(QNetworkReply *, QSslPreSharedKeyAuthenticator *)
{
#ifdef DEBUG
    RLogger::info("SSL/TLS handshake negotiates a PSK ciphersuite, and therefore a PSK authentication is then required.\n");
#endif
}

</t>
<t tx="leo.20201108101523.23">void HttpRequestWorker::onManagerProxyAuthenticationRequired(const QNetworkProxy &amp;, QAuthenticator *)
{
    RLogger::warning("Proxy authentication is required.\n");
}

#ifndef QT_NO_SSL
</t>
<t tx="leo.20201108101523.24">void HttpRequestWorker::onSslErrors(QNetworkReply *reply, const QList&lt;QSslError&gt; &amp;errors)
{
    if (!reply)
    {
        RLogger::error("HTTP request without a reply.\n");
        this-&gt;errorType = QNetworkReply::UnknownServerError;
    }
    else
    {
        QString errorString;
        foreach (const QSslError &amp;error, errors) {
            RLogger::warning("SSL error has occurred: %s\n",error.errorString().toUtf8().constData());
        }

        reply-&gt;ignoreSslErrors();
    }
}
#endif

</t>
<t tx="leo.20201108101523.25">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   ic_manager_tree.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Initial condition tree manager class definition     *
 *********************************************************************/

#include &lt;vector&gt;
#include &lt;QList&gt;
#include &lt;QMessageBox&gt;

#include &lt;rmlib.h&gt;

#include "session.h"
#include "ic_manager_tree.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.26">typedef enum _InitialConditionTreeColumn
{
    IC_TREE_COLUMN_NAME = 0,
    IC_TREE_N_COLUMNS
} InitialConditionTreeColumn;

ICManagerTree::ICManagerTree(QObject *parent) :
    QTreeWidget((QWidget*)parent),
    doNotPopulate(false)
{
    this-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;setSortingEnabled(true);
    this-&gt;sortByColumn(IC_TREE_COLUMN_NAME,Qt::AscendingOrder);

    this-&gt;setColumnCount(IC_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(IC_TREE_COLUMN_NAME,QString("Name"));
    this-&gt;setHeaderItem(headerItem);
    this-&gt;setHeaderHidden(true);
    this-&gt;setRootIsDecorated(false);

    QObject::connect(&amp;Session::getInstance(),&amp;Session::problemSelectionChanged,this,&amp;ICManagerTree::onProblemChanged);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::modelSelectionChanged,this,&amp;ICManagerTree::onModelSelectionChanged);
    QObject::connect(this,&amp;ICManagerTree::itemChanged,this,&amp;ICManagerTree::onItemChanged);
    QObject::connect(this,&amp;ICManagerTree::itemSelectionChanged,this,&amp;ICManagerTree::onItemSelectionChanged);
    QObject::connect(this,&amp;ICManagerTree::icSelected,this,&amp;ICManagerTree::onIcSelected);
}

</t>
<t tx="leo.20201108101523.27">void ICManagerTree::populate(void)
{
    if (this-&gt;doNotPopulate)
    {
        return;
    }

    RProblemTypeMask icPrbTypeMask;
    RProblemTypeMask modelPrbTypeMask = R_PROBLEM_NONE;
    REntityGroupTypeMask elementGroupTypeMask = R_ENTITY_GROUP_NONE;
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;selectedEntityIDs.size();i++)
    {
        elementGroupTypeMask |= selectedEntityIDs[i].getType();
        modelPrbTypeMask |= Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getProblemTaskTree().getProblemTypeMask();
    }

    QList&lt;QTreeWidgetItem*&gt; selectedItemsList = this-&gt;selectedItems();
    // Following is a hack to not to clear selected types list if item is being deselected.
    if (selectedItemsList.size() &gt; 0)
    {
        this-&gt;selectedTypes.clear();
    }
    for (int i=0;i&lt;selectedItemsList.size();i++)
    {
        this-&gt;selectedTypes.append(RInitialConditionType(selectedItemsList[i]-&gt;data(IC_TREE_COLUMN_NAME,Qt::UserRole).toInt()));
    }

    this-&gt;blockSignals(true);

    this-&gt;clear();

    QMap&lt;RInitialConditionType,uint&gt; icMap = this-&gt;getIcMap(selectedEntityIDs);

    for (RInitialConditionType icType = (RInitialConditionType)((int)R_INITIAL_CONDITION_NONE + 1);
                               icType &lt; R_INITIAL_CONDITION_N_TYPES;
                               icType ++)
    {
        icPrbTypeMask = RInitialCondition::getProblemTypeMask(icType);
        if (!(icPrbTypeMask &amp; modelPrbTypeMask))
        {
            continue;
        }
        bool applies = false;
        if (elementGroupTypeMask &amp; R_ENTITY_GROUP_POINT ||
            elementGroupTypeMask &amp; R_ENTITY_GROUP_LINE ||
            elementGroupTypeMask &amp; R_ENTITY_GROUP_SURFACE ||
            elementGroupTypeMask &amp; R_ENTITY_GROUP_VOLUME)
        {
            applies = true;
        }
        if (!applies)
        {
            continue;
        }

        Qt::CheckState state = Qt::Unchecked;
        if (icMap.contains(icType))
        {
            if (icMap.value(icType,1) == (uint)selectedEntityIDs.size())
            {
                state = Qt::Checked;
            }
            else
            {
                state = Qt::PartiallyChecked;
            }
        }
        QTreeWidgetItem *itemModel = new QTreeWidgetItem(this);
        itemModel-&gt;setText(IC_TREE_COLUMN_NAME, RInitialCondition::getName(icType));
        itemModel-&gt;setData(IC_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(state));
        itemModel-&gt;setData(IC_TREE_COLUMN_NAME,Qt::UserRole,QVariant(icType));
    }

    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        this-&gt;topLevelItem(i)-&gt;setSelected(false);
        for (int j=0;j&lt;this-&gt;selectedTypes.size();j++)
        {
            if (this-&gt;selectedTypes[j] == RInitialConditionType(this-&gt;topLevelItem(i)-&gt;data(IC_TREE_COLUMN_NAME,Qt::UserRole).toInt()))
            {
                this-&gt;topLevelItem(i)-&gt;setSelected(true);
                break;
            }
        }
    }

    this-&gt;blockSignals(false);

    emit this-&gt;itemSelectionChanged();
}

</t>
<t tx="leo.20201108101523.28">void ICManagerTree::onModelSelectionChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101523.29">void ICManagerTree::onProblemChanged(uint)
{
    this-&gt;populate();
}

QMap&lt;RInitialConditionType,uint&gt; ICManagerTree::getIcMap(const QList&lt;SessionEntityID&gt; &amp;entityIDs) const
{
    QMap&lt;RInitialConditionType,uint&gt; icMap;
    RInitialConditionType icType;
    uint icCount;

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(entityIDs[i].getMid());

        if (entityIDs[i].getType() == R_ENTITY_GROUP_POINT)
        {
            for (uint j=0;j&lt;pModel-&gt;getPoint(entityIDs[i].getEid()).getNInitialConditions();j++)
            {
                icType = pModel-&gt;getPoint(entityIDs[i].getEid()).getInitialCondition(j).getType();
                icCount = icMap.value(icType,0) + 1;
                icMap.insert(icType,icCount);
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_LINE)
        {
            for (uint j=0;j&lt;pModel-&gt;getLine(entityIDs[i].getEid()).getNInitialConditions();j++)
            {
                icType = pModel-&gt;getLine(entityIDs[i].getEid()).getInitialCondition(j).getType();
                icCount = icMap.value(icType,0) + 1;
                icMap.insert(icType,icCount);
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_SURFACE)
        {
            for (uint j=0;j&lt;pModel-&gt;getSurface(entityIDs[i].getEid()).getNInitialConditions();j++)
            {
                icType = pModel-&gt;getSurface(entityIDs[i].getEid()).getInitialCondition(j).getType();
                icCount = icMap.value(icType,0) + 1;
                icMap.insert(icType,icCount);
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_VOLUME)
        {
            for (uint j=0;j&lt;pModel-&gt;getVolume(entityIDs[i].getEid()).getNInitialConditions();j++)
            {
                icType = pModel-&gt;getVolume(entityIDs[i].getEid()).getInitialCondition(j).getType();
                icCount = icMap.value(icType,0) + 1;
                icMap.insert(icType,icCount);
            }
        }
    }

    return icMap;
}

</t>
<t tx="leo.20201108101523.3">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   help_tutorial_widget.cpp                                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th December 2017                                       *
 *                                                                   *
 *  DESCRIPTION: Help tutorial widget class definition               *
 *********************************************************************/

#include &lt;rmlib.h&gt;

#include "help_tutorial_widget.h"
#include "main_settings.h"

HelpTutorialWidget::HelpTutorialWidget(QWidget *parent)
    : DocumentWidget(RFileManager::buildPath(MainSettings::getInstance().getApplicationSettings()-&gt;getHelpDir(),"tutorial_index.html"),parent)
{
    QStringList tutorials;

    tutorials.append("Draw cube");
    tutorials.append("Transform geometry");
    tutorials.append("Stress and deformation analysis");
    tutorials.append("Multiphysics");
    tutorials.append("Contaminant dispersion in fluids");

    foreach (const QString &amp;tutorialName, tutorials)
    {
        this-&gt;addListItem(tutorialName,
                          RFileManager::buildPath(MainSettings::getInstance().getApplicationSettings()-&gt;getHelpDir(),"tutorial_" + tutorialName + ".html"));
    }
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.30">void ICManagerTree::onItemChanged(QTreeWidgetItem *item, int column)
{
    Qt::CheckState checkState = item-&gt;checkState(column);
    RInitialConditionType icType = (RInitialConditionType) item-&gt;data(IC_TREE_COLUMN_NAME,Qt::UserRole).toInt();
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(entityIDs[i].getMid());
        if (entityIDs[i].getType() == R_ENTITY_GROUP_POINT)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getPoint(entityIDs[i].getEid()).addInitialCondition(RInitialCondition(icType));
            }
            else
            {
                if (pModel-&gt;getPoint(entityIDs[i].getEid()).hasInitialCondition(icType))
                {
                    pModel-&gt;getPoint(entityIDs[i].getEid()).removeInitialCondition(icType);
                }
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_LINE)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getLine(entityIDs[i].getEid()).addInitialCondition(RInitialCondition(icType));
            }
            else
            {
                if (pModel-&gt;getLine(entityIDs[i].getEid()).hasInitialCondition(icType))
                {
                    pModel-&gt;getLine(entityIDs[i].getEid()).removeInitialCondition(icType);
                }
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_SURFACE)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getSurface(entityIDs[i].getEid()).addInitialCondition(RInitialCondition(icType));
            }
            else
            {
                if (pModel-&gt;getSurface(entityIDs[i].getEid()).hasInitialCondition(icType))
                {
                    pModel-&gt;getSurface(entityIDs[i].getEid()).removeInitialCondition(icType);
                }
            }
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_VOLUME)
        {
            if (checkState == Qt::Checked)
            {
                pModel-&gt;getVolume(entityIDs[i].getEid()).addInitialCondition(RInitialCondition(icType));
            }
            else
            {
                if (pModel-&gt;getVolume(entityIDs[i].getEid()).hasInitialCondition(icType))
                {
                    pModel-&gt;getVolume(entityIDs[i].getEid()).removeInitialCondition(icType);
                }
            }
        }
    }

    if (item-&gt;isSelected())
    {
        emit this-&gt;icSelected(icType,(checkState != Qt::Unchecked));
    }
    else
    {
        emit this-&gt;icSelected(R_INITIAL_CONDITION_NONE,false);
    }
}

</t>
<t tx="leo.20201108101523.31">void ICManagerTree::onItemSelectionChanged(void)
{
    QList&lt;QTreeWidgetItem *&gt; items = this-&gt;selectedItems();
    emit this-&gt;icSelected(R_INITIAL_CONDITION_NONE,false);
    for (int i=0;i&lt;items.size();i++)
    {
        RInitialConditionType icType = (RInitialConditionType)items[i]-&gt;data(IC_TREE_COLUMN_NAME,Qt::UserRole).toInt();
        bool applied = (items[i]-&gt;checkState(IC_TREE_COLUMN_NAME) == Qt::Checked);
        emit this-&gt;icSelected(icType,applied);
    }
}

</t>
<t tx="leo.20201108101523.32">void ICManagerTree::onIcSelected(void)
{
    this-&gt;doNotPopulate = true;
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
    this-&gt;doNotPopulate = false;
}
</t>
<t tx="leo.20201108101523.33">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   ic_tree.cpp                                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Initial condition tree class definition             *
 *********************************************************************/

#include &lt;QStandardItemModel&gt;
#include &lt;QLineEdit&gt;
#include &lt;QPushButton&gt;

#include "component_edit_dialog.h"
#include "session.h"
#include "ic_tree.h"
#include "variable_value_edit.h"
#include "push_button.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.34">typedef enum _ICTreeColumn
{
    IC_TREE_PROPERTY_NAME = 0,
    IC_TREE_PROPERTY_VALUE,
    IC_TREE_PROPERTY_UNITS,
    IC_TREE_PROPERTY_TYPE,
    IC_TREE_N_COLUMNS
} ICTreeColumn;

ICTree::ICTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setRootIsDecorated(false);
    this-&gt;setSelectionMode(QAbstractItemView::NoSelection);

    this-&gt;setColumnCount(IC_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(IC_TREE_PROPERTY_TYPE,QString("Property type"));
    headerItem-&gt;setText(IC_TREE_PROPERTY_NAME,QString("Property name"));
    headerItem-&gt;setText(IC_TREE_PROPERTY_VALUE,QString("Value"));
    headerItem-&gt;setText(IC_TREE_PROPERTY_UNITS,QString("Units"));
    this-&gt;setHeaderItem(headerItem);

    this-&gt;setColumnHidden(IC_TREE_PROPERTY_TYPE,true);

    this-&gt;populate();
}

</t>
<t tx="leo.20201108101523.35">void ICTree::populate(void)
{
    this-&gt;clear();

    for (uint i=0;i&lt;this-&gt;ic.size();i++)
    {
        RConditionComponent component = this-&gt;ic.getComponent(i);

        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setData(IC_TREE_PROPERTY_TYPE,Qt::DisplayRole,QVariant(component.getType()));
        item-&gt;setText(IC_TREE_PROPERTY_NAME,component.getName());
        item-&gt;setText(IC_TREE_PROPERTY_UNITS,component.getUnits());
        VariableValueEdit *lineEdit = new VariableValueEdit(component.getType());
        lineEdit-&gt;setValue(component.getValue(0));
        this-&gt;setItemWidget(item,IC_TREE_PROPERTY_VALUE,lineEdit);

        QObject::connect(lineEdit,&amp;VariableValueEdit::valueChanged,this,&amp;ICTree::onIcValueChanged);
    }

    this-&gt;resizeColumnToContents(IC_TREE_PROPERTY_NAME);
    this-&gt;resizeColumnToContents(IC_TREE_PROPERTY_VALUE);
    this-&gt;resizeColumnToContents(IC_TREE_PROPERTY_UNITS);
}

</t>
<t tx="leo.20201108101523.36">void ICTree::updateSelectedEntities(void) const
{
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        switch (entityIDs[i].getType())
        {
            case R_ENTITY_GROUP_POINT:
                Session::getInstance().getModel(entityIDs[i].getMid()).getPoint(entityIDs[i].getEid()).addInitialCondition(this-&gt;ic);
                break;
            case R_ENTITY_GROUP_LINE:
                Session::getInstance().getModel(entityIDs[i].getMid()).getLine(entityIDs[i].getEid()).addInitialCondition(this-&gt;ic);
                break;
            case R_ENTITY_GROUP_SURFACE:
                Session::getInstance().getModel(entityIDs[i].getMid()).getSurface(entityIDs[i].getEid()).addInitialCondition(this-&gt;ic);
                break;
            case R_ENTITY_GROUP_VOLUME:
                Session::getInstance().getModel(entityIDs[i].getMid()).getVolume(entityIDs[i].getEid()).addInitialCondition(this-&gt;ic);
                break;
            default:
                break;
        }
        Session::getInstance().setInitialConditionChanged(entityIDs[i].getMid(),
                                                           entityIDs[i].getType(),
                                                           entityIDs[i].getEid());
    }

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
}

</t>
<t tx="leo.20201108101523.37">void ICTree::onIcSelected(RInitialConditionType icType, bool applied)
{
    if (applied)
    {
        QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

        for (int i=0;i&lt;entityIDs.size();i++)
        {
            switch (entityIDs[i].getType())
            {
                case R_ENTITY_GROUP_POINT:
                    this-&gt;ic = Session::getInstance().getModel(entityIDs[i].getMid()).getPoint(entityIDs[i].getEid()).getInitialCondition(icType);
                    break;
                case R_ENTITY_GROUP_LINE:
                    this-&gt;ic = Session::getInstance().getModel(entityIDs[i].getMid()).getLine(entityIDs[i].getEid()).getInitialCondition(icType);
                    break;
                case R_ENTITY_GROUP_SURFACE:
                    this-&gt;ic = Session::getInstance().getModel(entityIDs[i].getMid()).getSurface(entityIDs[i].getEid()).getInitialCondition(icType);
                    break;
                case R_ENTITY_GROUP_VOLUME:
                    this-&gt;ic = Session::getInstance().getModel(entityIDs[i].getMid()).getVolume(entityIDs[i].getEid()).getInitialCondition(icType);
                    break;
                default:
                    this-&gt;ic.setType(icType);
                    break;
            }
        }

        this-&gt;populate();
    }
    else
    {
        this-&gt;ic.setType(R_INITIAL_CONDITION_NONE);
        this-&gt;clear();
    }
}

</t>
<t tx="leo.20201108101523.38">void ICTree::onIcValueChanged(RVariableType variableType, double value)
{
    for (uint i=0;i&lt;this-&gt;ic.size();i++)
    {
        if (this-&gt;ic.getComponent(i).getType() == variableType)
        {
            this-&gt;ic.getComponent(i).add(0,value);
        }
    }

    this-&gt;updateSelectedEntities();
}
</t>
<t tx="leo.20201108101523.39">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   iso_dialog.cpp                                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   22-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Iso dialog class definition                         *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include "session.h"
#include "iso_dialog.h"

IsoDialog::IsoDialog(uint modelID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityID(RConstants::eod)
{
    this-&gt;createDialog();
}

IsoDialog::IsoDialog(uint modelID, uint entityID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityID(entityID)
{
    this-&gt;createDialog();
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.4">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   http_request_worker.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th May 2016                                           *
 *                                                                   *
 *  DESCRIPTION: HTTP request worker class definition                *
 *********************************************************************/

#include &lt;QDateTime&gt;
#include &lt;QUrl&gt;
#include &lt;QFileInfo&gt;
#include &lt;QBuffer&gt;

#include "http_request_worker.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.40">int IsoDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        Session::getInstance().storeCurentModelVersion(this-&gt;modelID,tr("Create ISO"));

        RVariableType varType = this-&gt;getVariableType();
        QList&lt;SessionEntityID&gt; entities = this-&gt;modelTree-&gt;getSelected();

        if (varType != R_VARIABLE_NONE &amp;&amp; entities.size() &gt; 0)
        {
            if (this-&gt;entityID != RConstants::eod)
            {
                RIso &amp;iso = Session::getInstance().getModel(this-&gt;modelID).getIso(this-&gt;entityID);

                iso.clearElementGroupIDs();

                iso.setVariableType(varType);
                iso.setVariableValue(this-&gt;variableValue-&gt;getValue());

                for (int i=0;i&lt;entities.size();i++)
                {
                    uint elementGroupId = Session::getInstance().getModel(this-&gt;modelID).getElementGroupID(entities[i].getType(),
                                                                                                           entities[i].getEid());
                    if (elementGroupId == RConstants::eod)
                    {
                        continue;
                    }
                    iso.addElementGroupID(elementGroupId);
                }

                RLogger::info("Modified ISO entity \'%s\'\n",iso.getName().toUtf8().constData());
            }
            else
            {
                RIso iso;

                iso.setName(RVariable::getName(varType));
                iso.setVariableType(varType);
                iso.setVariableValue(this-&gt;variableValue-&gt;getValue());

                for (int i=0;i&lt;entities.size();i++)
                {
                    uint elementGroupId = Session::getInstance().getModel(this-&gt;modelID).getElementGroupID(entities[i].getType(),
                                                                                                           entities[i].getEid());
                    iso.addElementGroupID(elementGroupId);
                }

                Session::getInstance().getModel(this-&gt;modelID).addIso(iso);
                RLogger::info("Created new ISO entity \'%s\'\n",iso.getName().toUtf8().constData());
            }

            Session::getInstance().setModelChanged(this-&gt;modelID);
        }
    }

    return retVal;
}

</t>
<t tx="leo.20201108101523.41">void IsoDialog::createDialog(void)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;resize(500,400);

    QString windowTitleStr = tr("ISO entity editor");
    this-&gt;setWindowTitle(tr(windowTitleStr.toUtf8().constData()));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);


    QLabel *titleLabel = new QLabel;
    if (this-&gt;entityID == RConstants::eod)
    {
        titleLabel-&gt;setText(tr("Create new ISO entity."));
    }
    else
    {
        titleLabel-&gt;setText(tr("Modify ISO entity:") + " &lt;b&gt;" + Session::getInstance().getModel(modelID).getIso(entityID).getName() + "&lt;/b&gt;");
    }
    mainLayout-&gt;addWidget(titleLabel, 0, 0, 1, 1);

    REntityGroupTypeMask typeMask = R_ENTITY_GROUP_POINT
                                  | R_ENTITY_GROUP_LINE
                                  | R_ENTITY_GROUP_SURFACE
                                  | R_ENTITY_GROUP_VOLUME;

    Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    this-&gt;modelTree = new ModelTreeSimple(this-&gt;modelID,typeMask,this);
    if (this-&gt;entityID != RConstants::eod)
    {
        RIso &amp;rIso = rModel.getIso(entityID);
        const std::vector&lt;unsigned int&gt; groupIDs = rIso.getElementGroupIDs();
        this-&gt;modelTree-&gt;clearSelection();
        for (uint i=0;i&lt;groupIDs.size();i++)
        {
            REntityGroupType entityGroupType;
            uint entityIDNum;
            if (rModel.getEntityID(groupIDs[i],entityGroupType,entityIDNum))
            {
                this-&gt;modelTree-&gt;selectEntity(this-&gt;modelID,entityGroupType,entityIDNum);
            }
        }
    }
    mainLayout-&gt;addWidget(this-&gt;modelTree, 1, 0, 1, 1);

    QObject::connect(this-&gt;modelTree,
                     &amp;QTreeWidget::itemSelectionChanged,
                     this,
                     &amp;IsoDialog::onModelTreeSelectionChanged);

    this-&gt;variableTree = new QTreeWidget(this);
    this-&gt;variableTree-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;variableTree-&gt;setColumnCount(IsoDialog::NColumns);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(IsoDialog::Name,QString("Variables"));
    headerItem-&gt;setText(IsoDialog::Type,QString("type"));
    this-&gt;variableTree-&gt;setHeaderItem(headerItem);
    this-&gt;variableTree-&gt;setColumnHidden(IsoDialog::Type,true);

    double variableValue = 0.0;
    double minVariableValue = 0.0;
    double maxVariableValue = 0.0;

    for (uint i=0;i&lt;rModel.getNVariables();i++)
    {
        RVariable &amp;rVariable = rModel.getVariable(i);
        if (rVariable.getApplyType() != R_VARIABLE_APPLY_NODE)
        {
            continue;
        }

        if (i == 0)
        {
            minVariableValue = rVariable.getMinValue();
            maxVariableValue = rVariable.getMaxValue();
        }

        QTreeWidgetItem *itemVariable = new QTreeWidgetItem(this-&gt;variableTree);
        itemVariable-&gt;setText(IsoDialog::Name, rVariable.getName());
        itemVariable-&gt;setData(IsoDialog::Type,Qt::DisplayRole,QVariant(rVariable.getType()));
        if (this-&gt;entityID != RConstants::eod)
        {
            RIso &amp;rIso = Session::getInstance().getModel(this-&gt;modelID).getIso(entityID);
            if (rVariable.getType() == rIso.getVariableType())
            {
                itemVariable-&gt;setSelected(true);

                variableValue = rIso.getVariableValue();

                minVariableValue = rVariable.getMinValue();
                maxVariableValue = rVariable.getMaxValue();
            }
        }
    }

    mainLayout-&gt;addWidget(this-&gt;variableTree, 1, 1, 1, 1);

    QObject::connect(this-&gt;variableTree,
                     &amp;QTreeWidget::itemSelectionChanged,
                     this,
                     &amp;IsoDialog::onVariableTreeSelectionChanged);

    QHBoxLayout *valueLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(valueLayout, 2, 0, 1, 2);

    QLabel *valueLabel = new QLabel(tr("Value:"));
    valueLayout-&gt;addWidget(valueLabel);

    this-&gt;variableValue = new ValueLineEdit(minVariableValue, maxVariableValue);
    this-&gt;variableValue-&gt;setValue(variableValue);
    valueLayout-&gt;addWidget(this-&gt;variableValue);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, 3, 0, 1, 2);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());
    this-&gt;okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;IsoDialog::reject);
    QObject::connect(this-&gt;okButton,&amp;QPushButton::clicked,this,&amp;IsoDialog::accept);
}

RVariableType IsoDialog::getVariableType(void) const
{
    QList&lt;QTreeWidgetItem*&gt; items = this-&gt;variableTree-&gt;selectedItems();

    if (items.size() == 0)
    {
        return R_VARIABLE_NONE;
    }

    return RVariableType(items[0]-&gt;data(IsoDialog::Type,Qt::DisplayRole).toInt());
}

</t>
<t tx="leo.20201108101523.42">void IsoDialog::onVariableTreeSelectionChanged(void)
{
    RVariableType variableType = this-&gt;getVariableType();

    this-&gt;variableValue-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());

    if (!this-&gt;variableTree-&gt;selectedItems().size() || !this-&gt;modelTree-&gt;selectedItems().size())
    {
        return;
    }

    Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    double minVariableValue = 0.0;
    double maxVariableValue = 0.0;

    for (uint i=0;i&lt;rModel.getNVariables();i++)
    {
        RVariable &amp;rVariable = rModel.getVariable(i);

        if (rVariable.getType() == variableType)
        {
            minVariableValue = rVariable.getMinValue();
            maxVariableValue = rVariable.getMaxValue();
        }
    }

    this-&gt;variableValue-&gt;setRange(minVariableValue,maxVariableValue);
}

</t>
<t tx="leo.20201108101523.43">void IsoDialog::onModelTreeSelectionChanged()
{
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());
}
</t>
<t tx="leo.20201108101523.44">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   job.cpp                                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th January 2012                                        *
 *                                                                   *
 *  DESCRIPTION: Job class definition                                *
 *********************************************************************/

#include &lt;omp.h&gt;

#include "job.h"
#include "job_manager.h"
#include "main_settings.h"
#include "session.h"

static uint lastID = 0;

Job::Job(QObject *parent)
    : QObject(parent)
    , id(++lastID)
    , jobFinished(false)
    , autoDelete(true)
    , blocking(true)
{
}

uint Job::getID(void)
{
    return this-&gt;id;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.45">bool Job::isFinished(void) const
{
    return this-&gt;jobFinished;
}

</t>
<t tx="leo.20201108101523.46">bool Job::getAutoDelete(void) const
{
    return this-&gt;autoDelete;
}

</t>
<t tx="leo.20201108101523.47">void Job::setAutoDelete(bool autoDelete)
{
    this-&gt;autoDelete = autoDelete;
}

</t>
<t tx="leo.20201108101523.48">void Job::setBlocking(bool blocking)
{
    this-&gt;blocking = blocking;
}

</t>
<t tx="leo.20201108101523.49">void Job::exec(void)
{
    Session::getInstance().lock();
    emit this-&gt;started();
    if (this-&gt;blocking)
    {
        emit this-&gt;isBlocking(true);
    }
    Session::getInstance().unlock();
    omp_set_num_threads(MainSettings::getInstance().getApplicationSettings()-&gt;getNThreads());
    this-&gt;run();
    Session::getInstance().lock();
    this-&gt;jobFinished = true;
    if (this-&gt;blocking)
    {
        emit this-&gt;isBlocking(false);
    }
    emit this-&gt;finished();
    Session::getInstance().unlock();
}

</t>
<t tx="leo.20201108101523.5">void HttpRequestInput::_init(const HttpRequestInput *pHttpRequestInput)
{
    if (pHttpRequestInput)
    {
        this-&gt;urlStr = pHttpRequestInput-&gt;urlStr;
        this-&gt;httpMethod = pHttpRequestInput-&gt;httpMethod;
        this-&gt;variableLayout = pHttpRequestInput-&gt;variableLayout;
        this-&gt;variables = pHttpRequestInput-&gt;variables;
        this-&gt;files = pHttpRequestInput-&gt;files;
    }
}

HttpRequestInput::HttpRequestInput(QString urlStr, QString httpMethod)
    : urlStr(urlStr)
    , httpMethod(httpMethod)
    , variableLayout(NOT_SET)
{
    this-&gt;_init();
}

HttpRequestInput::HttpRequestInput(const HttpRequestInput &amp;httpRequestInput)
{
    this-&gt;_init(&amp;httpRequestInput);
}

HttpRequestInput::~HttpRequestInput()
{

}

HttpRequestInput &amp;HttpRequestInput::operator =(const HttpRequestInput &amp;httpRequestInput)
{
    this-&gt;_init(&amp;httpRequestInput);
    return (*this);
}

</t>
<t tx="leo.20201108101523.50">void Job::process(void)
{
    this-&gt;exec();
}

</t>
<t tx="leo.20201108101523.51">void Job::run(void)
{
}
</t>
<t tx="leo.20201108101523.52">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   job_manager.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th January 2012                                        *
 *                                                                   *
 *  DESCRIPTION: Job manager class definition                        *
 *********************************************************************/

#include &lt;QVector&gt;

#include &lt;rblib.h&gt;

#include "job_manager.h"

JobManager::JobManager(QObject *parent)
    : QObject(parent)
    , jobIsStarting(false)
{
}

JobManager &amp; JobManager::getInstance(void)
{
    static JobManager jobManager;
    return jobManager;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.53">void JobManager::submit(Job *job)
{
    this-&gt;waitingJobs.enqueue(job);
    this-&gt;processWaitingJobs();
    this-&gt;processFinishedJobs();
}

uint JobManager::getNWaiting(void) const
{
    return (uint)this-&gt;waitingJobs.size();
}

uint JobManager::getNRunning(void) const
{
    QList&lt;Job*&gt;::const_iterator iter;
    uint nRunning = 0;

    for (iter = this-&gt;runningJobs.begin();
         iter != this-&gt;runningJobs.end();
         ++iter)
    {
        if (!(*iter)-&gt;isFinished())
        {
            nRunning ++;
        }
    }
    return nRunning;
}

QVector&lt;uint&gt; JobManager::getRunningIDs(void) const
{
    QVector&lt;uint&gt; runningIDs;

    QList&lt;Job*&gt;::const_iterator iter;
    for (iter = this-&gt;runningJobs.begin();
         iter != this-&gt;runningJobs.end();
         ++iter)
    {
        if (!(*iter)-&gt;isFinished())
        {
            runningIDs.push_back((*iter)-&gt;getID());
        }
    }

    return runningIDs;
}

</t>
<t tx="leo.20201108101523.54">void JobManager::onJobBlocking(bool blocking)
{
    emit this-&gt;jobBlocking(blocking);
}

</t>
<t tx="leo.20201108101523.55">void JobManager::onJobStarted(void)
{
    this-&gt;jobIsStarting = false;
    emit this-&gt;jobStarted();
}

</t>
<t tx="leo.20201108101523.56">void JobManager::onJobFinished(void)
{
    emit this-&gt;jobFinished();
    this-&gt;processWaitingJobs();
    this-&gt;processFinishedJobs();
}

</t>
<t tx="leo.20201108101523.57">void JobManager::processWaitingJobs(void)
{
    if (this-&gt;getNRunning() == 0 &amp;&amp; this-&gt;getNWaiting() &gt; 0 &amp;&amp; !this-&gt;jobIsStarting)
    {
        this-&gt;startJob(this-&gt;waitingJobs.dequeue());
    }
}

</t>
<t tx="leo.20201108101523.58">void JobManager::processFinishedJobs(void)
{
    this-&gt;removeFinishedJobs();
}

</t>
<t tx="leo.20201108101523.59">void JobManager::startJob(Job *job)
{
    this-&gt;jobIsStarting = true;

    job-&gt;moveToThread(&amp;this-&gt;runningThread);

    QObject::connect(job,&amp;Job::isBlocking,this,&amp;JobManager::onJobBlocking);
    QObject::connect(&amp;this-&gt;runningThread,&amp;QThread::started,this,&amp;JobManager::onJobStarted);
    QObject::connect(&amp;this-&gt;runningThread,&amp;QThread::started,job,&amp;Job::process);
    QObject::connect(job,&amp;Job::finished,&amp;this-&gt;runningThread,&amp;QThread::quit);
    QObject::connect(&amp;this-&gt;runningThread,&amp;QThread::finished,this,&amp;JobManager::onJobFinished);

    this-&gt;runningJobs.append(job);

    this-&gt;runningThread.start();
}

Job * JobManager::findFinishedJob(void) const
{
    QList&lt;Job*&gt;::const_iterator iter;
    for (iter = this-&gt;runningJobs.begin();
         iter != this-&gt;runningJobs.end();
         ++iter)
    {
        if ((*iter)-&gt;isFinished())
        {
            return (*iter);
        }
    }
    return 0;
}

uint JobManager::removeFinishedJobs()
{
    Job *job;
    uint nRemovedTotal = 0;
    int nRemoved = 0;

    while ((job = this-&gt;findFinishedJob()) != 0)
    {
        nRemoved = this-&gt;runningJobs.removeAll(job);
        if (job-&gt;getAutoDelete())
        {
            delete job;
        }
        if (nRemoved == 0)
        {
            RLogger::error("No job could be found in the running queue.\n");
        }
        else if (nRemoved &gt; 1)
        {
            RLogger::error("Multiple occurences of one jobe wre found in the running queue.\n");
            nRemovedTotal += (uint) nRemoved;
        }
        else if (nRemoved &lt; 0)
        {
            RLogger::error("Unknown error while removing the job from the running queue.\n");
        }
    }

    return nRemovedTotal;
}
</t>
<t tx="leo.20201108101523.6">const QString &amp;HttpRequestInput::getUrlStr(void) const
{
    return this-&gt;urlStr;
}

QString &amp;HttpRequestInput::getUrlStr(void)
{
    return this-&gt;urlStr;
}

</t>
<t tx="leo.20201108101523.60">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   keyboard_shortcuts_edit.cpp                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   10-th September 2014                                     *
 *                                                                   *
 *  DESCRIPTION: Keyboard shortcuts editor class definition          *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QGridLayout&gt;
#include &lt;QGroupBox&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;
#include &lt;QMessageBox&gt;

#include "keyboard_shortcuts_edit.h"

KeyboardShortcutsEdit::KeyboardShortcutsEdit(const ActionDefinition *actionDefinition, QWidget *parent) :
    QWidget(parent),
    actionDefinition(actionDefinition)
{
    QVBoxLayout *topLayout = new QVBoxLayout;
    this-&gt;setLayout(topLayout);

    QGroupBox *keyboardShortcutsBox = new QGroupBox(tr("Keayboard Shortcuts"));
    topLayout-&gt;addWidget(keyboardShortcutsBox);

    QGridLayout *keyboardShortcutsLayout = new QGridLayout;
    keyboardShortcutsBox-&gt;setLayout(keyboardShortcutsLayout);

    this-&gt;populateTree();

    keyboardShortcutsLayout-&gt;addWidget(this-&gt;tree,0,0,1,2);

    QObject::connect(this-&gt;tree,
                     &amp;QTreeWidget::itemSelectionChanged,
                     this,
                     &amp;KeyboardShortcutsEdit::onSelectionChanged);

    QPushButton *resetAllButton = new QPushButton(tr("Reset All"));
    resetAllButton-&gt;setSizePolicy(QSizePolicy::Maximum,QSizePolicy::Maximum);
    keyboardShortcutsLayout-&gt;addWidget(resetAllButton,1,0,1,1);

    QObject::connect(resetAllButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;KeyboardShortcutsEdit::onResetAllClicked);

    QGroupBox *shortcutBox = new QGroupBox(tr("Shortcut"));
    topLayout-&gt;addWidget(shortcutBox);

    QHBoxLayout *shortcutLayout = new QHBoxLayout;
    shortcutBox-&gt;setLayout(shortcutLayout);

    QLabel *shortcutLabel = new QLabel(tr("Target:"));
    shortcutLabel-&gt;setSizePolicy(QSizePolicy::Maximum,QSizePolicy::Maximum);
    shortcutLayout-&gt;addWidget(shortcutLabel);

    this-&gt;lineEdit = new ShortcutLineEdit;
    this-&gt;lineEdit-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Maximum);
    this-&gt;lineEdit-&gt;setDisabled(true);
    shortcutLayout-&gt;addWidget(this-&gt;lineEdit);

    QObject::connect(this-&gt;lineEdit,
                     &amp;ShortcutLineEdit::shortcutChanged,
                     this,
                     &amp;KeyboardShortcutsEdit::onShortcutChanged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.61">void KeyboardShortcutsEdit::resetToDefault(void)
{
    QList&lt;ActionDefinitionItem&gt; actionDesc;

    ActionDefinition::generateActionDescList(actionDesc);

    for (int i=0;i&lt;this-&gt;tree-&gt;topLevelItemCount();i++)
    {
        for (int j=0;j&lt;this-&gt;tree-&gt;topLevelItem(i)-&gt;childCount();j++)
        {
            ActionType type = ActionType(this-&gt;tree-&gt;topLevelItem(i)-&gt;child(j)-&gt;data(0,Qt::UserRole).toInt());
            const QString &amp;shortcut = actionDesc[type].getShortcut();
            if (this-&gt;tree-&gt;topLevelItem(i)-&gt;child(j)-&gt;text(1) != shortcut)
            {
                this-&gt;tree-&gt;blockSignals(true);
                this-&gt;tree-&gt;topLevelItem(i)-&gt;child(j)-&gt;setText(1,shortcut);
                this-&gt;tree-&gt;blockSignals(false);
                emit this-&gt;shortcutChanged(type,shortcut);
            }
        }
    }
}

</t>
<t tx="leo.20201108101523.62">void KeyboardShortcutsEdit::populateTree(void)
{
    this-&gt;tree = new QTreeWidget;
    this-&gt;tree-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;tree-&gt;setSortingEnabled(true);
    this-&gt;tree-&gt;setColumnCount(2);
    this-&gt;tree-&gt;sortByColumn(0,Qt::AscendingOrder);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(0,QString("Action"));
    headerItem-&gt;setText(1,QString("Shortcut"));
    this-&gt;tree-&gt;setHeaderItem(headerItem);
    this-&gt;tree-&gt;setRootIsDecorated(true);

    QList&lt;ActionGroupType&gt; actionGroupTypes = ActionDefinitionItem::getGroupTypes();

    for (int i=0;i&lt;actionGroupTypes.size();i++)
    {
        QTreeWidgetItem *itemGroup = new QTreeWidgetItem(this-&gt;tree);

        itemGroup-&gt;setText(0,ActionDefinitionItem::getGroupName(actionGroupTypes[i]));
        itemGroup-&gt;setData(0,Qt::UserRole,QVariant(ACTION_NONE));
        itemGroup-&gt;setForeground(0,this-&gt;palette().brush(QPalette::Active,QPalette::Text));
        QFont font(itemGroup-&gt;font(0));
        font.setBold(true);
        itemGroup-&gt;setFont(0,font);

        QList&lt;ActionType&gt; actionTypes = this-&gt;actionDefinition-&gt;getActionTypes(actionGroupTypes[i]);
        for (int j=0;j&lt;actionTypes.size();j++)
        {
            if (!ACTION_TYPE_IS_ACTION(actionTypes[j]))
            {
                continue;
            }

            QTreeWidgetItem *item = new QTreeWidgetItem(itemGroup);

            item-&gt;setText(0,this-&gt;actionDefinition-&gt;getText(actionTypes[j]));
            item-&gt;setData(0,Qt::UserRole,QVariant(actionTypes[j]));
            item-&gt;setText(1,this-&gt;actionDefinition-&gt;getShortCut(actionTypes[j]));
        }
    }

    this-&gt;tree-&gt;expandAll();

    this-&gt;tree-&gt;resizeColumnToContents(0);
    this-&gt;tree-&gt;resizeColumnToContents(1);

    this-&gt;tree-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Expanding);
}

QList&lt;QTreeWidgetItem *&gt; KeyboardShortcutsEdit::findItems(ActionType type)
{
    QList&lt;QTreeWidgetItem*&gt; items;
    for (int i=0;i&lt;this-&gt;tree-&gt;topLevelItemCount();i++)
    {
        for (int j=0;j&lt;this-&gt;tree-&gt;topLevelItem(i)-&gt;childCount();j++)
        {
            QTreeWidgetItem *item = this-&gt;tree-&gt;topLevelItem(i)-&gt;child(j);
            if (ActionType(item-&gt;data(0,Qt::UserRole).toInt()) == type)
            {
                items.push_back(item);
            }
        }
    }
    return items;
}

QList&lt;QTreeWidgetItem *&gt; KeyboardShortcutsEdit::findItems(const QString &amp;shortcut)
{
    QList&lt;QTreeWidgetItem*&gt; items;
    for (int i=0;i&lt;this-&gt;tree-&gt;topLevelItemCount();i++)
    {
        for (int j=0;j&lt;this-&gt;tree-&gt;topLevelItem(i)-&gt;childCount();j++)
        {
            QTreeWidgetItem *item = this-&gt;tree-&gt;topLevelItem(i)-&gt;child(j);
            if (item-&gt;text(1) == shortcut)
            {
                items.push_back(item);
            }
        }
    }
    return items;
}

</t>
<t tx="leo.20201108101523.63">void KeyboardShortcutsEdit::onSelectionChanged(void)
{
    QList&lt;QTreeWidgetItem *&gt; items = this-&gt;tree-&gt;selectedItems();

    this-&gt;lineEdit-&gt;setDisabled(true);
    this-&gt;lineEdit-&gt;clear();

    for (int i=0;i&lt;items.size();i++)
    {
        if (ACTION_TYPE_IS_ACTION(ActionType(items[i]-&gt;data(0,Qt::UserRole).toInt())))
        {
            QString shortcut = items[i]-&gt;text(1);
            this-&gt;lineEdit-&gt;setText(shortcut);
            this-&gt;lineEdit-&gt;setEnabled(true);
            return;
        }
    }
}

</t>
<t tx="leo.20201108101523.64">void KeyboardShortcutsEdit::onResetAllClicked(void)
{
    this-&gt;resetToDefault();
}

</t>
<t tx="leo.20201108101523.65">void KeyboardShortcutsEdit::onShortcutChanged(const QString &amp;shortcut)
{
    QList&lt;QTreeWidgetItem *&gt; selectedItems = this-&gt;tree-&gt;selectedItems();

    if (!shortcut.isEmpty())
    {
        QList&lt;QTreeWidgetItem*&gt; previousItems = this-&gt;findItems(shortcut);

        if (previousItems.size() &gt; 0)
        {
            QString previousActions;
            for (int j=0;j&lt;previousItems.size();j++)
            {
                previousActions += " &lt;b&gt;" + previousItems[j]-&gt;text(0) + "&lt;/b&gt;";
                if (j&lt;previousItems.size()-1)
                {
                    previousActions += ",";
                }
            }

            QString question = tr("Shortcut ")
                             + QString("&lt;b&gt;") + shortcut + QString("&lt;/b&gt; ")
                             + tr("is already assigned to action")
                             + previousActions
                             + QString(".&lt;br/&gt;")
                             + tr("Are you sure you want to reassign this shortcut?");
            @others
}
</t>
<t tx="leo.20201108101523.66">        int response = QMessageBox::question(this,
                                             tr("Assign shortcut?"),
                                             question,
                                             QMessageBox::Yes | QMessageBox::No);
        if (response != QMessageBox::Yes)
        {
            return;
        }
    }

    for (int i=0;i&lt;previousItems.size();i++)
    {
        previousItems[i]-&gt;setText(1,QString());
        emit this-&gt;shortcutChanged(ActionType(previousItems[i]-&gt;data(0,Qt::UserRole).toInt()),QString());
    }
}

for (int i=0;i&lt;selectedItems.size();i++)
{
    ActionType type = ActionType(selectedItems[i]-&gt;data(0,Qt::UserRole).toInt());

    this-&gt;lineEdit-&gt;setText(shortcut);
    selectedItems[i]-&gt;setText(1,shortcut);

    emit this-&gt;shortcutChanged(type,shortcut);
}
</t>
<t tx="leo.20201108101523.67">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   light_properties_widget.cpp                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   29-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Light properties widget class definition            *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;

#include "light_properties_widget.h"
#include "color_combo_box.h"
#include "direction_widget.h"
#include "position_widget.h"

LightPropertiesWidget::LightPropertiesWidget(const QString &amp;title, const RGLLight &amp;glLight, QWidget *parent) :
    QGroupBox(title,parent),
    glLight(glLight),
    id(0)
{
    this-&gt;setCheckable(true);
    this-&gt;setChecked(glLight.getEnabled());

    QGridLayout *lightLayout = new QGridLayout;
    this-&gt;setLayout(lightLayout);

    QLabel *ambientLabel = new QLabel(tr("Ambient:"));
    lightLayout-&gt;addWidget(ambientLabel,0,0,1,1);

    ColorComboBox *ambientColorComboBox = new ColorComboBox;
    ambientColorComboBox-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Fixed);
    ambientColorComboBox-&gt;setColor(glLight.getAmbient());
    lightLayout-&gt;addWidget(ambientColorComboBox,0,1,1,1);

    QLabel *difuseLabel = new QLabel(tr("Difuse:"));
    lightLayout-&gt;addWidget(difuseLabel,1,0,1,1);

    ColorComboBox *diffuseColorComboBox = new ColorComboBox;
    diffuseColorComboBox-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Fixed);
    diffuseColorComboBox-&gt;setColor(glLight.getDiffuse());
    lightLayout-&gt;addWidget(diffuseColorComboBox,1,1,1,1);

    QLabel *specularLabel = new QLabel(tr("Specular:"));
    lightLayout-&gt;addWidget(specularLabel,2,0,1,1);

    ColorComboBox *specularColorComboBox = new ColorComboBox;
    specularColorComboBox-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Fixed);
    specularColorComboBox-&gt;setColor(glLight.getSpecular());
    lightLayout-&gt;addWidget(specularColorComboBox,2,1,1,1);

    PositionWidget *positionWidget = new PositionWidget("Position",glLight.getPosition());
    positionWidget-&gt;hideButtons();
    positionWidget-&gt;hidePickButton();
    positionWidget-&gt;setXRange(-10.0,10.0);
    positionWidget-&gt;setYRange(-10.0,10.0);
    positionWidget-&gt;setZRange(0.0,10.0);
    lightLayout-&gt;addWidget(positionWidget,3,0,1,2);

    DirectionWidget *directionWidget = new DirectionWidget("Direction",glLight.getDirection());
    directionWidget-&gt;hideButtons();
    lightLayout-&gt;addWidget(directionWidget,4,0,1,2);

    QObject::connect(this,&amp;LightPropertiesWidget::toggled,this,&amp;LightPropertiesWidget::lightToggled);
    this-&gt;connect(ambientColorComboBox,SIGNAL(colorChanged(QColor)),SLOT(ambientColorChanged(QColor)));
    this-&gt;connect(diffuseColorComboBox,SIGNAL(colorChanged(QColor)),SLOT(diffuseColorChanged(QColor)));
    this-&gt;connect(specularColorComboBox,SIGNAL(colorChanged(QColor)),SLOT(specularColorChanged(QColor)));
    QObject::connect(positionWidget,&amp;PositionWidget::changed,this,&amp;LightPropertiesWidget::positionChanged);
    QObject::connect(directionWidget,&amp;DirectionWidget::changed,this,&amp;LightPropertiesWidget::directionChanged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.68">const RGLLight &amp;LightPropertiesWidget::getLight(void) const
{
    return this-&gt;glLight;
}

</t>
<t tx="leo.20201108101523.69">void LightPropertiesWidget::lightToggled(bool enabled)
{
    this-&gt;glLight.setEnabled(enabled);
    emit this-&gt;lightChanged(this-&gt;glLight);
    emit this-&gt;lightChanged(this-&gt;glLight,this-&gt;id);
}

</t>
<t tx="leo.20201108101523.7">void HttpRequestInput::setUrlStr(const QString &amp;urlStr)
{
    this-&gt;urlStr = urlStr;
}

</t>
<t tx="leo.20201108101523.70">void LightPropertiesWidget::ambientColorChanged(const QColor &amp;color)
{
    this-&gt;glLight.setAmbient(color);
    emit this-&gt;lightChanged(this-&gt;glLight);
    emit this-&gt;lightChanged(this-&gt;glLight,this-&gt;id);
}

</t>
<t tx="leo.20201108101523.71">void LightPropertiesWidget::diffuseColorChanged(const QColor &amp;color)
{
    this-&gt;glLight.setDiffuse(color);
    emit this-&gt;lightChanged(this-&gt;glLight);
    emit this-&gt;lightChanged(this-&gt;glLight,this-&gt;id);
}

</t>
<t tx="leo.20201108101523.72">void LightPropertiesWidget::specularColorChanged(const QColor &amp;color)
{
    this-&gt;glLight.setSpecular(color);
    emit this-&gt;lightChanged(this-&gt;glLight);
    emit this-&gt;lightChanged(this-&gt;glLight,this-&gt;id);
}

</t>
<t tx="leo.20201108101523.73">void LightPropertiesWidget::positionChanged(const RR3Vector &amp;position)
{
    this-&gt;glLight.setPosition(position);
    emit this-&gt;lightChanged(this-&gt;glLight);
    emit this-&gt;lightChanged(this-&gt;glLight,this-&gt;id);
}

</t>
<t tx="leo.20201108101523.74">void LightPropertiesWidget::directionChanged(const RR3Vector &amp;direction)
{
    this-&gt;glLight.setDirection(direction);
    emit this-&gt;lightChanged(this-&gt;glLight);
    emit this-&gt;lightChanged(this-&gt;glLight,this-&gt;id);
}
</t>
<t tx="leo.20201108101523.75">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   local_direction_widget.cpp                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   11-th May 2020                                           *
 *                                                                   *
 *  DESCRIPTION: Local direction widget class definition             *
 *********************************************************************/

#include &lt;QGridLayout&gt;

#include "local_direction_widget.h"

LocalDirectionWidget::LocalDirectionWidget(const QString &amp;title, const RLocalDirection &amp;localDirection, QWidget *parent)
    : QGroupBox(title, parent)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QGridLayout *layout = new QGridLayout;
    this-&gt;setLayout(layout);

    this-&gt;positionWidget = new PositionWidget(tr("Position"),localDirection.getPosition(),false);
    this-&gt;positionWidget-&gt;hideSliders();
    this-&gt;positionWidget-&gt;hideButtons();
    layout-&gt;addWidget(this-&gt;positionWidget,0,0,1,1);

    this-&gt;directionWidget = new DirectionWidget(tr("Direction"),localDirection.getDirection());
    this-&gt;directionWidget-&gt;hideButtons();
    layout-&gt;addWidget(this-&gt;directionWidget,1,0,1,1);

    this-&gt;positionWidget-&gt;blockSignals(true);
    this-&gt;directionWidget-&gt;blockSignals(true);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);

    this-&gt;cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(this-&gt;cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setDisabled(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    layout-&gt;addLayout(buttonsLayout,2,0,1,1);

    layout-&gt;addWidget(new QWidget,3,0,1,4);
    layout-&gt;setRowStretch(3,1);

    QObject::connect(this-&gt;positionWidget,
                     &amp;PositionWidget::changed,
                     this,
                     &amp;LocalDirectionWidget::onPositionChanged);

    QObject::connect(this-&gt;directionWidget,
                     &amp;DirectionWidget::changed,
                     this,
                     &amp;LocalDirectionWidget::onDirectionChanged);

    QObject::connect(this-&gt;cancelButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;LocalDirectionWidget::onCancelButtonClicked);
    QObject::connect(this-&gt;okButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;LocalDirectionWidget::onOkButtonClicked);
}

RLocalDirection LocalDirectionWidget::getLocalDirection() const
{
    return RLocalDirection(this-&gt;positionWidget-&gt;getPosition(),this-&gt;directionWidget-&gt;getDirection());
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.76">void LocalDirectionWidget::setLocalDirection(const RLocalDirection &amp;localDirection)
{
    RLogger::warning("setLocalDirection\n");
    this-&gt;positionWidget-&gt;setPosition(localDirection.getPosition());
    this-&gt;directionWidget-&gt;setDirection(localDirection.getDirection());

    emit this-&gt;changed(localDirection);
}

</t>
<t tx="leo.20201108101523.77">void LocalDirectionWidget::showEvent(QShowEvent *event)
{
    this-&gt;QGroupBox::showEvent(event);
    this-&gt;positionWidget-&gt;blockSignals(false);
    this-&gt;directionWidget-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101523.78">void LocalDirectionWidget::onPositionChanged(const RR3Vector &amp;position)
{
    this-&gt;okButton-&gt;setEnabled(true);
    emit this-&gt;changed(this-&gt;getLocalDirection());
}

</t>
<t tx="leo.20201108101523.79">void LocalDirectionWidget::onDirectionChanged(const RR3Vector &amp;direction)
{
    this-&gt;okButton-&gt;setEnabled(true);
    emit this-&gt;changed(this-&gt;getLocalDirection());
}

</t>
<t tx="leo.20201108101523.8">const QString &amp;HttpRequestInput::getHttpMethod(void) const
{
    return this-&gt;httpMethod;
}

HttpRequestInput::VariableLayout HttpRequestInput::getVariableLayout(void) const
{
    return this-&gt;variableLayout;
}

</t>
<t tx="leo.20201108101523.80">void LocalDirectionWidget::onCancelButtonClicked()
{
    emit this-&gt;closed();
}

</t>
<t tx="leo.20201108101523.81">void LocalDirectionWidget::onOkButtonClicked()
{
    emit this-&gt;changed(this-&gt;getLocalDirection());
    emit this-&gt;closed();
}
</t>
<t tx="leo.20201108101523.82">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   locker.cpp                                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-rd February 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Locker functions                                    *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "locker.h"

static void lockHandler (bool lock);


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.83">void Locker::initialize(void)
{
    RLocker::getInstance().setLockHandler(lockHandler);
}

Locker &amp; Locker::getInstance(void)
{
    static Locker locker;
    return locker;
}

QMutex * Locker::getMutexPtr(void)
{
    return &amp;this-&gt;mutex;
}

</t>
<t tx="leo.20201108101523.84">static void lockHandler (bool lock)
{
    if (lock)
    {
        Locker::getInstance().getMutexPtr()-&gt;lock();
    }
    else
    {
        Locker::getInstance().getMutexPtr()-&gt;unlock();
    }
}
</t>
<t tx="leo.20201108101523.85">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   logger.cpp                                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   3-rd January 2012                                        *
 *                                                                   *
 *  DESCRIPTION: Logger functions                                    *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "logger.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.86">void Logger::initialize(void)
{
    RLogger::getInstance().setLevel(R_LOG_LEVEL_DETAIL);
    RLogger::getInstance().setHalted(true);
    RLogger::getInstance().setLogHandler(Logger::logHandler);
}

</t>
<t tx="leo.20201108101523.87">void Logger::halt(void)
{
    RLogger::getInstance().setHalted(true);
}

</t>
<t tx="leo.20201108101523.88">void Logger::unhalt(void)
{
    RLogger::getInstance().setHalted(false);
}

Logger &amp; Logger::getInstance()
{
    static Logger logger;
    return logger;
}

</t>
<t tx="leo.20201108101523.89">void Logger::logHandler(const RMessage &amp;message)
{
    switch (message.getType())
    {
        case R_MESSAGE_INFO:
            emit Logger::getInstance().infoPrinted(message);
            break;
        case R_MESSAGE_NOTICE:
            emit Logger::getInstance().noticePrinted(message);
            break;
        case R_MESSAGE_WARNING:
            emit Logger::getInstance().warningPrinted(message);
            break;
        case R_MESSAGE_ERROR:
            emit Logger::getInstance().errorPrinted(message);
            break;
        case R_MESSAGE_DEBUG:
            emit Logger::getInstance().infoPrinted(message);
            break;
        case R_MESSAGE_TRACE:
            emit Logger::getInstance().infoPrinted(message);
            break;
        default:
            emit Logger::getInstance().errorPrinted("UNKNOWN MESSAGE TYPE: " + message);
            break;
    }
}
</t>
<t tx="leo.20201108101523.9">void HttpRequestInput::setVariableLayout(HttpRequestInput::VariableLayout varLayout)
{
    this-&gt;variableLayout = varLayout;
}

</t>
<t tx="leo.20201108101523.90">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   log_browser.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th August 2013                                         *
 *                                                                   *
 *  DESCRIPTION: Log browser class definition                        *
 *********************************************************************/

#include &lt;QFileSystemWatcher&gt;
#include &lt;QFile&gt;
#include &lt;QTextStream&gt;

#include &lt;rblib.h&gt;

#include "log_browser.h"

LogBrowser::LogBrowser(const QString &amp;logFileName, QWidget *parent) :
    QTextBrowser(parent),
    logFileName(logFileName),
    fileStreamEnd(0)
{
    QFont font("Monospace");
    font.setStyleHint(QFont::TypeWriter);
    this-&gt;setFont(font);

    QFileSystemWatcher *systemWatcher = new QFileSystemWatcher(QStringList(this-&gt;logFileName),this);

    this-&gt;onFileChanged(this-&gt;logFileName);

    QObject::connect(systemWatcher,&amp;QFileSystemWatcher::fileChanged,this,&amp;LogBrowser::onFileChanged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.91">void LogBrowser::clearLog(void)
{
    QFile file(this-&gt;logFileName);

    if (!file.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        RLogger::warning("Failed to open the file \'%s\' for writing.\n", this-&gt;logFileName.toUtf8().constData());
        return;
    }
    file.close();

    this-&gt;clear();
}

</t>
<t tx="leo.20201108101523.92">void LogBrowser::onFileChanged(const QString &amp;path)
{
    QFile file(path);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        RLogger::warning("Failed to open the file \'%s\' for reading.\n", path.toUtf8().constData());
        return;
    }

    try
    {
        qint64 fileSize = file.size();

        if (fileSize &lt;= this-&gt;fileStreamEnd)
        {
            this-&gt;fileStreamEnd = 0;
            this-&gt;clear();
        }

        QTextStream fileStream(&amp;file);

        fileStream.seek(this-&gt;fileStreamEnd);

        while (!fileStream.atEnd())
        {
            // add line
            this-&gt;append(fileStream.readLine());
        }
        this-&gt;fileStreamEnd = fileStream.pos();
    }
    catch (...)
    {
        RLogger::error("Unknown error while reading the log file.\n");
    }

    file.close();
}
</t>
<t tx="leo.20201108101523.93">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   log_browser_dialog.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th August 2013                                         *
 *                                                                   *
 *  DESCRIPTION: Log browser dialog class definition                 *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;
#include &lt;QFile&gt;

#include &lt;rblib.h&gt;

#include "log_browser_dialog.h"

LogBrowserDialog::LogBrowserDialog(const QString &amp;logFileName, QWidget *parent) :
    QDialog(parent)
{
    QIcon clearIcon(":/icons/file/pixmaps/range-clear.svg");
    QIcon closeIcon(":/icons/file/pixmaps/range-close.svg");

    this-&gt;setWindowTitle(tr("Log file viewer"));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *label = new QLabel("Log: &lt;i&gt;" + logFileName + "&lt;/i&gt;");
    mainLayout-&gt;addWidget(label, 0, 0, 1, 1);

    this-&gt;logBrowser = new LogBrowser(logFileName,this);
    mainLayout-&gt;addWidget(this-&gt;logBrowser, 1, 0, 1, 1);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(buttonsLayout, 2, 0, 1, 1);

    QPushButton *clearButton = new QPushButton(clearIcon, tr("Clear"));
    buttonsLayout-&gt;addWidget(clearButton);

    buttonsLayout-&gt;addStretch(1);

    QPushButton *closeButton = new QPushButton(closeIcon, tr("Close"));
    closeButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(closeButton);

    connect(clearButton,
            &amp;QPushButton::clicked,
            this,
            &amp;LogBrowserDialog::onClearButtonClicked);

    connect(closeButton,
            &amp;QPushButton::clicked,
            this,
            &amp;LogBrowserDialog::reject);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.94">int LogBrowserDialog::exec(void)
{
    int retVal = QDialog::exec();

    return retVal;
}

</t>
<t tx="leo.20201108101523.95">void LogBrowserDialog::onClearButtonClicked(void)
{
    this-&gt;logBrowser-&gt;clearLog();
}
</t>
<t tx="leo.20201108101523.96">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   main.cpp                                                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Main function                                       *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "application.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101523.97">int main(int argc, char *argv[])
{
    RArgumentsParser::printHeader("GUI");

    QLocale::setDefault(QLocale::c());

    int exitValue = 0;
    if ((exitValue = Application(argc, argv).exec()) != 0)
    {
        RLogger::info("Application has terminated with error code (%d).\n", exitValue);
    }

    RArgumentsParser::printFooter();
    return exitValue;
} /* main */
</t>
<t tx="leo.20201108101524.1">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   main_settings.cpp                                        *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Main settings class definition                      *
 *********************************************************************/

#include &lt;QDir&gt;
#include &lt;QDesktopServices&gt;
#include &lt;QImageWriter&gt;

#include &lt;rblib.h&gt;

#include "main_settings.h"

const QString MainSettings::logFileName("range.log");
const QString MainSettings::licenseFileName("LICENSE.txt");
const QString MainSettings::releaseNotesFileName("RELEASE_NOTES.txt");

MainSettings::MainSettings(const QString &amp;organization,
                           @others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.10">void MainWindow::hideDrawWidget(void)
{
    this-&gt;hideCustomDockWidget(QString::fromUtf8("dockDraw"));
}

</t>
<t tx="leo.20201108101524.100">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   material_property_line_edit.cpp                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th August 2012                                        *
 *                                                                   *
 *  DESCRIPTION: Material property line edit class definition        *
 *********************************************************************/

#include "material_property_line_edit.h"

MaterialPropertyLineEdit::MaterialPropertyLineEdit(RMaterialPropertyType type, QWidget *parent) :
    ValueLineEdit(parent),
    type(type)
{
    this-&gt;setDoubleValidator();
    QObject::connect(this,&amp;ValueLineEdit::valueChanged,this,&amp;MaterialPropertyLineEdit::onValueChaged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.101">void MaterialPropertyLineEdit::onValueChaged(double value)
{
    emit this-&gt;valueChanged(this-&gt;type,value);
}
</t>
<t tx="leo.20201108101524.102">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   material_tree.cpp                                        *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th August 2012                                        *
 *                                                                   *
 *  DESCRIPTION: Material tree class definition                      *
 *********************************************************************/


#include "material_list.h"
#include "material_tree.h"
#include "material_property_add_dialog.h"
#include "material_property_line_edit.h"
#include "material_property_edit_dialog.h"
#include "push_button.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.103">typedef enum _MaterialTreeColumn
{
    MATERIAL_TREE_PROPERTY_NAME = 0,
    MATERIAL_TREE_PROPERTY_VALUE,
    MATERIAL_TREE_PROPERTY_UNITS,
    MATERIAL_TREE_PROPERTY_TYPE,
    MATERIAL_TREE_N_COLUMNS
} MaterialTreeColumn;

MaterialTree::MaterialTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setRootIsDecorated(true);
    this-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;setSortingEnabled(true);
    this-&gt;sortByColumn(MATERIAL_TREE_PROPERTY_NAME,Qt::AscendingOrder);

    this-&gt;setColumnCount(MATERIAL_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(MATERIAL_TREE_PROPERTY_TYPE,QString("Property type"));
    headerItem-&gt;setText(MATERIAL_TREE_PROPERTY_NAME,QString("Property name"));
    headerItem-&gt;setText(MATERIAL_TREE_PROPERTY_VALUE,QString("Value"));
    headerItem-&gt;setText(MATERIAL_TREE_PROPERTY_UNITS,QString("Units"));
    this-&gt;setHeaderItem(headerItem);

    this-&gt;setColumnHidden(MATERIAL_TREE_PROPERTY_TYPE,true);

    this-&gt;setContextMenuPolicy(Qt::ActionsContextMenu);

    this-&gt;actionAddProperty = new QAction(this);
    this-&gt;actionAddProperty-&gt;setText(tr("Add new property"));
    this-&gt;actionAddProperty-&gt;setIcon(QIcon(":/icons/file/pixmaps/range-new.svg"));
    this-&gt;addAction(this-&gt;actionAddProperty);

    this-&gt;actionRemoveProperty = new QAction(this);
    this-&gt;actionRemoveProperty-&gt;setText(tr("Remove property"));
    this-&gt;actionRemoveProperty-&gt;setIcon(QIcon(":/icons/file/pixmaps/range-close.svg"));
    this-&gt;addAction(this-&gt;actionRemoveProperty);

    QObject::connect(this-&gt;actionAddProperty,&amp;QAction::triggered,this,&amp;MaterialTree::onPropertyAdd);
    QObject::connect(this-&gt;actionRemoveProperty,&amp;QAction::triggered,this,&amp;MaterialTree::onPropertyDelete);

    this-&gt;populate();

    QObject::connect(this,&amp;MaterialTree::currentItemChanged,this,&amp;MaterialTree::onCurrentItemChanged);
}

</t>
<t tx="leo.20201108101524.104">void MaterialTree::populate(void)
{
    this-&gt;blockSignals(true);

    this-&gt;clear();
    this-&gt;actionAddProperty-&gt;setDisabled(true);
    this-&gt;actionRemoveProperty-&gt;setDisabled(true);

    if (this-&gt;materialName.length() == 0)
    {
        return;
    }
    this-&gt;actionAddProperty-&gt;setEnabled(true);

    RMaterial material = MaterialList::getInstance().get(this-&gt;materialName);

    for (uint i=0;i&lt;material.size();i++)
    {
        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setData(MATERIAL_TREE_PROPERTY_TYPE,Qt::DisplayRole,QVariant(material.get(i).getType()));
        item-&gt;setText(MATERIAL_TREE_PROPERTY_NAME,material.get(i).getName());
        item-&gt;setText(MATERIAL_TREE_PROPERTY_UNITS,material.get(i).getUnits());

        MaterialPropertyLineEdit *lineEdit = new MaterialPropertyLineEdit(material.get(i).getType());
        lineEdit-&gt;setValue(material.get(i).get(RVariable::getInitValue(material.get(i).getKeyType())));
        this-&gt;setItemWidget(item,MATERIAL_TREE_PROPERTY_VALUE,lineEdit);
        if (material.get(i).size() &gt; 1)
        {
            lineEdit-&gt;setDisabled(true);
        }

        QTreeWidgetItem *child = new QTreeWidgetItem(item);
        child-&gt;setFirstColumnSpanned(true);
        child-&gt;setData(MATERIAL_TREE_PROPERTY_TYPE,Qt::DisplayRole,QVariant(material.get(i).getType()));
        PushButton *buttonValues = new PushButton(int(material.get(i).getType()),QString("Edit temperature dependent values"));
        this-&gt;setItemWidget(child,MATERIAL_TREE_PROPERTY_NAME,buttonValues);

        QObject::connect(lineEdit,&amp;MaterialPropertyLineEdit::valueChanged,
                         this,&amp;MaterialTree::onValueChanged);
        QObject::connect(buttonValues,&amp;PushButton::clicked,this,&amp;MaterialTree::onButtonValueClicked);
    }

    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101524.105">void MaterialTree::onMaterialSelected(const QString &amp;materialName)
{
    this-&gt;materialName = materialName;
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101524.106">void MaterialTree::onCurrentItemChanged(QTreeWidgetItem *current, QTreeWidgetItem *)
{
    if (current)
    {
        this-&gt;actionRemoveProperty-&gt;setEnabled(true);
    }
    else
    {
        this-&gt;actionRemoveProperty-&gt;setDisabled(true);
    }
    RMaterial material = MaterialList::getInstance().get(this-&gt;materialName);
    if (material.size()+2 &lt; R_MATERIAL_PROPERTY_N_TYPES)
    {
        this-&gt;actionAddProperty-&gt;setEnabled(true);
    }
    else
    {
        this-&gt;actionAddProperty-&gt;setDisabled(true);
    }
}

</t>
<t tx="leo.20201108101524.107">void MaterialTree::onValueChanged(RMaterialPropertyType type, double value)
{
    RMaterial material = MaterialList::getInstance().get(this-&gt;materialName);
    uint propertyPosition = material.findPosition(type);
    material.get(propertyPosition).add(RVariable::getInitValue(material.get(propertyPosition).getKeyType()),value);
    MaterialList::getInstance().add(material);
}

</t>
<t tx="leo.20201108101524.108">void MaterialTree::onButtonValueClicked(int id)
{
    RMaterial material = MaterialList::getInstance().get(this-&gt;materialName);
    uint propertyPosition = material.findPosition(RMaterialPropertyType(id));

    MaterialPropertyEditDialog materialPropertyEditDialog(material.get(propertyPosition),this);

    if (materialPropertyEditDialog.exec() == QDialog::Accepted)
    {
//        for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
//        {
//            RMaterialPropertyType type = RMaterialPropertyType(this-&gt;topLevelItem(i)-&gt;data(MATERIAL_TREE_PROPERTY_TYPE,Qt::DisplayRole).toInt());
//            if (type != RMaterialPropertyType(id))
//            {
//                continue;
//            }
//            MaterialPropertyLineEdit *lineEdit = (MaterialPropertyLineEdit*)this-&gt;itemWidget(this-&gt;topLevelItem(i),MATERIAL_TREE_PROPERTY_VALUE);
//            lineEdit-&gt;setValue(material.get(propertyPosition).get(RVariable::getInitValue(material.get(propertyPosition).getKeyType())));
//            lineEdit-&gt;setEnabled(material.get(propertyPosition).size() == 1);
//        }
        MaterialList::getInstance().blockSignals(true);
        MaterialList::getInstance().add(material);
        MaterialList::getInstance().blockSignals(false);
        this-&gt;populate();
    }
}

</t>
<t tx="leo.20201108101524.109">void MaterialTree::onPropertyAdd(void)
{
    RMaterial material = MaterialList::getInstance().get(this-&gt;materialName);
    MaterialPropertyAddDialog addPropertyDialog(material,this);
    if (addPropertyDialog.exec() == QDialog::Accepted)
    {
        MaterialList::getInstance().add(material);
        this-&gt;populate();
    }
}

</t>
<t tx="leo.20201108101524.11">void MainWindow::progressAutoHideEnable(void)
{
    this-&gt;mainProgressBar-&gt;setAutoHide(true);
}

</t>
<t tx="leo.20201108101524.110">void MaterialTree::onPropertyDelete(void)
{
    RMaterial material = MaterialList::getInstance().get(this-&gt;materialName);

    QList&lt;QTreeWidgetItem*&gt; items = this-&gt;selectedItems();

    for (int i=0;i&lt;items.size();i++)
    {
        RMaterialPropertyType type = RMaterialPropertyType(items[i]-&gt;data(MATERIAL_TREE_PROPERTY_TYPE,Qt::DisplayRole).toInt());

        uint propertyPosition = material.findPosition(type);
        material.remove(propertyPosition);
    }
    MaterialList::getInstance().add(material);
    this-&gt;populate();
}
</t>
<t tx="leo.20201108101524.111">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   material_updater.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source material (*.cpp)                                  *
 *  DATE:   17-th May 2016                                           *
 *                                                                   *
 *  DESCRIPTION: Material updater class definition                   *
 *********************************************************************/

#include &lt;rmlib.h&gt;

#include "material_updater.h"
#include "material_list.h"

MaterialUpdater::MaterialUpdater(QObject *parent)
    : Job(parent)
{

}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.112">void MaterialUpdater::addMaterial(const QString &amp;source)
{
    this-&gt;materials.append(source);
}

</t>
<t tx="leo.20201108101524.113">void MaterialUpdater::run(void)
{
    RLogger::info("Updating material database.\n");
    RLogger::indent();
    RProgressInitialize("Updating material database.");
    for (int i=0;i&lt;this-&gt;materials.size();i++)
    {
        RProgressPrint(i+1,this-&gt;materials.size());

        RLogger::info("Reading material file \'%s\'.\n",this-&gt;materials.at(i).toUtf8().constData());

        RMaterial material;
        try
        {
            material.read(this-&gt;materials.at(i));
            if (MaterialList::getInstance().containName(material.getName()))
            {
                RLogger::info("Material database already contains material with name \'%s\'. Material will not be imported.\n",material.getName().toUtf8().constData());
            }
            else
            {
                RLogger::info("Inserting material \'%s\' into database.\n",material.getName().toUtf8().constData());
                MaterialList::getInstance().add(material);
            }
        }
        catch (const RError &amp;rError)
        {
            RLogger::warning("Failed to update material from file \'%s\'. %s\n",
                             this-&gt;materials.at(i).toUtf8().constData(),
                             rError.getMessage().toUtf8().constData());
        }
    }
    RProgressFinalize();
    RLogger::unindent();
}
</t>
<t tx="leo.20201108101524.114">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   matrix_solver_config_dialog.cpp                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   1-st February 2013                                       *
 *                                                                   *
 *  DESCRIPTION: Matrix solver config. dialog class definition       *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include &lt;rmlib.h&gt;

#include "session.h"
#include "matrix_solver_config_dialog.h"

MatrixSolverConfigDialog::MatrixSolverConfigDialog(uint modelID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Matrix solver configuration"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    // CG SOLVER
    RMatrixSolverConf &amp;solverConfCG = Session::getInstance().getModel(this-&gt;modelID).getMatrixSolverConf(RMatrixSolverConf::CG);

    this-&gt;groupCG = new QGroupBox(RMatrixSolverConf::getName(RMatrixSolverConf::CG));
    mainLayout-&gt;addWidget(this-&gt;groupCG);

    QGridLayout *cgLayout = new QGridLayout;
    this-&gt;groupCG-&gt;setLayout(cgLayout);

    uint cgRowCount = 0;

    QLabel *labelCGNIterations = new QLabel(tr("Number of iterations:"));
    cgLayout-&gt;addWidget(labelCGNIterations, cgRowCount, 0, 1, 1);

    this-&gt;spinCGNIterations = new QSpinBox;
    this-&gt;spinCGNIterations-&gt;setRange(1,INT_MAX);
    this-&gt;spinCGNIterations-&gt;setValue(solverConfCG.getNOuterIterations());
    cgLayout-&gt;addWidget(this-&gt;spinCGNIterations, cgRowCount, 1, 1, 1);

    cgRowCount ++;

    QLabel *labelCGCvgValue = new QLabel(tr("Convergence value:"));
    cgLayout-&gt;addWidget(labelCGCvgValue, cgRowCount, 0, 1, 1);

    this-&gt;editCGCvgValue = new ValueLineEdit(0.0,1.0);
    this-&gt;editCGCvgValue-&gt;setValue(solverConfCG.getSolverCvgValue());
    cgLayout-&gt;addWidget(this-&gt;editCGCvgValue, cgRowCount, 1, 1, 1);

    cgRowCount ++;

    QLabel *labelCGOutputFrequency = new QLabel(tr("Solver output frequency:"));
    cgLayout-&gt;addWidget(labelCGOutputFrequency, cgRowCount, 0, 1, 1);

    this-&gt;spinCGOutputFrequency = new QSpinBox;
    this-&gt;spinCGOutputFrequency-&gt;setRange(0,INT_MAX);
    this-&gt;spinCGOutputFrequency-&gt;setValue(solverConfCG.getOutputFrequency());
    cgLayout-&gt;addWidget(this-&gt;spinCGOutputFrequency, cgRowCount, 1, 1, 1);

    cgRowCount ++;

    // GMRES SOLVER
    RMatrixSolverConf &amp;solverConfGMRES = Session::getInstance().getModel(this-&gt;modelID).getMatrixSolverConf(RMatrixSolverConf::GMRES);

    this-&gt;groupGMRES = new QGroupBox(RMatrixSolverConf::getName(RMatrixSolverConf::GMRES));
    mainLayout-&gt;addWidget(this-&gt;groupGMRES);

    QGridLayout *gmresLayout = new QGridLayout;
    this-&gt;groupGMRES-&gt;setLayout(gmresLayout);

    uint gmresRowCount = 0;

    QLabel *labelGMRESNInnerIterations = new QLabel(tr("Number of inner iterations:"));
    gmresLayout-&gt;addWidget(labelGMRESNInnerIterations, gmresRowCount, 0, 1, 1);

    this-&gt;spinGMRESNInnerIterations = new QSpinBox;
    this-&gt;spinGMRESNInnerIterations-&gt;setRange(1,INT_MAX);
    this-&gt;spinGMRESNInnerIterations-&gt;setValue(solverConfGMRES.getNInnerIterations());
    gmresLayout-&gt;addWidget(this-&gt;spinGMRESNInnerIterations, gmresRowCount, 1, 1, 1);

    gmresRowCount ++;

    QLabel *labelGMRESNOuterIterations = new QLabel(tr("Number of outer iterations:"));
    gmresLayout-&gt;addWidget(labelGMRESNOuterIterations, gmresRowCount, 0, 1, 1);

    this-&gt;spinGMRESNOuterIterations = new QSpinBox;
    this-&gt;spinGMRESNOuterIterations-&gt;setRange(1,INT_MAX);
    this-&gt;spinGMRESNOuterIterations-&gt;setValue(solverConfGMRES.getNOuterIterations());
    gmresLayout-&gt;addWidget(this-&gt;spinGMRESNOuterIterations, gmresRowCount, 1, 1, 1);

    gmresRowCount ++;

    QLabel *labelGMRESCvgValue = new QLabel(tr("Convergence value:"));
    gmresLayout-&gt;addWidget(labelGMRESCvgValue, gmresRowCount, 0, 1, 1);

    this-&gt;editGMRESCvgValue = new ValueLineEdit(0.0,1.0);
    this-&gt;editGMRESCvgValue-&gt;setValue(solverConfGMRES.getSolverCvgValue());
    gmresLayout-&gt;addWidget(this-&gt;editGMRESCvgValue, gmresRowCount, 1, 1, 1);

    gmresRowCount ++;

    QLabel *labelGMRESOutputFrequency = new QLabel(tr("Solver output frequency:"));
    gmresLayout-&gt;addWidget(labelGMRESOutputFrequency, gmresRowCount, 0, 1, 1);

    this-&gt;spinGMRESOutputFrequency = new QSpinBox;
    this-&gt;spinGMRESOutputFrequency-&gt;setRange(0,INT_MAX);
    this-&gt;spinGMRESOutputFrequency-&gt;setValue(solverConfGMRES.getOutputFrequency());
    gmresLayout-&gt;addWidget(this-&gt;spinGMRESOutputFrequency, gmresRowCount, 1, 1, 1);

    gmresRowCount ++;

    // Button layout

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;MatrixSolverConfigDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;MatrixSolverConfigDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.115">int MatrixSolverConfigDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        RMatrixSolverConf &amp;solverConfCG = Session::getInstance().getModel(this-&gt;modelID).getMatrixSolverConf(RMatrixSolverConf::CG);

        solverConfCG.setNOuterIterations(this-&gt;spinCGNIterations-&gt;value());
        solverConfCG.setSolverCvgValue(this-&gt;editCGCvgValue-&gt;getValue());
        solverConfCG.setOutputFrequency(this-&gt;spinCGOutputFrequency-&gt;value());

        RMatrixSolverConf &amp;solverConfGMRES = Session::getInstance().getModel(this-&gt;modelID).getMatrixSolverConf(RMatrixSolverConf::GMRES);

        solverConfGMRES.setNInnerIterations(this-&gt;spinGMRESNInnerIterations-&gt;value());
        solverConfGMRES.setNOuterIterations(this-&gt;spinGMRESNOuterIterations-&gt;value());
        solverConfGMRES.setSolverCvgValue(this-&gt;editGMRESCvgValue-&gt;getValue());
        solverConfGMRES.setOutputFrequency(this-&gt;spinGMRESOutputFrequency-&gt;value());
    }

    return retVal;
}
</t>
<t tx="leo.20201108101524.116">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   merge_entity_dialog.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   30-th November 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Merge entity dialog class definition                *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;
#include &lt;QGroupBox&gt;

#include "merge_entity_dialog.h"
#include "session.h"
#include "model_action.h"
#include "job_manager.h"

MergeEntityDialog::MergeEntityDialog(REntityGroupTypeMask entityTypeMask, QWidget *parent) :
    QDialog(parent),
    entityTypeMask(entityTypeMask)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Merge entities"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *listLabel = new QLabel(tr("Following entities will be merged:"));
    mainLayout-&gt;addWidget(listLabel);

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QList&lt;SessionEntityID&gt; selectedEntities = this-&gt;findEntities(modelIDs[i],this-&gt;entityTypeMask);

        QList&lt;SessionEntityID&gt; selectedPoints = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_POINT);
        QList&lt;SessionEntityID&gt; selectedLines = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_LINE);
        QList&lt;SessionEntityID&gt; selectedSurfaces = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_SURFACE);
        QList&lt;SessionEntityID&gt; selectedVolumes = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_VOLUME);

        Model &amp;rModel = Session::getInstance().getModel(modelIDs[i]);

        QGroupBox *modelGroupBox= new QGroupBox;
        modelGroupBox-&gt;setTitle(rModel.getName());
        mainLayout-&gt;addWidget(modelGroupBox);

        QGridLayout *modelGroupLayout = new QGridLayout;
        modelGroupBox-&gt;setLayout(modelGroupLayout);

        QString text = "&lt;dl&gt;";
        if (selectedPoints.size() &gt;= 2)
        {
            text += "&lt;dt&gt;" + tr("Points:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedPoints.size();j++)
            {
                text += rModel.getPoint(selectedPoints[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedLines.size() &gt;= 2)
        {
            text += "&lt;dt&gt;" + tr("Lines:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedLines.size();j++)
            {
                text += rModel.getLine(selectedLines[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedSurfaces.size() &gt;= 2)
        {
            text += "&lt;dt&gt;" + tr("Surfaces:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedSurfaces.size();j++)
            {
                text += rModel.getSurface(selectedSurfaces[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedVolumes.size() &gt;= 2)
        {
            text += "&lt;dt&gt;" + tr("Volumes:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedVolumes.size();j++)
            {
                text += rModel.getVolume(selectedVolumes[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        text += "&lt;/dl&gt;";

        QLabel *modelLabel = new QLabel(text);
        modelGroupLayout-&gt;addWidget(modelLabel,1,0,1,1);
    }

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;MergeEntityDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;MergeEntityDialog::accept);

    this-&gt;layout()-&gt;setSizeConstraint(QLayout::SetFixedSize);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.117">int MergeEntityDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
        for (int i=0;i&lt;modelIDs.size();i++)
        {
            QList&lt;SessionEntityID&gt; selectedEntities = SessionEntityID::filterList(this-&gt;findEntities(modelIDs[i],this-&gt;entityTypeMask));

            if (selectedEntities.size() &lt; 2)
            {
                continue;
            }
            ModelActionInput modelActionInput(modelIDs[i]);
            modelActionInput.setMergeEntities(selectedEntities);

            ModelAction *modelAction = new ModelAction;
            modelAction-&gt;setAutoDelete(true);
            modelAction-&gt;addAction(modelActionInput);
            JobManager::getInstance().submit(modelAction);
        }
    }

    return retVal;
}

</t>
<t tx="leo.20201108101524.118">bool MergeEntityDialog::entitiesSelected(REntityGroupTypeMask entityTypeMask)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QList&lt;SessionEntityID&gt; selectedEntities = Session::filterSelectedEntityIDs(Session::getInstance().getSelectedEntityIDs(),modelIDs[i],entityTypeMask);

        QList&lt;SessionEntityID&gt; selectedPoints = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_POINT);
        QList&lt;SessionEntityID&gt; selectedLines = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_LINE);
        QList&lt;SessionEntityID&gt; selectedSurfaces = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_SURFACE);
        QList&lt;SessionEntityID&gt; selectedVolumes = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_VOLUME);
        if (selectedPoints.size() &gt;= 2 || selectedLines.size() &gt;= 2 || selectedSurfaces.size() &gt;= 2 || selectedVolumes.size() &gt;= 2)
        {
            return true;
        }
    }
    return false;
}

QList&lt;SessionEntityID&gt; MergeEntityDialog::findEntities(uint mid, REntityGroupTypeMask entityTypeMask)
{
    return Session::filterSelectedEntityIDs(Session::getInstance().getSelectedEntityIDs(),mid,entityTypeMask);
}
</t>
<t tx="leo.20201108101524.119">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   merge_near_nodes_dialog.cpp                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   18-th November 2016                                      *
 *                                                                   *
 *  DESCRIPTION: Merge near nodes dialog class definition            *
 *********************************************************************/

#include &lt;QIcon&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "merge_near_nodes_dialog.h"
#include "session.h"
#include "model_action.h"
#include "job_manager.h"

MergeNearNodesDialog::MergeNearNodesDialog(uint modelID, QWidget *parent)
    : QDialog(parent)
    , modelID(modelID)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Merge near nodes"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *label = new QLabel(tr("Merge near nodes for model") + " &lt;b&gt;" + Session::getInstance().getModel(this-&gt;modelID).getName() + "&lt;/b&gt;");
    mainLayout-&gt;addWidget(label);

    QHBoxLayout *toleranceLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(toleranceLayout);

    QLabel *toleranceLabel = new QLabel(tr("Tolerance:"));
    toleranceLayout-&gt;addWidget(toleranceLabel);

    this-&gt;toleranceEdit = new ValueLineEdit(0.0,1e10);
    this-&gt;toleranceEdit-&gt;setValue(Session::getInstance().getModel(this-&gt;modelID).findMinimumNodeDistance());
    toleranceLayout-&gt;addWidget(this-&gt;toleranceEdit);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;MergeNearNodesDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;MergeNearNodesDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.12">void MainWindow::progressAutoHideDisable(void)
{
    this-&gt;mainProgressBar-&gt;setAutoHide(false);
}

QDockWidget *MainWindow::findCustomDockWidget(const QString &amp;name)
{
    return this-&gt;findChild&lt;QDockWidget*&gt;(name);
}

</t>
<t tx="leo.20201108101524.120">int MergeNearNodesDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        ModelActionInput modelActionInput(this-&gt;modelID);
        modelActionInput.setMergeNearNodes(this-&gt;toleranceEdit-&gt;getValue());

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }

    return retVal;
}
</t>
<t tx="leo.20201108101524.121">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   mesh_generator.cpp                                       *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   7-th September 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Mesh generator class definition                     *
 *********************************************************************/

#include &lt;rblib.h&gt;
#include &lt;rmlib.h&gt;

#include "session.h"
#include "mesh_generator.h"

MeshGenerator::MeshGenerator(uint modelID, QObject *parent) :
    Job(parent),
    modelID(modelID)
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.122">void MeshGenerator::run(void)
{
    Session::getInstance().storeCurentModelVersion(this-&gt;modelID,tr("Generate 3D mesh"));

    Model model = Session::getInstance().getModel(this-&gt;modelID);
    RLogger::info("Generating 3D mesh for model \'%s\'\n",model.getName().toUtf8().constData());
    RLogger::indent();

    try
    {
        if (model.getMeshInput().getSurfaceIntegrityCheck())
        {
            uint nIntersected = model.breakIntersectedElements(10);
            if (nIntersected &gt; 0)
            {
                RLogger::warning("Number of intersected elements found = %u.\n",nIntersected);
            }
        }
        RMeshGenerator::generate(model.getMeshInput(),model);
        model.clearEdgeNodes();
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to generate 3D mesh: %s\n",error.getMessage().toUtf8().constData());
        RLogger::unindent();
        return;
    }

    RLogger::unindent();

    RLogger::info("Consolidating mesh internal structures.\n");
    RLogger::indent();

    try
    {
        model.consolidate(Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateSliverElements);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to consolidate internal structures: %s\n",error.getMessage().toUtf8().constData());
        RLogger::unindent();
        return;
    }

    RLogger::unindent();

    Session::getInstance().setModel(this-&gt;modelID,model);
}
</t>
<t tx="leo.20201108101524.13">void MainWindow::showCustomDockWidget(QWidget *widget, const QString &amp;name, const QString &amp;title)
{
    QDockWidget *dockWidget = this-&gt;findCustomDockWidget(name);

    if (!dockWidget)
    {
        QWidget *layoutWidget;
        QGridLayout *gridLayout;

        layoutWidget = new QWidget();

        gridLayout = new QGridLayout(layoutWidget);

        gridLayout-&gt;addWidget(widget);

        dockWidget = new QDockWidget(this);
        dockWidget-&gt;setObjectName(name);
        dockWidget-&gt;setWindowTitle(title);
        dockWidget-&gt;setWidget(layoutWidget);

        this-&gt;addDockWidget(Qt::RightDockWidgetArea, dockWidget);

        QDockWidget *firstDockWidget = this-&gt;findFirstDockWidget(Qt::RightDockWidgetArea);
        if (firstDockWidget)
        {
            this-&gt;tabifyDockWidget(firstDockWidget,dockWidget);
        }
    }

    dockWidget-&gt;show();
    dockWidget-&gt;raise();
}

</t>
<t tx="leo.20201108101524.14">void MainWindow::hideCustomDockWidget(const QString &amp;name)
{
    QDockWidget *dockWidget = this-&gt;findCustomDockWidget(name);
    if (dockWidget)
    {
        delete dockWidget;
    }
}

</t>
<t tx="leo.20201108101524.15">void MainWindow::createMenus(void)
{
    QMenuBar *menubar = new QMenuBar(this);
    this-&gt;setMenuBar(menubar);

    QMenu *menuFile = new QMenu(menubar);
    menuFile-&gt;setTitle(QApplication::translate("MainWindow", "File"));
    QMenu *menuFileSession = new QMenu(menuFile);
    menuFileSession-&gt;setTitle(QApplication::translate("MainWindow", "Session"));
    menuFileSession-&gt;setIcon(QIcon(":/icons/file/pixmaps/range-session.svg"));
    menuFileSession-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SESSION_NEW));
    menuFileSession-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SESSION_OPEN));
    menuFileSession-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SESSION_SAVE));
    menuFileSession-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SESSION_SAVE_AS));
    menuFileSession-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SESSION_CLOSE));
    menuFile-&gt;addAction(menuFileSession-&gt;menuAction());
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_NEW));
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_OPEN));
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_SAVE));
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_SAVE_AS));
    QMenu *menuFileExport = new QMenu(menuFile);
    menuFileExport-&gt;setTitle(QApplication::translate("MainWindow", "Export"));
    menuFileExport-&gt;setIcon(QIcon(":/icons/file/pixmaps/range-model_save_as.svg"));
    menuFileExport-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_EXPORT_MSH));
    menuFileExport-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_EXPORT_RAW));
    menuFileExport-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_EXPORT_STL_ASCII));
    menuFileExport-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_EXPORT_STL_BINARY));
    menuFile-&gt;addAction(menuFileExport-&gt;menuAction());
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_CLOSE));
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_RELOAD_RESULTS));
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_DROP_RESULTS));
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_RENAME));
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    menuFile-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_QUIT));
    menubar-&gt;addAction(menuFile-&gt;menuAction());

    QMenu *menuGeometry = new QMenu(menubar);
    menuGeometry-&gt;setTitle(QApplication::translate("MainWindow", "Geometry"));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_UNDO));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_REDO));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    QMenu *menuGeometryDraw = new QMenu(menuGeometry);
    menuGeometryDraw-&gt;setTitle(QApplication::translate("MainWindow", "Draw"));
    menuGeometryDraw-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-draw_geometry.svg"));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_POINT));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_LINE));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_TRIANGLE));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_QUADRILATERAL));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_CIRCLE));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_ELLIPSE));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_TETRAHEDRON));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_HEXAHEDRON));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_CYLINDER));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_SPHERE));
    menuGeometryDraw-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_RAW));
    menuGeometry-&gt;addAction(menuGeometryDraw-&gt;menuAction());
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
//    QMenu *menuGeometryPoint = new QMenu(menuGeometry);
//    menuGeometryPoint-&gt;setTitle(QApplication::translate("MainWindow", "Point"));
//    menuGeometryPoint-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-entity_point.svg"));
//    menuGeometry-&gt;addAction(menuGeometryPoint-&gt;menuAction());
    QMenu *menuGeometryLine = new QMenu(menuGeometry);
    menuGeometryLine-&gt;setTitle(QApplication::translate("MainWindow", "Line"));
    menuGeometryLine-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-entity_line.svg"));
    menuGeometryLine-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_LINE_GENERATE_FROM_EDGES));
    menuGeometry-&gt;addAction(menuGeometryLine-&gt;menuAction());
    QMenu *menuGeometrySurface = new QMenu(menuGeometry);
    menuGeometrySurface-&gt;setTitle(QApplication::translate("MainWindow", "Surface"));
    menuGeometrySurface-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-entity_surface.svg"));
    menuGeometrySurface-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_MARK));
    menuGeometrySurface-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_SWAP_ELEMENT_NORMAL));
    menuGeometrySurface-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_SWAP_NORMALS));
    menuGeometrySurface-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_SYNC_NORMALS));
    menuGeometrySurface-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    menuGeometrySurface-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_CLOSE_HOLE));
    menuGeometrySurface-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_COARSEN));
    menuGeometrySurface-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_FIND_INTERSECTED_ELEMENTS));
    menuGeometrySurface-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_BREAK_INTERSECTED_ELEMENTS));
    QMenu *menuGeometryBoolOperations = new QMenu(menuGeometrySurface);
    menuGeometryBoolOperations-&gt;setTitle(QApplication::translate("MainWindow", "Boolean operations"));
    menuGeometryBoolOperations-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-entity_surface_bool_operation.svg"));
    menuGeometryBoolOperations-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_BOOL_UNION));
    menuGeometryBoolOperations-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_BOOL_DIFFERENCE));
    menuGeometryBoolOperations-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_BOOL_INTERSECTION));
    menuGeometrySurface-&gt;addAction(menuGeometryBoolOperations-&gt;menuAction());
    menuGeometry-&gt;addAction(menuGeometrySurface-&gt;menuAction());
    QMenu *menuGeometryVolume = new QMenu(menuGeometry);
    menuGeometryVolume-&gt;setTitle(QApplication::translate("MainWindow", "Volume"));
    menuGeometryVolume-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-entity_volume.svg"));
    menuGeometryVolume-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_VOLUME_GENERATE_TETRAHEDRA));
    menuGeometry-&gt;addAction(menuGeometryVolume-&gt;menuAction());
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    QMenu *menuGeometryCut = new QMenu(menuGeometry);
    menuGeometryCut-&gt;setTitle(QApplication::translate("MainWindow", "Cut"));
    menuGeometryCut-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-entity_cut.svg"));
    menuGeometryCut-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_CUT_CREATE));
    menuGeometryCut-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_CUT_EDIT));
    menuGeometry-&gt;addAction(menuGeometryCut-&gt;menuAction());
    QMenu *menuGeometryIso = new QMenu(menuGeometry);
    menuGeometryIso-&gt;setTitle(QApplication::translate("MainWindow", "Iso"));
    menuGeometryIso-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-entity_iso.svg"));
    menuGeometryIso-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_ISO_CREATE));
    menuGeometryIso-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_ISO_EDIT));
    menuGeometry-&gt;addAction(menuGeometryIso-&gt;menuAction());
    QMenu *menuGeometryStreamLine = new QMenu(menuGeometry);
    menuGeometryStreamLine-&gt;setTitle(QApplication::translate("MainWindow", "Stream line"));
    menuGeometryStreamLine-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-entity_stream_line.svg"));
    menuGeometryStreamLine-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_STREAM_LINE_CREATE));
    menuGeometryStreamLine-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_STREAM_LINE_EDIT));
    menuGeometry-&gt;addAction(menuGeometryStreamLine-&gt;menuAction());
    QMenu *menuGeometryScalarField = new QMenu(menuGeometry);
    menuGeometryScalarField-&gt;setTitle(QApplication::translate("MainWindow", "Scalar field"));
    menuGeometryScalarField-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-entity_scalar_field.svg"));
    menuGeometryScalarField-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SCALAR_FIELD_CREATE));
    menuGeometryScalarField-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SCALAR_FIELD_EDIT));
    menuGeometry-&gt;addAction(menuGeometryScalarField-&gt;menuAction());
    QMenu *menuGeometryVectorField = new QMenu(menuGeometry);
    menuGeometryVectorField-&gt;setTitle(QApplication::translate("MainWindow", "Vector field"));
    menuGeometryVectorField-&gt;setIcon(QIcon(":/icons/geometry/pixmaps/range-entity_vector_field.svg"));
    menuGeometryVectorField-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_VECTOR_FIELD_CREATE));
    menuGeometryVectorField-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_VECTOR_FIELD_EDIT));
    menuGeometry-&gt;addAction(menuGeometryVectorField-&gt;menuAction());
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_ENTITY_MERGE));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_ENTITY_REMOVE));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_FIND_SLIVER_ELEMENTS));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_FIX_SLIVER_ELEMENTS));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_MERGE_NEAR_NODES));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_MOVE_NODE));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_REMOVE_NODE));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_REMOVE_NODE_AND_CLOSE_HOLE));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_CREATE_ELEMENT));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_REMOVE_ELEMENT));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_TRANSFORM));
    menuGeometry-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    QMenu *menuGeometryDevelopement = new QMenu(menuGeometry);
    menuGeometryDevelopement-&gt;setTitle(QApplication::translate("MainWindow", "Special tools"));
    menuGeometryDevelopement-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DEV_EXPORT_SLIVER_ELEMENTS));
    menuGeometryDevelopement-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DEV_EXPORT_INTERSECTED_ELEMENTS));
    menuGeometryDevelopement-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DEV_PURGE_UNUSED_NODES));
    menuGeometryDevelopement-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DEV_PURGE_UNUSED_ELEMENTS));
    menuGeometryDevelopement-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DEV_REMOVE_DUPLICATE_NODES));
    menuGeometryDevelopement-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DEV_REMOVE_DUPLICATE_ELEMENTS));
    menuGeometryDevelopement-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DEV_POINT_INSIDE_SURFACE));
    menuGeometryDevelopement-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DEV_TETRAHEDRALIZE_SURFACE));
    menuGeometryDevelopement-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DEV_CONSOLIDATE));
    menuGeometry-&gt;addAction(menuGeometryDevelopement-&gt;menuAction());
    menubar-&gt;addAction(menuGeometry-&gt;menuAction());

    QMenu *menuProblem = new QMenu(menubar);
    menuProblem-&gt;setTitle(QApplication::translate("MainWindow", "Problem"));
    menuProblem-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_PROBLEM_TASK_FLOW));
    menuProblem-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_PROBLEM_SOLVER_SETUP));
    menuProblem-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_PROBLEM_DEFINE_MONITORING_POINTS));
    menuProblem-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    menuProblem-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_PROBLEM_RESET));
    menubar-&gt;addAction(menuProblem-&gt;menuAction());

    QMenu *menuSolver = new QMenu(menubar);
    menuSolver-&gt;setTitle(QApplication::translate("MainWindow", "Solution"));
    menuSolver-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SOLVER_START));
    menuSolver-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SOLVER_STOP));
    menuSolver-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SOLVER_KILL));
    menuSolver-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    menubar-&gt;addAction(menuSolver-&gt;menuAction());

    QMenu *menuReport = new QMenu(menubar);
    menuReport-&gt;setTitle(QApplication::translate("MainWindow", "Report"));
    menuReport-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_REPORT_MODEL_STATISTICS));
    menuReport-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_REPORT_SOLVER_LOG));
    menuReport-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_REPORT_CONVERGENCE_GRAPH));
    menuReport-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_REPORT_MONITORING_POINT_GRAPH));
    menuReport-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_REPORT_CREATE_REPORT));
    menubar-&gt;addAction(menuReport-&gt;menuAction());

    QMenu *menuTools = new QMenu(menubar);
    menuTools-&gt;setTitle(QApplication::translate("MainWindow", "Tools"));
    menuTools-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_SETTINGS));
    menubar-&gt;addAction(menuTools-&gt;menuAction());

    menubar-&gt;addSeparator();

    QMenu *menuHelp = new QMenu(menubar);
    menuHelp-&gt;setTitle(QApplication::translate("MainWindow", "Help"));
    menuHelp-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_HELP));
    menuHelp-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_UPDATE));
    menuHelp-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_ABOUT));
    menuHelp-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_ABOUT_QT));
    menuHelp-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_LICENSE));
    menuHelp-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_RELEASE_NOTES));
    menubar-&gt;addAction(menuHelp-&gt;menuAction());
}

</t>
<t tx="leo.20201108101524.16">void MainWindow::createToolBars(void)
{
    QString key, actionName;

    uint nToolBars;
    uint nActions;

    nToolBars = MainSettings::getInstance().value("nToolBars", 0).toUInt();

    //! Disable toolbar restoring untill its modification is not implemented.
    nToolBars = 0;

    if (nToolBars == 0 || nToolBars != 1)
    {
        QToolBar *mainToolBar = new QToolBar(this);
        mainToolBar-&gt;setObjectName(QString::fromUtf8("mainToolBar"));
        mainToolBar-&gt;setWindowTitle(tr("Main toolbar"));
        this-&gt;addToolBar(Qt::TopToolBarArea, mainToolBar);
        this-&gt;toolBars.push_back(mainToolBar);

        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_NEW));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_OPEN));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_SAVE));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_CLOSE));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_QUIT));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_UNDO));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_REDO));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_TRANSFORM));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_VOLUME_GENERATE_TETRAHEDRA));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_PROBLEM_TASK_FLOW));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SOLVER_START));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SOLVER_STOP));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SOLVER_KILL));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_REPORT_CONVERGENCE_GRAPH));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_REPORT_CREATE_REPORT));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_RELOAD_RESULTS));

        QWidget* spacer = new QWidget();
        spacer-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
        mainToolBar-&gt;addWidget(spacer);

        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_SETTINGS));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_HELP));
        mainToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_APPLICATION_ABOUT));

        this-&gt;addToolBarBreak();

        QToolBar *drawToolBar = new QToolBar(this);
        drawToolBar-&gt;setObjectName(QString::fromUtf8("drawToolBar"));
        drawToolBar-&gt;setWindowTitle(tr("Draw toolbar"));
        this-&gt;addToolBar(Qt::TopToolBarArea, drawToolBar);
        this-&gt;toolBars.push_back(drawToolBar);

        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_POINT));
        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_LINE));
        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_TRIANGLE));
        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_QUADRILATERAL));
        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_CIRCLE));
        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_ELLIPSE));
        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_TETRAHEDRON));
        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_HEXAHEDRON));
        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_CYLINDER));
        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_SPHERE));
        drawToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_DRAW_RAW));

        QToolBar *surfaceToolBar = new QToolBar(this);
        surfaceToolBar-&gt;setObjectName(QString::fromUtf8("surfaceToolBar"));
        surfaceToolBar-&gt;setWindowTitle(tr("Surface toolbar"));
        this-&gt;addToolBar(Qt::TopToolBarArea, surfaceToolBar);
        this-&gt;toolBars.push_back(surfaceToolBar);

        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_MARK));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_SWAP_ELEMENT_NORMAL));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_SWAP_NORMALS));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_SYNC_NORMALS));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_CLOSE_HOLE));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SURFACE_COARSEN));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_FIND_INTERSECTED_ELEMENTS));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_BREAK_INTERSECTED_ELEMENTS));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_FIND_SLIVER_ELEMENTS));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_FIX_SLIVER_ELEMENTS));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_BOOL_DIFFERENCE));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_BOOL_INTERSECTION));
        surfaceToolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_BOOL_UNION));
    }
    else
    {
        for (uint i=0;i&lt;nToolBars;i++)
        {
            QToolBar *toolBar = new QToolBar(this);

            key = "toolBar_" + QString::number(i+1) + "_size";
            nActions = MainSettings::getInstance().value(key, QString()).toUInt();

            key = "toolBar_" + QString::number(i+1) + "_name";
            toolBar-&gt;setObjectName(MainSettings::getInstance().value(key, QString()).toString());

            key = "toolBar_" + QString::number(i+1) + "_title";
            toolBar-&gt;setWindowTitle(MainSettings::getInstance().value(key, QString()).toString());

            this-&gt;addToolBar(Qt::TopToolBarArea, toolBar);

            for (uint j=0;j&lt;nActions;j++)
            {
                key = "toolBar_" + QString::number(i+1) + "_action_" + QString::number(j+1);
                actionName = MainSettings::getInstance().value(key, QString()).toString();
                toolBar-&gt;addAction(this-&gt;actionList-&gt;getAction(actionName));
            }
            this-&gt;toolBars.push_back(toolBar);
        }
    }
}

</t>
<t tx="leo.20201108101524.17">void MainWindow::createStatusBar(void)
{
    QStatusBar *statusbar;

    statusbar = new QStatusBar(this);
    statusbar-&gt;setObjectName(QString::fromUtf8("statusbar"));
    this-&gt;setStatusBar(statusbar);

    QWidget *progressBarWidget = new QWidget;
    statusbar-&gt;addWidget(progressBarWidget,1);

    QVBoxLayout *progressBarLayout = new QVBoxLayout;
    progressBarLayout-&gt;setSpacing(0);
    progressBarLayout-&gt;setMargin(0);
    progressBarWidget-&gt;setLayout(progressBarLayout);

    this-&gt;mainProgressBar = new ProgressBar(this);
    this-&gt;mainProgressBar-&gt;hide();
    progressBarLayout-&gt;addWidget(this-&gt;mainProgressBar);

    this-&gt;downloadProgressBar = new ProgressBar(this);
    this-&gt;downloadProgressBar-&gt;hide();
    progressBarLayout-&gt;addWidget(this-&gt;downloadProgressBar);
}

</t>
<t tx="leo.20201108101524.18">void MainWindow::createDownloadBar(void)
{

}

</t>
<t tx="leo.20201108101524.19">void MainWindow::createCentralWidget(void)
{
    this-&gt;centralTabWidget = new CentralTabWidget(this);
    this-&gt;setCentralWidget(this-&gt;centralTabWidget);
    this-&gt;modelSubWindows = new SubWindowManager(this-&gt;centralTabWidget-&gt;getMdiArea(), this);
}

</t>
<t tx="leo.20201108101524.2">                           const QString &amp;application,
                           QObject       *parent)
    : QSettings(organization,application,parent)
{
    this-&gt;applicationSettings = new ApplicationSettings(this);
    this-&gt;sync();
    this-&gt;storedVersion = RVersion(this-&gt;value("version").toString());
    this-&gt;setValue("version",QVariant(RVendor::version.toString()));
}

MainSettings &amp;MainSettings::getInstance(void)
{
    static MainSettings mainSettings(RVendor::name, RVendor::shortName);
    return mainSettings;
}

MainSettings * MainSettings::getInstancePtr(void)
{
    return &amp;MainSettings::getInstance();
}

</t>
<t tx="leo.20201108101524.20">void MainWindow::createModelDock(void)
{
    this-&gt;dockModel = new QDockWidget(this);
    this-&gt;dockModel-&gt;setObjectName(QString::fromUtf8("dockModel"));
    this-&gt;dockModel-&gt;setWindowTitle(QApplication::translate("MainWindow", "Model"));
    this-&gt;addDockWidget(Qt::LeftDockWidgetArea, this-&gt;dockModel);

    QWidget *layoutModels = new QWidget();
    this-&gt;dockModel-&gt;setWidget(layoutModels);

    QGridLayout *gridLayoutModels = new QGridLayout(layoutModels);

    QSplitter *splitter = new QSplitter;
    splitter-&gt;setOpaqueResize(false);
    splitter-&gt;setOrientation(Qt::Vertical);
    splitter-&gt;setChildrenCollapsible(false);
    gridLayoutModels-&gt;addWidget(splitter);

    //! Model tree.
    this-&gt;treeModelManager = new ModelTree(this-&gt;actionList,splitter);

    //! Model display properties tree.
    ModelEntityDisplayPropertiesTree *treeModelDisplayProperties = new ModelEntityDisplayPropertiesTree;
    splitter-&gt;addWidget(treeModelDisplayProperties);

    //! Model geometric properties tree.
    ModelEntityGeometricPropertiesTree *treeModelGeometricProperties = new ModelEntityGeometricPropertiesTree;
    splitter-&gt;addWidget(treeModelGeometricProperties);

    splitter-&gt;setStretchFactor(0,10);
    splitter-&gt;setStretchFactor(1,4);
    splitter-&gt;setStretchFactor(2,1);
}

</t>
<t tx="leo.20201108101524.21">void MainWindow::createProblemDock(void)
{
    QWidget *layoutProblem;
    QGridLayout *gridLayoutProblem;

    layoutProblem = new QWidget();

    gridLayoutProblem = new QGridLayout(layoutProblem);

    ProblemTree*treeProblem = new ProblemTree;
    gridLayoutProblem-&gt;addWidget(treeProblem);

    this-&gt;dockProblem = new QDockWidget(this);
    this-&gt;dockProblem-&gt;setObjectName(QString::fromUtf8("dockProblem"));
    this-&gt;dockProblem-&gt;setWindowTitle(QApplication::translate("MainWindow", "Problem setup"));
    this-&gt;dockProblem-&gt;setWidget(layoutProblem);
    this-&gt;addDockWidget(Qt::RightDockWidgetArea, this-&gt;dockProblem);
}

</t>
<t tx="leo.20201108101524.22">void MainWindow::createDocumentDock(void)
{
    QWidget *layoutDocuments;
    QGridLayout *gridLayoutDocuments;

    layoutDocuments = new QWidget();
    gridLayoutDocuments = new QGridLayout(layoutDocuments);

    DocumentTree *treeDocuments = new DocumentTree;
    gridLayoutDocuments-&gt;addWidget(treeDocuments);

    this-&gt;dockDocuments = new QDockWidget(this);
    this-&gt;dockDocuments-&gt;setObjectName(QString::fromUtf8("dockDocuments"));
    this-&gt;dockDocuments-&gt;setWindowTitle(QApplication::translate("MainWindow", "Documents"));
    this-&gt;dockDocuments-&gt;setWidget(layoutDocuments);

    this-&gt;addDockWidget(Qt::LeftDockWidgetArea, this-&gt;dockDocuments);
}

</t>
<t tx="leo.20201108101524.23">void MainWindow::createRecordsDock(void)
{
    QWidget *layoutRecords;
    QGridLayout *gridLayoutRecords;

    layoutRecords = new QWidget();
    gridLayoutRecords = new QGridLayout(layoutRecords);

    ModelRecordsSelector *treeRecords = new ModelRecordsSelector;
    gridLayoutRecords-&gt;addWidget(treeRecords);

    this-&gt;dockRecords = new QDockWidget(this);
    this-&gt;dockRecords-&gt;setObjectName(QString::fromUtf8("dockRecords"));
    this-&gt;dockRecords-&gt;setWindowTitle(QApplication::translate("MainWindow", "Model records"));
    this-&gt;dockRecords-&gt;setWidget(layoutRecords);

    this-&gt;addDockWidget(Qt::LeftDockWidgetArea, this-&gt;dockRecords);
}

</t>
<t tx="leo.20201108101524.24">void MainWindow::createBcDock(void)
{
    this-&gt;dockBc = new QDockWidget(this);
    this-&gt;dockBc-&gt;setObjectName(QString::fromUtf8("dockBcList"));
    this-&gt;dockBc-&gt;setWindowTitle(QApplication::translate("MainWindow", "Boundary conditions"));
    this-&gt;addDockWidget(Qt::RightDockWidgetArea, this-&gt;dockBc);

    QSplitter *splitter = new QSplitter(this-&gt;dockBc);
    splitter-&gt;setOrientation(Qt::Vertical);
    splitter-&gt;setChildrenCollapsible(false);
    this-&gt;dockBc-&gt;setWidget(splitter);

    BCManagerTree *treeBcList = new BCManagerTree(splitter);

    BCTree *treeBc = new BCTree(splitter);

    QObject::connect(treeBcList,
                     &amp;BCManagerTree::bcSelected,
                     treeBc,
                     &amp;BCTree::onBcSelected);
}

</t>
<t tx="leo.20201108101524.25">void MainWindow::createIcDock(void)
{
    this-&gt;dockIc = new QDockWidget(this);
    this-&gt;dockIc-&gt;setObjectName(QString::fromUtf8("dockIcList"));
    this-&gt;dockIc-&gt;setWindowTitle(QApplication::translate("MainWindow", "Initial conditions"));
    this-&gt;addDockWidget(Qt::RightDockWidgetArea, this-&gt;dockIc);

    QSplitter *splitter = new QSplitter(this-&gt;dockIc);
    splitter-&gt;setOrientation(Qt::Vertical);
    splitter-&gt;setChildrenCollapsible(false);
    this-&gt;dockIc-&gt;setWidget(splitter);

    ICManagerTree *treeIcList = new ICManagerTree(splitter);

    ICTree *treeIc = new ICTree(splitter);

    QObject::connect(treeIcList,
                     &amp;ICManagerTree::icSelected,
                     treeIc,
                     &amp;ICTree::onIcSelected);
}

</t>
<t tx="leo.20201108101524.26">void MainWindow::createEcDock(void)
{
    this-&gt;dockEc = new QDockWidget(this);
    this-&gt;dockEc-&gt;setObjectName(QString::fromUtf8("dockEcList"));
    this-&gt;dockEc-&gt;setWindowTitle(QApplication::translate("MainWindow", "Environment conditions"));
    this-&gt;addDockWidget(Qt::RightDockWidgetArea, this-&gt;dockEc);

    QSplitter *splitter = new QSplitter(this-&gt;dockEc);
    splitter-&gt;setOrientation(Qt::Vertical);
    splitter-&gt;setChildrenCollapsible(false);
    this-&gt;dockEc-&gt;setWidget(splitter);

    ECManagerTree *treeEcList = new ECManagerTree(splitter);

    ECTree *treeEc = new ECTree(splitter);

    QObject::connect(treeEcList,
                     &amp;ECManagerTree::ecSelected,
                     treeEc,
                     &amp;ECTree::onEcSelected);
}

</t>
<t tx="leo.20201108101524.27">void MainWindow::createMaterialDock(void)
{
    this-&gt;dockMaterial = new QDockWidget(this);
    this-&gt;dockMaterial-&gt;setObjectName(QString::fromUtf8("dockMaterialList"));
    this-&gt;dockMaterial-&gt;setWindowTitle(QApplication::translate("MainWindow", "Materials"));
    this-&gt;addDockWidget(Qt::RightDockWidgetArea, this-&gt;dockMaterial);

    QSplitter *splitter = new QSplitter(this-&gt;dockMaterial);
    splitter-&gt;setOrientation(Qt::Vertical);
    splitter-&gt;setChildrenCollapsible(false);
    this-&gt;dockMaterial-&gt;setWidget(splitter);

    MaterialManagerTree *treeMaterialList = new MaterialManagerTree(this-&gt;actionList,splitter);

    MaterialTree *treeMaterial = new MaterialTree(splitter);

    QObject::connect(treeMaterialList,
                     &amp;MaterialManagerTree::materialSelected,
                     treeMaterial,
                     &amp;MaterialTree::onMaterialSelected);
}

</t>
<t tx="leo.20201108101524.28">void MainWindow::createResultsDock(void)
{
    this-&gt;dockResults = new QDockWidget(this);
    this-&gt;dockResults-&gt;setObjectName(QString::fromUtf8("dockResultsList"));
    this-&gt;dockResults-&gt;setWindowTitle(QApplication::translate("MainWindow", "Results"));
    this-&gt;addDockWidget(Qt::RightDockWidgetArea, this-&gt;dockResults);

    QWidget *layoutResults = new QWidget();
    QGridLayout *gridLayout = new QGridLayout(layoutResults);

    this-&gt;dockResults-&gt;setWidget(layoutResults);

    ResultsVariableSelector *resultsComboBox = new ResultsVariableSelector;

    gridLayout-&gt;addWidget(resultsComboBox,0,0,1,1);

    ResultsVariableTree *treeResultsVariable = new ResultsVariableTree;
    gridLayout-&gt;addWidget(treeResultsVariable,1,0,1,1);

    QObject::connect(resultsComboBox,
                     &amp;ResultsVariableSelector::resultsVariableSelected,
                     treeResultsVariable,
                     &amp;ResultsVariableTree::onResultsVariableSelected);
}

QMenu * MainWindow::createPopupMenu (void)
{
    QMenu *popupMenu = this-&gt;QMainWindow::createPopupMenu();
//    Disabled untill toolbar modification is not implemented.
//    popupMenu-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
//    popupMenu-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SETTINGS_RESTORE));
    return popupMenu;
}

</t>
<t tx="leo.20201108101524.29">void MainWindow::readSettings(void)
{
    ApplicationSettings *pApplicationSettings = MainSettings::getInstance().getApplicationSettings();
    if (!pApplicationSettings)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Nonexisting application object.");
    }

    RVersion version(MainSettings::getInstance().value("application/version").toString());

    this-&gt;isFirstRun = (version != RVendor::version);

    if (version &lt;= RVendor::version)
    {
        pApplicationSettings-&gt;setSolverPath(MainSettings::getInstance().value("application/SolverPath").toString());
        if (pApplicationSettings-&gt;getSolverPath().isEmpty())
        {
            pApplicationSettings-&gt;setSolverPath(ApplicationSettings::getDefaultRangeSolverExecutable());
        }

        pApplicationSettings-&gt;setHelpDir(MainSettings::getInstance().value("application/HelpDir").toString());
        if (pApplicationSettings-&gt;getHelpDir().isEmpty())
        {
            pApplicationSettings-&gt;setHelpDir(ApplicationSettings::getDefaultHelpDir());
        }

        pApplicationSettings-&gt;setNThreads(MainSettings::getInstance().value("application/nThreads",pApplicationSettings-&gt;getNThreads()).toUInt());
        pApplicationSettings-&gt;setNHistoryRecords(MainSettings::getInstance().value("application/nHistoryRecords",pApplicationSettings-&gt;getNHistoryRecords()).toUInt());
        pApplicationSettings-&gt;setStyle(MainSettings::getInstance().value("application/style",pApplicationSettings-&gt;getStyle()).toString());
        pApplicationSettings-&gt;setToolbarIconSize(MainSettings::getInstance().value("application/toolbarIconSize",pApplicationSettings-&gt;getToolbarIconSize()).toInt());
        pApplicationSettings-&gt;setSendUsageInfo(MainSettings::getInstance().value("application/sendUsageInfo",pApplicationSettings-&gt;getSendUsageInfo()).toBool());
        pApplicationSettings-&gt;setRangeApiAllowed(MainSettings::getInstance().value("application/rangeApiAllowed",pApplicationSettings-&gt;getRangeApiAllowed()).toBool());
        pApplicationSettings-&gt;setRangeApiServer(MainSettings::getInstance().value("application/rangeApiServer",pApplicationSettings-&gt;getRangeApiServer()).toString());
        pApplicationSettings-&gt;setRangeAccount(MainSettings::getInstance().value("application/rangeAccount",pApplicationSettings-&gt;getRangeAccount()).toString());
        pApplicationSettings-&gt;setRangePassword(MainSettings::getInstance().value("application/rangePassword",pApplicationSettings-&gt;getRangePassword()).toString());

        for (int i=ACTION_NONE;i&lt;ACTION_N_TYPES;i++)
        {
            if (!ACTION_TYPE_IS_ACTION(ActionType(i)))
            {
                continue;
            }
            QString key = "application/shortcut_" + this-&gt;actionList-&gt;getAction(ActionType(i))-&gt;text();
            if (MainSettings::getInstance().contains(key))
            {
                const QString &amp;shortcut = MainSettings::getInstance().value(key).toString();

                pApplicationSettings-&gt;getActionDefinition()-&gt;setShortcut(ActionType(i),shortcut);
                this-&gt;actionList-&gt;getAction(ActionType(i))-&gt;setShortcut(shortcut);
            }
        }
    }

    MainSettings::getInstance().sync();
}

</t>
<t tx="leo.20201108101524.3">void MainSettings::setDirApplicationPath(const QString &amp;applicationPath)
{
    this-&gt;applicationDirPath = applicationPath;
}

QString MainSettings::getHomeDir(void) const
{
    return QStandardPaths::writableLocation(QStandardPaths::HomeLocation);
}

QString MainSettings::getRangeDir(void) const
{
    return this-&gt;getDir(QStandardPaths::writableLocation(QStandardPaths::DocumentsLocation),RVendor::name);
}

QString MainSettings::getDataDir(void) const
{
    return this-&gt;getDir(this-&gt;getRangeDir(),"data");
}

QString MainSettings::getMaterialsDir(void) const
{
    return this-&gt;getDir(this-&gt;getRangeDir(),"materials");
}

QString MainSettings::getDocDir(void) const
{
    return this-&gt;getDir(this-&gt;getRangeDir(),"doc");
}

QString MainSettings::getLogDir(void) const
{
    return this-&gt;getDir(this-&gt;getRangeDir(),"log");
}

QString MainSettings::getTmpDir(void) const
{
    return this-&gt;getDir(this-&gt;getRangeDir(),"tmp");
}

QString MainSettings::getSessionDir(void) const
{
    return this-&gt;getDir(this-&gt;getRangeDir(),"session");
}

QString MainSettings::getSessionFileName(void) const
{
    return this-&gt;value("session/fileName").toString();
}

QString MainSettings::getLogFileName() const
{
    return this-&gt;getLogDir() + QDir::separator() + MainSettings::logFileName;
}

QString MainSettings::findLicenseFileName(void) const
{
    QDir dir(this-&gt;applicationDirPath);
    dir.cdUp();
    dir.cd("doc");
    return dir.filePath(MainSettings::licenseFileName);
}

QString MainSettings::findReleaseNotesFileName(void) const
{
    QDir dir(this-&gt;applicationDirPath);
    dir.cdUp();
    dir.cd("doc");
    return dir.filePath(MainSettings::releaseNotesFileName);
}

QString MainSettings::findHelpDir(void) const
{
    QDir dir(this-&gt;applicationDirPath);
    dir.cdUp();
    return dir.filePath("help");
}

QString MainSettings::findPixmapsDir(void) const
{
    QDir dir(this-&gt;applicationDirPath);
    dir.cdUp();
    return dir.filePath("pixmaps");
}

</t>
<t tx="leo.20201108101524.30">void MainWindow::writeSettings(void) const
{
    QList&lt;QAction*&gt; actionList;
    QAction *action;
    QString key;

    // Main window
    MainSettings::getInstance().setValue("mainWindow/geometry", this-&gt;saveGeometry());
    MainSettings::getInstance().setValue("mainWindow/windowState", this-&gt;saveState());
    // Tool bars
    MainSettings::getInstance().setValue("nToolBars", uint(this-&gt;toolBars.size()));
    for (QList&lt;QToolBar*&gt;::size_type i = 0; i != this-&gt;toolBars.size(); i++)
    {
        actionList = this-&gt;toolBars[i]-&gt;actions();

        key = "toolBar_" + QString::number(i+1) + "_size";
        MainSettings::getInstance().setValue(key, actionList.size());
        key = "toolBar_" + QString::number(i+1) + "_name";
        MainSettings::getInstance().setValue(key, this-&gt;toolBars[i]-&gt;objectName());
        key = "toolBar_" + QString::number(i+1) + "_title";
        MainSettings::getInstance().setValue(key, this-&gt;toolBars[i]-&gt;windowTitle());

        for (int j=0;j&lt;actionList.size();j++)
        {
            action = actionList[j];
            key = "toolBar_" + QString::number(i+1) + "_action_" + QString::number(j+1);
            MainSettings::getInstance().setValue(key,action-&gt;objectName());
        }
    }
    // Session
    QString sessionFileName = Session::getInstance().getFileName();
    if (sessionFileName.isEmpty())
    {
        sessionFileName = Session::getInstance().getDefaultFileName();
    }
    MainSettings::getInstance().setValue("session/fileName", sessionFileName.toUtf8().constData());
    // Application settings
    MainSettings::getInstance().setValue("application/SolverPath", MainSettings::getInstance().getApplicationSettings()-&gt;getSolverPath());
    MainSettings::getInstance().setValue("application/HelpDir", MainSettings::getInstance().getApplicationSettings()-&gt;getHelpDir());
    MainSettings::getInstance().setValue("application/nThreads", MainSettings::getInstance().getApplicationSettings()-&gt;getNThreads());
    MainSettings::getInstance().setValue("application/nHistoryRecords", MainSettings::getInstance().getApplicationSettings()-&gt;getNHistoryRecords());
    MainSettings::getInstance().setValue("application/style", MainSettings::getInstance().getApplicationSettings()-&gt;getStyle());
    MainSettings::getInstance().setValue("application/toolbarIconSize", MainSettings::getInstance().getApplicationSettings()-&gt;getToolbarIconSize());
    MainSettings::getInstance().setValue("application/sendUsageInfo", MainSettings::getInstance().getApplicationSettings()-&gt;getSendUsageInfo());
    MainSettings::getInstance().setValue("application/rangeApiAllowed", MainSettings::getInstance().getApplicationSettings()-&gt;getRangeApiAllowed());
    MainSettings::getInstance().setValue("application/rangeApiServer", MainSettings::getInstance().getApplicationSettings()-&gt;getRangeApiServer());
    MainSettings::getInstance().setValue("application/rangeAccount", MainSettings::getInstance().getApplicationSettings()-&gt;getRangeAccount());
    MainSettings::getInstance().setValue("application/rangePassword", MainSettings::getInstance().getApplicationSettings()-&gt;getRangePassword());

    for (int i=ACTION_NONE;i&lt;ACTION_N_TYPES;i++)
    {
        if (!ACTION_TYPE_IS_ACTION(ActionType(i)))
        {
            continue;
        }
        QString key = "application/shortcut_" + this-&gt;actionList-&gt;getAction(ActionType(i))-&gt;text();
        MainSettings::getInstance().setValue(key, this-&gt;actionList-&gt;getAction(ActionType(i))-&gt;shortcut().toString());
    }

    MainSettings::getInstance().setValue("application/version",RVendor::version.toString());

    MainSettings::getInstance().sync();
}

uint MainWindow::getNToolBars(void) const
{
    return uint(this-&gt;toolBars.size());
}

QList&lt;uint&gt; MainWindow::getSelectedModelIDs(void) const
{
    return this-&gt;treeModelManager-&gt;getSelectedModelIDs();
}

</t>
<t tx="leo.20201108101524.31">void MainWindow::closeEvent(QCloseEvent *event)
{
    QuitDialog quitDialog(this);

    if (quitDialog.exec() == QDialog::Accepted) {
        this-&gt;writeSettings();
        // Accept event -&gt; close window.
        event-&gt;accept();
    }
    else {
        // Ignore event -&gt; leave window open.
        event-&gt;ignore();
    }
}

QDockWidget *MainWindow::findFirstDockWidget(Qt::DockWidgetArea area)
{
    QList&lt;QDockWidget *&gt; dockWidgets = this-&gt;findChildren&lt;QDockWidget *&gt;();

    for (int i=0;i&lt;dockWidgets.size();i++)
    {
        if (this-&gt;dockWidgetArea(dockWidgets[i]) == area)
        {
            return dockWidgets[i];
        }
    }
    return nullptr;
}

</t>
<t tx="leo.20201108101524.32">void MainWindow::progressBar(ProgressBar *progressBar, double fraction)
{
    progressBar-&gt;setValue(qRound(fraction*100));
//    progressBar-&gt;show();
}

</t>
<t tx="leo.20201108101524.33">void MainWindow::progressBarInitialize(ProgressBar *progressBar, const QString &amp;message, bool pulseType)
{
    if (pulseType)
    {
        progressBar-&gt;startPulse();
    }
    else
    {
        progressBar-&gt;setRange(0,100);
    }
    progressBar-&gt;setMessage(message);
    progressBar-&gt;setValue(0);
    progressBar-&gt;show();
    this-&gt;statusBar()-&gt;clearMask();
}

</t>
<t tx="leo.20201108101524.34">void MainWindow::progressBarFinalize(ProgressBar *progressBar, const QString &amp;message)
{
    progressBar-&gt;stopPulse();
    progressBar-&gt;setRange(0,100);
    progressBar-&gt;setValue(100);
    progressBar-&gt;setMessage("");
    progressBar-&gt;hide();
    this-&gt;statusBar()-&gt;showMessage(message,5000);
}

</t>
<t tx="leo.20201108101524.35">void MainWindow::setEnabled(bool enabled)
{
    this-&gt;dockModel-&gt;setEnabled(enabled);
    this-&gt;dockProblem-&gt;setEnabled(enabled);
    this-&gt;dockBc-&gt;setEnabled(enabled);
    this-&gt;dockIc-&gt;setEnabled(enabled);
    this-&gt;dockEc-&gt;setEnabled(enabled);
    this-&gt;dockMaterial-&gt;setEnabled(enabled);
    this-&gt;dockResults-&gt;setEnabled(enabled);
    this-&gt;dockDocuments-&gt;setEnabled(enabled);
//    this-&gt;dockRecords-&gt;setEnabled(enabled);
    if (enabled)
    {
        this-&gt;actionList-&gt;enable();
    }
    else
    {
        this-&gt;actionList-&gt;disable();
    }
}

</t>
<t tx="leo.20201108101524.36">void MainWindow::enable(void)
{
    this-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101524.37">void MainWindow::disable(void)
{
    this-&gt;setEnabled(false);
}

</t>
<t tx="leo.20201108101524.38">void MainWindow::onMainProgress(double fraction)
{
    this-&gt;progressBar(this-&gt;mainProgressBar,fraction);
}

</t>
<t tx="leo.20201108101524.39">void MainWindow::onMainProgressInitialize(const QString &amp;message, bool pulseType)
{
    this-&gt;progressBarInitialize(this-&gt;mainProgressBar,message,pulseType);
}

</t>
<t tx="leo.20201108101524.4">const ApplicationSettings *MainSettings::getApplicationSettings(void) const
{
    return this-&gt;applicationSettings;
}

ApplicationSettings *MainSettings::getApplicationSettings(void)
{
    return this-&gt;applicationSettings;
}

</t>
<t tx="leo.20201108101524.40">void MainWindow::onMainProgressFinalize(const QString &amp;message)
{
    this-&gt;progressBarFinalize(this-&gt;mainProgressBar,message);
}

</t>
<t tx="leo.20201108101524.41">void MainWindow::onDownloadProgress(uint downloadID, qint64 bytesReceived, qint64 bytesTotal, double speed)
{
    double fraction = bytesTotal == 0 ?  0.0 : double(bytesReceived) / double(bytesTotal);

    QString unit;
    double displaySpeed = speed;
    if (displaySpeed &lt; 1024)
    {
        unit = "bytes/sec";
    }
    else if (displaySpeed &lt; 1024*1024)
    {
        displaySpeed /= 1024;
        unit = "kB/s";
    }
    else
    {
        displaySpeed /= 1024*1024;
        unit = "MB/s";
    }
    this-&gt;downloadProgressBar-&gt;setMessage(tr("Downloading file")
                                          + " # "
                                          + QString::number(downloadID)
                                          + " "
                                          + QString::number(bytesReceived)
                                          + " / "
                                          + QString::number(bytesTotal)
                                          + " Bytes ("
                                          + QString::number(displaySpeed,'g',2)
                                          + " "
                                          + unit
                                          + ")");
    this-&gt;progressBar(this-&gt;downloadProgressBar,fraction);
}

</t>
<t tx="leo.20201108101524.42">void MainWindow::onDownloadProgressInitialize(uint)
{
    this-&gt;progressBarInitialize(this-&gt;downloadProgressBar,tr("Downloading"),false);
}

</t>
<t tx="leo.20201108101524.43">void MainWindow::onDownloadProgressFinalize(uint)
{
    this-&gt;progressBarFinalize(this-&gt;downloadProgressBar,tr("Download complete"));
}

</t>
<t tx="leo.20201108101524.44">void MainWindow::onDrawObjectAdded(void)
{
    this-&gt;showDrawWidget();
}

</t>
<t tx="leo.20201108101524.45">void MainWindow::onDrawObjectRemoved(void)
{
    if (Session::getInstance().getDrawEngine()-&gt;getNObjects() == 0)
    {
        this-&gt;hideDrawWidget();
    }
}

</t>
<t tx="leo.20201108101524.46">void MainWindow::onJobBlocking(bool blocking)
{
    if (blocking)
    {
        this-&gt;disable();
    }
    else
    {
        this-&gt;enable();
    }
}

</t>
<t tx="leo.20201108101524.47">void MainWindow::onJobStarted(void)
{
}

</t>
<t tx="leo.20201108101524.48">void MainWindow::onJobEnded(void)
{
}

</t>
<t tx="leo.20201108101524.49">void MainWindow::onModelAdded(uint position)
{
    this-&gt;modelSubWindows-&gt;onModelAdded(position);
    this-&gt;treeModelManager-&gt;onModelAdded(position);
    if (!Session::getInstance().isModelSelected(position))
    {
        Session::getInstance().setModelSelected(position,true);
    }
    if (Session::getInstance().getModel(position).getProblemTaskTree().getProblemTypeMask() == R_PROBLEM_NONE)
    {
        ProblemTaskDialog problemTaskDialog(position,this);
        problemTaskDialog.exec();
    }
}

</t>
<t tx="leo.20201108101524.5">const RVersion &amp;MainSettings::getStoredVersion(void) const
{
    return this-&gt;storedVersion;
}

QList&lt;QString&gt; MainSettings::getSupportedImageFormats(void)
{
    QList&lt;QString&gt; formats;

    QList&lt;QByteArray&gt; supportedFormats = QImageWriter::supportedImageFormats();
    foreach (QString format, supportedFormats)
    {
        formats.append(format.toLower());
    }

    return formats;
}

QList&lt;QString&gt; MainSettings::getSupportedVideoFormats(void)
{
    QList&lt;QString&gt; formats;

    formats.append("avi");
    formats.append("mpeg");
    formats.append("ogg");

    return formats;
}

QString MainSettings::getDefaultVideoFormat(void)
{
    return QString("avi");
}

QList&lt;QString&gt; MainSettings::getSupportedDocumentFormats(void)
{
    QList&lt;QString&gt; formats;

    formats.append("txt");
    formats.append("log");
    formats.append("pdf");
    formats.append("odf");
    formats.append("html");

    return formats;
}

QString MainSettings::getDir(QString topDir, QString subDir)
{
    QDir dir(topDir);

    if (!dir.exists(subDir))
    {
        QString fullPath(dir.filePath(subDir));
        RLogger::info("Creating directory \'%s\'\n",fullPath.toUtf8().constData());
        if (!dir.mkpath(fullPath))
        {
            RLogger::error("Failed to create a directory \'%s\'\n",fullPath.toUtf8().constData());
        }
    }
    if (!dir.cd(subDir))
    {
        RLogger::error("Failed to change to a sub-directory \'%s\' in \'%s\'\n",
                  subDir.toUtf8().constData(),
                  dir.path().toUtf8().constData());
    }

    return dir.path();
}
</t>
<t tx="leo.20201108101524.50">void MainWindow::onModelRemoved(uint position)
{
    this-&gt;modelSubWindows-&gt;onModelRemoved(position);
    this-&gt;treeModelManager-&gt;onModelRemoved(position);
    this-&gt;actionList-&gt;processAvailability();
}

</t>
<t tx="leo.20201108101524.51">void MainWindow::onModelChanged(uint position)
{
    this-&gt;modelSubWindows-&gt;onModelChanged(position);
    this-&gt;treeModelManager-&gt;onModelChanged(position);
    this-&gt;actionList-&gt;processAvailability();
}

</t>
<t tx="leo.20201108101524.52">void MainWindow::onProblemChanged(uint)
{
    this-&gt;actionList-&gt;processAvailability();
}

</t>
<t tx="leo.20201108101524.53">void MainWindow::onResultsChanged(uint)
{
    this-&gt;actionList-&gt;processAvailability();
}

</t>
<t tx="leo.20201108101524.54">void MainWindow::onEntityVisibilityChanged(uint modelID, REntityGroupType, uint, bool visible)
{
    bool modelIsVisible = false;
    if (visible)
    {
        modelIsVisible = true;
    }
    else
    {
        if (!Session::getInstance().getModel(modelID).isVisible(false))
        {
            modelIsVisible = true;
        }
    }
    if (modelIsVisible)
    {
        if (!this-&gt;modelSubWindows-&gt;windowExists(modelID))
        {
            this-&gt;modelSubWindows-&gt;windowCreate(modelID);
        }
    }
}

</t>
<t tx="leo.20201108101524.55">void MainWindow::onGeometryTransformFinalize(void)
{
    this-&gt;hideTransformGeometryWidget();
}

</t>
<t tx="leo.20201108101524.56">void MainWindow::onNHistoryRecordsChanged(uint)
{
    this-&gt;actionList-&gt;processAvailability();
}

</t>
<t tx="leo.20201108101524.57">void MainWindow::onToolbarIconSizeChanged(int toolbarIconSize)
{
    this-&gt;setIconSize(QSize(toolbarIconSize,toolbarIconSize));
}
</t>
<t tx="leo.20201108101524.58">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   mark_entity_dialog.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th November 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Mark entity dialog class definition                 *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;
#include &lt;QMessageBox&gt;

#include "session.h"
#include "mark_entity_dialog.h"
#include "model_action.h"
#include "job_manager.h"

double MarkEntityDialog::separationAngle = 45.0;

MarkEntityDialog::MarkEntityDialog(REntityGroupType entityType, QWidget *parent)
    : QDialog(parent)
    , entityType(entityType)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QString windowTitleStr = tr("Mark entity") + " (" + RElementGroup::getTypeName(entityType) + ")";
    this-&gt;setWindowTitle(tr(windowTitleStr.toUtf8().constData()));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    this-&gt;autoMarkRadio = new QRadioButton("Auto-mark all entities");
    mainLayout-&gt;addWidget(this-&gt;autoMarkRadio,0,0,1,2);

    QString markPickMessage = tr("To mark elements at least one element must be picked.")
                              + " " + tr("Use") + " &lt;strong&gt;"
                              + GLActionEvent::findKeyMouseCombination(GL_ACTION_EVENT_PICK_ELEMENT)
                              + "&lt;/strong&gt; " + tr("to pick element") + ".";
    this-&gt;pickedMarkRadio = new QRadioButton("Mark only selected and related elements");
    this-&gt;pickedMarkRadio-&gt;setToolTip(markPickMessage);
    mainLayout-&gt;addWidget(this-&gt;pickedMarkRadio,1,0,1,2);

    if (Session::getInstance().getPickList().isEmpty())
    {
        this-&gt;autoMarkRadio-&gt;setChecked(true);
        this-&gt;pickedMarkRadio-&gt;setDisabled(true);
    }
    else
    {
        this-&gt;pickedMarkRadio-&gt;setChecked(true);
    }

    QLabel *separationAngleLabel = new QLabel(tr("Separation angle:"));
    mainLayout-&gt;addWidget(separationAngleLabel, 2, 0, 1, 1);

    this-&gt;separationAngleSpin = new QSpinBox;
    this-&gt;separationAngleSpin-&gt;setRange(0,360);
    this-&gt;separationAngleSpin-&gt;setValue(MarkEntityDialog::separationAngle);
    mainLayout-&gt;addWidget(this-&gt;separationAngleSpin, 2, 1, 1, 2);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, 3, 0, 1, 2);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;MarkEntityDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;MarkEntityDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.59">int MarkEntityDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        this-&gt;separationAngle = double(this-&gt;separationAngleSpin-&gt;value());
        bool markSuccess = false;
        if (this-&gt;autoMarkRadio-&gt;isChecked() || Session::getInstance().getPickList().isEmpty())
        {
            // Automark all selected models.
            QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
            for (int i=0;i&lt;modelIDs.size();i++)
            {
                RLogger::info("Auto-marking model \'%s\'\n",Session::getInstance().getModel(modelIDs[i]).getName().toUtf8().constData());
                if (this-&gt;autoMarkEntities(modelIDs[i]))
                {
                    markSuccess = true;
                }
            }
        }
        else
        {
            // Mark each model at a time.
            QList&lt;uint&gt; modelIDs = Session::getInstance().getPickList().getModelIDs();
            for (int i=0;i&lt;modelIDs.size();i++)
            {
                RLogger::info("Marking model \'%s\'\n",Session::getInstance().getModel(modelIDs[i]).getName().toUtf8().constData());
                if (this-&gt;markEntities(modelIDs[i],Session::getInstance().getPickList().getItems(modelIDs[i])))
                {
                    markSuccess = true;
                }
            }
        }
        if (markSuccess)
        {
            Session::getInstance().getPickList().clear();
        }
    }

    return retVal;
}

</t>
<t tx="leo.20201108101524.6">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   main_window.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Main window class definition                        *
 *********************************************************************/

#include &lt;QtGui/QCloseEvent&gt;
#include &lt;QApplication&gt;
#include &lt;QMenuBar&gt;
#include &lt;QMenu&gt;
#include &lt;QGridLayout&gt;
#include &lt;QStatusBar&gt;
#include &lt;QSplitter&gt;
#include &lt;QScrollBar&gt;
#include &lt;QMessageBox&gt;

#include "logger.h"
#include "progress.h"
#include "bc_manager_tree.h"
#include "bc_tree.h"
#include "document_tree.h"
#include "draw_input_widget.h"
#include "first_run_dialog.h"
#include "ic_manager_tree.h"
#include "ic_tree.h"
#include "ec_manager_tree.h"
#include "ec_tree.h"
#include "material_manager_tree.h"
#include "material_tree.h"
#include "model_entity_display_properties_tree.h"
#include "model_entity_geometric_properties_tree.h"
#include "model_records_selector.h"
#include "problem_tree.h"
#include "problem_task_dialog.h"
#include "solver_manager.h"
#include "results_variable_selector.h"
#include "results_variable_tree.h"
#include "job_manager.h"
#include "main_window.h"
#include "quit_dialog.h"
#include "session.h"
#include "geometry_transform_widget.h"

MainWindow::MainWindow (QWidget *parent)
    : QMainWindow(parent)
    , isFirstRun(true)
{
    if (this-&gt;objectName().isEmpty())
    {
        this-&gt;setObjectName(QString::fromUtf8("MainWindow"));
    }

    this-&gt;actionList = new ActionList (this);

    this-&gt;readSettings();

    this-&gt;setWindowTitle(QApplication::translate("MainWindow", "Range :: Finite Element Analysis"));
    this-&gt;setWindowIcon(QIcon(":/icons/logos/pixmaps/range-logo-128.png"));

    this-&gt;setDockNestingEnabled(true);

    int toolbarIconSize = MainSettings::getInstance().getApplicationSettings()-&gt;getToolbarIconSize();
    this-&gt;setIconSize(QSize(toolbarIconSize,toolbarIconSize));
    this-&gt;setToolButtonStyle(Qt::ToolButtonIconOnly);

    this-&gt;createMenus();
    this-&gt;createToolBars();
    this-&gt;createStatusBar();
    this-&gt;createDownloadBar();
    this-&gt;createCentralWidget();
    this-&gt;createModelDock();
    this-&gt;createDocumentDock();
    this-&gt;createRecordsDock();
    this-&gt;createProblemDock();
    this-&gt;createBcDock();
    this-&gt;createIcDock();
    this-&gt;createEcDock();
    this-&gt;createMaterialDock();
    this-&gt;createResultsDock();

    this-&gt;setTabPosition(Qt::LeftDockWidgetArea,QTabWidget::West);
    this-&gt;setTabPosition(Qt::RightDockWidgetArea,QTabWidget::East);

    this-&gt;tabifyDockWidget(this-&gt;dockModel,this-&gt;dockRecords);
    this-&gt;tabifyDockWidget(this-&gt;dockRecords,this-&gt;dockDocuments);
    this-&gt;dockModel-&gt;raise();

    this-&gt;tabifyDockWidget(this-&gt;dockProblem,this-&gt;dockBc);
    this-&gt;tabifyDockWidget(this-&gt;dockBc,this-&gt;dockIc);
    this-&gt;tabifyDockWidget(this-&gt;dockIc,this-&gt;dockEc);
    this-&gt;tabifyDockWidget(this-&gt;dockEc,this-&gt;dockMaterial);
    this-&gt;tabifyDockWidget(this-&gt;dockMaterial,this-&gt;dockResults);
    this-&gt;dockProblem-&gt;raise();

    this-&gt;restoreGeometry(MainSettings::getInstance().value("mainWindow/geometry").toByteArray());
    this-&gt;restoreState(MainSettings::getInstance().value("mainWindow/windowState").toByteArray());

    // Actions signals
    QObject::connect(MainSettings::getInstance().getApplicationSettings(),&amp;ApplicationSettings::shortcutChanged,this-&gt;actionList,&amp;ActionList::changeShortcut);

    // Tooplbar icon size changed signal
    QObject::connect(MainSettings::getInstance().getApplicationSettings(),&amp;ApplicationSettings::toolbarIconSizeChanged,this,&amp;MainWindow::onToolbarIconSizeChanged);

    // Main progress signals
    QObject::connect(&amp;Progress::getInstance(),&amp;Progress::progress,this,&amp;MainWindow::onMainProgress);
    QObject::connect(&amp;Progress::getInstance(),&amp;Progress::progressInitialize,this,&amp;MainWindow::onMainProgressInitialize);
    QObject::connect(&amp;Progress::getInstance(),&amp;Progress::progressFinalize,this,&amp;MainWindow::onMainProgressFinalize);

    // Download progress signals
    QObject::connect(Session::getInstance().getDownloadManager(),&amp;DownloadManager::progress,this,&amp;MainWindow::onDownloadProgress);
    QObject::connect(Session::getInstance().getDownloadManager(),&amp;DownloadManager::started,this,&amp;MainWindow::onDownloadProgressInitialize);
    QObject::connect(Session::getInstance().getDownloadManager(),&amp;DownloadManager::finished,this,&amp;MainWindow::onDownloadProgressFinalize);

    // Solver manager signals.
    QObject::connect(&amp;SolverManager::getInstance(),&amp;SolverManager::jobBlocking,this,&amp;MainWindow::onJobBlocking);

    // Draw engine signals.
    QObject::connect(Session::getInstance().getDrawEngine(),&amp;DrawEngine::objectAdded,this,&amp;MainWindow::onDrawObjectAdded);
    QObject::connect(Session::getInstance().getDrawEngine(),&amp;DrawEngine::objectRemoved,this,&amp;MainWindow::onDrawObjectRemoved);
    QObject::connect(Session::getInstance().getDrawEngine(),&amp;DrawEngine::objectsRemoved,this,&amp;MainWindow::onDrawObjectRemoved);

    // Job manager signals
    QObject::connect(&amp;JobManager::getInstance(),&amp;JobManager::jobBlocking,this,&amp;MainWindow::onJobBlocking);
    QObject::connect(&amp;JobManager::getInstance(),&amp;JobManager::jobStarted,this,&amp;MainWindow::onJobStarted);
    QObject::connect(&amp;JobManager::getInstance(),&amp;JobManager::jobFinished,this,&amp;MainWindow::onJobEnded);

    // Connect model modification signals
    QObject::connect(&amp;Session::getInstance(),&amp;Session::modelAdded,this,&amp;MainWindow::onModelAdded);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::modelRemoved,this,&amp;MainWindow::onModelRemoved);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::modelChanged,this,&amp;MainWindow::onModelChanged);

    // Connect problem modification signals
    QObject::connect(&amp;Session::getInstance(),&amp;Session::problemChanged,this,&amp;MainWindow::onProblemChanged);

    // Connect results modification signals
    QObject::connect(&amp;Session::getInstance(),&amp;Session::resultsChanged,this,&amp;MainWindow::onResultsChanged);

    // Model selection signals
    QObject::connect(&amp;Session::getInstance(),&amp;Session::entityVisibilityChanged,this,&amp;MainWindow::onEntityVisibilityChanged);

    // Number of history records has changed.
    QObject::connect(&amp;Session::getInstance(),&amp;Session::nHistoryRecordsChanged,this,&amp;MainWindow::onNHistoryRecordsChanged);

    if (this-&gt;isFirstRun)
    {
        FirstRunDialog(this).exec();
    }
}

MainWindow *MainWindow::getInstance(void)
{
    static MainWindow *mainWindow = new MainWindow;
    return mainWindow;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.60">bool MarkEntityDialog::autoMarkEntities(uint modelID)
{
    ModelActionInput modelActionInput(modelID);

    switch (this-&gt;entityType)
    {
        case R_ENTITY_GROUP_POINT:
            break;
        case R_ENTITY_GROUP_LINE:
            break;
        case R_ENTITY_GROUP_SURFACE:
            modelActionInput.setAutoMarkSurfaces(this-&gt;separationAngle);
            break;
        case R_ENTITY_GROUP_VOLUME:
            break;
        default:
            RLogger::error("Unknown element group \'%d\'",int(this-&gt;entityType));
            return false;
    }

    ModelAction *modelAction = new ModelAction;
    modelAction-&gt;setAutoDelete(true);
    modelAction-&gt;addAction(modelActionInput);
    JobManager::getInstance().submit(modelAction);

    return true;
}

</t>
<t tx="leo.20201108101524.61">bool MarkEntityDialog::markEntities(uint modelID, const QVector&lt;PickItem&gt; &amp;pickList)
{
    QList&lt;uint&gt; elementIDs;
    for (int j=0;j&lt;pickList.size();j++)
    {
        const SessionEntityID &amp;pickEntityID = pickList[j].getEntityID();
        if (pickEntityID.getMid() == modelID &amp;&amp; pickEntityID.getType() == this-&gt;entityType)
        {
            uint elementID = pickList[j].getElementID();
            if (elementID &lt; Session::getInstance().getModel(modelID).getNElements() &amp;&amp;
                R_ELEMENT_TYPE_IS_SURFACE(Session::getInstance().getModel(modelID).getElement(elementID).getType()))
            {
                elementIDs.append(elementID);
            }
        }
    }

    if (elementIDs.size() == 0)
    {
        QMessageBox::warning(this,tr("No elements were picked."),tr("To mark elements at least one element must be picked.")
                                                                 + " " + tr("Use") + " "
                                                                 + GLActionEvent::findKeyMouseCombination(GL_ACTION_EVENT_PICK_ELEMENT)
                                                                 + " " + tr("to pick element") + ".");
        return false;
    }

    ModelActionInput modelActionInput(modelID);

    switch (this-&gt;entityType)
    {
        case R_ENTITY_GROUP_POINT:
            break;
        case R_ENTITY_GROUP_LINE:
            break;
        case R_ENTITY_GROUP_SURFACE:
            modelActionInput.setMarkSurfaces(this-&gt;separationAngle,elementIDs);
            break;
        case R_ENTITY_GROUP_VOLUME:
            break;
        default:
            RLogger::error("Unknown element group \'%d\'",int(this-&gt;entityType));
            return false;
    }

    ModelAction *modelAction = new ModelAction;
    modelAction-&gt;setAutoDelete(true);
    modelAction-&gt;addAction(modelActionInput);
    JobManager::getInstance().submit(modelAction);

    return true;
}
</t>
<t tx="leo.20201108101524.62">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   material_list.cpp                                        *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Material list (database) definition                 *
 *********************************************************************/

#include "material_list.h"

MaterialList::MaterialList()
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.63">void MaterialList::initialize(void)
{
}

MaterialList &amp;MaterialList::getInstance(void)
{
    static MaterialList materialList;
    return materialList;
}

</t>
<t tx="leo.20201108101524.64">void MaterialList::addMaterial(RMaterial &amp;material, bool isNew)
{
    unsigned int nMaterials = this-&gt;size();
    RMaterialList::add(material);
    if (nMaterials != this-&gt;size())
    {
        emit this-&gt;materialAdded(material.getName(), isNew);
    }
    else
    {
        emit this-&gt;materialChanged(material.getName());
    }
}

</t>
<t tx="leo.20201108101524.65">void MaterialList::add(RMaterial &amp;material)
{
    this-&gt;addMaterial(material,false);
}

</t>
<t tx="leo.20201108101524.66">unsigned int MaterialList::remove(const QString &amp;materialName, unsigned int *id)
{
    uint removedID = 0;
    unsigned int nRemoved = RMaterialList::remove(materialName,&amp;removedID);
    if (nRemoved &gt; 0)
    {
        emit this-&gt;materialRemoved(materialName,removedID);
    }
    if (id)
    {
        (*id) = removedID;
    }
    return nRemoved;
}

</t>
<t tx="leo.20201108101524.67">bool MaterialList::rename(const QString &amp;materialOldName, const QString &amp;materialNewName, bool override)
{
    if (materialNewName.isEmpty())
    {
        return false;
    }
    if (RMaterialList::rename(materialOldName, materialNewName, override))
    {
        emit this-&gt;materialRenamed(materialOldName, materialNewName);
        return true;
    }
    return false;
}

RMaterial MaterialList::get(const QString &amp;materialName)
{
    unsigned int nMaterials = this-&gt;size();
    RMaterial material = RMaterialList::get(materialName);
    if (nMaterials != this-&gt;size())
    {
        emit this-&gt;materialAdded(materialName,false);
    }
    return material;
}

</t>
<t tx="leo.20201108101524.68">void MaterialList::selectMaterial(const QString &amp;materialName)
{
    this-&gt;selectedMaterialName = materialName;
    emit this-&gt;materialSelected(materialName);
}

</t>
<t tx="leo.20201108101524.69">const QString &amp;MaterialList::getSelectedMaterialName(void) const
{
    return this-&gt;selectedMaterialName;
}

</t>
<t tx="leo.20201108101524.7">void MainWindow::showTransformGeometryWidget(void)
{
    QString dockName = QString::fromUtf8("dockTransform");
    GeometryTransformWidget *transformGeometryWidget = nullptr;

    if (!findCustomDockWidget(dockName))
    {
        transformGeometryWidget = new GeometryTransformWidget;

        QObject::connect(transformGeometryWidget,
                         &amp;GeometryTransformWidget::finalize,
                         this,
                         &amp;MainWindow::onGeometryTransformFinalize);
    }
    this-&gt;showCustomDockWidget(transformGeometryWidget,dockName,tr("Transform geometry"));
}

</t>
<t tx="leo.20201108101524.70">void MaterialList::signalMaterialChanged(const QString &amp;materialName)
{
    emit this-&gt;materialChanged(materialName);
}

</t>
<t tx="leo.20201108101524.71">void MaterialList::readStore(void)
{
    this-&gt;RMaterialList::readStore();

    std::map&lt;QString,QString&gt;::const_iterator iter;

    for (iter=this-&gt;materials.begin();iter!=this-&gt;materials.end();++iter)
    {
        emit this-&gt;materialAdded(iter-&gt;first,false);
    }
}
</t>
<t tx="leo.20201108101524.72">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   material_manager_tree.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Material manager tree class definition              *
 *********************************************************************/

#include &lt;QMessageBox&gt;

#include "action_list.h"
#include "material_manager_tree.h"
#include "material_list.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.73">typedef enum _MaterialTreeColumn
{
    MATERIAL_TREE_COLUMN_NAME = 0,
    MATERIAL_TREE_COLUMN_FILE,
    MATERIAL_TREE_N_COLUMNS
} MaterialTreeColumn;

MaterialManagerTree::MaterialManagerTree(ActionList *actionList,
                                         QWidget *parent) :
    QTreeWidget(parent),
    actionList(actionList),
    problemTypeMask(R_PROBLEM_NONE),
    doNotPopulate(false)
{
    this-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;setSortingEnabled(true);
    this-&gt;sortByColumn(MATERIAL_TREE_COLUMN_NAME,Qt::AscendingOrder);

    this-&gt;setColumnCount(MATERIAL_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(MATERIAL_TREE_COLUMN_NAME,QString("Name"));
    headerItem-&gt;setText(MATERIAL_TREE_COLUMN_FILE,QString("File"));
    this-&gt;setHeaderItem(headerItem);
    this-&gt;setRootIsDecorated(false);
    this-&gt;resizeColumnToContents(MATERIAL_TREE_COLUMN_NAME);
    this-&gt;resizeColumnToContents(MATERIAL_TREE_COLUMN_FILE);

    this-&gt;populate();

    this-&gt;setContextMenuPolicy(Qt::ActionsContextMenu);

    this-&gt;addAction(actionList-&gt;getAction(ACTION_MATERIAL_NEW));
    this-&gt;addAction(actionList-&gt;getAction(ACTION_MATERIAL_IMPORT));
    this-&gt;addAction(actionList-&gt;getAction(ACTION_MATERIAL_DELETE));

    QObject::connect(&amp;MaterialList::getInstance(),
                     &amp;MaterialList::materialAdded,
                     this,
                     &amp;MaterialManagerTree::onMaterialAdded);
    QObject::connect(&amp;MaterialList::getInstance(),
                     &amp;MaterialList::materialRemoved,
                     this,
                     &amp;MaterialManagerTree::onMaterialRemoved);
    QObject::connect(&amp;MaterialList::getInstance(),
                     &amp;MaterialList::materialRenamed,
                     this,
                     &amp;MaterialManagerTree::onMaterialRenamed);
    QObject::connect(&amp;MaterialList::getInstance(),
                     &amp;MaterialList::materialChanged,
                     this,
                     &amp;MaterialManagerTree::onMaterialChanged);

    QObject::connect(this,
                     &amp;MaterialManagerTree::itemChanged,
                     this,
                     &amp;MaterialManagerTree::onItemChanged);
    QObject::connect(this,
                     &amp;MaterialManagerTree::itemDoubleClicked,
                     this,
                     &amp;MaterialManagerTree::onItemDoubleClicked);
    QObject::connect(this,
                     &amp;MaterialManagerTree::itemSelectionChanged,
                     this,
                     &amp;MaterialManagerTree::onItemSelectionChanged);

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelSelectionChanged,
                     this,
                     &amp;MaterialManagerTree::onModelSelectionChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelAdded,
                     this,
                     &amp;MaterialManagerTree::onModelAdded,
                     Qt::BlockingQueuedConnection);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::problemSelectionChanged,
                     this,
                     &amp;MaterialManagerTree::onProblemChanged);
    QObject::connect(this,&amp;MaterialManagerTree::materialSelected,
                     this,&amp;MaterialManagerTree::onMaterialSelected);
}

</t>
<t tx="leo.20201108101524.74">void MaterialManagerTree::populate(void)
{
    if (this-&gt;doNotPopulate)
    {
        return;
    }

    RProblemTypeMask modelPrbTypeMask = R_PROBLEM_NONE;
    REntityGroupTypeMask elementGroupTypeMask = R_ENTITY_GROUP_NONE;
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;selectedEntityIDs.size();i++)
    {
        elementGroupTypeMask |= selectedEntityIDs[i].getType();
        modelPrbTypeMask |= Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getProblemTaskTree().getProblemTypeMask();
    }

    std::vector&lt;RMaterialPropertyType&gt; propertyTypes = RMaterialProperty::getTypes(modelPrbTypeMask);
    std::vector&lt;QString&gt; materialNames = MaterialList::getInstance().getMaterialNames(propertyTypes);

    for (uint i=0;i&lt;materialNames.size();i++)
    {
        bool applies = false;
        if (elementGroupTypeMask &amp; R_ENTITY_GROUP_POINT ||
            elementGroupTypeMask &amp; R_ENTITY_GROUP_LINE ||
            elementGroupTypeMask &amp; R_ENTITY_GROUP_SURFACE ||
            elementGroupTypeMask &amp; R_ENTITY_GROUP_VOLUME)
        {
            applies = true;
        }
        if (!applies)
        {
            continue;
        }
        this-&gt;addMaterial(materialNames[i],false);
    }

    this-&gt;updateCheckStates();
    this-&gt;actionList-&gt;processAvailability();
}

</t>
<t tx="leo.20201108101524.75">void MaterialManagerTree::updateCheckStates(void)
{
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();
    QMap&lt;QString,bool&gt; selectedMaterialNames;

    for (int i=0;i&lt;selectedEntityIDs.size();i++)
    {
        QString materialName;
        switch (selectedEntityIDs[i].getType())
        {
            case R_ENTITY_GROUP_POINT:
                materialName = Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getPoint(selectedEntityIDs[i].getEid()).getMaterial().getName();
                break;
            case R_ENTITY_GROUP_LINE:
                materialName = Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getLine(selectedEntityIDs[i].getEid()).getMaterial().getName();
                break;
            case R_ENTITY_GROUP_SURFACE:
                materialName = Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getSurface(selectedEntityIDs[i].getEid()).getMaterial().getName();
                break;
            case R_ENTITY_GROUP_VOLUME:
                materialName = Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getVolume(selectedEntityIDs[i].getEid()).getMaterial().getName();
                break;
            default:
                break;
        }
        selectedMaterialNames[materialName] = true;
    }

    Qt::CheckState state;
    switch (selectedMaterialNames.size())
    {
        case 0:
            state = Qt::Unchecked;
            break;
        case 1:
            state = Qt::Checked;
            break;
        default:
            state = Qt::PartiallyChecked;
            break;
    }

    this-&gt;blockSignals(true);

    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        if (selectedMaterialNames.find(this-&gt;topLevelItem(i)-&gt;text(MATERIAL_TREE_COLUMN_NAME)) == selectedMaterialNames.end())
        {
            this-&gt;topLevelItem(i)-&gt;setData(MATERIAL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(Qt::Unchecked));
        }
        else
        {
            this-&gt;topLevelItem(i)-&gt;setData(MATERIAL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(state));
        }
    }

    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101524.76">void MaterialManagerTree::updateProblemTypeMask(void)
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    this-&gt;problemTypeMask = R_PROBLEM_NONE;
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        this-&gt;problemTypeMask |= Session::getInstance().getModel(selectedModelIDs[i]).getProblemTaskTree().getProblemTypeMask();
    }

    this-&gt;blockSignals(true);
    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        QTreeWidgetItem *item = this-&gt;topLevelItem(i);
        RMaterial material = MaterialList::getInstance().get(item-&gt;text(MATERIAL_TREE_COLUMN_NAME));
        this-&gt;setItemValid(item,material.validForProblemType(this-&gt;problemTypeMask));
    }
    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101524.77">void MaterialManagerTree::setItemValid(QTreeWidgetItem *item, bool valid)
{
    QFont font = item-&gt;font(MATERIAL_TREE_COLUMN_NAME);
    font.setBold(valid);
    font.setItalic(!valid);
    item-&gt;setFont(MATERIAL_TREE_COLUMN_NAME,font);
}

</t>
<t tx="leo.20201108101524.78">void MaterialManagerTree::addMaterial(const QString &amp;materialName, bool setSelected)
{
    this-&gt;blockSignals(true);

    RMaterial material = MaterialList::getInstance().get(materialName);

    QTreeWidgetItem *item = new QTreeWidgetItem(this);
    item-&gt;setText(MATERIAL_TREE_COLUMN_NAME,materialName);
    item-&gt;setData(MATERIAL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(Qt::Unchecked));
    item-&gt;setData(MATERIAL_TREE_COLUMN_NAME,Qt::UserRole,QVariant(material.getID()));
    this-&gt;setItemValid(item,material.validForProblemType(this-&gt;problemTypeMask));
    item-&gt;setText(MATERIAL_TREE_COLUMN_FILE,MaterialList::getInstance().getFileName(materialName));
    QFont font = item-&gt;font(MATERIAL_TREE_COLUMN_FILE);
    font.setItalic(true);
    item-&gt;setFont(MATERIAL_TREE_COLUMN_FILE,font);
    this-&gt;resizeColumnToContents(MATERIAL_TREE_COLUMN_NAME);
    this-&gt;resizeColumnToContents(MATERIAL_TREE_COLUMN_FILE);
    this-&gt;blockSignals(false);

    if (setSelected)
    {
        this-&gt;clearSelection();
        item-&gt;setSelected(true);
    }
}

</t>
<t tx="leo.20201108101524.79">void MaterialManagerTree::onModelSelectionChanged(uint)
{
    this-&gt;updateProblemTypeMask();
    this-&gt;updateCheckStates();
}

</t>
<t tx="leo.20201108101524.8">void MainWindow::hideTransformGeometryWidget(void)
{
    this-&gt;hideCustomDockWidget(QString::fromUtf8("dockTransform"));
}

</t>
<t tx="leo.20201108101524.80">void MaterialManagerTree::onModelAdded(uint modelID)
{
    QMap&lt;QString,RMaterial&gt; unknownMaterials;
    QMap&lt;QString,RMaterial&gt; differentMaterials;

    // Loop over all element groups and check if it contains unknown material.

    for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNPoints();j++)
    {
        RMaterial &amp;material = Session::getInstance().getModel(modelID).getPoint(j).getMaterial();
        if (material.getName().isEmpty())
        {
            continue;
        }
        if (MaterialList::getInstance().containName(material.getName()))
        {
            RMaterial cmpMaterial = MaterialList::getInstance().get(material.getName());
            if (!cmpMaterial.propertiesEqual(material))
            {
                differentMaterials[material.getName()] = material;
            }
        }
        else
        {
            if (unknownMaterials.find(material.getName()) == unknownMaterials.end())
            {
                unknownMaterials[material.getName()] = material;
            }
        }
    }
    for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNLines();j++)
    {
        RMaterial &amp;material = Session::getInstance().getModel(modelID).getLine(j).getMaterial();
        if (material.getName().isEmpty())
        {
            continue;
        }
        if (MaterialList::getInstance().containName(material.getName()))
        {
            RMaterial cmpMaterial = MaterialList::getInstance().get(material.getName());
            if (!cmpMaterial.propertiesEqual(material))
            {
                differentMaterials[material.getName()] = material;
            }
        }
        else
        {
            if (unknownMaterials.find(material.getName()) == unknownMaterials.end())
            {
                unknownMaterials[material.getName()] = material;
            }
        }
    }
    for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNSurfaces();j++)
    {
        RMaterial &amp;material = Session::getInstance().getModel(modelID).getSurface(j).getMaterial();
        if (material.getName().isEmpty())
        {
            continue;
        }
        if (MaterialList::getInstance().containName(material.getName()))
        {
            RMaterial cmpMaterial = MaterialList::getInstance().get(material.getName());
            if (!cmpMaterial.propertiesEqual(material))
            {
                differentMaterials[material.getName()] = material;
            }
        }
        else
        {
            if (unknownMaterials.find(material.getName()) == unknownMaterials.end())
            {
                unknownMaterials[material.getName()] = material;
            }
        }
    }
    for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNVolumes();j++)
    {
        RMaterial &amp;material = Session::getInstance().getModel(modelID).getVolume(j).getMaterial();
        if (material.getName().isEmpty())
        {
            continue;
        }
        if (MaterialList::getInstance().containName(material.getName()))
        {
            RMaterial cmpMaterial = MaterialList::getInstance().get(material.getName());
            if (!cmpMaterial.propertiesEqual(material))
            {
                differentMaterials[material.getName()] = material;
            }
        }
        else
        {
            if (unknownMaterials.find(material.getName()) == unknownMaterials.end())
            {
                unknownMaterials[material.getName()] = material;
            }
        }
    }

    bool addUnknown = false;
    if (unknownMaterials.size() &gt; 0)
    {
        QString materialNames;
        QMap&lt;QString,RMaterial&gt;::const_iterator iter;
        for (iter = unknownMaterials.constBegin(); iter != unknownMaterials.constEnd(); ++iter)
        {
            materialNames += "&lt;li&gt;&lt;b&gt;" + iter.key() + "&lt;/b&gt;&lt;/li&gt;";
        }

        QString question = "Following materials are not present in your database:&lt;ol&gt;"
                         + materialNames
                         + "&lt;/ol&gt;Do you want to add them to the material list?";
        @others
}

</t>
<t tx="leo.20201108101524.81">    int response = QMessageBox::question(this,
                                         "Unknown materials",
                                         question,
                                         QMessageBox::Yes | QMessageBox::No,
                                         QMessageBox::No);
    if (response == QMessageBox::Yes)
    {
        addUnknown = true;
    }
}

if (addUnknown)
{
    QMap&lt;QString,RMaterial&gt;::iterator iter;
    for (iter = unknownMaterials.begin(); iter != unknownMaterials.end(); ++iter)
    {
        MaterialList::getInstance().add(iter.value());
    }
}
else
{
    QMap&lt;QString,RMaterial&gt;::const_iterator iter;
    for (iter = unknownMaterials.constBegin(); iter != unknownMaterials.constEnd(); ++iter)
    {
        // Remove unknown material from the model's element groups.
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNPoints();j++)
        {
            if (Session::getInstance().getModel(modelID).getPoint(j).getMaterial().getName() == iter.key())
            {
                Session::getInstance().getModel(modelID).getPoint(j).setMaterial(RMaterial());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNLines();j++)
        {
            if (Session::getInstance().getModel(modelID).getLine(j).getMaterial().getName() == iter.key())
            {
                Session::getInstance().getModel(modelID).getLine(j).setMaterial(RMaterial());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNSurfaces();j++)
        {
            if (Session::getInstance().getModel(modelID).getSurface(j).getMaterial().getName() == iter.key())
            {
                Session::getInstance().getModel(modelID).getSurface(j).setMaterial(RMaterial());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNVolumes();j++)
        {
            if (Session::getInstance().getModel(modelID).getVolume(j).getMaterial().getName() == iter.key())
            {
                Session::getInstance().getModel(modelID).getVolume(j).setMaterial(RMaterial());
            }
        }
    }
}

bool addDifferent = false;
if (differentMaterials.size() &gt; 0)
{
    QString materialNames;
    QMap&lt;QString,RMaterial&gt;::const_iterator iter;
    for (iter = differentMaterials.constBegin(); iter != differentMaterials.constEnd(); ++iter)
    {
        materialNames += "&lt;li&gt;&lt;b&gt;" + iter.key() + "&lt;/b&gt;&lt;/li&gt;";
    }

    QString question = "Model contains following materials which already exist in your database and have different properties:&lt;ol&gt;"
                     + materialNames
                     + "&lt;/ol&gt;Do you want to add them to the material list with different names?&lt;br/&gt;If not material from database will be applied.";
</t>
<t tx="leo.20201108101524.82">    int response = QMessageBox::question(this,
                                         "Different materials",
                                         question,
                                         QMessageBox::Yes | QMessageBox::No,
                                         QMessageBox::No);
    if (response == QMessageBox::Yes)
    {
        addDifferent = true;
    }
}

if (addDifferent)
{
    QMap&lt;QString,RMaterial&gt;::iterator iter;
    for (iter = differentMaterials.begin(); iter != differentMaterials.end(); ++iter)
    {
        RMaterial &amp;rMaterial = iter.value();

        QString materialNameBase = rMaterial.getName() + QString(" - Imported");
        QString materialName = materialNameBase;
        uint nTries = 0;
        while (MaterialList::getInstance().containName(materialName))
        {
            materialName = materialNameBase + " - " + QString::number(++nTries);
        }

        rMaterial.setName(materialName);
        MaterialList::getInstance().add(rMaterial);
    }

    QMap&lt;QString,RMaterial&gt;::const_iterator citer;
    for (citer = differentMaterials.constBegin(); citer != differentMaterials.constEnd(); ++citer)
    {
        // Remove unknown material from the model's element groups.
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNPoints();j++)
        {
            if (Session::getInstance().getModel(modelID).getPoint(j).getMaterial().getName() == citer.key())
            {
                Session::getInstance().getModel(modelID).getPoint(j).setMaterial(citer.value());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNLines();j++)
        {
            if (Session::getInstance().getModel(modelID).getLine(j).getMaterial().getName() == citer.key())
            {
                Session::getInstance().getModel(modelID).getLine(j).setMaterial(citer.value());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNSurfaces();j++)
        {
            if (Session::getInstance().getModel(modelID).getSurface(j).getMaterial().getName() == citer.key())
            {
                Session::getInstance().getModel(modelID).getSurface(j).setMaterial(citer.value());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNVolumes();j++)
        {
            if (Session::getInstance().getModel(modelID).getVolume(j).getMaterial().getName() == citer.key())
            {
                Session::getInstance().getModel(modelID).getVolume(j).setMaterial(citer.value());
            }
        }
    }
}
else
{
    QMap&lt;QString,RMaterial&gt;::const_iterator iter;
    for (iter = differentMaterials.constBegin(); iter != differentMaterials.constEnd(); ++iter)
    {
        // Remove unknown material from the model's element groups.
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNPoints();j++)
        {
            if (Session::getInstance().getModel(modelID).getPoint(j).getMaterial().getName() == iter.key())
            {
                Session::getInstance().getModel(modelID).getPoint(j).setMaterial(RMaterial());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNLines();j++)
        {
            if (Session::getInstance().getModel(modelID).getLine(j).getMaterial().getName() == iter.key())
            {
                Session::getInstance().getModel(modelID).getLine(j).setMaterial(RMaterial());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNSurfaces();j++)
        {
            if (Session::getInstance().getModel(modelID).getSurface(j).getMaterial().getName() == iter.key())
            {
                Session::getInstance().getModel(modelID).getSurface(j).setMaterial(RMaterial());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(modelID).getNVolumes();j++)
        {
            if (Session::getInstance().getModel(modelID).getVolume(j).getMaterial().getName() == iter.key())
            {
                Session::getInstance().getModel(modelID).getVolume(j).setMaterial(RMaterial());
            }
        }
    }
}
</t>
<t tx="leo.20201108101524.83">void MaterialManagerTree::onProblemChanged(uint)
{
    this-&gt;updateProblemTypeMask();
}

</t>
<t tx="leo.20201108101524.84">void MaterialManagerTree::onMaterialAdded(const QString &amp;materialName, bool isNew)
{
    this-&gt;addMaterial(materialName, isNew);
    this-&gt;updateCheckStates();
}

</t>
<t tx="leo.20201108101524.85">void MaterialManagerTree::onMaterialRemoved(const QString &amp;, uint removedID)
{
    for (int i=this-&gt;topLevelItemCount()-1;i&gt;=0;i--)
    {
        if (this-&gt;topLevelItem(i)-&gt;data(MATERIAL_TREE_COLUMN_NAME,Qt::UserRole).toUInt() == removedID)
        {
            this-&gt;takeTopLevelItem(i);
        }
    }

    // Loop over all element groups and delete the material.
    for (uint i=0;i&lt;Session::getInstance().getNModels();i++)
    {
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNPoints();j++)
        {
            if (Session::getInstance().getModel(i).getPoint(j).getMaterial().getID() == removedID)
            {
                Session::getInstance().getModel(i).getPoint(j).setMaterial(RMaterial());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNLines();j++)
        {
            if (Session::getInstance().getModel(i).getLine(j).getMaterial().getID() == removedID)
            {
                Session::getInstance().getModel(i).getLine(j).setMaterial(RMaterial());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNSurfaces();j++)
        {
            if (Session::getInstance().getModel(i).getSurface(j).getMaterial().getID() == removedID)
            {
                Session::getInstance().getModel(i).getSurface(j).setMaterial(RMaterial());
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNVolumes();j++)
        {
            if (Session::getInstance().getModel(i).getVolume(j).getMaterial().getID() == removedID)
            {
                Session::getInstance().getModel(i).getVolume(j).setMaterial(RMaterial());
            }
        }
    }
}

</t>
<t tx="leo.20201108101524.86">void MaterialManagerTree::onMaterialRenamed(const QString &amp;materialOldName, const QString &amp;materialNewName)
{
    // Loop over all element groups and rename applied material.
    for (uint i=0;i&lt;Session::getInstance().getNModels();i++)
    {
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNPoints();j++)
        {
            if (Session::getInstance().getModel(i).getPoint(j).getMaterial().getName() == materialOldName)
            {
                Session::getInstance().getModel(i).getPoint(j).getMaterial().setName(materialNewName);
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNLines();j++)
        {
            if (Session::getInstance().getModel(i).getLine(j).getMaterial().getName() == materialOldName)
            {
                Session::getInstance().getModel(i).getLine(j).getMaterial().setName(materialNewName);
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNSurfaces();j++)
        {
            if (Session::getInstance().getModel(i).getSurface(j).getMaterial().getName() == materialOldName)
            {
                Session::getInstance().getModel(i).getSurface(j).getMaterial().setName(materialNewName);
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNVolumes();j++)
        {
            if (Session::getInstance().getModel(i).getVolume(j).getMaterial().getName() == materialOldName)
            {
                Session::getInstance().getModel(i).getVolume(j).getMaterial().setName(materialNewName);
            }
        }
    }
}

</t>
<t tx="leo.20201108101524.87">void MaterialManagerTree::onMaterialChanged(const QString &amp;materialName)
{
    // Loop over all element groups and set changed material.

    RMaterial material = MaterialList::getInstance().get(materialName);

    for (uint i=0;i&lt;Session::getInstance().getNModels();i++)
    {
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNPoints();j++)
        {
            if (Session::getInstance().getModel(i).getPoint(j).getMaterial().getName() == materialName)
            {
                Session::getInstance().getModel(i).getPoint(j).setMaterial(material);
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNLines();j++)
        {
            if (Session::getInstance().getModel(i).getLine(j).getMaterial().getName() == materialName)
            {
                Session::getInstance().getModel(i).getLine(j).setMaterial(material);
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNSurfaces();j++)
        {
            if (Session::getInstance().getModel(i).getSurface(j).getMaterial().getName() == materialName)
            {
                Session::getInstance().getModel(i).getSurface(j).setMaterial(material);
            }
        }
        for (uint j=0;j&lt;Session::getInstance().getModel(i).getNVolumes();j++)
        {
            if (Session::getInstance().getModel(i).getVolume(j).getMaterial().getName() == materialName)
            {
                Session::getInstance().getModel(i).getVolume(j).setMaterial(material);
            }
        }
    }

    this-&gt;updateProblemTypeMask();
}

</t>
<t tx="leo.20201108101524.88">void MaterialManagerTree::onItemChanged(QTreeWidgetItem *item, int)
{
    uint id = item-&gt;data(MATERIAL_TREE_COLUMN_NAME,Qt::UserRole).toUInt();
    QString oldName = MaterialList::getInstance().findID(id);
    QString newName = item-&gt;text(MATERIAL_TREE_COLUMN_NAME);

    if (oldName != newName)
    {
        if (MaterialList::getInstance().containName(newName))
        {
            RLogger::warning("Material \'%s\' can not be renamed to \'%s\', because there already is a material with such name.\n",
                             oldName.toUtf8().constData(),newName.toUtf8().constData());
            item-&gt;setText(MATERIAL_TREE_COLUMN_NAME,oldName);
        }
        else
        {
            if (!MaterialList::getInstance().rename(oldName,newName))
            {
                RLogger::error("Failed to rename material from \'%s\' to \'%s\'\n",oldName.toUtf8().constData(),newName.toUtf8().constData());
                this-&gt;blockSignals(true);
                item-&gt;setText(MATERIAL_TREE_COLUMN_NAME,oldName);
                this-&gt;blockSignals(false);
            }
            emit this-&gt;materialSelected(newName);
        }
    }
    else
    {
        Qt::CheckState checkState = item-&gt;checkState(MATERIAL_TREE_COLUMN_NAME);
        RMaterial material;
        if (checkState == Qt::Checked)
        {
            material = MaterialList::getInstance().get(item-&gt;text(MATERIAL_TREE_COLUMN_NAME));
        }

        QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();

        for (int i=0;i&lt;selectedEntityIDs.size();i++)
        {
            switch (selectedEntityIDs[i].getType())
            {
                case R_ENTITY_GROUP_POINT:
                    Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getPoint(selectedEntityIDs[i].getEid()).setMaterial(material);
                    break;
                case R_ENTITY_GROUP_LINE:
                    Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getLine(selectedEntityIDs[i].getEid()).setMaterial(material);
                    break;
                case R_ENTITY_GROUP_SURFACE:
                    Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getSurface(selectedEntityIDs[i].getEid()).setMaterial(material);
                    break;
                case R_ENTITY_GROUP_VOLUME:
                    Session::getInstance().getModel(selectedEntityIDs[i].getMid()).getVolume(selectedEntityIDs[i].getEid()).setMaterial(material);
                    break;
                default:
                    break;
            }
        }
    }
    this-&gt;updateCheckStates();
}

</t>
<t tx="leo.20201108101524.89">void MaterialManagerTree::onItemDoubleClicked(QTreeWidgetItem *item, int column)
{
    this-&gt;blockSignals(true);
    if (column == MATERIAL_TREE_COLUMN_NAME)
    {
        item-&gt;setFlags(item-&gt;flags() | Qt::ItemIsEditable);
    }
    else
    {
        if (item-&gt;flags() &amp; Qt::ItemIsEditable)
        {
            item-&gt;setFlags(item-&gt;flags() ^ Qt::ItemIsEditable);
        }
    }
    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101524.9">void MainWindow::showDrawWidget(void)
{
    QString dockName = QString::fromUtf8("dockDraw");
    this-&gt;showCustomDockWidget((findCustomDockWidget(dockName) ? nullptr : new DrawInputWidget),dockName,tr("Draw object"));
}

</t>
<t tx="leo.20201108101524.90">void MaterialManagerTree::onItemSelectionChanged(void)
{
    QList&lt;QTreeWidgetItem *&gt; items = this-&gt;selectedItems();

    if (items.size() == 0)
    {
        MaterialList::getInstance().selectMaterial(QString());
        emit this-&gt;materialSelected(QString());
    }

    for (int i=0;i&lt;items.size();i++)
    {
        QString materialName = items[i]-&gt;text(MATERIAL_TREE_COLUMN_NAME);

        MaterialList::getInstance().selectMaterial(materialName);

        emit this-&gt;materialSelected(materialName);
    }

    this-&gt;actionList-&gt;processAvailability();
}

</t>
<t tx="leo.20201108101524.91">void MaterialManagerTree::onMaterialSelected(void)
{
    this-&gt;doNotPopulate = true;
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
    this-&gt;doNotPopulate = false;
}
</t>
<t tx="leo.20201108101524.92">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   material_property_add_dialog.cpp                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   30-th August 2012                                        *
 *                                                                   *
 *  DESCRIPTION: Material property add dialog class definition       *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "material_property_add_dialog.h"

MaterialPropertyAddDialog::MaterialPropertyAddDialog(RMaterial &amp;material, QWidget *parent) :
    QDialog(parent),
    pMaterial(&amp;material)
{
    this-&gt;setWindowTitle(QString("Material property editor"));
    this-&gt;resize(300,300);

    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    int mainLayoutRow = 0;

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *label = new QLabel(tr("Select one or more material properties from the list below."));
    mainLayout-&gt;addWidget(label, mainLayoutRow++, 0, 1, 1);

    this-&gt;propertyList = new QListWidget;
    this-&gt;propertyList-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection);
    mainLayout-&gt;addWidget(this-&gt;propertyList, mainLayoutRow++, 0, 1, 1);

    QList&lt;RMaterialPropertyType&gt; properties = this-&gt;findAvailableProperties(material);
    for (int i=0;i&lt;properties.size();i++)
    {
        QListWidgetItem *item = new QListWidgetItem(this-&gt;propertyList);
        item-&gt;setText(RMaterialProperty::getName(properties[i]));
        item-&gt;setData(Qt::UserRole,QVariant(int(properties[i])));
    }

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRow++, 0, 1, 1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;MaterialPropertyAddDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;MaterialPropertyAddDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.93">int MaterialPropertyAddDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted &amp;&amp; this-&gt;pMaterial)
    {
        QList&lt;QListWidgetItem*&gt; items = this-&gt;propertyList-&gt;selectedItems();
        for (int i=0;i&lt;items.size();i++)
        {
            RMaterialPropertyType type = RMaterialPropertyType(items[i]-&gt;data(Qt::UserRole).toInt());
            this-&gt;pMaterial-&gt;add(RMaterialProperty(type));
        }
    }
    return retVal;
}

QList&lt;RMaterialPropertyType&gt; MaterialPropertyAddDialog::findAvailableProperties(const RMaterial &amp;material) const
{
    QList&lt;RMaterialPropertyType&gt; propertyTypes;

    for (int i=int(R_MATERIAL_PROPERTY_NONE);
         i&lt;int(R_MATERIAL_PROPERTY_N_TYPES);
         i++)
    {
        if (RMaterialPropertyType(i) == R_MATERIAL_PROPERTY_NONE ||
            RMaterialPropertyType(i) == R_MATERIAL_PROPERTY_CUSTOM)
        {
            continue;
        }
        if (material.findPosition(RMaterialPropertyType(i)) &gt;= material.size())
        {
            propertyTypes.push_back(RMaterialPropertyType(i));
        }
    }

    return propertyTypes;
}
</t>
<t tx="leo.20201108101524.94">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   material_property_edit_dialog.cpp                        *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   2-nd August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Material property edit dialog class definition      *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QSpinBox&gt;
#include &lt;QPushButton&gt;

#include "material_property_edit_dialog.h"

MaterialPropertyEditDialog::MaterialPropertyEditDialog(RMaterialProperty &amp;property, QWidget *parent) :
    QDialog(parent),
    pProperty(&amp;property)
{
    this-&gt;setWindowTitle(QString("Material property editor"));
    this-&gt;resize(400,500);

    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    int mainLayoutRow = 0;

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QHBoxLayout *nValuesLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(nValuesLayout, mainLayoutRow++, 0, 1, 1);

    QLabel *labelNValues = new QLabel(tr("Number of values:"));
    nValuesLayout-&gt;addWidget(labelNValues);

    this-&gt;spinNValues = new QSpinBox;
    this-&gt;spinNValues-&gt;setMinimum(1);
    this-&gt;spinNValues-&gt;setValue(property.size());
    nValuesLayout-&gt;addWidget(this-&gt;spinNValues);

    this-&gt;connect(this-&gt;spinNValues,SIGNAL(valueChanged(int)),SLOT(onSpinNValuesChanged(int)));

    nValuesLayout-&gt;addStretch(1);

    this-&gt;editTable = new MaterialPropertyEditTable(property, parent);
    mainLayout-&gt;addWidget(this-&gt;editTable, mainLayoutRow++, 0, 1, 1);

    QObject::connect(this-&gt;editTable,&amp;ValueTable::sizeChanged,this,&amp;MaterialPropertyEditDialog::onTableSizeChanged);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRow++, 0, 1, 1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;MaterialPropertyEditDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;MaterialPropertyEditDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.95">int MaterialPropertyEditDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted &amp;&amp; this-&gt;pProperty)
    {
        this-&gt;pProperty-&gt;clear();
        for (int i=0;i&lt;this-&gt;editTable-&gt;rowCount();i++)
        {
            this-&gt;pProperty-&gt;add(this-&gt;editTable-&gt;getKey(i),
                                 this-&gt;editTable-&gt;getValue(i));
        }
    }
    return retVal;
}

</t>
<t tx="leo.20201108101524.96">void MaterialPropertyEditDialog::onTableSizeChanged(int nRows)
{
    this-&gt;spinNValues-&gt;setValue(nRows);
}

</t>
<t tx="leo.20201108101524.97">void MaterialPropertyEditDialog::onSpinNValuesChanged(int nValues)
{
     int oldRowCount = this-&gt;editTable-&gt;rowCount();

     if (oldRowCount &gt; nValues)
     {
         this-&gt;editTable-&gt;setRowCount(nValues);
         return;
     }

     double keyIncrement = 1.0;

     double key = this-&gt;editTable-&gt;getKey(oldRowCount-1);
     double value = this-&gt;editTable-&gt;getValue(oldRowCount-1);

     for (int i=oldRowCount;i&lt;nValues;i++)
     {
         key += keyIncrement;
         this-&gt;editTable-&gt;addValue(key,value);
     }
}
</t>
<t tx="leo.20201108101524.98">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   material_property_edit_table.cpp                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th August 2012                                        *
 *                                                                   *
 *  DESCRIPTION: Material property edit table class definition       *
 *********************************************************************/

#include "material_property_edit_table.h"

MaterialPropertyEditTable::MaterialPropertyEditTable(RMaterialProperty &amp;property, QWidget *parent) :
    ValueTable(parent)
{
    this-&gt;setKeyHeader(property.getKeyName());
    this-&gt;setValueHeader(property.getValueName());
    this-&gt;populate(property);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101524.99">void MaterialPropertyEditTable::populate(RMaterialProperty &amp;property)
{
    for (uint i=0;i&lt;property.size();i++)
    {
        this-&gt;addValue(property.getKey(i),
                       property.getValue(i));
    }
    this-&gt;resizeColumnsToContents();
}
</t>
<t tx="leo.20201108101525.1">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   mesh_generator_dialog.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   7-th September 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Mesh generator dialog class definition              *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "mesh_generator_dialog.h"
#include "session.h"
#include "mesh_generator.h"
#include "job_manager.h"

MeshGeneratorDialog::MeshGeneratorDialog(uint modelID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID)
{
    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    this-&gt;meshInput = rModel.getMeshInput();

    this-&gt;setWindowTitle(tr("Genenerate 3D mesh"));

    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    this-&gt;surfaceIntegrityCheck = new QCheckBox(tr("Check surface integrity"));
    mainLayout-&gt;addWidget(this-&gt;surfaceIntegrityCheck);
    this-&gt;surfaceIntegrityCheck-&gt;setChecked(rModel.getNVolumes() == 0);

    this-&gt;reconstructCheck = new QCheckBox(tr("Reconstruct mesh (reuse current nodes)"));
    mainLayout-&gt;addWidget(this-&gt;reconstructCheck);
    this-&gt;reconstructCheck-&gt;setChecked(this-&gt;meshInput.getReconstruct());
    this-&gt;reconstructCheck-&gt;setEnabled(rModel.getNVolumes() &gt; 0);

    this-&gt;keepResultsCheck = new QCheckBox(tr("Keep computed results"));
    mainLayout-&gt;addWidget(this-&gt;keepResultsCheck);
    this-&gt;keepResultsCheck-&gt;setChecked(this-&gt;meshInput.getKeepResults());
    this-&gt;keepResultsCheck-&gt;setEnabled(rModel.getNVariables() &gt; 0);

    this-&gt;qualityMeshGroupBox = new QGroupBox(tr("Quality mesh"));
    mainLayout-&gt;addWidget(this-&gt;qualityMeshGroupBox);
    this-&gt;qualityMeshGroupBox-&gt;setCheckable(true);
    this-&gt;qualityMeshGroupBox-&gt;setChecked(this-&gt;meshInput.getQualityMesh());

    QGridLayout *qualityMeshLayout = new QGridLayout;
    this-&gt;qualityMeshGroupBox-&gt;setLayout(qualityMeshLayout);

    QLabel *label = new QLabel(tr("Maximum element volume:"));
    qualityMeshLayout-&gt;addWidget(label,0,0,1,1);

    this-&gt;volumeConstraintEdit = new ValueLineEdit(0.0,1e99);
    qualityMeshLayout-&gt;addWidget(this-&gt;volumeConstraintEdit,0,1,1,1);
    this-&gt;volumeConstraintEdit-&gt;setValue(this-&gt;meshInput.getVolumeConstraint());

    QLabel *volumeConstraintUnitsLabel = new QLabel("[m^3]");
    qualityMeshLayout-&gt;addWidget(volumeConstraintUnitsLabel,0,2,1,1);

    this-&gt;meshSizeFunctionGroupBox = new QGroupBox(tr("Generate mesh size function"));
    qualityMeshLayout-&gt;addWidget(this-&gt;meshSizeFunctionGroupBox,1,0,1,3);
    this-&gt;meshSizeFunctionGroupBox-&gt;setCheckable(true);
    this-&gt;meshSizeFunctionGroupBox-&gt;setChecked(false);
    this-&gt;meshSizeFunctionGroupBox-&gt;setEnabled(rModel.getNVariables() &gt; 0);

    QGridLayout *meshSizeFunctionLayout = new QGridLayout;
    this-&gt;meshSizeFunctionGroupBox-&gt;setLayout(meshSizeFunctionLayout);

    QLabel *meshSizeFunctionLabel = new QLabel(tr("Source variable"));
    meshSizeFunctionLayout-&gt;addWidget(meshSizeFunctionLabel,0,0,1,1);

    this-&gt;meshSizeFunctionSourceComboBox = new QComboBox;
    meshSizeFunctionLayout-&gt;addWidget(this-&gt;meshSizeFunctionSourceComboBox,0,1,1,2);

    for (uint i=0;i&lt;rModel.getNVariables();i++)
    {
        this-&gt;meshSizeFunctionSourceComboBox-&gt;addItem(rModel.getVariable(i).getName(),
                                                      QVariant(int(rModel.getVariable(i).getType())));
    }

    double initEdgeLenght = std::cbrt(12.0 * this-&gt;meshInput.getVolumeConstraint() / std::sqrt(2.0));

    QLabel *meshSizeFunctionMinValueLabel = new QLabel(tr("Minimum edge length"));
    meshSizeFunctionLayout-&gt;addWidget(meshSizeFunctionMinValueLabel,1,0,1,1);

    this-&gt;meshSizeFunctionMinValueEdit = new ValueLineEdit(0.0,1e10);
    this-&gt;meshSizeFunctionMinValueEdit-&gt;setValue(initEdgeLenght*0.1);
    meshSizeFunctionLayout-&gt;addWidget(this-&gt;meshSizeFunctionMinValueEdit,1,1,1,1);

    QLabel *meshSizeFunctionMinValueUnitsLabel = new QLabel("[m]");
    meshSizeFunctionLayout-&gt;addWidget(meshSizeFunctionMinValueUnitsLabel,1,2,1,1);

    QLabel *meshSizeFunctionMaxValueLabel = new QLabel(tr("Maximum edge length"));
    meshSizeFunctionLayout-&gt;addWidget(meshSizeFunctionMaxValueLabel,2,0,1,1);

    this-&gt;meshSizeFunctionMaxValueEdit = new ValueLineEdit(0.0,1e10);
    this-&gt;meshSizeFunctionMaxValueEdit-&gt;setValue(initEdgeLenght);
    meshSizeFunctionLayout-&gt;addWidget(this-&gt;meshSizeFunctionMaxValueEdit,2,1,1,1);

    QLabel *meshSizeFunctionMaxValueUnitsLabel = new QLabel("[m]");
    meshSizeFunctionLayout-&gt;addWidget(meshSizeFunctionMaxValueUnitsLabel,2,2,1,1);

    this-&gt;tetgenParamsGroupBox = new QGroupBox(tr("TetGen parameters"));
    this-&gt;tetgenParamsGroupBox-&gt;setCheckable(true);
    this-&gt;tetgenParamsGroupBox-&gt;setChecked(false);
    mainLayout-&gt;addWidget(this-&gt;tetgenParamsGroupBox);

    QVBoxLayout *tetgenParamsLayout = new QVBoxLayout;
    this-&gt;tetgenParamsGroupBox-&gt;setLayout(tetgenParamsLayout);

    this-&gt;tetgenParamsEdit = new QLineEdit(Session::getInstance().getModel(this-&gt;modelID).generateMeshTetGenInputParams(this-&gt;meshInput));
    tetgenParamsLayout-&gt;addWidget(this-&gt;tetgenParamsEdit);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(this-&gt;surfaceIntegrityCheck,&amp;QCheckBox::stateChanged,this,&amp;MeshGeneratorDialog::onSurfaceIntegrityStateChanged);
    QObject::connect(this-&gt;qualityMeshGroupBox,&amp;QGroupBox::clicked,this,&amp;MeshGeneratorDialog::onQualityMeshGroupBoxClicked);
    QObject::connect(this-&gt;volumeConstraintEdit,&amp;ValueLineEdit::valueChanged,this,&amp;MeshGeneratorDialog::onVolumeConstraintValueChanged);
    QObject::connect(this-&gt;meshSizeFunctionMinValueEdit,&amp;ValueLineEdit::valueChanged,this,&amp;MeshGeneratorDialog::onVolumeConstraintValueChanged);
    QObject::connect(this-&gt;meshSizeFunctionMaxValueEdit,&amp;ValueLineEdit::valueChanged,this,&amp;MeshGeneratorDialog::onVolumeConstraintValueChanged);
    QObject::connect(this-&gt;reconstructCheck,&amp;QCheckBox::stateChanged,this,&amp;MeshGeneratorDialog::onReconstructStateChanged);
    QObject::connect(this-&gt;keepResultsCheck,&amp;QCheckBox::stateChanged,this,&amp;MeshGeneratorDialog::onKeepResultsStateChanged);
    QObject::connect(this-&gt;tetgenParamsGroupBox,&amp;QGroupBox::clicked,this,&amp;MeshGeneratorDialog::onTetgenParamsGroupBoxClicked);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;MeshGeneratorDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;MeshGeneratorDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101525.10">void MeshGeneratorDialog::onKeepResultsStateChanged(int)
{
    this-&gt;updateMeshInput();
}

</t>
<t tx="leo.20201108101525.100">void Model::undo(uint revision)
{
    for (uint i=0;i&lt;revision;i++)
    {
        this-&gt;redoStack.push(this-&gt;undoStack.pop());
    }
    this-&gt;redoStack.push(*this);
    this-&gt;operator =(this-&gt;undoStack.pop());
}

QString Model::getUndoActionMessage() const
{
    if (this-&gt;undoStack.size() &gt; 0)
    {
        return this-&gt;undoStack.top().actionDescription;
    }
    return QString();
}

uint Model::getRedoStackSize() const
{
    return uint(this-&gt;redoStack.size());
}

</t>
<t tx="leo.20201108101525.101">void Model::redo(uint revision)
{
    for (uint i=0;i&lt;revision;i++)
    {
        this-&gt;undoStack.push(this-&gt;redoStack.pop());
    }
    this-&gt;undoStack.push(*this);
    this-&gt;operator =(this-&gt;redoStack.pop());
}

QString Model::getRedoActionMessage() const
{
    if (this-&gt;redoStack.size() &gt; 0)
    {
        return this-&gt;redoStack.top().actionDescription;
    }
    return QString();
}

</t>
<t tx="leo.20201108101525.102">void Model::storeCurentVersion(uint maxDepth, const QString &amp;actionDescription)
{
    this-&gt;actionDescription = actionDescription;
    this-&gt;redoStack.clear();
    if (maxDepth &gt; 0)
    {
        this-&gt;undoStack.push(*this);
        while (this-&gt;undoStack.size() &gt; int(maxDepth))
        {
            this-&gt;undoStack.pop_front();
        }
    }
    else
    {
        this-&gt;undoStack.clear();
    }
}

</t>
<t tx="leo.20201108101525.103">void Model::updateHistoryStackSize(uint maxDepth)
{
    if (this-&gt;undoStack.size() &gt; int(maxDepth))
    {
        this-&gt;undoStack.resize(int(maxDepth));
    }
    if (this-&gt;redoStack.size() &gt; int(maxDepth))
    {
        this-&gt;redoStack.resize(int(maxDepth));
    }
}

</t>
<t tx="leo.20201108101525.104">void Model::clearEdgeNodes()
{
    this-&gt;edgeNodes.clear();
}

QSet&lt;uint&gt; Model::findEdgeNodeIDs(const QList&lt;SessionEntityID&gt; &amp;entityIDs) const
{
    QSet&lt;uint&gt; nodeIDs;

    RUVector nodeIsOnEdge(this-&gt;getNNodes(),0);
    RBVector elementIsInGroup(this-&gt;getNElements(),false);
    RUVector nodeIsInGroup(this-&gt;getNNodes(),RConstants::eod);

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        uint entityGroupId = this-&gt;getEntityGroupID(entityIDs[i].getType(),entityIDs[i].getEid(),true);
        if (entityGroupId == RConstants::eod)
        {
            continue;
        }
        const RElementGroup *pEelementGroup = static_cast&lt;const RElementGroup*&gt;(this-&gt;getEntityGroupPtr(entityGroupId,true));
        if (!pEelementGroup)
        {
            continue;
        }
        for (uint j=0;j&lt;pEelementGroup-&gt;size();j++)
        {
            uint elementID = pEelementGroup-&gt;get(j);
            elementIsInGroup[elementID] = true;
            const RElement &amp;rElement = this-&gt;getElement(elementID);
            for (uint k=0;k&lt;rElement.size();k++)
            {
                nodeIsOnEdge[rElement.getNodeId(k)] = 1;
                if (entityIDs[i].getType() == R_ENTITY_GROUP_POINT)
                {
                    nodeIsInGroup[rElement.getNodeId(k)] = R_ENTITY_GROUP_POINT;
                }
                else if (entityIDs[i].getType() == R_ENTITY_GROUP_LINE)
                {
                    nodeIsInGroup[rElement.getNodeId(k)] = R_ENTITY_GROUP_LINE;
                }
                else if (entityIDs[i].getType() == R_ENTITY_GROUP_SURFACE)
                {
                    nodeIsInGroup[rElement.getNodeId(k)] = R_ENTITY_GROUP_SURFACE;
                }
                else if (entityIDs[i].getType() == R_ENTITY_GROUP_VOLUME)
                {
                    nodeIsInGroup[rElement.getNodeId(k)] = R_ENTITY_GROUP_VOLUME;
                }
            }
        }
    }

    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (elementIsInGroup[i])
        {
            continue;
        }
        const RElement &amp;rElement = this-&gt;getElement(i);
        for (uint j=0;j&lt;rElement.size();j++)
        {
            uint nodeID = rElement.getNodeId(j);
            if (nodeIsOnEdge[nodeID] == 1)
            {
                nodeIsOnEdge[nodeID] = 2;
            }
        }
    }

    uint nn = 0;
    for (uint i=0;i&lt;this-&gt;getNNodes();i++)
    {
        if (nodeIsOnEdge[i] == 2 || nodeIsInGroup[i] == R_ENTITY_GROUP_POINT || nodeIsInGroup[i] == R_ENTITY_GROUP_LINE)
        {
            nn++;
        }
    }
    nodeIDs.reserve(int(nn));
    for (uint i=0;i&lt;this-&gt;getNNodes();i++)
    {
        if (nodeIsOnEdge[i] == 2 || nodeIsInGroup[i] == R_ENTITY_GROUP_POINT || nodeIsInGroup[i] == R_ENTITY_GROUP_LINE)
        {
            nodeIDs.insert(i);
        }
    }
    for (int i=0;i&lt;this-&gt;holeElements.size();i++)
    {
        for (uint j=0;j&lt;this-&gt;holeElements[i].size();j++)
        {
            nodeIDs.insert(this-&gt;holeElements[i].getNodeId(j));
        }
    }

    return nodeIDs;
} /* Model::findEdgeNodeIDs */

QMap&lt;uint, uint&gt; Model::splitNodes(const QSet&lt;uint&gt; &amp;nodeIDs, const QSet&lt;uint&gt; &amp;elementIDs)
{
    QMap&lt;uint,uint&gt; newNodeMap;

    foreach (uint nodeID, nodeIDs)
    {
        this-&gt;addNode(this-&gt;getNode(nodeID));
        uint newNodeID = this-&gt;getNNodes()-1;
        newNodeMap[nodeID] = newNodeID;
    }

    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (elementIDs.contains(i))
        {
            continue;
        }
        RElement &amp;rElement = this-&gt;getElement(i);
        for (uint j=0;j&lt;rElement.size();j++)
        {
            uint nodeID = rElement.getNodeId(j);
            if (newNodeMap.contains(nodeID))
            {
                rElement.setNodeId(j,newNodeMap[nodeID]);
            }
        }
    }

    return newNodeMap;
} /* Model::splitNodes */

QList&lt;RElement&gt; Model::generateEdgeElements(const QSet&lt;uint&gt; &amp;edgeNodeIDs, const QSet&lt;uint&gt; &amp;elementIDs) const
{
    QList&lt;RElement&gt; edgeElements;

    foreach (uint elementID, elementIDs)
    {
        if (R_ELEMENT_TYPE_IS_POINT(this-&gt;getElement(elementID).getType()) || R_ELEMENT_TYPE_IS_LINE(this-&gt;getElement(elementID).getType()))
        {
            edgeElements.push_back(this-&gt;getElement(elementID));
        }
        else
        {
            std::vector&lt;RElement&gt; elementEdgeElements = this-&gt;getElement(elementID).generateEdgeElements();
            for (uint j=0;j&lt;elementEdgeElements.size();j++)
            {
                const RElement &amp;rElement = elementEdgeElements[j];
                bool allNodesOnEdge = true;
                for (uint k=0;k&lt;rElement.size();k++)
                {
                    if (!edgeNodeIDs.contains(rElement.getNodeId(k)))
                    {
                        allNodesOnEdge = false;
                        break;
                    }
                }
                if (allNodesOnEdge)
                {
                    edgeElements.push_back(rElement);
                }
            }
        }
    }

    for (int i=edgeElements.size()-1;i&gt;=0;i--)
    {
        bool keepElement = true;
        uint nElementsFound = 0;
        foreach (uint elementID, elementIDs)
        {
            uint nFound = 0;
            for (uint j=0;j&lt;edgeElements[i].size();j++)
            {
                if (this-&gt;getElement(elementID).hasNodeId(edgeElements[i].getNodeId(j)))
                {
                    nFound ++;
                }
            }
            if (nFound == edgeElements[i].size())
            {
                nElementsFound++;
            }
            if (nElementsFound &gt;= 2)
            {
                keepElement = false;
                break;
            }
        }
        if (!keepElement)
        {
            edgeElements.removeAt(i);
        }
    }

    return edgeElements;
} /* Model::generateEdgeElements */

</t>
<t tx="leo.20201108101525.105">void Model::createSweepEdgeElements(const QList&lt;RElement&gt; &amp;edgeElements, const QMap&lt;uint, uint&gt; &amp;edgeNodeMap, bool useLastGroupID, bool selectNewEntities, bool showNewEntities)
{
    QList&lt;RElement&gt; lineElements;
    QList&lt;RElement&gt; surfaceElements;

    for (int i=0;i&lt;edgeElements.size();i++)
    {
        switch (edgeElements[i].getType())
        {
            case R_ELEMENT_POINT:
            {
                if (edgeNodeMap.contains(edgeElements[i].getNodeId(0)))
                {
                    RElement e;
                    e.setType(R_ELEMENT_TRUSS1);
                    e.setNodeId(0,edgeElements[i].getNodeId(0));
                    e.setNodeId(1,edgeNodeMap[edgeElements[i].getNodeId(0)]);
                    lineElements.push_back(e);
                }
                break;
            }
            case R_ELEMENT_TRUSS1:
            {
                if (edgeNodeMap.contains(edgeElements[i].getNodeId(0)) &amp;&amp;
                    edgeNodeMap.contains(edgeElements[i].getNodeId(1)))
                {
                    RElement e;
                    e.setType(R_ELEMENT_QUAD1);
                    e.setNodeId(0,edgeElements[i].getNodeId(1));
                    e.setNodeId(1,edgeElements[i].getNodeId(0));
                    e.setNodeId(2,edgeNodeMap[edgeElements[i].getNodeId(0)]);
                    e.setNodeId(3,edgeNodeMap[edgeElements[i].getNodeId(1)]);
                    surfaceElements.push_back(e);
                }
                break;
            }
            default:
            {
                break;
            }
        }
    }

    if (lineElements.size() &gt; 0)
    {
        uint groupID = this-&gt;getNLines() - (useLastGroupID ? 1 : 0);
        this-&gt;lines.resize(this-&gt;getNLines() + (useLastGroupID ? 0 : 1));
        this-&gt;lines[groupID].setName("Line " + QString::number(groupID + 1));
        this-&gt;lines[groupID].getData().setVisible(showNewEntities);
        this-&gt;lines[groupID].getData().setSelected(selectNewEntities);
        for (int i=0;i&lt;lineElements.size();i++)
        {
            this-&gt;addElement(lineElements[i],true,groupID);
        }
    }

    if (surfaceElements.size() &gt; 0)
    {
        uint groupID = this-&gt;getNSurfaces() - (useLastGroupID ? 1 : 0);
        this-&gt;surfaces.resize(this-&gt;getNSurfaces() + (useLastGroupID ? 0 : 1));
        this-&gt;surfaces[groupID].setName("Surface " + QString::number(groupID + 1));
        this-&gt;surfaces[groupID].getData().setVisible(showNewEntities);
        this-&gt;surfaces[groupID].getData().setSelected(selectNewEntities);
        for (int i=0;i&lt;surfaceElements.size();i++)
        {
            this-&gt;addElement(surfaceElements[i],true,groupID);
        }
    }
} /* Model::createSweepEdgeElements */


QVector&lt;RElement&gt; Model::findEdgeElements(double separationAngle) const
{
    RLogger::info("Finding hole elements\n");
    RLogger::indent();

    double radAngle = R_DEG_TO_RAD(separationAngle);

    QVector&lt;RElement&gt; segments;

    for (uint i=0;i&lt;this-&gt;surfaceNeigs.size();i++)
    {
        uint ceID = i;

        if (!R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getElement(ceID).getType()))
        {
            continue;
        }

        RR3Vector cn;

        const RElement &amp;cElement = this-&gt;getElement(ceID);
        cElement.findNormal(this-&gt;getNodes(),cn[0],cn[1],cn[2]);

        // Inspect neighboring elements.
        for (uint j=0;j&lt;surfaceNeigs[i].getNRows();j++)
        {
            uint neID = this-&gt;surfaceNeigs[i][j];

            if (!R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getElement(neID).getType()))
            {
                continue;
            }

            RR3Vector nn;

            const RElement &amp;nElement = this-&gt;getElement(neID);
            nElement.findNormal(this-&gt;getNodes(),nn[0],nn[1],nn[2]);

            if (RR3Vector::angle(cn,nn) &gt;= radAngle)
            {
                std::vector&lt;uint&gt; sNodeIDs;
                for (uint k=0;k&lt;cElement.size();k++)
                {
                    if (nElement.hasNodeId(cElement.getNodeId(k)))
                    {
                        sNodeIDs.push_back(cElement.getNodeId(k));
                    }
                }
                if (sNodeIDs.size() == 2)
                {
                    RElement e(R_ELEMENT_TRUSS1);
                    e.setNodeId(0,sNodeIDs[0]);
                    e.setNodeId(1,sNodeIDs[1]);
                    segments.append(e);
                }
            }
        }

        // Inspect nodes that have no neighbor
        std::vector&lt;RElement&gt; edges = cElement.generateEdgeElements();
        for (uint j=0;j&lt;edges.size();j++)
        {
            bool edgeHasNoNeighbor = true;
            for (uint k=0;k&lt;surfaceNeigs[i].getNRows();k++)
            {
                if (edges[j].size() &lt; 2)
                {
                    continue;
                }
                uint neID = this-&gt;surfaceNeigs[i][k];
                const RElement &amp;nElement = this-&gt;getElement(neID);
                if (nElement.hasNodeId(edges[j].getNodeId(0)) &amp;&amp; nElement.hasNodeId(edges[j].getNodeId(1)))
                {
                    edgeHasNoNeighbor = false;
                }

            }
            if (edgeHasNoNeighbor)
            {
                segments.append(edges[j]);
            }
        }
    }

    RLogger::unindent();
    return segments;
} /* Model::findEdgeElements */


QVector&lt;RElement&gt; Model::findHoleElements() const
{
    RLogger::info("Finding hole elements\n");
    RLogger::indent();

    if (this-&gt;getNElements() != this-&gt;surfaceNeigs.size())
    {
        RLogger::info("Invalid surface neighbors\n");
        RLogger::unindent();
        return QVector&lt;RElement&gt;();
    }


    QVector&lt;RElement&gt; elementList;

    for (uint i=0;i&lt;this-&gt;surfaceNeigs.size();i++)
    {
        if (RElementGroup::getGroupType(this-&gt;getElement(i).getType()) != R_ENTITY_GROUP_SURFACE)
        {
            continue;
        }
        if (this-&gt;surfaceNeigs[i].size() == this-&gt;getElement(i).size())
        {
            continue;
        }
        std::vector&lt;RElement&gt; edgeElements = this-&gt;getElement(i).generateEdgeElements();
        for (uint j=0;j&lt;edgeElements.size();j++)
        {
            bool edgeFound = false;
            for (uint k=0;k&lt;this-&gt;surfaceNeigs[i].size();k++)
            {
                std::vector&lt;RElement&gt; neighborEdgeElements = this-&gt;getElement(this-&gt;surfaceNeigs[i][k]).generateEdgeElements();
                for (uint l=0;l&lt;neighborEdgeElements.size();l++)
                {
                    if (edgeElements[j] == neighborEdgeElements[l])
                    {
                        edgeFound = true;
                        break;
                    }
                }
                if (edgeFound)
                {
                    break;
                }
            }
            if (!edgeFound)
            {
                elementList.push_back(edgeElements[j]);
            }
        }
    }
    RLogger::unindent();

    return elementList;
} /* Model::findHoleElements */
</t>
<t tx="leo.20201108101525.106">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model_action.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th November 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Model action class definition                       *
 *********************************************************************/

#include &lt;QtAlgorithms&gt;

#include &lt;rsolverlib.h&gt;

#include "model_action.h"
#include "session.h"

ModelAction::ModelAction(QObject *parent)
    : Job(parent)
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101525.107">void ModelAction::addAction(const ModelActionInput &amp;modelActionInput)
{
    this-&gt;actions.append(modelActionInput);
    std::sort(this-&gt;actions.begin(),this-&gt;actions.end());
}

</t>
<t tx="leo.20201108101525.108">void ModelAction::run(void)
{
    RLogger::info("Processing model actions\n");
    for (int i=0;i&lt;this-&gt;actions.size();i++)
    {
        RLogger::indent();
        this-&gt;executeAction(this-&gt;actions[i]);
        RLogger::unindent();
    }
}

</t>
<t tx="leo.20201108101525.109">void ModelAction::executeAction(const ModelActionInput &amp;modelActionInput)
{
    Session::getInstance().getModel(modelActionInput.getModelID()).glDrawLock();

    try
    {
        switch (modelActionInput.getType())
        {
            case MODEL_ACTION_AUTOMARK_SURFACES:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Automark surface entities"));
                this-&gt;autoMarkSurfaces(modelActionInput);
                break;
            case MODEL_ACTION_MARK_SURFACES:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Mark surface entities"));
                this-&gt;markSurfaces(modelActionInput);
                break;
            case MODEL_ACTION_CLOSE_SURFACE_HOLE:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Close surface hole"));
                this-&gt;closeSurfaceHole(modelActionInput);
                break;
            case MODEL_ACTION_MERGE_NEAR_NODES:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Merge near nodes"));
                this-&gt;mergeNearNodes(modelActionInput);
                break;
            case MODEL_ACTION_MERGE_ENTITIES:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Merge entities"));
                this-&gt;mergeEntities(modelActionInput);
                break;
            case MODEL_ACTION_REMOVE_ENTITIES:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Remove entities"));
                this-&gt;removeEntities(modelActionInput);
                break;
            case MODEL_ACTION_CREATE_ELEMENT:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Create element"));
                this-&gt;createElement(modelActionInput);
                break;
            case MODEL_ACTION_REMOVE_NODES:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Remove nodes"));
                this-&gt;removeNodes(modelActionInput);
                break;
            case MODEL_ACTION_PURGE_UNUSED_NODES:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Purge unused nodes"));
                this-&gt;purgeUnusedNodes(modelActionInput);
                break;
            case MODEL_ACTION_PURGE_UNUSED_ELEMENTS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Purge unused elements"));
                this-&gt;purgeUnusedElements(modelActionInput);
                break;
            case MODEL_ACTION_REMOVE_DUPLICATE_NODES:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Remove duplicate nodes"));
                this-&gt;removeDuplicateNodes(modelActionInput);
                break;
            case MODEL_ACTION_REMOVE_DUPLICATE_ELEMENTS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Remove duplicate elements"));
                this-&gt;removeDuplicateElements(modelActionInput);
                break;
            case MODEL_ACTION_REMOVE_ELEMENTS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Remove elements"));
                this-&gt;removeElements(modelActionInput);
                break;
            case MODEL_ACTION_GENERATE_LINE_FROM_EDGES:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Generate line entities from model edges"));
                this-&gt;generateLineFromEdges(modelActionInput);
                break;
            case MODEL_ACTION_FIND_SLIVER_ELEMENTS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Find sliver elements"));
                this-&gt;findSliverElements(modelActionInput);
                break;
            case MODEL_ACTION_FIX_SLIVER_ELEMENTS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Fix sliver elements"));
                this-&gt;fixSliverElements(modelActionInput);
                break;
            case MODEL_ACTION_FIND_INTERSECTED_ELEMENTS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Find intersected elements"));
                this-&gt;findIntersectedElements(modelActionInput);
                break;
            case MODEL_ACTION_BREAK_INTERSECTED_ELEMENTS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Break intersected elements"));
                this-&gt;breakIntersectedElements(modelActionInput);
                break;
            case MODEL_ACTION_EXPORT_SLIVER_ELEMENTS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Export intersected elements"));
                this-&gt;exportSliverElements(modelActionInput);
                break;
            case MODEL_ACTION_EXPORT_INTERSECTED_ELEMENTS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Export intersected elements"));
                this-&gt;exportIntersectedElements(modelActionInput);
                break;
            case MODEL_ACTION_BOOL_DIFFERENCE:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Boolean difference"));
                this-&gt;boolDifference(modelActionInput);
                break;
            case MODEL_ACTION_BOOL_INTERSECTION:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Boolean intersection"));
                this-&gt;boolIntersection(modelActionInput);
                break;
            case MODEL_ACTION_BOOL_UNION:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Boolean union"));
                this-&gt;boolUnion(modelActionInput);
                break;
            case MODEL_ACTION_CHECK_POINT_INSIDE_SURFACE:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Check point inside surface"));
                this-&gt;checkPointInsideSurface(modelActionInput);
                break;
            case MODEL_ACTION_GENERATE_PATCHES:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Generate patches"));
                this-&gt;generatePatches(modelActionInput);
                break;
            case MODEL_ACTION_CALCULATE_VIEWFACTORS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Calculate view-factors"));
                this-&gt;calculateViewFactors(modelActionInput);
                break;
            case MODEL_ACTION_SWAP_SURFACE_ELEMENT_NORMAL:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Swap surface element normal"));
                this-&gt;swapSurfaceElementNormal(modelActionInput);
                break;
            case MODEL_ACTION_SWAP_SURFACE_NORMALS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Swap surface normals"));
                this-&gt;swapSurfaceNormals(modelActionInput);
                break;
            case MODEL_ACTION_SYNC_SURFACE_NORMALS:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Synchronize surface normals"));
                this-&gt;syncSurfaceNormals(modelActionInput);
                break;
            case MODEL_ACTION_COARSEN_SURFACE:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Coarsen surface"));
                this-&gt;coarsenSurface(modelActionInput);
                break;
            case MODEL_ACTION_TETRAHEDRALIZE_SURFACE:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Tetrahedralize surface"));
                this-&gt;tetrahedralizeSurface(modelActionInput);
                break;
            case MODEL_ACTION_CONSOLIDATE:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Consolidate geometry"));
                this-&gt;consolidate(modelActionInput);
                break;
            case MODEL_ACTION_GEOMETRY_TRANSFORM:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Transform geometry"));
                this-&gt;geometryTransform(modelActionInput);
                break;
            case MODEL_ACTION_APPLY_VARIABLE_ON_NODE:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Apply variable on nodes"));
                this-&gt;applyVariableOnNode(modelActionInput);
                break;
            case MODEL_ACTION_REMOVE_VARIABLE:
                Session::getInstance().storeCurentModelVersion(modelActionInput.getModelID(),tr("Remove variable"));
                this-&gt;removeVariable(modelActionInput);
                break;
            default:
                //! Nothing to be performed.
                break;
        }
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to perform model action \'%d\'. %s\n",modelActionInput.getType(),error.getMessage().toUtf8().constData());
    }
    Session::getInstance().getModel(modelActionInput.getModelID()).glDrawUnlock();
}

</t>
<t tx="leo.20201108101525.11">void MeshGeneratorDialog::onTetgenParamsGroupBoxClicked(bool)
{
    this-&gt;updateMeshInput();
}
</t>
<t tx="leo.20201108101525.110">void ModelAction::autoMarkSurfaces(const ModelActionInput &amp;modelActionInput)
{
    Session::getInstance().getModel(modelActionInput.getModelID()).autoMarkSurfaces(modelActionInput.getSeparationAngle());
    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.111">void ModelAction::markSurfaces(const ModelActionInput &amp;modelActionInput)
{
    Session::getInstance().getModel(modelActionInput.getModelID()).markSurface(modelActionInput.getSeparationAngle(),modelActionInput.getElementIDs());
    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.112">void ModelAction::closeSurfaceHole(const ModelActionInput &amp;modelActionInput)
{
    Session::getInstance().getModel(modelActionInput.getModelID()).closeSurfaceHole(modelActionInput.getElementIDs());
    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.113">void ModelAction::mergeNearNodes(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Merging near nodes\n");
    RLogger::indent();
    uint nMerged = rModel.mergeNearNodes(modelActionInput.getTolerance());
    RLogger::info("Number of merged nodes = %u\n",nMerged);
    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.114">void ModelAction::mergeEntities(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Merging entities\n");
    RLogger::indent();
    rModel.mergeEntities(R_ENTITY_GROUP_POINT,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_POINT));
    rModel.mergeEntities(R_ENTITY_GROUP_LINE,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_LINE));
    rModel.mergeEntities(R_ENTITY_GROUP_SURFACE,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_SURFACE));
    rModel.mergeEntities(R_ENTITY_GROUP_VOLUME,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_VOLUME));
    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.115">void ModelAction::removeEntities(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Removing entities\n");
    RLogger::indent();

    uint nSurfaceEntities = 0;
    uint nVolumeEntities = 0;
    foreach (SessionEntityID sessionEntityID, modelActionInput.getEntityIDs())
    {
        if (sessionEntityID.getType() == R_ENTITY_GROUP_SURFACE)
        {
            nSurfaceEntities++;
        }
        if (sessionEntityID.getType() == R_ENTITY_GROUP_VOLUME)
        {
            nVolumeEntities++;
        }
    }

    rModel.removeEntities(R_ENTITY_GROUP_POINT,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_POINT));
    rModel.removeEntities(R_ENTITY_GROUP_LINE,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_LINE));
    rModel.removeEntities(R_ENTITY_GROUP_SURFACE,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_SURFACE));
    rModel.removeEntities(R_ENTITY_GROUP_VOLUME,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_VOLUME));
    rModel.removeEntities(R_ENTITY_GROUP_CUT,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_CUT));
    rModel.removeEntities(R_ENTITY_GROUP_ISO,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_ISO));
    rModel.removeEntities(R_ENTITY_GROUP_STREAM_LINE,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_STREAM_LINE));
    rModel.removeEntities(R_ENTITY_GROUP_VECTOR_FIELD,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_VECTOR_FIELD));
    rModel.removeEntities(R_ENTITY_GROUP_SCALAR_FIELD,SessionEntityID::getEntityIDs(modelActionInput.getEntityIDs(),R_ENTITY_GROUP_SCALAR_FIELD));

    rModel.RModel::purgeUnusedElements();
    rModel.RModel::purgeUnusedNodes();

    int consolidateActionMask = Model::ConsolidateEdgeNodes | Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateMeshInput | Model::ConsolidateSliverElements;

    if (nSurfaceEntities &gt; 0)
    {
        consolidateActionMask |= Model::ConsolidateSurfaceNeighbors;
        if (rModel.getNIntersected() &gt; 0)
        {
            consolidateActionMask |= Model::ConsolidateIntersectedElements;
        }
    }
    if (nSurfaceEntities &gt; 0)
    {
        consolidateActionMask |= Model::ConsolidateVolumeNeighbors;
    }

    rModel.consolidate(consolidateActionMask);

    Session::getInstance().getPickList().clear();

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.116">void ModelAction::createElement(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Creating element\n");
    RLogger::indent();

    RElementType elementType = modelActionInput.getElementType();
    QList&lt;uint&gt; nodeIDs = modelActionInput.getNodeIDs();

    RElement e(elementType);
    for (uint i=0;i&lt;e.size();i++)
    {
        e.setNodeId(i,nodeIDs[int(i)]);
    }

    if (elementType == R_ELEMENT_QUAD1)
    {
        uint n1 = e.getNodeId(0);
        uint n2 = e.getNodeId(1);
        uint n3 = e.getNodeId(2);
        uint n4 = e.getNodeId(3);
        RTriangle t1(rModel.getNode(n1),rModel.getNode(n2),rModel.getNode(n3));
        RTriangle t2(rModel.getNode(n2),rModel.getNode(n3),rModel.getNode(n4));
        if (RR3Vector::angle(t1.getNormal(),t2.getNormal()) &gt; RConstants::pi / 2.0)
        {
            e.swapNodeIds(2,3);
        }
    }

    rModel.addElement(e);

    rModel.consolidate(Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateSliverElements);
    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.117">void ModelAction::removeNodes(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Removing nodes\n");
    RLogger::indent();

    rModel.removeNodes(modelActionInput.getNodeIDs(),modelActionInput.getCloseHole());
    rModel.consolidate(Model::ConsolidateActionAll);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.118">void ModelAction::purgeUnusedNodes(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Purging unused nodes\n");
    RLogger::indent();

    uint nPurged = rModel.purgeUnusedNodes();
    RLogger::info("Number of purged nodes = %u\n",nPurged);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.119">void ModelAction::purgeUnusedElements(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Purging unused elements\n");
    RLogger::indent();

    uint nPurged = rModel.purgeUnusedElements();
    RLogger::info("Number of purged elements = %u\n",nPurged);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.12">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   mesh_setup_widget.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th October 2018                                       *
 *                                                                   *
 *  DESCRIPTION: Mesh setup widget class definition                  *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QGroupBox&gt;
#include &lt;QListWidget&gt;
#include &lt;QListWidgetItem&gt;
#include &lt;QLabel&gt;

#include "mesh_setup_widget.h"
#include "session.h"

MeshSetupWidget::MeshSetupWidget(const RMeshSetup &amp;meshSetup,
                                 @others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101525.120">void ModelAction::removeDuplicateNodes(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Removing duplicate nodes\n");
    RLogger::indent();
    uint nMerged = rModel.mergeNearNodes(RConstants::eps);
    RLogger::info("Number of removed nodes = %u\n",nMerged);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.121">void ModelAction::removeDuplicateElements(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Removing duplicate elements\n");
    RLogger::indent();
    uint nMerged = rModel.removeDuplicateElements();
    RLogger::info("Number of removed elements = %u\n",nMerged);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.122">void ModelAction::removeElements(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Removing elements\n");
    RLogger::indent();

    uint nSurfaceElements = 0;
    uint nVolumeElements = 0;
    foreach (uint elementID, modelActionInput.getElementIDs())
    {
        if (R_ELEMENT_TYPE_IS_SURFACE(rModel.getElement(elementID).getType()))
        {
            nSurfaceElements++;
        }
        if (R_ELEMENT_TYPE_IS_VOLUME(rModel.getElement(elementID).getType()))
        {
            nVolumeElements++;
        }
    }

    int consolidateActionMask = Model::ConsolidateEdgeNodes | Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateMeshInput | Model::ConsolidateSliverElements;

    if (nSurfaceElements &gt; 0)
    {
        consolidateActionMask |= Model::ConsolidateSurfaceNeighbors;
        if (rModel.getNIntersected() &gt; 0)
        {
            consolidateActionMask |= Model::ConsolidateIntersectedElements;
        }
    }
    if (nVolumeElements &gt; 0)
    {
        consolidateActionMask |= Model::ConsolidateVolumeNeighbors;
    }

    rModel.removeElements(modelActionInput.getElementIDs(),modelActionInput.getCloseHole());
    rModel.consolidate(Model::ConsolidateActionAll);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.123">void ModelAction::generateLineFromEdges(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Generating line(s) from surface edges\n");
    RLogger::indent();

    rModel.generateLineFromSurfaceEdges(modelActionInput.getSeparationAngle());

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.124">void ModelAction::findSliverElements(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Finding sliver elements\n");
    RLogger::indent();

    rModel.updateSliverElements(modelActionInput.getEdgeRatio());

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.125">void ModelAction::fixSliverElements(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Fixing sliver elements\n");
    RLogger::indent();

    rModel.fixSliverElements(modelActionInput.getEdgeRatio());

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.126">void ModelAction::exportSliverElements(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Exporting sliver elements\n");
    RLogger::indent();

    rModel.exportSliverElements();

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101525.127">void ModelAction::findIntersectedElements(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Finding intersected elements\n");
    RLogger::indent();

    rModel.updateIntersectedElements();

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.128">void ModelAction::breakIntersectedElements(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Breaking intersected elements\n");
    RLogger::indent();

//    // Better to remove volume emelements before breaking the triangles.
//    if (rModel.getNVolumes() &gt; 0)
//    {
//        QList&lt;uint&gt; entityIDs;
//        for (uint i=0;i&lt;rModel.getNVolumes();i++)
//        {
//            entityIDs.append(i);
//        }
//        rModel.removeEntities(R_ENTITY_GROUP_VOLUME,entityIDs);
//    }
    rModel.breakIntersectedElements(modelActionInput.getNIterations());

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.129">void ModelAction::exportIntersectedElements(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Exporting intersected elements\n");
    RLogger::indent();

    rModel.exportIntersectedElements();

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101525.13">                                 const std::vector&lt;RVariableType&gt; &amp;variableTypes,
                                 QWidget *parent)
    : QWidget(parent)
    , meshSetup(meshSetup)
{
    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QGroupBox *groupBox = new QGroupBox(tr("Mesh refinement setup"));
    mainLayout-&gt;addWidget(groupBox);

    QGridLayout *groupLayout = new QGridLayout;
    groupBox-&gt;setLayout(groupLayout);

    int groupLayoutRow = 0;

    QListWidget *variablesListWidget = new QListWidget();
    variablesListWidget-&gt;setSelectionMode(QAbstractItemView::NoSelection);
    groupLayout-&gt;addWidget(variablesListWidget,groupLayoutRow,0,1,3);

    for (uint i=0;i&lt;variableTypes.size();i++)
    {
        QListWidgetItem *item = new QListWidgetItem(variablesListWidget);
        item-&gt;setText(RVariable::getName(variableTypes[i]));
        item-&gt;setData(Qt::UserRole,QVariant(variableTypes[i]));
        item-&gt;setFlags(item-&gt;flags() | Qt::ItemIsUserCheckable);
        item-&gt;setCheckState(meshSetup.getVariables().contains(variableTypes[i]) ? Qt::Checked : Qt::Unchecked);
    }

    QObject::connect(variablesListWidget,&amp;QListWidget::itemChanged,this,&amp;MeshSetupWidget::onVariableListItemChanged);

    groupLayoutRow++;

    QLabel *minEdgeLengthLabel = new QLabel(tr("Minimum edge length"));
    groupLayout-&gt;addWidget(minEdgeLengthLabel,groupLayoutRow,0,1,1);

    this-&gt;minEdgeLengthEdit = new ValueLineEdit(0.0,1e10);
    this-&gt;minEdgeLengthEdit-&gt;setValue(this-&gt;meshSetup.getMinEdgeLength());
    this-&gt;minEdgeLengthEdit-&gt;setEnabled(this-&gt;meshSetup.getVariables().size() &gt; 0);
    groupLayout-&gt;addWidget(this-&gt;minEdgeLengthEdit,groupLayoutRow,1,1,1);

    QObject::connect(this-&gt;minEdgeLengthEdit,&amp;ValueLineEdit::valueChanged,this,&amp;MeshSetupWidget::onMinEdgeLengthChanged);

    QLabel *minEdgeLengthUnitLabel = new QLabel("[m]");
    groupLayout-&gt;addWidget(minEdgeLengthUnitLabel,groupLayoutRow,2,1,1);

    groupLayoutRow++;

    QLabel *maxEdgeLengthLabel = new QLabel(tr("Maximum edge length"));
    groupLayout-&gt;addWidget(maxEdgeLengthLabel,groupLayoutRow,0,1,1);

    this-&gt;maxEdgeLengthEdit = new ValueLineEdit(0.0,1e10);
    this-&gt;maxEdgeLengthEdit-&gt;setValue(this-&gt;meshSetup.getMaxEdgeLength());
    this-&gt;maxEdgeLengthEdit-&gt;setEnabled(this-&gt;meshSetup.getVariables().size() &gt; 0);
    groupLayout-&gt;addWidget(this-&gt;maxEdgeLengthEdit,groupLayoutRow,1,1,1);

    QObject::connect(this-&gt;maxEdgeLengthEdit,&amp;ValueLineEdit::valueChanged,this,&amp;MeshSetupWidget::onMaxEdgeLengthChanged);

    QLabel *maxEdgeLengthUnitLabel = new QLabel("[m]");
    groupLayout-&gt;addWidget(maxEdgeLengthUnitLabel,groupLayoutRow,2,1,1);

}

</t>
<t tx="leo.20201108101525.130">void ModelAction::boolDifference(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());
    const QList&lt;SessionEntityID&gt; &amp;entityIDs = modelActionInput.getEntityIDs();
    QList&lt;uint&gt; surfaceIDs;

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        surfaceIDs.append(entityIDs.at(i).getEid());
    }

    RLogger::info("Performing difference geometry operation\n");
    RLogger::indent();

    try
    {
        uint cuttingSurfaceID = surfaceIDs.last();
        surfaceIDs.pop_back();
        rModel.boolDifference(modelActionInput.getNIterations(),surfaceIDs,cuttingSurfaceID);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to perform difference boolean operation. %s", error.getMessage().toUtf8().constData());
    }

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.131">void ModelAction::boolIntersection(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());
    const QList&lt;SessionEntityID&gt; &amp;entityIDs = modelActionInput.getEntityIDs();
    QList&lt;uint&gt; surfaceIDs;

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        surfaceIDs.append(entityIDs.at(i).getEid());
    }

    RLogger::info("Performing intersection geometry operation\n");
    RLogger::indent();

    try
    {
        rModel.boolIntersection(modelActionInput.getNIterations(),surfaceIDs);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to perform intersection boolean operation. %s", error.getMessage().toUtf8().constData());
    }

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.132">void ModelAction::boolUnion(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());
    const QList&lt;SessionEntityID&gt; &amp;entityIDs = modelActionInput.getEntityIDs();
    QList&lt;uint&gt; surfaceIDs;

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        surfaceIDs.append(entityIDs.at(i).getEid());
    }

    RLogger::info("Performing union geometry operation\n");
    RLogger::indent();

    try
    {
        rModel.boolUnion(modelActionInput.getNIterations(),surfaceIDs);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to perform union boolean operation. %s", error.getMessage().toUtf8().constData());
    }

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.133">void ModelAction::checkPointInsideSurface(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());
    const QList&lt;SessionEntityID&gt; &amp;entityIDs = modelActionInput.getEntityIDs();
    const RR3Vector &amp;point = modelActionInput.getPoint();

    RLogger::info("Checking if point is inside selected surfaces.\n");
    RLogger::indent();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        const RSurface &amp;rSurface = rModel.getSurface(entityIDs.at(i).getEid());
        bool isInside = rSurface.pointInside(rModel.getNodes(),rModel.getElements(),point,false);
        RLogger::info("Point [%g %g %g] is inside the surface %s: %s\n",point[0],point[1],point[2],rSurface.getName().toUtf8().constData(),isInside?"TRUE":"FALSE");
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101525.134">void ModelAction::generatePatches(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    // Clear view-factor matrix
    rModel.getViewFactorMatrix().clear();
    // Generate new header
    rModel.generateViewFactorMatrixHeader(rModel.getViewFactorMatrix().getHeader());
    // Generate patches
    rModel.generatePatchSurface(rModel.getViewFactorMatrix().getHeader().getPatchInput(),
                                rModel.getViewFactorMatrix().getPatchBook());

    // Write view factors.
    QString viewFactorMatrixFile = rModel.getProblemSetup().getRadiationSetup().getViewFactorMatrixFile();
    if (viewFactorMatrixFile.isEmpty())
    {
        viewFactorMatrixFile = rModel.buildDataFileName(RViewFactorMatrix::getDefaultFileExtension(true),rModel.getTimeSolver().getEnabled());
    }
    viewFactorMatrixFile = rModel.writeViewFactorMatrix(rModel.getViewFactorMatrix(),viewFactorMatrixFile);
    rModel.getProblemSetup().getRadiationSetup().setViewFactorMatrixFile(viewFactorMatrixFile);

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.135">void ModelAction::calculateViewFactors(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RViewFactorMatrixHeader viewFactorMatrixHeader;

    // Generate new header
    rModel.generateViewFactorMatrixHeader(viewFactorMatrixHeader);

    // Check if patches need to be regenerated
    if (viewFactorMatrixHeader.getPatchInput() != rModel.getViewFactorMatrix().getHeader().getPatchInput() ||
        viewFactorMatrixHeader.getPatchInput().size() != rModel.getNSurfaces() ||
        viewFactorMatrixHeader.getNElements() != rModel.getNElements())
    {
        // Clear view-factor matrix
        rModel.getViewFactorMatrix().clear();
        // Set new header
        rModel.getViewFactorMatrix().setHeader(viewFactorMatrixHeader);
        // Generate patches
        rModel.generatePatchSurface(rModel.getViewFactorMatrix().getHeader().getPatchInput(),
                                    rModel.getViewFactorMatrix().getPatchBook());
    }

    // Calculate view factors
    RHemiCube::calculateViewFactors(rModel,rModel.getViewFactorMatrix());

    // Write view factors.
    QString viewFactorMatrixFile = rModel.getProblemSetup().getRadiationSetup().getViewFactorMatrixFile();
    viewFactorMatrixFile = rModel.writeViewFactorMatrix(rModel.getViewFactorMatrix(),viewFactorMatrixFile);
    rModel.getProblemSetup().getRadiationSetup().setViewFactorMatrixFile(viewFactorMatrixFile);

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.136">void ModelAction::swapSurfaceElementNormal(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Swapping normals of selected surface elements\n");
    RLogger::indent();

    const QList&lt;uint&gt; &amp;elementIDs = modelActionInput.getElementIDs();

    for (int i=0;i&lt;elementIDs.size();i++)
    {
        RElement &amp;rElement = rModel.getElement(elementIDs[i]);
        rElement.swapNormal();
    }

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.137">void ModelAction::swapSurfaceNormals(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Swapping normals of selected surface entities\n");
    RLogger::indent();

    const QList&lt;SessionEntityID&gt; &amp;entityIDs = modelActionInput.getEntityIDs();

    std::vector&lt;bool&gt; elementIDs;
    elementIDs.resize(rModel.getNElements(),false);

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs.at(i).getType() != R_ENTITY_GROUP_SURFACE)
        {
            continue;
        }
        RSurface &amp;rSurface = rModel.getSurface(entityIDs.at(i).getEid());

        for (uint j=0;j&lt;rSurface.size();j++)
        {
            elementIDs[rSurface.get(j)] = true;

        }
    }

    for (uint i=0;i&lt;elementIDs.size();i++)
    {
        if (elementIDs[i])
        {
            RElement &amp;rElement = rModel.getElement(i);
            rElement.swapNormal();
        }
    }
    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.138">void ModelAction::syncSurfaceNormals(const ModelActionInput &amp;modelActionInput)
{
    Model &amp;rModel = Session::getInstance().getModel(modelActionInput.getModelID());

    RLogger::info("Synchronizing surface entities normals\n");
    RLogger::indent();

    rModel.syncSurfaceNormals();
    rModel.consolidate(Model::ConsolidateHoleElements | Model::ConsolidateEdgeElements | Model::ConsolidateSliverElements);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.139">void ModelAction::coarsenSurface(const ModelActionInput &amp;modelActionInput)
{
    uint modelID = modelActionInput.getModelID();

    Model &amp;rModel = Session::getInstance().getModel(modelID);

    RLogger::info("Coarsening surface\n");
    RLogger::indent();

    const QList&lt;SessionEntityID&gt; &amp;entityIDs = modelActionInput.getEntityIDs();

    std::vector&lt;uint&gt; surfaceIDs;
    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs.at(i).getType() == R_ENTITY_GROUP_SURFACE)
        {
            surfaceIDs.push_back(entityIDs.at(i).getEid());
        }
    }

    uint nDeleted = rModel.coarsenSurfaceElements(surfaceIDs,
                                                  modelActionInput.getEdgeLength(),
                                                  modelActionInput.getElementArea());
    RLogger::info("Number of deleted surface elements = %u.\n",nDeleted);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.14">void MeshSetupWidget::onVariableListItemChanged(QListWidgetItem *item)
{
    RVariableType variableType = RVariableType(item-&gt;data(Qt::UserRole).toInt());
    if (item-&gt;checkState() == Qt::Checked)
    {
        this-&gt;meshSetup.getVariables().insert(variableType);
    }
    else
    {
        QSet&lt;RVariableType&gt;::iterator iter = this-&gt;meshSetup.getVariables().find(variableType);
        if (iter != this-&gt;meshSetup.getVariables().end())
        {
            this-&gt;meshSetup.getVariables().erase(iter);
        }
    }

    this-&gt;minEdgeLengthEdit-&gt;setEnabled(this-&gt;meshSetup.getVariables().size() &gt; 0);
    this-&gt;maxEdgeLengthEdit-&gt;setEnabled(this-&gt;meshSetup.getVariables().size() &gt; 0);

    emit this-&gt;changed(this-&gt;meshSetup);
}

</t>
<t tx="leo.20201108101525.140">void ModelAction::tetrahedralizeSurface(const ModelActionInput &amp;modelActionInput)
{
    uint modelID = modelActionInput.getModelID();

    Model &amp;rModel = Session::getInstance().getModel(modelID);

    RLogger::info("Tetrahedralizing surface\n");
    RLogger::indent();

    const QList&lt;SessionEntityID&gt; &amp;entityIDs = modelActionInput.getEntityIDs();

    std::vector&lt;uint&gt; surfaceIDs;
    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs.at(i).getType() == R_ENTITY_GROUP_SURFACE)
        {
            surfaceIDs.push_back(entityIDs.at(i).getEid());
        }
    }

    uint nCreated = rModel.tetrahedralizeSurface(surfaceIDs);
    RLogger::info("Number of created volume elements = %u.\n",nCreated);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.141">void ModelAction::consolidate(const ModelActionInput &amp;modelActionInput)
{
    uint modelID = modelActionInput.getModelID();

    Model &amp;rModel = Session::getInstance().getModel(modelID);

    RLogger::info("Consolidating geometry\n");
    RLogger::indent();

    rModel.consolidate(Model::ConsolidateActionAll);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelActionInput.getModelID());
}

</t>
<t tx="leo.20201108101525.142">void ModelAction::geometryTransform(const ModelActionInput &amp;modelActionInput)
{
    uint modelID = modelActionInput.getModelID();

    Model &amp;rModel = Session::getInstance().getModel(modelID);

    RLogger::info("Transforming model geometry\n");
    RLogger::indent();

    QList&lt;SessionEntityID&gt; entityIDs;

    switch (modelActionInput.getGeometryTransformInput().getApplyTo())
    {
        case GeometryTransformInput::ApplyToAll:
        {
            entityIDs = Session::getInstance().getAllEntityIDs(modelID);
            break;
        }
        case GeometryTransformInput::ApplyToSelected:
        {
            entityIDs = Session::getInstance().getModel(modelID).getSelectedEntityIDs(modelID);
            break;
        }
        case GeometryTransformInput::ApplyToPicked:
        {
            entityIDs = Session::getInstance().getModel(modelID).getPickedEntityIDs(modelID);
            break;
        }
        case GeometryTransformInput::ApplyToVisible:
        {
            entityIDs = Session::getInstance().getModel(modelID).getVisibleEntityIDs(modelID);
            break;
        }
        default:
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid \'ApplyTo\' type.");
        }
    }

    // Model transformation
    rModel.transformGeometry(modelActionInput.getGeometryTransformInput(),entityIDs);

    RLogger::unindent();

    Session::getInstance().setModelChanged(modelID);
}

</t>
<t tx="leo.20201108101525.143">void ModelAction::applyVariableOnNode(const ModelActionInput &amp;modelActionInput)
{
    uint modelID = modelActionInput.getModelID();

    Model &amp;rModel = Session::getInstance().getModel(modelID);
    RVariableType variableType = modelActionInput.getVariableType();

    RLogger::info("Applying variable %s on node\n",RVariable::getName(variableType).toUtf8().constData());
    RLogger::indent();

    uint nVariables = rModel.getNVariables();

    for (uint i=0;i&lt;nVariables;i++)
    {
        RVariable &amp;rVariable = rModel.getVariable(i);
        if (rVariable.getType() != variableType)
        {
            continue;

        }
        if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            continue;
        }

        RVariable newVariable(rVariable);
        newVariable.setApplyType(R_VARIABLE_APPLY_NODE);
        newVariable.resize(rVariable.getNVectors(),rModel.getNNodes());
        for (uint j=0;j&lt;rVariable.getNVectors();j++)
        {
            RRVector elementValues = rVariable.getValues(j);
            RRVector nodeValues(rModel.getNNodes());
            RBVector explicitFlags;
            explicitFlags.resize(rModel.getNElements(),false);
            rModel.convertElementToNodeVector(elementValues,explicitFlags,nodeValues);
            for (uint k=0;k&lt;rModel.getNNodes();k++)
            {
                newVariable.setValue(j,k,nodeValues[k]);
            }
        }
        rVariable = newVariable;
    }

    RLogger::unindent();
    Session::getInstance().setResultsChanged(modelID);
}

</t>
<t tx="leo.20201108101525.144">void ModelAction::removeVariable(const ModelActionInput &amp;modelActionInput)
{
    uint modelID = modelActionInput.getModelID();

    Model &amp;rModel = Session::getInstance().getModel(modelID);
    RVariableType variableType = modelActionInput.getVariableType();

    RLogger::info("Removing variable %s from model %s\n",
                  RVariable::getName(variableType).toUtf8().constData(),
                  rModel.getName().toUtf8().constData());
    RLogger::indent();

    uint variablePosition = RConstants::eod;
    while ((variablePosition = rModel.findVariable(variableType)) != RConstants::eod)
    {
        rModel.removeVariable(variablePosition);
    }

    RLogger::unindent();
    Session::getInstance().setResultsChanged(modelID);
}
</t>
<t tx="leo.20201108101525.145">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model_action_input.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th November 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Model action input class definition                 *
 *********************************************************************/

#include "model_action_input.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101525.146">void ModelActionInput::_init(const ModelActionInput *pModelActionInput)
{
    if (pModelActionInput)
    {
        this-&gt;type = pModelActionInput-&gt;type;
        this-&gt;modelID = pModelActionInput-&gt;modelID;
        this-&gt;priority = pModelActionInput-&gt;priority;
        this-&gt;nIterations = pModelActionInput-&gt;nIterations;
        this-&gt;separationAngle = pModelActionInput-&gt;separationAngle;
        this-&gt;closeHole = pModelActionInput-&gt;closeHole;
        this-&gt;elementType = pModelActionInput-&gt;elementType;
        this-&gt;nodeIDs = pModelActionInput-&gt;nodeIDs;
        this-&gt;elementIDs = pModelActionInput-&gt;elementIDs;
        this-&gt;entityIDs = pModelActionInput-&gt;entityIDs;
        this-&gt;point = pModelActionInput-&gt;point;
        this-&gt;edgeRatio = pModelActionInput-&gt;edgeRatio;
        this-&gt;edgeLength = pModelActionInput-&gt;edgeLength;
        this-&gt;elementArea = pModelActionInput-&gt;elementArea;
        this-&gt;tolerance = pModelActionInput-&gt;tolerance;
        this-&gt;geometryTransformInput = pModelActionInput-&gt;geometryTransformInput;
        this-&gt;variableType = pModelActionInput-&gt;variableType;
    }
}

ModelActionInput::ModelActionInput(uint modelID, uint priority)
    : modelID(modelID)
    , priority(priority)
    , type(MODEL_ACTION_NONE)
    , nIterations(10)
    , separationAngle(0.0)
    , closeHole(false)
    , elementType(R_ELEMENT_NONE)
    , nodeIDs(QList&lt;uint&gt;())
    , elementIDs(QList&lt;uint&gt;())
    , entityIDs(QList&lt;SessionEntityID&gt;())
    , point(RR3Vector(0.0,0.0,0.0))
    , edgeRatio(6.0)
    , edgeLength(RConstants::eps)
    , elementArea(RConstants::eps)
    , tolerance(RConstants::findMachineDoubleEpsilon())
    , variableType(R_VARIABLE_NONE)
{
    this-&gt;_init();
}

ModelActionInput::ModelActionInput(const ModelActionInput &amp;modelActionInput)
{
    this-&gt;_init(&amp;modelActionInput);
}

ModelActionInput::~ModelActionInput()
{
}

ModelActionInput &amp;ModelActionInput::operator =(const ModelActionInput &amp;modelActionInput)
{
    this-&gt;_init(&amp;modelActionInput);
    return (*this);
}

</t>
<t tx="leo.20201108101525.147">bool ModelActionInput::operator &lt;(const ModelActionInput &amp;modelActionInput) const
{
    return (this-&gt;priority &lt; modelActionInput.priority);
}

uint ModelActionInput::getModelID() const
{
    return this-&gt;modelID;
}

ModelActionType ModelActionInput::getType() const
{
    return this-&gt;type;
}

uint ModelActionInput::getNIterations() const
{
    return this-&gt;nIterations;
}

double ModelActionInput::getSeparationAngle() const
{
    return this-&gt;separationAngle;
}

</t>
<t tx="leo.20201108101525.148">bool ModelActionInput::getCloseHole() const
{
    return this-&gt;closeHole;
}

RElementType ModelActionInput::getElementType() const
{
    return this-&gt;elementType;
}

</t>
<t tx="leo.20201108101525.149">const QList&lt;uint&gt; &amp;ModelActionInput::getNodeIDs() const
{
    return this-&gt;nodeIDs;
}

</t>
<t tx="leo.20201108101525.15">void MeshSetupWidget::onMinEdgeLengthChanged(double value)
{
    this-&gt;meshSetup.setMinEdgeLength(value);
    this-&gt;maxEdgeLengthEdit-&gt;setRange(value,this-&gt;maxEdgeLengthEdit-&gt;getMaximum());
    emit this-&gt;changed(this-&gt;meshSetup);
}

</t>
<t tx="leo.20201108101525.150">const QList&lt;uint&gt; &amp;ModelActionInput::getElementIDs() const
{
    return this-&gt;elementIDs;
}

</t>
<t tx="leo.20201108101525.151">const QList&lt;SessionEntityID&gt; &amp;ModelActionInput::getEntityIDs() const
{
    return this-&gt;entityIDs;
}

</t>
<t tx="leo.20201108101525.152">const RR3Vector &amp;ModelActionInput::getPoint() const
{
    return this-&gt;point;
}

double ModelActionInput::getEdgeRatio() const
{
    return this-&gt;edgeRatio;
}

double ModelActionInput::getEdgeLength() const
{
    return this-&gt;edgeLength;
}

double ModelActionInput::getElementArea() const
{
    return this-&gt;elementArea;
}

double ModelActionInput::getTolerance() const
{
    return this-&gt;tolerance;
}

</t>
<t tx="leo.20201108101525.153">const GeometryTransformInput &amp;ModelActionInput::getGeometryTransformInput() const
{
    return this-&gt;geometryTransformInput;
}

RVariableType ModelActionInput::getVariableType() const
{
    return this-&gt;variableType;
}

</t>
<t tx="leo.20201108101525.154">void ModelActionInput::setAutoMarkSurfaces(double separationAngle)
{
    this-&gt;type = MODEL_ACTION_AUTOMARK_SURFACES;
    this-&gt;separationAngle = separationAngle;
}

</t>
<t tx="leo.20201108101525.155">void ModelActionInput::setMarkSurfaces(double separationAngle, const QList&lt;uint&gt; &amp;elementIDs)
{
    this-&gt;type = MODEL_ACTION_MARK_SURFACES;
    this-&gt;separationAngle = separationAngle;
    this-&gt;elementIDs = elementIDs;
}

</t>
<t tx="leo.20201108101525.156">void ModelActionInput::setCloseSurfaceHole(const QList&lt;uint&gt; &amp;edgeIDs)
{
    this-&gt;type = MODEL_ACTION_CLOSE_SURFACE_HOLE;
    this-&gt;elementIDs = edgeIDs;
}

</t>
<t tx="leo.20201108101525.157">void ModelActionInput::setMergeNearNodes(double tolerance)
{
    this-&gt;type = MODEL_ACTION_MERGE_NEAR_NODES;
    this-&gt;tolerance = tolerance;
}

</t>
<t tx="leo.20201108101525.158">void ModelActionInput::setMergeEntities(const QList&lt;SessionEntityID&gt; &amp;entityIDs)
{
    this-&gt;type = MODEL_ACTION_MERGE_ENTITIES;
    this-&gt;entityIDs = entityIDs;
}

</t>
<t tx="leo.20201108101525.159">void ModelActionInput::setRemoveEntities(const QList&lt;SessionEntityID&gt; &amp;entityIDs)
{
    this-&gt;type = MODEL_ACTION_REMOVE_ENTITIES;
    this-&gt;entityIDs = entityIDs;
}

</t>
<t tx="leo.20201108101525.16">void MeshSetupWidget::onMaxEdgeLengthChanged(double value)
{
    this-&gt;meshSetup.setMaxEdgeLength(value);
    this-&gt;minEdgeLengthEdit-&gt;setRange(this-&gt;minEdgeLengthEdit-&gt;getMinimum(),value);
    emit this-&gt;changed(this-&gt;meshSetup);
}
</t>
<t tx="leo.20201108101525.160">void ModelActionInput::setCreateElement(const QList&lt;uint&gt; &amp;nodeIDs, RElementType elementType)
{
    this-&gt;type = MODEL_ACTION_CREATE_ELEMENT;
    this-&gt;nodeIDs = nodeIDs;
    this-&gt;elementType = elementType;
}

</t>
<t tx="leo.20201108101525.161">void ModelActionInput::setRemoveNodes(const QList&lt;uint&gt; &amp;nodeIDs, bool closeHole)
{
    this-&gt;type = MODEL_ACTION_REMOVE_NODES;
    this-&gt;nodeIDs = nodeIDs;
    this-&gt;closeHole = closeHole;
}

</t>
<t tx="leo.20201108101525.162">void ModelActionInput::setPurgeUnusedNodes()
{
    this-&gt;type = MODEL_ACTION_PURGE_UNUSED_NODES;
}

</t>
<t tx="leo.20201108101525.163">void ModelActionInput::setPurgeUnusedElements()
{
    this-&gt;type = MODEL_ACTION_PURGE_UNUSED_ELEMENTS;
}

</t>
<t tx="leo.20201108101525.164">void ModelActionInput::setRemoveDuplicateNodes()
{
    this-&gt;type = MODEL_ACTION_REMOVE_DUPLICATE_NODES;
}

</t>
<t tx="leo.20201108101525.165">void ModelActionInput::setRemoveDuplicateElements()
{
    this-&gt;type = MODEL_ACTION_REMOVE_DUPLICATE_ELEMENTS;
}

</t>
<t tx="leo.20201108101525.166">void ModelActionInput::setRemoveElements(const QList&lt;uint&gt; &amp;elementIDs, bool closeHole)
{
    this-&gt;type = MODEL_ACTION_REMOVE_ELEMENTS;
    this-&gt;elementIDs = elementIDs;
    this-&gt;closeHole = closeHole;
}

</t>
<t tx="leo.20201108101525.167">void ModelActionInput::setGenerateLinesFromEdges(double separationAngle)
{
    this-&gt;type = MODEL_ACTION_GENERATE_LINE_FROM_EDGES;
    this-&gt;separationAngle = separationAngle;
}

</t>
<t tx="leo.20201108101525.168">void ModelActionInput::setFindSliverElements(double edgeRatio)
{
    this-&gt;type = MODEL_ACTION_FIND_SLIVER_ELEMENTS;
    this-&gt;edgeRatio = edgeRatio;
}

</t>
<t tx="leo.20201108101525.169">void ModelActionInput::setFixSliverElements(double edgeRatio)
{
    this-&gt;type = MODEL_ACTION_FIX_SLIVER_ELEMENTS;
    this-&gt;edgeRatio = edgeRatio;
}

</t>
<t tx="leo.20201108101525.17">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   modal_setup_widget.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   11-th May 2016                                           *
 *                                                                   *
 *  DESCRIPTION: Modal setup widget class definition                 *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QGroupBox&gt;
#include &lt;QLabel&gt;
#include &lt;QComboBox&gt;
#include &lt;QSpinBox&gt;

#include "modal_setup_widget.h"
#include "value_line_edit.h"

ModalSetupWidget::ModalSetupWidget(const RModalSetup &amp;modalSetup, QWidget *parent)
    : QWidget(parent)
    , modalSetup(modalSetup)
{
    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QGroupBox *groupBox = new QGroupBox(tr("Modal analysis setup"));
    mainLayout-&gt;addWidget(groupBox);

    QGridLayout *groupLayout = new QGridLayout;
    groupBox-&gt;setLayout(groupLayout);

    int groupLayoutRow = 0;

    // Modal method
    QLabel *labelModalMethod = new QLabel(tr("Modal method"));
    groupLayout-&gt;addWidget(labelModalMethod,groupLayoutRow,0);

    QComboBox *comboModalMethod = new QComboBox();
    for (uint i=0;i&lt;R_MODAL_N_TYPES;i++)
    {
        comboModalMethod-&gt;addItem(RModalSetup::getMethodName(RModalMethod(i)));
    }
    comboModalMethod-&gt;setCurrentIndex(this-&gt;modalSetup.getMethod());
    groupLayout-&gt;addWidget(comboModalMethod,groupLayoutRow++,1);

    this-&gt;connect(comboModalMethod,SIGNAL(currentIndexChanged(int)),SLOT(onModalMethodChanged(int)));

    // Number of iterations
    QLabel *labelNIterations = new QLabel(tr("Iterations"));
    groupLayout-&gt;addWidget(labelNIterations,groupLayoutRow,0);

    this-&gt;spinNIterations = new QSpinBox;
    this-&gt;spinNIterations-&gt;setMinimum(R_MODAL_ITERATIONS_MIN_NUMBER);
    this-&gt;spinNIterations-&gt;setMaximum(R_MODAL_ITERATIONS_MAX_NUMBER);
    this-&gt;spinNIterations-&gt;setValue(this-&gt;modalSetup.getNIterations());
    this-&gt;spinNIterations-&gt;setToolTip(tr("Number of modal iterations to be performed."));
    this-&gt;spinNIterations-&gt;setEnabled(this-&gt;modalSetup.getMethod() == R_MODAL_MULTIPLE_MODES);
    groupLayout-&gt;addWidget(this-&gt;spinNIterations,groupLayoutRow++,1);

    this-&gt;connect(this-&gt;spinNIterations,SIGNAL(valueChanged(int)),SLOT(onNIterationsChanged(int)));

    // Number of modes to extract
    QLabel *labelNModes = new QLabel(tr("Extract modes"));
    groupLayout-&gt;addWidget(labelNModes,groupLayoutRow,0);

    this-&gt;spinNModesExtract = new QSpinBox;
    this-&gt;spinNModesExtract-&gt;setMinimum(R_MODAL_ITERATIONS_MIN_NUMBER);
    this-&gt;spinNModesExtract-&gt;setMaximum(spinNIterations-&gt;value());
    this-&gt;spinNModesExtract-&gt;setValue(this-&gt;modalSetup.getNModesToExtract());
    this-&gt;spinNModesExtract-&gt;setToolTip(tr("Number of modes to extract."));
    this-&gt;spinNModesExtract-&gt;setEnabled(this-&gt;modalSetup.getMethod() == R_MODAL_MULTIPLE_MODES);
    groupLayout-&gt;addWidget(this-&gt;spinNModesExtract,groupLayoutRow++,1);

    this-&gt;connect(this-&gt;spinNModesExtract,SIGNAL(valueChanged(int)),SLOT(onNModesExtractChanged(int)));

    // Convergence value
    QLabel *labelConvergenceValue = new QLabel(tr("Convergence value"));
    groupLayout-&gt;addWidget(labelConvergenceValue,groupLayoutRow,0);

    ValueLineEdit *lineConvergenceValue = new ValueLineEdit(1.0e-99,1.0e99);
    lineConvergenceValue-&gt;setText(QString::number(this-&gt;modalSetup.getConvergenceValue()));
    lineConvergenceValue-&gt;setToolTip(tr("Value at which it solver will assume that solution has converged."));
    groupLayout-&gt;addWidget(lineConvergenceValue,groupLayoutRow++,1);

    QObject::connect(lineConvergenceValue,&amp;ValueLineEdit::valueChanged,this,&amp;ModalSetupWidget::onConvergenceValueChanged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101525.170">void ModelActionInput::setFindIntersectedElements()
{
    this-&gt;type = MODEL_ACTION_FIND_INTERSECTED_ELEMENTS;
}

</t>
<t tx="leo.20201108101525.171">void ModelActionInput::setBreakIntersectedElements(uint nIterations)
{
    this-&gt;type = MODEL_ACTION_BREAK_INTERSECTED_ELEMENTS;
    this-&gt;nIterations = nIterations;
}

</t>
<t tx="leo.20201108101525.172">void ModelActionInput::setExportSliverElements()
{
    this-&gt;type = MODEL_ACTION_EXPORT_SLIVER_ELEMENTS;
}

</t>
<t tx="leo.20201108101525.173">void ModelActionInput::setExportIntersectedElements()
{
    this-&gt;type = MODEL_ACTION_EXPORT_INTERSECTED_ELEMENTS;
}

</t>
<t tx="leo.20201108101525.174">void ModelActionInput::setBoolDifference(const QList&lt;SessionEntityID&gt; &amp;entityIDs)
{
    this-&gt;type = MODEL_ACTION_BOOL_DIFFERENCE;
    this-&gt;entityIDs.clear();
    this-&gt;entityIDs = entityIDs;
}

</t>
<t tx="leo.20201108101525.175">void ModelActionInput::setBoolIntersection(const QList&lt;SessionEntityID&gt; &amp;entityIDs)
{
    this-&gt;type = MODEL_ACTION_BOOL_INTERSECTION;
    this-&gt;entityIDs = entityIDs;
}

</t>
<t tx="leo.20201108101525.176">void ModelActionInput::setBoolUnion(const QList&lt;SessionEntityID&gt; &amp;entityIDs)
{
    this-&gt;type = MODEL_ACTION_BOOL_UNION;
    this-&gt;entityIDs = entityIDs;
}

</t>
<t tx="leo.20201108101525.177">void ModelActionInput::setCheckPointInsideSurface(const RR3Vector &amp;point, const QList&lt;SessionEntityID&gt; &amp;entityIDs)
{
    this-&gt;type = MODEL_ACTION_CHECK_POINT_INSIDE_SURFACE;
    this-&gt;point = point;
    this-&gt;entityIDs = entityIDs;
}

</t>
<t tx="leo.20201108101525.178">void ModelActionInput::setGeneratePatches()
{
    this-&gt;type = MODEL_ACTION_GENERATE_PATCHES;
}

</t>
<t tx="leo.20201108101525.179">void ModelActionInput::setCalculateViewFactors()
{
    this-&gt;type = MODEL_ACTION_CALCULATE_VIEWFACTORS;
}

</t>
<t tx="leo.20201108101525.18">void ModalSetupWidget::onModalMethodChanged(int index)
{
    RModalMethod method = RModalMethod(index);
    this-&gt;modalSetup.setMethod(method);
    this-&gt;spinNIterations-&gt;setEnabled(method == R_MODAL_MULTIPLE_MODES);
    this-&gt;spinNModesExtract-&gt;setEnabled(method == R_MODAL_MULTIPLE_MODES);
    emit this-&gt;changed(this-&gt;modalSetup);
}

</t>
<t tx="leo.20201108101525.180">void ModelActionInput::setSwapSurfaceElementNormal(const QList&lt;uint&gt; &amp;elementIDs)
{
    this-&gt;type = MODEL_ACTION_SWAP_SURFACE_ELEMENT_NORMAL;
    this-&gt;elementIDs = elementIDs;
}

</t>
<t tx="leo.20201108101525.181">void ModelActionInput::setSwapSurfaceNormals(const QList&lt;SessionEntityID&gt; &amp;entityIDs)
{
    this-&gt;type = MODEL_ACTION_SWAP_SURFACE_NORMALS;
    this-&gt;entityIDs = entityIDs;
}

</t>
<t tx="leo.20201108101525.182">void ModelActionInput::setSyncSurfaceNormals()
{
    this-&gt;type = MODEL_ACTION_SYNC_SURFACE_NORMALS;
}

</t>
<t tx="leo.20201108101525.183">void ModelActionInput::setCoarsenSurface(const QList&lt;SessionEntityID&gt; &amp;entityIDs, double edgeLength, double elementArea)
{
    this-&gt;type = MODEL_ACTION_COARSEN_SURFACE;
    this-&gt;entityIDs = entityIDs;
    this-&gt;edgeLength = edgeLength;
    this-&gt;elementArea = elementArea;
}

</t>
<t tx="leo.20201108101525.184">void ModelActionInput::setTetrahedralizeSurface(const QList&lt;SessionEntityID&gt; &amp;entityIDs)
{
    this-&gt;type = MODEL_ACTION_TETRAHEDRALIZE_SURFACE;
    this-&gt;entityIDs = entityIDs;
}

</t>
<t tx="leo.20201108101525.185">void ModelActionInput::setConsolidate()
{
    this-&gt;type = MODEL_ACTION_CONSOLIDATE;
}

</t>
<t tx="leo.20201108101525.186">void ModelActionInput::setGeometryTransform(GeometryTransformInput geometryTransformInput)
{
    this-&gt;type = MODEL_ACTION_GEOMETRY_TRANSFORM;
    this-&gt;geometryTransformInput = geometryTransformInput;
}

</t>
<t tx="leo.20201108101525.187">void ModelActionInput::setApplyVariableOnNode(RVariableType variableType)
{
    this-&gt;type = MODEL_ACTION_APPLY_VARIABLE_ON_NODE;
    this-&gt;variableType = variableType;
}

</t>
<t tx="leo.20201108101525.188">void ModelActionInput::setRemoveVariable(RVariableType variableType)
{
    this-&gt;type = MODEL_ACTION_REMOVE_VARIABLE;
    this-&gt;variableType = variableType;
}
</t>
<t tx="leo.20201108101525.189">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model_entity_display_properties_tree.cpp                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th February 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Entity display properties tree class definition     *
 *********************************************************************/

#include &lt;rmlib.h&gt;

#include "session.h"
#include "color_combo_box.h"
#include "model_entity_display_properties_tree.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101525.19">void ModalSetupWidget::onNIterationsChanged(int nIterations)
{
    this-&gt;modalSetup.setNIterations(uint(nIterations));
    this-&gt;spinNModesExtract-&gt;blockSignals(true);
    this-&gt;spinNModesExtract-&gt;setMaximum(nIterations);
    this-&gt;spinNModesExtract-&gt;blockSignals(false);
    if (this-&gt;modalSetup.getNModesToExtract() &gt; this-&gt;modalSetup.getNIterations())
    {
        this-&gt;modalSetup.setNModesToExtract(this-&gt;modalSetup.getNIterations());
    }
    emit this-&gt;changed(this-&gt;modalSetup);
}

</t>
<t tx="leo.20201108101525.190">typedef enum _DisplayPropertyType
{
    DISPLAY_PROPERTY_NONE = 0,
    DISPLAY_PROPERTY_DRAW_WIRE,
    DISPLAY_PROPERTY_DRAW_EDGES,
    DISPLAY_PROPERTY_DRAW_NODES,
    DISPLAY_PROPERTY_DRAW_ELEMENT_NUMS,
    DISPLAY_PROPERTY_DRAW_NODE_NUMS,
    DISPLAY_PROPERTY_DRAW_ARROW_HEADS,
    DISPLAY_PROPERTY_DRAW_EQUAL_ARROW_LENGTHS,
    DISPLAY_PROPERTY_DRAW_ARROW_FROM,
    DISPLAY_PROPERTY_COLOR_BY_PATCH,
    DISPLAY_PROPERTY_COLOR_BY_VIEW_FACTOR,
    DISPLAY_PROPERTY_N_TYPES
} DisplayPropertyType;

</t>
<t tx="leo.20201108101525.191">typedef enum _DisplayPropertiesTreeColumn
{
    DP_TREE_COLUMN_NAME = 0,
    DP_TREE_N_COLUMNS
} DisplayPropertiesTreeColumn;

ModelEntityDisplayPropertiesTree::ModelEntityDisplayPropertiesTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setColumnCount(DP_TREE_N_COLUMNS);
    this-&gt;setSelectionMode(QAbstractItemView::NoSelection);
    this-&gt;setRootIsDecorated(false);
    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(DP_TREE_COLUMN_NAME,QString("Display properties"));
    this-&gt;setHeaderItem(headerItem);

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelSelectionChanged,
                     this,
                     &amp;ModelEntityDisplayPropertiesTree::onModelSelectionChanged);

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelChanged,
                     this,
                     &amp;ModelEntityDisplayPropertiesTree::onModelChanged);

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::problemSelectionChanged,
                     this,
                     &amp;ModelEntityDisplayPropertiesTree::onProblemChanged);

    QObject::connect(this,
                     &amp;ModelEntityDisplayPropertiesTree::itemChanged,
                     this,
                     &amp;ModelEntityDisplayPropertiesTree::onItemChanged);

    this-&gt;populate();
}

</t>
<t tx="leo.20201108101525.192">void ModelEntityDisplayPropertiesTree::populate(void)
{
    this-&gt;clear();
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();
    if (entityIDs.size() == 0)
    {
        return;
    }
    this-&gt;blockSignals(true);

    int nDrawWire = 0;
    int nDrawEdges = 0;
    int nDrawNodes = 0;
    int nDrawElementNums = 0;
    int nDrawNodeNums = 0;
    int nDrawArrowHeads = 0;
    int nDrawEqualArrowLengths = 0;
    int nDrawArrowFrom = 0;
    int nColorByPatch = 0;
    int nColorByViewFactor = 0;
    bool canDrawWire = false;
    bool canDrawEdges = false;
    bool canDrawNodes = false;
    bool canDrawElementNums = false;
    bool canDrawNodeNums = false;
    bool canDrawArrowHeads = false;
    bool canDrawEqualArrowLengths = false;
    bool canDrawArrowFrom = false;
    bool canColorByPatch = false;
    bool canColorByViewFactor = false;
    QColor color;
    for (int i=0;i&lt;entityIDs.size();i++)
    {
        const Model &amp;rModel = Session::getInstance().getModel(entityIDs[i].getMid());
        if (rModel.getDrawWire(entityIDs[i].getType(),entityIDs[i].getEid()))
        {
            nDrawWire++;
        }
        if (rModel.getDrawEdges(entityIDs[i].getType(),entityIDs[i].getEid()))
        {
            nDrawEdges++;
        }
        if (rModel.getDrawNodes(entityIDs[i].getType(),entityIDs[i].getEid()))
        {
            nDrawNodes++;
        }
        if (rModel.getDrawElementNumbers(entityIDs[i].getType(),entityIDs[i].getEid()))
        {
            nDrawElementNums++;
        }
        if (rModel.getDrawNodeNumbers(entityIDs[i].getType(),entityIDs[i].getEid()))
        {
            nDrawNodeNums++;
        }
        if (rModel.getDrawArrowHeads(entityIDs[i].getType(),entityIDs[i].getEid()))
        {
            nDrawArrowHeads++;
        }
        if (rModel.getDrawEqualArrowLengths(entityIDs[i].getType(),entityIDs[i].getEid()))
        {
            nDrawEqualArrowLengths++;
        }
        if (rModel.getDrawArrowFrom(entityIDs[i].getType(),entityIDs[i].getEid()))
        {
            nDrawArrowFrom++;
        }
        if (rModel.getColorByPatch(entityIDs[i].getType(),entityIDs[i].getEid()))
        {
            nColorByPatch++;
        }
        if (rModel.getColorByViewFactor(entityIDs[i].getType(),entityIDs[i].getEid()))
        {
            nColorByViewFactor++;
        }
        color = rModel.getColor(entityIDs[i].getType(),entityIDs[i].getEid());

        switch (entityIDs[i].getType())
        {
            case R_ENTITY_GROUP_VOLUME:
            case R_ENTITY_GROUP_SURFACE:
                canDrawNodes = canDrawElementNums = canDrawNodeNums = true;
                canDrawWire = canDrawEdges = true;
                break;
            case R_ENTITY_GROUP_LINE:
            case R_ENTITY_GROUP_POINT:
                canDrawNodes = canDrawElementNums = canDrawNodeNums = true;
                canDrawWire = true;
                break;
            case R_ENTITY_GROUP_VECTOR_FIELD:
                canDrawArrowHeads = true;
                canDrawEqualArrowLengths = true;
                canDrawArrowFrom = true;
                break;
            case R_ENTITY_GROUP_SCALAR_FIELD:
                break;
            case R_ENTITY_GROUP_CUT:
            case R_ENTITY_GROUP_ISO:
                canDrawNodes = canDrawWire = canDrawEdges = true;
                break;
            case R_ENTITY_GROUP_STREAM_LINE:
            default:
                break;
        }
    }

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        const Model &amp;rModel = Session::getInstance().getModel(modelIDs[i]);

        if (!canColorByPatch)
        {
            canColorByPatch = rModel.canColorByPatch();
        }
        if (!canColorByViewFactor)
        {
            canColorByViewFactor = rModel.canColorByViewFactor();
        }
    }

    Qt::CheckState csDrawWire = Qt::Unchecked;
    Qt::CheckState csDrawEdges = Qt::Unchecked;
    Qt::CheckState csDrawNodes = Qt::Unchecked;
    Qt::CheckState csDrawElementNums = Qt::Unchecked;
    Qt::CheckState csDrawNodeNums = Qt::Unchecked;
    Qt::CheckState csDrawArrowHeads = Qt::Unchecked;
    Qt::CheckState csDrawEqualArrowLengths = Qt::Unchecked;
    Qt::CheckState csDrawArrowFrom = Qt::Unchecked;
    Qt::CheckState csColorByPatch = Qt::Unchecked;
    Qt::CheckState csColorByViewFactor = Qt::Unchecked;
    if (nDrawWire &gt; 0)
    {
        csDrawWire = (nDrawWire == entityIDs.size()) ? Qt::Checked : Qt::PartiallyChecked;
    }
    if (nDrawEdges &gt; 0)
    {
        csDrawEdges = (nDrawEdges == entityIDs.size()) ? Qt::Checked : Qt::PartiallyChecked;
    }
    if (nDrawNodes &gt; 0)
    {
        csDrawNodes = (nDrawNodes == entityIDs.size()) ? Qt::Checked : Qt::PartiallyChecked;
    }
    if (nDrawElementNums &gt; 0)
    {
        csDrawElementNums = (nDrawElementNums == entityIDs.size()) ? Qt::Checked : Qt::PartiallyChecked;
    }
    if (nDrawNodeNums &gt; 0)
    {
        csDrawNodeNums = (nDrawNodeNums == entityIDs.size()) ? Qt::Checked : Qt::PartiallyChecked;
    }
    if (nDrawArrowHeads &gt; 0)
    {
        csDrawArrowHeads = (nDrawArrowHeads == entityIDs.size()) ? Qt::Checked : Qt::PartiallyChecked;
    }
    if (nDrawEqualArrowLengths &gt; 0)
    {
        csDrawEqualArrowLengths = (nDrawEqualArrowLengths == entityIDs.size()) ? Qt::Checked : Qt::PartiallyChecked;
    }
    if (nDrawArrowFrom &gt; 0)
    {
        csDrawArrowFrom = (nDrawArrowFrom == entityIDs.size()) ? Qt::Checked : Qt::PartiallyChecked;
    }
    if (nColorByPatch &gt; 0)
    {
        csColorByPatch = (nColorByPatch == entityIDs.size()) ? Qt::Checked : Qt::PartiallyChecked;
    }
    if (nColorByViewFactor &gt; 0)
    {
        csColorByViewFactor = (nColorByViewFactor == entityIDs.size()) ? Qt::Checked : Qt::PartiallyChecked;
    }

    QTreeWidgetItem *item;

    if (canDrawWire)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(DP_TREE_COLUMN_NAME,tr("Draw as wireframe"));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(csDrawWire));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::UserRole,QVariant(DISPLAY_PROPERTY_DRAW_WIRE));
    }

    if (canDrawEdges)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(DP_TREE_COLUMN_NAME,tr("Draw element edges"));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(csDrawEdges));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::UserRole,QVariant(DISPLAY_PROPERTY_DRAW_EDGES));
    }

    if (canDrawNodes)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(DP_TREE_COLUMN_NAME,tr("Draw element nodes"));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(csDrawNodes));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::UserRole,QVariant(DISPLAY_PROPERTY_DRAW_NODES));
    }

    if (canDrawElementNums)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(DP_TREE_COLUMN_NAME,tr("Draw element numbers"));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(csDrawElementNums));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::UserRole,QVariant(DISPLAY_PROPERTY_DRAW_ELEMENT_NUMS));
    }

    if (canDrawNodeNums)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(DP_TREE_COLUMN_NAME,tr("Draw node numbers"));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(csDrawNodeNums));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::UserRole,QVariant(DISPLAY_PROPERTY_DRAW_NODE_NUMS));
    }

    if (canDrawArrowHeads)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(DP_TREE_COLUMN_NAME,tr("Draw arrow heads"));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(csDrawArrowHeads));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::UserRole,QVariant(DISPLAY_PROPERTY_DRAW_ARROW_HEADS));
    }

    if (canDrawEqualArrowLengths)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(DP_TREE_COLUMN_NAME,tr("Draw arrows with same length"));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(csDrawEqualArrowLengths));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::UserRole,QVariant(DISPLAY_PROPERTY_DRAW_EQUAL_ARROW_LENGTHS));
    }

    if (canDrawArrowFrom)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(DP_TREE_COLUMN_NAME,tr("Draw arrows pointing from"));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(csDrawArrowFrom));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::UserRole,QVariant(DISPLAY_PROPERTY_DRAW_ARROW_FROM));
    }

    if (canColorByPatch)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(DP_TREE_COLUMN_NAME,tr("Color elements by surface patch ID"));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(csColorByPatch));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::UserRole,QVariant(DISPLAY_PROPERTY_COLOR_BY_PATCH));
    }

    if (canColorByViewFactor)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(DP_TREE_COLUMN_NAME,tr("Color elements by view-factor"));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(csColorByViewFactor));
        item-&gt;setData(DP_TREE_COLUMN_NAME,Qt::UserRole,QVariant(DISPLAY_PROPERTY_COLOR_BY_VIEW_FACTOR));
    }

    item = new QTreeWidgetItem(this);
    ColorComboBox *colorCombo = new ColorComboBox(this);
    colorCombo-&gt;setColor(color);
    this-&gt;connect(colorCombo,SIGNAL(colorChanged(QColor)),SLOT(onColorChanged(QColor)));

    this-&gt;setItemWidget(item,DP_TREE_COLUMN_NAME,colorCombo);
    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101525.193">void ModelEntityDisplayPropertiesTree::onModelSelectionChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101525.194">void ModelEntityDisplayPropertiesTree::onModelChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101525.195">void ModelEntityDisplayPropertiesTree::onProblemChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101525.196">void ModelEntityDisplayPropertiesTree::onItemChanged(QTreeWidgetItem *item, int column)
{
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();
    if (column == DP_TREE_COLUMN_NAME)
    {
        DisplayPropertyType type = (DisplayPropertyType) item-&gt;data(DP_TREE_COLUMN_NAME,Qt::UserRole).toInt();

        for (int i=0;i&lt;entityIDs.size();i++)
        {
            Model *pModel = Session::getInstance().getModelPtr(entityIDs[i].getMid());

            if (type == DISPLAY_PROPERTY_DRAW_WIRE)
            {
                if (item-&gt;checkState(column) == Qt::Checked)
                {
                    pModel-&gt;setDrawWire(entityIDs[i].getType(), entityIDs[i].getEid(), true);
                }
                else if (item-&gt;checkState(column) == Qt::Unchecked)
                {
                    pModel-&gt;setDrawWire(entityIDs[i].getType(), entityIDs[i].getEid(), false);
                }
            }
            else if (type == DISPLAY_PROPERTY_DRAW_EDGES)
            {
                if (item-&gt;checkState(column) == Qt::Checked)
                {
                    pModel-&gt;setDrawEdges(entityIDs[i].getType(), entityIDs[i].getEid(), true);
                }
                else if (item-&gt;checkState(column) == Qt::Unchecked)
                {
                    pModel-&gt;setDrawEdges(entityIDs[i].getType(), entityIDs[i].getEid(), false);
                }
            }
            else if (type == DISPLAY_PROPERTY_DRAW_NODES)
            {
                if (item-&gt;checkState(column) == Qt::Checked)
                {
                    pModel-&gt;setDrawNodes(entityIDs[i].getType(), entityIDs[i].getEid(), true);
                }
                else if (item-&gt;checkState(column) == Qt::Unchecked)
                {
                    pModel-&gt;setDrawNodes(entityIDs[i].getType(), entityIDs[i].getEid(), false);
                }
            }
            else if (type == DISPLAY_PROPERTY_DRAW_ELEMENT_NUMS)
            {
                if (item-&gt;checkState(column) == Qt::Checked)
                {
                    pModel-&gt;setDrawElementNumbers(entityIDs[i].getType(), entityIDs[i].getEid(), true);
                }
                else if (item-&gt;checkState(column) == Qt::Unchecked)
                {
                    pModel-&gt;setDrawElementNumbers(entityIDs[i].getType(), entityIDs[i].getEid(), false);
                }
            }
            else if (type == DISPLAY_PROPERTY_DRAW_NODE_NUMS)
            {
                if (item-&gt;checkState(column) == Qt::Checked)
                {
                    pModel-&gt;setDrawNodeNumbers(entityIDs[i].getType(), entityIDs[i].getEid(), true);
                }
                else if (item-&gt;checkState(column) == Qt::Unchecked)
                {
                    pModel-&gt;setDrawNodeNumbers(entityIDs[i].getType(), entityIDs[i].getEid(), false);
                }
            }
            else if (type == DISPLAY_PROPERTY_DRAW_ARROW_HEADS)
            {
                if (item-&gt;checkState(column) == Qt::Checked)
                {
                    pModel-&gt;setDrawArrowHeads(entityIDs[i].getType(), entityIDs[i].getEid(), true);
                }
                else if (item-&gt;checkState(column) == Qt::Unchecked)
                {
                    pModel-&gt;setDrawArrowHeads(entityIDs[i].getType(), entityIDs[i].getEid(), false);
                }
            }
            else if (type == DISPLAY_PROPERTY_DRAW_EQUAL_ARROW_LENGTHS)
            {
                if (item-&gt;checkState(column) == Qt::Checked)
                {
                    pModel-&gt;setDrawEqualArrowLengths(entityIDs[i].getType(), entityIDs[i].getEid(), true);
                }
                else if (item-&gt;checkState(column) == Qt::Unchecked)
                {
                    pModel-&gt;setDrawEqualArrowLengths(entityIDs[i].getType(), entityIDs[i].getEid(), false);
                }
            }
            else if (type == DISPLAY_PROPERTY_DRAW_ARROW_FROM)
            {
                if (item-&gt;checkState(column) == Qt::Checked)
                {
                    pModel-&gt;setDrawArrowFrom(entityIDs[i].getType(), entityIDs[i].getEid(), true);
                }
                else if (item-&gt;checkState(column) == Qt::Unchecked)
                {
                    pModel-&gt;setDrawArrowFrom(entityIDs[i].getType(), entityIDs[i].getEid(), false);
                }
            }
            else if (type == DISPLAY_PROPERTY_COLOR_BY_PATCH)
            {
                if (item-&gt;checkState(column) == Qt::Checked)
                {
                    pModel-&gt;setColorByPatch(entityIDs[i].getType(), entityIDs[i].getEid(), true);
                }
                else if (item-&gt;checkState(column) == Qt::Unchecked)
                {
                    pModel-&gt;setColorByPatch(entityIDs[i].getType(), entityIDs[i].getEid(), false);
                }
            }
            else if (type == DISPLAY_PROPERTY_COLOR_BY_VIEW_FACTOR)
            {
                if (item-&gt;checkState(column) == Qt::Checked)
                {
                    pModel-&gt;setColorByViewFactor(entityIDs[i].getType(), entityIDs[i].getEid(), true);
                }
                else if (item-&gt;checkState(column) == Qt::Unchecked)
                {
                    pModel-&gt;setColorByViewFactor(entityIDs[i].getType(), entityIDs[i].getEid(), false);
                }
            }
            Session::getInstance().setDisplayPropertiesChanged(entityIDs[i].getMid(),entityIDs[i].getType(),entityIDs[i].getEid());
        }
    }
}

</t>
<t tx="leo.20201108101525.197">void ModelEntityDisplayPropertiesTree::onColorChanged(QColor color)
{
    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();
    for (int i=0;i&lt;entityIDs.size();i++)
    {
        Model *pModel = Session::getInstance().getModelPtr(entityIDs[i].getMid());
        pModel-&gt;setColor(entityIDs[i].getType(), entityIDs[i].getEid(), color);

        Session::getInstance().setDisplayPropertiesChanged(entityIDs[i].getMid(),entityIDs[i].getType(),entityIDs[i].getEid());
    }
}
</t>
<t tx="leo.20201108101525.198">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model_entity_geometric_properties_tree.cpp               *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   27-th June 2013                                          *
 *                                                                   *
 *  DESCRIPTION: Entity geometric properties tree class definition   *
 *********************************************************************/

#include &lt;rmlib.h&gt;

#include "session.h"
#include "model_entity_geometric_properties_tree.h"
#include "value_line_edit.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101525.199">typedef enum _GeometricPropertyType
{
    GEOMETRY_PROPERTY_NONE = 0,
    GEOMETRY_PROPERTY_VOLUME,
    GEOMETRY_PROPERTY_CROSS_AREA,
    GEOMETRY_PROPERTY_THICKNESS,
    GEOMETRY_PROPERTY_N_TYPES
} GeometricPropertyType;

</t>
<t tx="leo.20201108101525.2">int MeshGeneratorDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        this-&gt;updateMeshInput();

        if (this-&gt;meshInput.getUseSizeFunction())
        {
            RVariableType meshSizeFunctionVariableType = RVariableType(this-&gt;meshSizeFunctionSourceComboBox-&gt;currentData().toInt());
            double meshSizeFunctionMinValue = this-&gt;meshSizeFunctionMinValueEdit-&gt;getValue();
            double meshSizeFunctionMaxValue = this-&gt;meshSizeFunctionMaxValueEdit-&gt;getValue();

            Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

            QSet&lt;RVariableType&gt; variableList;
            variableList.insert(meshSizeFunctionVariableType);
            RRVector meshSizeFunction = rModel.generateMeshSizeFunction(variableList,
                                                                        meshSizeFunctionMinValue,
                                                                        meshSizeFunctionMaxValue,
                                                                        0.5);
            this-&gt;meshInput.setSizeFunctionValues(meshSizeFunction);
        }

        Session::getInstance().getModel(this-&gt;modelID).setMeshInput(this-&gt;meshInput);

        MeshGenerator *meshGenerator = new MeshGenerator(this-&gt;modelID);
        JobManager::getInstance().submit(meshGenerator);
    }
    return retVal;
}

</t>
<t tx="leo.20201108101525.20">void ModalSetupWidget::onNModesExtractChanged(int nModes)
{
    this-&gt;modalSetup.setNModesToExtract(uint(nModes));
    emit this-&gt;changed(this-&gt;modalSetup);
}

</t>
<t tx="leo.20201108101525.200">typedef enum _GeometricPropertiesTreeColumn
{
    GP_TREE_COLUMN_NAME = 0,
    GP_TREE_COLUMN_VALUE,
    GP_TREE_COLUMN_UNITS,
    GP_TREE_N_COLUMNS
} GeometricPropertiesTreeColumn;

ModelEntityGeometricPropertiesTree::ModelEntityGeometricPropertiesTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setColumnCount(GP_TREE_N_COLUMNS);
    this-&gt;setSelectionMode(QAbstractItemView::NoSelection);
    this-&gt;setRootIsDecorated(false);
    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(GP_TREE_COLUMN_NAME,QString("Geometric properties"));
    headerItem-&gt;setText(GP_TREE_COLUMN_VALUE,QString("Value"));
    headerItem-&gt;setText(GP_TREE_COLUMN_UNITS,QString("Units"));
    headerItem-&gt;setFirstColumnSpanned(true);
    this-&gt;setHeaderItem(headerItem);

    QObject::connect(&amp;Session::getInstance(),&amp;Session::modelSelectionChanged,
                     this,&amp;ModelEntityGeometricPropertiesTree::onModelSelectionChanged);
    QObject::connect(this,&amp;ModelEntityGeometricPropertiesTree::itemChanged,
                     this,&amp;ModelEntityGeometricPropertiesTree::onItemChanged);
    QObject::connect(this,&amp;ModelEntityGeometricPropertiesTree::itemDoubleClicked,
                     this,&amp;ModelEntityGeometricPropertiesTree::onItemDoubleClicked);

    this-&gt;populate();
}

</t>
<t tx="leo.20201108101525.201">void ModelEntityGeometricPropertiesTree::populate(void)
{
    this-&gt;clear();

    this-&gt;resizeColumnToContents(GP_TREE_COLUMN_NAME);
    this-&gt;resizeColumnToContents(GP_TREE_COLUMN_VALUE);
    this-&gt;resizeColumnToContents(GP_TREE_COLUMN_UNITS);

    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();
    if (entityIDs.size() == 0)
    {
        return;
    }

    double pointVolume = 0.0;
    double lineCrossArea = 0.0;
    double surfaceThickness = 0.0;

    bool hasVolume = false;
    bool hasCrossArea = false;
    bool hasThisckness = false;

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs[i].getType() == R_ENTITY_GROUP_POINT &amp;&amp; !hasVolume)
        {
            pointVolume = Session::getInstance().getModel(entityIDs[i].getMid()).getPoint(entityIDs[i].getEid()).getVolume();
            hasVolume = true;
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_LINE &amp;&amp; !hasCrossArea)
        {
            lineCrossArea = Session::getInstance().getModel(entityIDs[i].getMid()).getLine(entityIDs[i].getEid()).getCrossArea();
            hasCrossArea = true;
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_SURFACE &amp;&amp; !hasThisckness)
        {
            surfaceThickness = Session::getInstance().getModel(entityIDs[i].getMid()).getSurface(entityIDs[i].getEid()).getThickness();
            hasThisckness = true;
        }
    }

    this-&gt;blockSignals(true);

    if (hasVolume)
    {
        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setText(GP_TREE_COLUMN_NAME,tr("Point volume"));
        item-&gt;setText(GP_TREE_COLUMN_VALUE,QString::number(pointVolume));
        item-&gt;setData(GP_TREE_COLUMN_VALUE,Qt::UserRole,QVariant(GEOMETRY_PROPERTY_VOLUME));
        item-&gt;setText(GP_TREE_COLUMN_UNITS,RVariable::getUnits(R_VARIABLE_VOLUME));
    }

    if (hasCrossArea)
    {
        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setText(GP_TREE_COLUMN_NAME,tr("Line cross area"));
        item-&gt;setText(GP_TREE_COLUMN_VALUE,QString::number(lineCrossArea));
        item-&gt;setData(GP_TREE_COLUMN_VALUE,Qt::UserRole,QVariant(GEOMETRY_PROPERTY_CROSS_AREA));
        item-&gt;setText(GP_TREE_COLUMN_UNITS,RVariable::getUnits(R_VARIABLE_AREA));
    }

    if (hasThisckness)
    {
        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setText(GP_TREE_COLUMN_NAME,tr("Surface thickness"));
        item-&gt;setText(GP_TREE_COLUMN_VALUE,QString::number(surfaceThickness));
        item-&gt;setData(GP_TREE_COLUMN_VALUE,Qt::UserRole,QVariant(GEOMETRY_PROPERTY_THICKNESS));
        item-&gt;setText(GP_TREE_COLUMN_UNITS,RVariable::getUnits(R_VARIABLE_LENGTH));
    }

    this-&gt;blockSignals(false);

    this-&gt;resizeColumnToContents(GP_TREE_COLUMN_NAME);
    this-&gt;resizeColumnToContents(GP_TREE_COLUMN_VALUE);
    this-&gt;resizeColumnToContents(GP_TREE_COLUMN_UNITS);
}

</t>
<t tx="leo.20201108101525.202">void ModelEntityGeometricPropertiesTree::onModelSelectionChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101525.203">void ModelEntityGeometricPropertiesTree::onItemChanged(QTreeWidgetItem *item, int column)
{
    if (column != GP_TREE_COLUMN_VALUE)
    {
        return;
    }

    GeometricPropertyType type = GeometricPropertyType(item-&gt;data(GP_TREE_COLUMN_VALUE,Qt::UserRole).toInt());
    double value = QString(item-&gt;text(GP_TREE_COLUMN_VALUE)).toDouble();

    if (value &lt; 0.0)
    {
        item-&gt;setText(GP_TREE_COLUMN_VALUE,QString::number(0.0));
        return;
    }
    else if (value &gt; 1.0e99)
    {
        item-&gt;setText(GP_TREE_COLUMN_VALUE,QString::number(1.0e99));
        return;
    }

    QList&lt;uint&gt; selectedModeIDs = Session::getInstance().getSelectedModelIDs();
    for (int i=0;i&lt;selectedModeIDs.size();i++)
    {
        Session::getInstance().storeCurentModelVersion(selectedModeIDs[i],tr("Change geometric properties"));
    }

    QList&lt;SessionEntityID&gt; entityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;entityIDs.size();i++)
    {
        if (entityIDs[i].getType() == R_ENTITY_GROUP_POINT &amp;&amp; type == GEOMETRY_PROPERTY_VOLUME)
        {
            Session::getInstance().getModel(entityIDs[i].getMid()).getPoint(entityIDs[i].getEid()).setVolume(value);
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_LINE &amp;&amp; type == GEOMETRY_PROPERTY_CROSS_AREA)
        {
            Session::getInstance().getModel(entityIDs[i].getMid()).getLine(entityIDs[i].getEid()).setCrossArea(value);
        }
        else if (entityIDs[i].getType() == R_ENTITY_GROUP_SURFACE &amp;&amp; type == GEOMETRY_PROPERTY_THICKNESS)
        {
            Session::getInstance().getModel(entityIDs[i].getMid()).getSurface(entityIDs[i].getEid()).setThickness(value);
        }
    }

    for (int i=0;i&lt;selectedModeIDs.size();i++)
    {
        Session::getInstance().setModelChanged(selectedModeIDs[i]);
    }
}

</t>
<t tx="leo.20201108101525.204">void ModelEntityGeometricPropertiesTree::onItemDoubleClicked(QTreeWidgetItem *item, int column)
{
     this-&gt;blockSignals(true);
     if (column == GP_TREE_COLUMN_VALUE)
     {
         item-&gt;setFlags(item-&gt;flags() | Qt::ItemIsEditable);
     }
     else
     {
         if (item-&gt;flags() &amp; Qt::ItemIsEditable)
         {
             item-&gt;setFlags(item-&gt;flags() ^ Qt::ItemIsEditable);
         }
     }
     this-&gt;blockSignals(false);
}
</t>
<t tx="leo.20201108101525.205">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model_io.cpp                                             *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   16-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Model IO class definition                           *
 *********************************************************************/

#include &lt;QFileInfo&gt;
#include &lt;QFileDialog&gt;

#include "model_io.h"
#include "session.h"

ModelIO::ModelIO(ModelIOType    type,
                 @others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101525.206">                 const QString &amp;fileName,
                 Model         *pModel,
                 QObject       *parent) : Job(parent)
{
    this-&gt;type = type;
    this-&gt;fileName = fileName;
    this-&gt;pModel = pModel;
}

QString ModelIO::findNewModelName(const QString &amp;fileName)
{
    QString modelBaseName = QFileInfo(fileName).baseName();
    QString modelName = modelBaseName;
    uint nTries = 2;
    while (Session::getInstance().findModelByName(modelName) != RConstants::eod)
    {
        modelName = modelBaseName + " [" + QString::number(nTries) + "]";
        nTries++;
    }
    return modelName;
}

QString ModelIO::getModelSaveName(const MainSettings &amp;mainSettings, QWidget *parent, const Model &amp;rModel, bool saveAs)
{
    QDir dataDir(mainSettings.getDataDir());
    QString binaryExtension = RModel::getDefaultFileExtension(true);
    QString asciiExtension = RModel::getDefaultFileExtension(false);
    QString dialogDesc = "Range model files (*." + binaryExtension + " *." + asciiExtension + ");;Any files (*)";

    QString fileName = RFileManager::getFileNameWithOutTimeStep(rModel.getFileName());
    if (saveAs)
    {
        fileName = QFileDialog::getSaveFileName(parent,
                                                "Save model as",
                                                fileName,
                                                dialogDesc);
    }
    else
    {
        if (fileName.isEmpty())
        {
            fileName = dataDir.filePath(rModel.getName() + "." + binaryExtension);
            fileName = QFileDialog::getSaveFileName(parent,
                                                    "Save model",
                                                    fileName,
                                                    dialogDesc);
        }
    }

    return fileName;
}

</t>
<t tx="leo.20201108101525.207">void ModelIO::save(Model &amp;rModel, const QString &amp;fileName, bool writeLinkFile)
{
    RLogger::info("Saving model to file \'%s\'.\n", fileName.toUtf8().constData());
    RLogger::indent();

    try
    {
        rModel.write(fileName,writeLinkFile);

        RLogger::unindent();
        RLogger::info("Model has been successfully saved to file \'%s\'.\n", fileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Failed to save model to file \'%s\'.\n", fileName.toUtf8().constData());
        throw error;
    }
}

</t>
<t tx="leo.20201108101525.208">void ModelIO::open(Model &amp;rModel, const QString &amp;fileName)
{
    RLogger::info("Loading model file \'%s\'.\n", fileName.toUtf8().constData());
    RLogger::indent();

    try
    {
        rModel.read(fileName);

        RLogger::unindent();
        RLogger::info("Model has been successfully loaded from file \'%s\'.\n", fileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Failed to load model from file \'%s\'.\n", fileName.toUtf8().constData());
        throw error;
    }
}

</t>
<t tx="leo.20201108101525.209">void ModelIO::update(Model &amp;rModel, const QString &amp;fileName)
{
    RLogger::info("Updating model from file \'%s\'.\n", fileName.toUtf8().constData());
    RLogger::indent();

    try
    {
        RModel tmpModel;

        tmpModel.read(fileName);

        rModel.update(tmpModel);

        RLogger::unindent();
        RLogger::info("Model has been successfully updated from file \'%s\'.\n", fileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Failed to update from file \'%s\'.\n", fileName.toUtf8().constData());
        throw error;
    }
}

</t>
<t tx="leo.20201108101525.21">void ModalSetupWidget::onConvergenceValueChanged(double convergenceValue)
{
    this-&gt;modalSetup.setConvergenceValue(convergenceValue);
    emit this-&gt;changed(this-&gt;modalSetup);
}
</t>
<t tx="leo.20201108101525.210">void ModelIO::exportMsh(Model &amp;rModel, const QString &amp;fileName)
{
    RModelMsh modelMsh;
    rModel.exportTo(modelMsh);

    RLogger::info("Exporting MSH file \'%s\'.\n", fileName.toUtf8().constData());
    RLogger::indent();

    try
    {
        modelMsh.write(fileName);

        RLogger::unindent();
        RLogger::info("MSH file \'%s\' has been successfully exported.\n", fileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Failed to export MSH file \'%s\'.\n", fileName.toUtf8().constData());
        throw error;
    }
}

</t>
<t tx="leo.20201108101525.211">void ModelIO::importMsh(Model &amp;rModel, const QString &amp;fileName)
{
    RModelMsh modelMsh;

    RLogger::info("Importing MSH file \'%s\'.\n", fileName.toUtf8().constData());
    RLogger::indent();

    try
    {
        modelMsh.read(fileName);

        rModel = Model(modelMsh);

        RLogger::unindent();
        RLogger::info("MSH file \'%s\' has been successfully imported.\n", fileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Failed to import MSH file \'%s\'.\n", fileName.toUtf8().constData());
        throw error;
    }
}

</t>
<t tx="leo.20201108101525.212">void ModelIO::exportRaw(Model &amp;rModel, const QString &amp;fileName)
{
    RModelRaw modelRaw;
    rModel.exportTo(modelRaw);

    RLogger::info("Exporting RAW file \'%s\'.\n", fileName.toUtf8().constData());
    RLogger::indent();

    try
    {
        modelRaw.write(fileName);

        RLogger::unindent();
        RLogger::info("RAW file \'%s\' has been successfully exported.\n", fileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Failed to export RAW file \'%s\'.\n", fileName.toUtf8().constData());
        throw error;
    }
}

</t>
<t tx="leo.20201108101525.213">void ModelIO::importRaw(Model &amp;rModel, const QString &amp;fileName)
{
    RModelRaw modelRaw;
    double tolerance = 0.0;

    RLogger::info("Importing RAW file \'%s\'.\n", fileName.toUtf8().constData());
    RLogger::indent();

    try
    {
        modelRaw.read(fileName, tolerance);

        rModel = Model(modelRaw,ModelIO::findNewModelName(fileName).toUtf8().constData());

        RLogger::unindent();
        RLogger::info("RAW file \'%s\' has been successfully imported.\n", fileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Failed to import RAW file \'%s\'.\n", fileName.toUtf8().constData());
        throw error;
    }
}

</t>
<t tx="leo.20201108101525.214">void ModelIO::exportStl(Model &amp;rModel, const QString &amp;fileName, bool binary)
{
    RModelStl modelStl;
    rModel.exportTo(modelStl);

    RLogger::info("Exporting STL (%s) file \'%s\'.\n", binary?"binary":"ascii", fileName.toUtf8().constData());
    RLogger::indent();

    try
    {
        modelStl.write(fileName,binary);

        RLogger::unindent();
        RLogger::info("STL (%s) file \'%s\' has been successfully exported.\n", binary?"binary":"ascii", fileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Failed to export STL file \'%s\'.\n", fileName.toUtf8().constData());
        throw error;
    }
}

</t>
<t tx="leo.20201108101525.215">void ModelIO::importStl(Model &amp;rModel, const QString &amp;fileName)
{
    RModelStl modelStl;
    double tolerance = 0.0;

    RLogger::info("Importing STL file \'%s\'.\n", fileName.toUtf8().constData());
    RLogger::indent();

    try
    {
        modelStl.read(fileName, tolerance);

        rModel = Model(modelStl);

        RLogger::unindent();
        RLogger::info("STL file \'%s\' has been successfully imported.\n", fileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Failed to import STL file \'%s\'.\n", fileName.toUtf8().constData());
        throw error;
    }
}

</t>
<t tx="leo.20201108101525.216">void ModelIO::run(void)
{
    try
    {
        if (this-&gt;type == MODEL_IO_ADD)
        {
            Session::getInstance().addModel(*this-&gt;pModel);
            Session::getInstance().setModelSelected(Session::getInstance().getNModels()-1,true);
            delete this-&gt;pModel;
        }
        else if (this-&gt;type == MODEL_IO_SAVE)
        {
            ModelIO::save((*this-&gt;pModel),this-&gt;fileName,true);
        }
        else if (this-&gt;type == MODEL_IO_OPEN)
        {
            Model model;
            ModelIO::open(model,this-&gt;fileName);
            Session::getInstance().addModel(model);
        }
        else if (this-&gt;type == MODEL_IO_UPDATE)
        {
            uint updateModelID = Session::getInstance().findModelByPtr(this-&gt;pModel);
            if (updateModelID != RConstants::eod)
            {
                Session::getInstance().storeCurentModelVersion(updateModelID,tr("Update model from file"));
            }
            ModelIO::update((*this-&gt;pModel),this-&gt;fileName);
            if (updateModelID != RConstants::eod)
            {
                Session::getInstance().setModelChanged(updateModelID);
            }
        }
        else if (this-&gt;type == MODEL_IO_MSH_EXPORT)
        {
            ModelIO::exportMsh((*this-&gt;pModel),this-&gt;fileName);
        }
        else if (this-&gt;type == MODEL_IO_MSH_IMPORT)
        {
            Model model;
            ModelIO::importMsh(model,this-&gt;fileName);
            Session::getInstance().addModel(model);
        }
        else if (this-&gt;type == MODEL_IO_RAW_EXPORT)
        {
            ModelIO::exportRaw((*this-&gt;pModel),this-&gt;fileName);
        }
        else if (this-&gt;type == MODEL_IO_RAW_IMPORT)
        {
            Model model;
            ModelIO::importRaw(model,this-&gt;fileName);
            Session::getInstance().addModel(model);
        }
        else if (this-&gt;type == MODEL_IO_STL_ASCII_EXPORT)
        {
            ModelIO::exportStl((*this-&gt;pModel),this-&gt;fileName,false);
        }
        else if (this-&gt;type == MODEL_IO_STL_BINARY_EXPORT)
        {
            ModelIO::exportStl((*this-&gt;pModel),this-&gt;fileName);
        }
        else if (this-&gt;type == MODEL_IO_STL_IMPORT)
        {
            Model model;
            ModelIO::importStl(model,this-&gt;fileName);
            Session::getInstance().addModel(model);
        }
    }
    catch (const RError &amp;error)
    {
        RLogger::error("%s File: '%s'\n",
                       error.getMessage().toUtf8().constData(),
                       fileName.toUtf8().constData());
    }
}
</t>
<t tx="leo.20201108101525.217">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model_records_widget.cpp                                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th September 2013                                      *
 *                                                                   *
 *  DESCRIPTION: Model records widget class definition               *
 *********************************************************************/

#include &lt;QAction&gt;
#include &lt;QIcon&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QToolBar&gt;
#include &lt;QCheckBox&gt;

#include &lt;rblib.h&gt;

#include "job_manager.h"
#include "model_records_selector.h"
#include "model_io.h"
#include "session.h"
#include "main_window.h"
#include "video_output.h"
#include "video_settings_dialog.h"

ModelRecordsSelector::ModelRecordsSelector(QWidget *parent)
    : QWidget(parent)
    , markNextIndicator(false)
    , recordIndicator(false)
{
    QVBoxLayout *layout = new QVBoxLayout;
    layout-&gt;setSpacing(0);
    layout-&gt;setMargin(0);
    this-&gt;setLayout(layout);

    this-&gt;tree = new ModelRecordsTree;
    layout-&gt;addWidget(this-&gt;tree);

    QObject::connect(this-&gt;tree,
                     &amp;ModelRecordsTree::recordMarked,
                     this,
                     &amp;ModelRecordsSelector::onRecordMarked);

    QToolBar *toolBar = new QToolBar;
    layout-&gt;addWidget(toolBar);

    QList&lt;QAction*&gt; actions;

    actions.append(new QAction(QIcon(":/icons/media/pixmaps/range-play_first.svg"),"First",this));
    QObject::connect(actions.last(), &amp;QAction::triggered, this-&gt;tree, &amp;ModelRecordsTree::markFirst);

    actions.append(new QAction(QIcon(":/icons/media/pixmaps/range-play_backward.svg"),"Backward",this));
    QObject::connect(actions.last(), &amp;QAction::triggered, this-&gt;tree, &amp;ModelRecordsTree::markPrevious);

    actions.append(new QAction(QIcon(":/icons/media/pixmaps/range-play_play.svg"),"Play",this));
    QObject::connect(actions.last(), &amp;QAction::triggered, this, &amp;ModelRecordsSelector::playToggle);
    this-&gt;playAction = actions.last();

    actions.append(new QAction(QIcon(":/icons/media/pixmaps/range-play_forward.svg"),"Forward",this));
    QObject::connect(actions.last(), &amp;QAction::triggered, this-&gt;tree, &amp;ModelRecordsTree::markNext);

    actions.append(new QAction(QIcon(":/icons/media/pixmaps/range-play_last.svg"),"Last",this));
    QObject::connect(actions.last(), &amp;QAction::triggered, this-&gt;tree, &amp;ModelRecordsTree::markLast);

    toolBar-&gt;addActions(actions);

    QWidget* empty = new QWidget();
    empty-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Preferred);
    toolBar-&gt;addWidget(empty);

    actions.clear();

    actions.append(new QAction(QIcon(":/icons/media/pixmaps/range-play_record.svg"),"Record",this));
    QObject::connect(actions.last(), &amp;QAction::triggered, this, &amp;ModelRecordsSelector::onRecordVideo);
    this-&gt;recordAction = actions.last();

    toolBar-&gt;addActions(actions);

    QObject::connect(this,&amp;ModelRecordsSelector::recordFinished,this,&amp;ModelRecordsSelector::onRecordFinished);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101525.218">void ModelRecordsSelector::createAnimation(bool modelID)
{
    Model &amp;rModel = Session::getInstance().getModel(modelID);

    std::vector&lt;double&gt; &amp;rTimes = rModel.getTimeSolver().getTimes();

    QList&lt;QString&gt; imageFileNames;

    for (uint j=0;j&lt;rTimes.size();j++)
    {
        QString recordFileName(RFileManager::getFileNameWithTimeStep(rModel.getFileName(),j+1));
        QString imageFileName(RFileManager::getFileNameWithTimeStep(rModel.buildScreenShotFileName(),j+1));
        if (RFileManager::fileExists(recordFileName) &amp;&amp; RFileManager::fileExists(imageFileName))
        {
            imageFileNames.append(imageFileName);
        }
    }

    if (imageFileNames.size() &gt; 0)
    {
        QString fileName(rModel.buildAnimationFileName(this-&gt;videoSettings.getFormat()));

        RLogger::info("Creating animation file \'%s\'\n",fileName.toUtf8().constData());

        VideoOutput videoOutput;
        videoOutput.setStreamRate(this-&gt;videoSettings.getFps());
        videoOutput.setResolution(this-&gt;videoSettings.getWidth(),this-&gt;videoSettings.getHeight());
        if (!videoOutput.openMediaFile(this-&gt;videoSettings.getWidth(),this-&gt;videoSettings.getHeight(),fileName))
        {
            RLogger::error("Failed to create animation file \'%s\'\n",fileName.toUtf8().constData());
            return;
        }

        uint cnt=0;
        foreach (const QString &amp;imageFileName, imageFileNames)
        {
            QImage image;
            if (!image.load(imageFileName))
            {
                RLogger::error("Failed to load image file \'%s\'\n",imageFileName.toUtf8().constData());
                return;
            }
            QImage sImage = image.scaled(this-&gt;videoSettings.getWidth(),this-&gt;videoSettings.getHeight(),Qt::KeepAspectRatio,Qt::SmoothTransformation);
            if (sImage.isNull())
            {
                RLogger::error("Failed to scale image\n");
                return;
            }
            if (sImage.height() &gt; int(this-&gt;videoSettings.getHeight()))
            {
                sImage = image.scaled(this-&gt;videoSettings.getWidth(),this-&gt;videoSettings.getHeight(),Qt::KeepAspectRatioByExpanding,Qt::SmoothTransformation);
                if (sImage.isNull())
                {
                    RLogger::error("Failed to scale image\n");
                    return;
                }
            }

            QImage fImage(this-&gt;videoSettings.getWidth(),this-&gt;videoSettings.getHeight(),sImage.format());
            QPainter painter;
            painter.begin(&amp;fImage);
            painter.setBackground(QBrush(Qt::black));
            painter.setBrush(QBrush(Qt::black));
            painter.setPen(Qt::black);
            painter.drawRect(0,0,this-&gt;videoSettings.getWidth(),this-&gt;videoSettings.getHeight());
            painter.drawImage((this-&gt;videoSettings.getWidth()-sImage.width())/2,
                              (this-&gt;videoSettings.getHeight()-sImage.height())/2,
                              sImage);
            painter.end();

            RLogger::info("Adding frame from image file \'%s\'\n",imageFileName.toUtf8().constData());
            for (uint i=0;i&lt;this-&gt;videoSettings.getFpp();i++)
            {
                if (!videoOutput.newFrame(fImage))
                {
                    RLogger::error("Failed to add frame from image file \'%s\'\n",imageFileName.toUtf8().constData());
                    return;
                }
            }
            RProgressPrint(cnt++,imageFileNames.size());
        }

        if (!videoOutput.closeMediaFile())
        {
            RLogger::error("Failed to create animation file \'%s\'\n",fileName.toUtf8().constData());
            return;
        }
        RLogger::info("Animation file \'%s\' created\n",fileName.toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101525.219">void ModelRecordsSelector::onRecordMarked(uint modelID, const QString &amp;recordFileName)
{
    RLogger::info("Selected record: \'%s\'\n", recordFileName.toUtf8().constData());

    Job *updateJob = new ModelIO(MODEL_IO_UPDATE, recordFileName, &amp;Session::getInstance().getModel(modelID));
    this-&gt;updateModelID = modelID;

    QObject::connect(updateJob,
                     &amp;Job::finished,
                     this,
                     &amp;ModelRecordsSelector::onUpdateJobFinished);

    JobManager::getInstance().submit(updateJob);
}

</t>
<t tx="leo.20201108101525.22">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model.cpp                                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Model class definition - derived from RModel        *
 *********************************************************************/

#include &lt;QString&gt;

#include &lt;rblib.h&gt;

#include "model.h"
#include "variable_data.h"
#include "color.h"
#include "color_scale.h"
#include "gl_element.h"
#include "gl_element_group.h"
#include "gl_line.h"
#include "gl_interpolated_element.h"
#include "gl_interpolated_entity.h"
#include "gl_vector_field.h"
#include "gl_scalar_field.h"
#include "main_settings.h"
#include "session.h"

const int Model::ConsolidateActionAll = Model::ConsolidateSurfaceNeighbors |
@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20201108101525.23">void Model::_init(const Model *pModel)
{
    if (pModel)
    {
        this-&gt;edgeNodes = pModel-&gt;edgeNodes;
        this-&gt;edgeElements = pModel-&gt;edgeElements;
        this-&gt;holeElements = pModel-&gt;holeElements;
        this-&gt;sliverElements = pModel-&gt;sliverElements;
        this-&gt;intersectedElements = pModel-&gt;intersectedElements;
        this-&gt;surfaceNeigs = pModel-&gt;surfaceNeigs;
        this-&gt;volumeNeigs = pModel-&gt;volumeNeigs;
        this-&gt;fileName = pModel-&gt;fileName;
        this-&gt;meshInput = pModel-&gt;meshInput;
        this-&gt;viewFactorMatrix = pModel-&gt;viewFactorMatrix;
        this-&gt;patchColors = pModel-&gt;patchColors;
        this-&gt;actionDescription = pModel-&gt;actionDescription;
    }
}

Model::Model()
{
    this-&gt;_init();
}

Model::Model(const Model &amp;model) : RModel(model)
{
    this-&gt;_init(&amp;model);
}

Model::Model (const RModelMsh &amp;modelMsh) : RModel(modelMsh)
{
    this-&gt;_init();
    this-&gt;consolidate(Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateSliverElements | Model::ConsolidateIntersectedElements);
}

Model::Model (const RModelStl &amp;modelStl) : RModel(modelStl)
{
    this-&gt;_init();
    this-&gt;consolidate(Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateSliverElements | Model::ConsolidateIntersectedElements);
}

Model::Model (const RModelRaw &amp;modelRaw,
</t>
<t tx="leo.20201108101525.24">              const QString &amp;name,
              const QString &amp;description, bool consolidate) : RModel(modelRaw,name,description)
{
    this-&gt;_init();
    if (consolidate)
    {
        this-&gt;consolidate(Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateSliverElements | Model::ConsolidateIntersectedElements);
    }
}

Model &amp; Model::operator = (const Model &amp;model)
{
    this-&gt;RModel::operator =(model);
    this-&gt;_init(&amp;model);
    return (*this);
}

</t>
<t tx="leo.20201108101525.25">void Model::insertModel(const Model &amp;model, bool mergeNearNodes, double tolerance, bool findNearest)
{
    uint nn = this-&gt;getNNodes();
    uint ne = this-&gt;getNElements();
    uint neg = this-&gt;getNElementGroups();

    QVector&lt;uint&gt; nodeBook;
    nodeBook.resize(int(model.getNNodes()));

    for (uint i=0;i&lt;model.getNNodes();i++)
    {
        bool appendNode = false;
        if (mergeNearNodes)
        {
            uint nId = this-&gt;findNearNode(model.nodes[i],tolerance,findNearest);
            if (nId != RConstants::eod)
            {
                nodeBook[int(i)]=nId;
            }
            else
            {
                nodeBook[int(i)]=nn++;
                appendNode = true;
            }
        }
        else
        {
            nodeBook[int(i)]=nn++;
            appendNode = true;
        }
        if (appendNode)
        {
            this-&gt;nodes.push_back(model.nodes[i]);
            this-&gt;RResults::addNode();
        }
    }
    for (uint i=0;i&lt;model.getNElements();i++)
    {
        this-&gt;elements.push_back(model.elements[i]);
        // Adjust node IDs.
        for (uint j=0;j&lt;this-&gt;elements[ne+i].size();j++)
        {
            this-&gt;elements[ne+i].setNodeId(j,nodeBook[int(this-&gt;elements[ne+i].getNodeId(j))]);
        }
        this-&gt;RResults::addElement();
    }
    for (uint i=0;i&lt;model.getNPoints();i++)
    {
        this-&gt;points.push_back(model.points[i]);
        // Adjust element IDs.
        RPoint &amp;rPoint = this-&gt;getPoint(this-&gt;getNPoints()-1);
        for (uint j=0;j&lt;rPoint.size();j++)
        {
            rPoint.set(j,rPoint.get(j)+ne);
        }
        // Set name.
        if (rPoint.getName().isEmpty())
        {
            rPoint.setName(this-&gt;generateNextEntityName(R_ENTITY_GROUP_POINT));
        }
    }
    for (uint i=0;i&lt;model.getNLines();i++)
    {
        this-&gt;lines.push_back(model.lines[i]);
        // Adjust element IDs.
        RLine &amp;rLine = this-&gt;getLine(this-&gt;getNLines()-1);
        for (uint j=0;j&lt;rLine.size();j++)
        {
            rLine.set(j,rLine.get(j)+ne);
        }
        // Set name.
        if (rLine.getName().isEmpty())
        {
            rLine.setName(this-&gt;generateNextEntityName(R_ENTITY_GROUP_LINE));
        }
    }
    for (uint i=0;i&lt;model.getNSurfaces();i++)
    {
        this-&gt;surfaces.push_back(model.surfaces[i]);
        // Adjust element IDs.
        RSurface &amp;rSurface = this-&gt;getSurface(this-&gt;getNSurfaces()-1);
        for (uint j=0;j&lt;rSurface.size();j++)
        {
            rSurface.set(j,rSurface.get(j)+ne);
        }
        // Set name.
        if (rSurface.getName().isEmpty())
        {
            rSurface.setName(this-&gt;generateNextEntityName(R_ENTITY_GROUP_SURFACE));
        }
    }
    for (uint i=0;i&lt;model.getNVolumes();i++)
    {
        this-&gt;volumes.push_back(model.volumes[i]);
        // Adjust element IDs.
        RVolume &amp;rVolume = this-&gt;getVolume(this-&gt;getNVolumes()-1);
        for (uint j=0;j&lt;rVolume.size();j++)
        {
            rVolume.set(j,rVolume.get(j)+ne);
        }
        // Set name.
        if (rVolume.getName().isEmpty())
        {
            rVolume.setName(this-&gt;generateNextEntityName(R_ENTITY_GROUP_VOLUME));
        }
    }
    for (uint i=0;i&lt;model.getNVectorFields();i++)
    {
        this-&gt;vectorFields.push_back(model.vectorFields[i]);
        // Adjust element group IDs.
        RVectorField &amp;rVectorField = this-&gt;getVectorField(this-&gt;getNVectorFields()-1);
        std::vector&lt;uint&gt; &amp;elementGroupIDs = rVectorField.getElementGroupIDs();
        for (uint j=0;j&lt;elementGroupIDs.size();j++)
        {
            elementGroupIDs[j]+=neg;
        }
        // Set name.
        if (rVectorField.getName().isEmpty())
        {
            rVectorField.setName(this-&gt;generateNextEntityName(R_ENTITY_GROUP_VECTOR_FIELD));
        }
    }
    for (uint i=0;i&lt;model.getNScalarFields();i++)
    {
        this-&gt;scalarFields.push_back(model.scalarFields[i]);
        RScalarField &amp;rScalarField = this-&gt;getScalarField(this-&gt;getNScalarFields()-1);
        // Set name.
        if (rScalarField.getName().isEmpty())
        {
            rScalarField.setName(this-&gt;generateNextEntityName(R_ENTITY_GROUP_SCALAR_FIELD));
        }
    }
    for (uint i=0;i&lt;model.getNStreamLines();i++)
    {
        this-&gt;streamLines.push_back(model.streamLines[i]);
        RStreamLine &amp;rStreamLine = this-&gt;getStreamLine(this-&gt;getNStreamLines()-1);
        // Set name.
        if (rStreamLine.getName().isEmpty())
        {
            rStreamLine.setName(this-&gt;generateNextEntityName(R_ENTITY_GROUP_STREAM_LINE));
        }
    }
    for (uint i=0;i&lt;model.getNCuts();i++)
    {
        this-&gt;cuts.push_back(model.cuts[i]);
        // Adjust element group IDs.
        RCut &amp;rCut = this-&gt;getCut(this-&gt;getNCuts()-1);
        std::vector&lt;uint&gt; &amp;elementGroupIDs = rCut.getElementGroupIDs();
        for (uint j=0;j&lt;elementGroupIDs.size();j++)
        {
            elementGroupIDs[j]+=neg;
        }
        // Set name.
        if (rCut.getName().isEmpty())
        {
            rCut.setName(this-&gt;generateNextEntityName(R_ENTITY_GROUP_CUT));
        }
    }
    for (uint i=0;i&lt;model.getNIsos();i++)
    {
        this-&gt;isos.push_back(model.isos[i]);
        // Adjust element group IDs.
        RIso &amp;rIso = this-&gt;getIso(this-&gt;getNIsos()-1);
        std::vector&lt;uint&gt; &amp;elementGroupIDs = rIso.getElementGroupIDs();
        for (uint j=0;j&lt;elementGroupIDs.size();j++)
        {
            elementGroupIDs[j]+=neg;
        }
        // Set name.
        if (rIso.getName().isEmpty())
        {
            rIso.setName(this-&gt;generateNextEntityName(R_ENTITY_GROUP_ISO));
        }
    }
    this-&gt;consolidate(Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateSliverElements | Model::ConsolidateIntersectedElements);
}

</t>
<t tx="leo.20201108101525.26">const QString &amp;Model::getFileName() const
{
    return this-&gt;fileName;
}

</t>
<t tx="leo.20201108101525.27">void Model::setFileName(const QString &amp;fileName)
{
    this-&gt;fileName = fileName;
}

</t>
<t tx="leo.20201108101525.28">const RMeshInput &amp;Model::getMeshInput() const
{
    return this-&gt;meshInput;
}

RMeshInput &amp;Model::getMeshInput()
{
    return this-&gt;meshInput;
}

</t>
<t tx="leo.20201108101525.29">void Model::setMeshInput(const RMeshInput &amp;meshInput)
{
    this-&gt;meshInput = meshInput;
}

</t>
<t tx="leo.20201108101525.3">void MeshGeneratorDialog::updateMeshInput(void)
{
    this-&gt;meshInput.setSurfaceIntegrityCheck(this-&gt;surfaceIntegrityCheck-&gt;isChecked());
    this-&gt;meshInput.setQualityMesh(this-&gt;qualityMeshGroupBox-&gt;isChecked());
    this-&gt;meshInput.setUseSizeFunction(this-&gt;qualityMeshGroupBox-&gt;isChecked() &amp;&amp; this-&gt;meshSizeFunctionGroupBox-&gt;isChecked());
    this-&gt;meshInput.setVolumeConstraint(this-&gt;volumeConstraintEdit-&gt;getValue());
    this-&gt;meshInput.setReconstruct(this-&gt;reconstructCheck-&gt;isChecked());
    this-&gt;meshInput.setKeepResults(this-&gt;keepResultsCheck-&gt;isChecked());

    if (this-&gt;meshSizeFunctionMaxValueEdit-&gt;getValue() &gt; this-&gt;meshSizeFunctionMaxValueEdit-&gt;getMaximum())
    {
        this-&gt;meshSizeFunctionMaxValueEdit-&gt;setValue(this-&gt;meshSizeFunctionMaxValueEdit-&gt;getMaximum());
    }

    this-&gt;meshSizeFunctionMinValueEdit-&gt;setRange(this-&gt;meshSizeFunctionMaxValueEdit-&gt;getMinimum(),
                                                 this-&gt;meshSizeFunctionMaxValueEdit-&gt;getValue());
    if (this-&gt;meshSizeFunctionMinValueEdit-&gt;getValue() &gt; this-&gt;meshSizeFunctionMaxValueEdit-&gt;getValue())
    {
        this-&gt;meshSizeFunctionMinValueEdit-&gt;setValue(this-&gt;meshSizeFunctionMinValueEdit-&gt;getMaximum());
    }


    this-&gt;meshInput.setUseTetGenInputParams(this-&gt;tetgenParamsGroupBox-&gt;isChecked());
    if (!this-&gt;tetgenParamsGroupBox-&gt;isChecked())
    {
        // Update TetGen parameters line edit.
        bool oldState = this-&gt;tetgenParamsEdit-&gt;blockSignals(true);
        this-&gt;tetgenParamsEdit-&gt;setText(Session::getInstance().getModel(this-&gt;modelID).generateMeshTetGenInputParams(this-&gt;meshInput));
        this-&gt;tetgenParamsEdit-&gt;blockSignals(oldState);
    }
    this-&gt;meshInput.setTetGenInputParams(this-&gt;tetgenParamsEdit-&gt;text());
}

</t>
<t tx="leo.20201108101525.30">void Model::initializeMeshInput()
{
    double xmin, xmax, ymin, ymax, zmin, zmax;

    this-&gt;findNodeLimits(xmin, xmax, ymin, ymax, zmin, zmax);

    double dx = xmax - xmin;
    double dy = ymax - ymin;
    double dz = zmax - zmin;

    this-&gt;meshInput.setVolumeConstraint(dx*dy*dz/1000.0);

    RMeshSetup &amp;rMeshSetup = this-&gt;getProblemSetup().getMeshSetup();

    if (rMeshSetup.getMinEdgeLength() == 0.0 || rMeshSetup.getMaxEdgeLength() == 0.0)
    {
        double initEdgeLenght = std::cbrt(12.0 * this-&gt;meshInput.getVolumeConstraint() / std::sqrt(2.0));
        rMeshSetup.setMinEdgeLength(initEdgeLenght*0.1);
        rMeshSetup.setMaxEdgeLength(initEdgeLenght);
    }
}

</t>
<t tx="leo.20201108101525.31">const RViewFactorMatrix &amp;Model::getViewFactorMatrix() const
{
    return this-&gt;viewFactorMatrix;
}

RViewFactorMatrix &amp;Model::getViewFactorMatrix()
{
    return this-&gt;viewFactorMatrix;
}

</t>
<t tx="leo.20201108101525.32">bool Model::canColorByPatch() const
{
    return ((this-&gt;getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_RADIATIVE_HEAT) &amp;&amp;
            (this-&gt;getViewFactorMatrix().getPatchBook().getNPatches() &gt; 0));
}

</t>
<t tx="leo.20201108101525.33">bool Model::canColorByViewFactor() const
{
    return ((this-&gt;getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_RADIATIVE_HEAT) &amp;&amp;
            (this-&gt;getViewFactorMatrix().getPatchBook().getNPatches() &gt; 0) &amp;&amp;
            (this-&gt;getViewFactorMatrix().size() == this-&gt;getViewFactorMatrix().getPatchBook().getNPatches()));
}

</t>
<t tx="leo.20201108101525.34">const QList&lt;QColor&gt; &amp;Model::getPatchColors() const
{
    return this-&gt;patchColors;
}

QList&lt;QColor&gt; &amp;Model::getPatchColors()
{
    return this-&gt;patchColors;
}

</t>
<t tx="leo.20201108101525.35">void Model::generatePatchColors()
{
    this-&gt;patchColors.clear();
    for (uint i=0;i&lt;this-&gt;viewFactorMatrix.getPatchBook().getNPatches();i++)
    {
        int r,g,b;
        r = qRound(255*double(qrand())/double(RAND_MAX));
        g = qRound(255*double(qrand())/double(RAND_MAX));
        b = qRound(255*double(qrand())/double(RAND_MAX));
        this-&gt;patchColors.push_back(QColor(r,g,b,255));
    }
}

</t>
<t tx="leo.20201108101525.36">void Model::generateLineFromSurfaceEdges(double separationAngle)
{
    QVector&lt;RElement&gt; segments = this-&gt;findEdgeElements(separationAngle);

    if (segments.size() == 0)
    {
        return;
    }

    for (int i=0;i&lt;segments.size();i++)
    {
        this-&gt;addElement(segments[i],true);
    }
}

</t>
<t tx="leo.20201108101525.37">const REntityGroupData *Model::getElementGroupData(REntityGroupType elementGroupType, uint position) const
{
    switch (elementGroupType)
    {
        case R_ENTITY_GROUP_POINT:
            return &amp;this-&gt;getPoint(position).getData();
        case R_ENTITY_GROUP_LINE:
            return &amp;this-&gt;getLine(position).getData();
        case R_ENTITY_GROUP_SURFACE:
            return &amp;this-&gt;getSurface(position).getData();
        case R_ENTITY_GROUP_VOLUME:
            return &amp;this-&gt;getVolume(position).getData();
        case R_ENTITY_GROUP_VECTOR_FIELD:
            return &amp;this-&gt;getVectorField(position).getData();
        case R_ENTITY_GROUP_SCALAR_FIELD:
            return &amp;this-&gt;getScalarField(position).getData();
        case R_ENTITY_GROUP_STREAM_LINE:
            return &amp;this-&gt;getStreamLine(position).getData();
        case R_ENTITY_GROUP_CUT:
            return &amp;this-&gt;getCut(position).getData();
        case R_ENTITY_GROUP_ISO:
            return &amp;this-&gt;getIso(position).getData();
        default:
            return nullptr;
    }
}

REntityGroupData *Model::getElementGroupData(REntityGroupType elementGroupType, uint position)
{
    switch (elementGroupType)
    {
        case R_ENTITY_GROUP_POINT:
            return &amp;this-&gt;getPoint(position).getData();
        case R_ENTITY_GROUP_LINE:
            return &amp;this-&gt;getLine(position).getData();
        case R_ENTITY_GROUP_SURFACE:
            return &amp;this-&gt;getSurface(position).getData();
        case R_ENTITY_GROUP_VOLUME:
            return &amp;this-&gt;getVolume(position).getData();
        case R_ENTITY_GROUP_VECTOR_FIELD:
            return &amp;this-&gt;getVectorField(position).getData();
        case R_ENTITY_GROUP_SCALAR_FIELD:
            return &amp;this-&gt;getScalarField(position).getData();
        case R_ENTITY_GROUP_STREAM_LINE:
            return &amp;this-&gt;getStreamLine(position).getData();
        case R_ENTITY_GROUP_CUT:
            return &amp;this-&gt;getCut(position).getData();
        case R_ENTITY_GROUP_ISO:
            return &amp;this-&gt;getIso(position).getData();
        default:
            return nullptr;
    }
}

</t>
<t tx="leo.20201108101525.38">void Model::autoMarkSurfaces(double angle)
{
    RLogger::info("Auto-marking surface elements\n");
    RLogger::indent();
    RProgressInitialize("Auto-marking surface elements", true);

    std::vector&lt;uint&gt; marks;
    marks.resize(this-&gt;surfaceNeigs.size(),0);
    uint cMark = 0;

    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (RElementGroup::getGroupType(this-&gt;getElement(i).getType()) != R_ENTITY_GROUP_SURFACE)
        {
            continue;
        }
        if (marks[i] != 0)
        {
            continue;
        }
        marks[i] = ++cMark;
        this-&gt;markSurfaceNeighbors(i,angle,this-&gt;surfaceNeigs,marks);
    }

    REntityGroupData data = this-&gt;getSurface(0).getData();
    RMaterial material = this-&gt;getSurface(0).getMaterial();
    double thickness = this-&gt;getSurface(0).getThickness();

    // Must be resized to 0 to loose all information about stored elements
    this-&gt;setNSurfaces(0);
    this-&gt;setNSurfaces(cMark);

    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        Color color = Color::random(true);
        data.setColor(color.red(),color.green(),color.blue());

        this-&gt;getSurface(i).setName("Surface " + QString::number(i+1));
        this-&gt;getSurface(i).setMaterial(material);
        this-&gt;getSurface(i).setThickness(thickness);
        this-&gt;getSurface(i).setData(data);
    }

    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (RElementGroup::getGroupType(this-&gt;getElement(i).getType()) != R_ENTITY_GROUP_SURFACE)
        {
            continue;
        }
        if (marks[i] == 0)
        {
            RLogger::warning("Unmarked surface element \'%u\'\n",i);
            continue;
        }
        this-&gt;getSurface(marks[i]-1).add(i);
    }

    RProgressFinalize();
    RLogger::unindent();
}

</t>
<t tx="leo.20201108101525.39">void Model::markSurface(double angle, QList&lt;uint&gt; elementIDs)
{
    if (elementIDs.empty())
    {
        return;
    }

    RLogger::info("Marking surface elements\n");
    RLogger::indent();
    RProgressInitialize("Marking surface elements", true);

    std::vector&lt;uint&gt; marks;
    marks.resize(this-&gt;surfaceNeigs.size(),0);

    uint nMark = this-&gt;getNSurfaces();

    // Remember data, thickness and material for the first selected element.
    uint sourceSurfaceId = 0;
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        uint position;
        if (this-&gt;getSurface(i).findPosition(elementIDs[0],&amp;position))
        {
            sourceSurfaceId = i;
            break;
        }
    }

    for (int i=0;i&lt;elementIDs.size();i++)
    {
        marks[elementIDs[i]] = nMark;
        this-&gt;markSurfaceNeighbors(elementIDs[i],angle,this-&gt;surfaceNeigs,marks);
    }

    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        for (uint j=0;j&lt;marks.size();j++)
        {
            if (marks[j] == 0)
            {
                continue;
            }
            uint elementPosition;
            if (!this-&gt;getSurface(i).findPosition(j,&amp;elementPosition))
            {
                continue;
            }
            this-&gt;getSurface(i).remove(elementPosition);
        }
    }

    this-&gt;setNSurfaces(this-&gt;getNSurfaces()+1);

    for (uint i=0;i&lt;marks.size();i++)
    {
        if (marks[i] &gt; 0)
        {
            this-&gt;getSurface(marks[i]).add(i);
        }
    }

    REntityGroupData data = this-&gt;getSurface(sourceSurfaceId).getData();
    RMaterial material = this-&gt;getSurface(sourceSurfaceId).getMaterial();
    double thickness = this-&gt;getSurface(sourceSurfaceId).getThickness();

    Color color = Color::random(true);
    data.setColor(color.red(),color.green(),color.blue());

    this-&gt;getSurface(nMark).setName("Surface " + QString::number(nMark+1));
    this-&gt;getSurface(nMark).setMaterial(material);
    this-&gt;getSurface(nMark).setThickness(thickness);
    this-&gt;getSurface(nMark).setData(data);

    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        if (this-&gt;getSurface(i).size() == 0)
        {
            this-&gt;removeSurface(i);
            i--;
        }
    }

    RProgressFinalize();
    RLogger::unindent();
}

</t>
<t tx="leo.20201108101525.4">void MeshGeneratorDialog::onSurfaceIntegrityStateChanged(int)
{
    this-&gt;updateMeshInput();
}

</t>
<t tx="leo.20201108101525.40">void Model::closeSurfaceHole(QList&lt;uint&gt; edgeIDs)
{
    if (edgeIDs.empty())
    {
        return;
    }

    RLogger::info("Closing surface hole\n");
    RLogger::indent();

    QList&lt;uint&gt; elementIDs = this-&gt;sortLineElements(this-&gt;holeElements.toList(),edgeIDs[0]);

    QList&lt;uint&gt; nodeIDs;
    nodeIDs.reserve(elementIDs.size());

    for (int i=0;i&lt;elementIDs.size();i++)
    {
        nodeIDs.append(this-&gt;holeElements[int(elementIDs[i])].getNodeId(0));
    }

    std::vector&lt;RNode&gt; edgeNodes;
    edgeNodes.resize(uint(nodeIDs.size()));
    for (uint i=0;i&lt;edgeNodes.size();i++)
    {
        edgeNodes[i] = this-&gt;getNode(nodeIDs[int(i)]);
    }

    if (edgeNodes.size() &gt; 0)
    {
        std::vector&lt;RElement&gt; patchElements = RPolygon::triangulate(edgeNodes,true);
        for (uint j=0;j&lt;patchElements.size();j++)
        {
            patchElements[j].swapNodeIds(1,2);
            for (uint k=0;k&lt;patchElements[j].size();k++)
            {
                patchElements[j].setNodeId(k,nodeIDs[int(patchElements[j].getNodeId(k))]);
            }
            this-&gt;addElement(patchElements[j]);
        }
    }

    this-&gt;consolidate(Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateSliverElements | Model::ConsolidateIntersectedElements);

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101525.41">void Model::transformGeometry(const GeometryTransformInput &amp;geometryTransformInput, const QList&lt;SessionEntityID&gt; &amp;entityIDs)
{
    this-&gt;consolidate(Model::ConsolidateActionAll);

    QSet&lt;uint&gt; nodeIDs;

    uint nSweepSteps = 1;

    if (geometryTransformInput.getApplyTo() != GeometryTransformInput::ApplyToAll &amp;&amp;
        geometryTransformInput.getIncludeSharedNodes() &amp;&amp;
        geometryTransformInput.getSplitSharedNodes() &amp;&amp;
        geometryTransformInput.getSweepSharedNodes())
    {
        nSweepSteps = geometryTransformInput.getNSweepSteps();
    }

    for (uint sweepStep=0;sweepStep&lt;nSweepSteps;sweepStep++)
    {
        GeometryTransformInput input(geometryTransformInput);

        RLogger::info("Performing sweep step %u of %u\n",sweepStep+1,nSweepSteps);

        if (nSweepSteps &gt; 1)
        {
            double scale = 1.0/double(nSweepSteps);
            if (input.isTranslateActive())
            {
                input.getTranslation().scale(scale);
            }
            if (input.isRotateActive())
            {
                input.getRotation().scale(scale);
            }
            if (input.isScaleActive())
            {

                double sx = input.getScale()[0];
                double sy = input.getScale()[1];
                double sz = input.getScale()[2];

                sx = (1.0+(double(sweepStep+1)/double(nSweepSteps))*(sx-1.0))/(1.0+(double(sweepStep)/double(nSweepSteps))*(sx-1.0));
                sy = (1.0+(double(sweepStep+1)/double(nSweepSteps))*(sy-1.0))/(1.0+(double(sweepStep)/double(nSweepSteps))*(sy-1.0));
                sz = (1.0+(double(sweepStep+1)/double(nSweepSteps))*(sz-1.0))/(1.0+(double(sweepStep)/double(nSweepSteps))*(sz-1.0));

                if (input.getScale()[0] != 1.0)
                {
                    input.getScale()[0] = sx;
                }
                if (input.getScale()[1] != 1.0)
                {
                    input.getScale()[1] = sy;
                }
                if (input.getScale()[2] != 1.0)
                {
                    input.getScale()[2] = sz;
                }
            }
        }

        if (input.getApplyTo() == GeometryTransformInput::ApplyToAll)
        {
            nodeIDs.reserve(int(this-&gt;getNNodes()));
            for (uint i=0;i&lt;this-&gt;getNNodes();i++)
            {
                nodeIDs.insert(uint(i));
            }
        }
        else if (input.getApplyTo() == GeometryTransformInput::ApplyToSelected ||
                 input.getApplyTo() == GeometryTransformInput::ApplyToPicked ||
                 input.getApplyTo() == GeometryTransformInput::ApplyToVisible)
        {
            QSet&lt;uint&gt; elementIDs = this-&gt;getElementIDs(entityIDs);
            QSet&lt;uint&gt; edgeNodeIDs = this-&gt;findEdgeNodeIDs(entityIDs);

            nodeIDs = this-&gt;getNodeIDs(elementIDs);

            if (input.getIncludeSharedNodes())
            {
                if (input.getSplitSharedNodes())
                {
                    QMap&lt;uint,uint&gt; newEdgeNodeMap = this-&gt;splitNodes(edgeNodeIDs,elementIDs);
                    if (input.getSweepSharedNodes())
                    {
                        QList&lt;RElement&gt; edgeElements = this-&gt;generateEdgeElements(edgeNodeIDs,elementIDs);
                        this-&gt;createSweepEdgeElements(edgeElements,newEdgeNodeMap,sweepStep &gt; 0,sweepStep+1 == nSweepSteps,sweepStep+1 == nSweepSteps);
                    }
                }
            }
            else
            {
                nodeIDs.subtract(edgeNodeIDs);
            }
        }
        else
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Unknown apply-to type \'%d\'",input.getApplyTo());
        }

        try
        {
            this-&gt;rotateGeometry(nodeIDs,input.getRotation(),input.getRotationCenter());
        }
        catch (const RError &amp;error)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to rotate the geometry. %s", error.getMessage().toUtf8().constData());
        }

        try
        {
            this-&gt;scaleGeometry(nodeIDs,input.getScale(),input.getScaleCenter());
        }
        catch (const RError &amp;error)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to scale the geometry. %s", error.getMessage().toUtf8().constData());
        }

        try
        {
            this-&gt;translateGeometry(nodeIDs,input.getTranslation());
        }
        catch (const RError &amp;error)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to translate the geometry. %s", error.getMessage().toUtf8().constData());
        }
    }

    this-&gt;mergeNearNodes();
    this-&gt;consolidate(Model::ConsolidateActionAll);
}

uint Model::coarsenSurfaceElements(const std::vector&lt;uint&gt; surfaceIDs, double edgeLength, double elementArea)
{
    uint nDeleted = this-&gt;RModel::coarsenSurfaceElements(surfaceIDs,edgeLength,elementArea);

    this-&gt;consolidate(Model::ConsolidateActionAll);

    return nDeleted;
}

uint Model::tetrahedralizeSurface(const std::vector&lt;uint&gt; surfaceIDs)
{
    uint nGenerated = this-&gt;RModel::tetrahedralizeSurface(surfaceIDs);

    this-&gt;consolidate(Model::ConsolidateActionAll);

    return nGenerated;
}

uint Model::mergeNearNodes(double tolerance)
{
    uint nMerged = this-&gt;RModel::mergeNearNodes(tolerance);

    this-&gt;consolidate(Model::ConsolidateActionAll);

    return nMerged;
}

uint Model::purgeUnusedNodes()
{
    uint nPurged = this-&gt;RModel::purgeUnusedNodes();

    this-&gt;consolidate(Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements);

    return nPurged;
}

uint Model::purgeUnusedElements()
{
    uint nPurged = this-&gt;RModel::purgeUnusedElements();

    this-&gt;consolidate(Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateSliverElements | Model::ConsolidateIntersectedElements);

    return nPurged;
}

uint Model::removeDuplicateElements()
{
    uint nMerged = this-&gt;RModel::removeDuplicateElements();

    this-&gt;consolidate(Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements | Model::ConsolidateSliverElements | Model::ConsolidateIntersectedElements);

    return nMerged;
}

uint Model::fixSliverElements(double edgeRatio)
{
    uint nAffected = this-&gt;RModel::fixSliverElements(edgeRatio);
    if (nAffected == 0)
    {
        RLogger::info("No sliver elements were found.\n");
    }
    else
    {
        RLogger::info("Total number of sliver elements that were affected = %d.\n", nAffected);

        RMeshInput tmpInput = this-&gt;getMeshInput();
        this-&gt;consolidate(Model::ConsolidateActionAll);
        this-&gt;setMeshInput(tmpInput);
    }

    return nAffected;
}

</t>
<t tx="leo.20201108101525.42">void Model::updateSliverElements(double edgeRatio)
{
    this-&gt;sliverElements = this-&gt;findSliverElements(edgeRatio);
    int ni = this-&gt;sliverElements.size();
    if (ni == 0)
    {
        RLogger::info("No sliver elements were found.\n");
    }
    else
    {
        RLogger::warning("Number of sliver elements found = %d.\n", ni);
    }
}

</t>
<t tx="leo.20201108101525.43">void Model::updateIntersectedElements()
{
    this-&gt;intersectedElements = this-&gt;findIntersectedElements();
    int ni = this-&gt;intersectedElements.size();
    if (ni == 0)
    {
        RLogger::info("No intersected elements were found.\n");
    }
    else
    {
        RLogger::warning("Number of intersected elements found = %d.\n", ni);
    }
}

uint Model::breakIntersectedElements(uint nIterations)
{
    uint ni = this-&gt;RModel::breakIntersectedElements(nIterations);
    if (ni == 0)
    {
        RLogger::info("No intersected elements were found.\n");
    }
    else
    {
        RLogger::info("Total number of elements that were intersected = %d.\n", ni);

        RMeshInput tmpInput = this-&gt;getMeshInput();
        this-&gt;consolidate(Model::ConsolidateActionAll);
        this-&gt;setMeshInput(tmpInput);
    }
    return ni;
}

</t>
<t tx="leo.20201108101525.44">bool Model::exportSliverElements() const
{
    if (this-&gt;sliverElements.size() == 0)
    {
        RLogger::warning("No intersecting elements were found.\n");
        return false;
    }

    std::vector&lt;uint&gt; nodeBook;
    nodeBook.resize(this-&gt;getNNodes(),RConstants::eod);

    for (int i=0;i&lt;this-&gt;sliverElements.size();i++)
    {
        uint elementID = this-&gt;sliverElements[i];
        const RElement &amp;rElement = this-&gt;getElement(elementID);
        for (uint j=0;j&lt;rElement.size();j++)
        {
            nodeBook[rElement.getNodeId(j)] = 0;
        }
    }

    Model model;

    uint nn = 0;
    for (uint i=0;i&lt;nodeBook.size();i++)
    {
        if (nodeBook[i] == 0)
        {
            nodeBook[i] = nn++;
            model.addNode(this-&gt;getNode(i));
        }
    }

    for (int i=0;i&lt;this-&gt;sliverElements.size();i++)
    {
        uint elementID = this-&gt;sliverElements[i];
        RElement element = this-&gt;getElement(elementID);
        for (uint j=0;j&lt;element.size();j++)
        {
            element.setNodeId(j,nodeBook[element.getNodeId(j)]);
        }
        model.addElement(element,true,0);
    }

    model.setName(this-&gt;getName() + " - sliver");
    model.setDescription("Sliver elements");
    model.consolidate(Model::ConsolidateActionAll);

    Session::getInstance().addModel(model);

    RLogger::warning("Sliver elements were found (%u).\n",model.getNElements());

    return true;
}

</t>
<t tx="leo.20201108101525.45">bool Model::exportIntersectedElements() const
{
    if (this-&gt;intersectedElements.size() == 0)
    {
        RLogger::warning("No intersecting elements were found.\n");
        return false;
    }

    std::vector&lt;uint&gt; nodeBook;
    nodeBook.resize(this-&gt;getNNodes(),RConstants::eod);

    for (int i=0;i&lt;this-&gt;intersectedElements.size();i++)
    {
        uint elementID = this-&gt;intersectedElements[i];
        const RElement &amp;rElement = this-&gt;getElement(elementID);
        for (uint j=0;j&lt;rElement.size();j++)
        {
            nodeBook[rElement.getNodeId(j)] = 0;
        }
    }

    Model model;

    uint nn = 0;
    for (uint i=0;i&lt;nodeBook.size();i++)
    {
        if (nodeBook[i] == 0)
        {
            nodeBook[i] = nn++;
            model.addNode(this-&gt;getNode(i));
        }
    }

    for (int i=0;i&lt;this-&gt;intersectedElements.size();i++)
    {
        uint elementID = this-&gt;intersectedElements[i];
        RElement element = this-&gt;getElement(elementID);
        for (uint j=0;j&lt;element.size();j++)
        {
            element.setNodeId(j,nodeBook[element.getNodeId(j)]);
        }
        model.addElement(element,true,0);
    }

    model.setName(this-&gt;getName() + " - intersected");
    model.setDescription("Reuslt of element intersections");
    model.consolidate(Model::ConsolidateActionAll);

    Session::getInstance().addModel(model);

    RLogger::warning("Intersecting elements were found (%u).\n",model.getNElements());

    return true;
}

</t>
<t tx="leo.20201108101525.46">bool Model::boolDifference(uint nIterations, QList&lt;uint&gt; surfaceEntityIDs, uint cuttingSurfaceEntityId)
{
    bool success = this-&gt;RModel::boolDifference(nIterations,surfaceEntityIDs,cuttingSurfaceEntityId);

    this-&gt;consolidate(Model::ConsolidateActionAll);

    return success;
}

</t>
<t tx="leo.20201108101525.47">bool Model::boolIntersection(uint nIterations, QList&lt;uint&gt; surfaceEntityIDs)
{
    bool success = this-&gt;RModel::boolIntersection(nIterations,surfaceEntityIDs);

    this-&gt;consolidate(Model::ConsolidateActionAll);

    return success;
}

</t>
<t tx="leo.20201108101525.48">bool Model::boolUnion(uint nIterations, QList&lt;uint&gt; surfaceEntityIDs)
{
    bool success = this-&gt;RModel::boolUnion(nIterations,surfaceEntityIDs);

    this-&gt;consolidate(Model::ConsolidateActionAll);

    return success;
}

</t>
<t tx="leo.20201108101525.49">bool Model::isSliver(uint elementID) const
{
    return (this-&gt;sliverElements.indexOf(elementID) &gt;= 0);
}

</t>
<t tx="leo.20201108101525.5">void MeshGeneratorDialog::onQualityMeshGroupBoxClicked(bool)
{
    this-&gt;updateMeshInput();
}

</t>
<t tx="leo.20201108101525.50">bool Model::isIntersected(uint elementID) const
{
    return (this-&gt;intersectedElements.indexOf(elementID) &gt;= 0);
}

</t>
<t tx="leo.20201108101525.51">bool Model::isSelected(bool selected) const
{
    if (isEmpty())
    {
        return (this-&gt;getSelected() == selected);
    }
    if (!this-&gt;isSelected(R_ENTITY_GROUP_POINT,selected) &amp;&amp; this-&gt;getNPoints() &gt; 0)
    {
        return false;
    }
    if (!this-&gt;isSelected(R_ENTITY_GROUP_LINE,selected) &amp;&amp; this-&gt;getNLines() &gt; 0)
    {
        return false;
    }
    if (!this-&gt;isSelected(R_ENTITY_GROUP_SURFACE,selected) &amp;&amp; this-&gt;getNSurfaces() &gt; 0)
    {
        return false;
    }
    if (!this-&gt;isSelected(R_ENTITY_GROUP_VOLUME,selected) &amp;&amp; this-&gt;getNVolumes() &gt; 0)
    {
        return false;
    }
    if (!this-&gt;isSelected(R_ENTITY_GROUP_VECTOR_FIELD,selected) &amp;&amp; this-&gt;getNVectorFields() &gt; 0)
    {
        return false;
    }
    if (!this-&gt;isSelected(R_ENTITY_GROUP_SCALAR_FIELD,selected) &amp;&amp; this-&gt;getNScalarFields() &gt; 0)
    {
        return false;
    }
    if (!this-&gt;isSelected(R_ENTITY_GROUP_STREAM_LINE,selected) &amp;&amp; this-&gt;getNStreamLines() &gt; 0)
    {
        return false;
    }
    if (!this-&gt;isSelected(R_ENTITY_GROUP_CUT,selected) &amp;&amp; this-&gt;getNCuts() &gt; 0)
    {
        return false;
    }
    if (!this-&gt;isSelected(R_ENTITY_GROUP_ISO,selected) &amp;&amp; this-&gt;getNIsos() &gt; 0)
    {
        return false;
    }
    return true;
}

</t>
<t tx="leo.20201108101525.52">bool Model::isSelected(REntityGroupType elementGroupType,
                       bool             selected) const
{
    uint nEntities;
    switch (elementGroupType)
    {
        case R_ENTITY_GROUP_POINT:
            nEntities = this-&gt;getNPoints();
            break;
        case R_ENTITY_GROUP_LINE:
            nEntities = this-&gt;getNLines();
            break;
        case R_ENTITY_GROUP_SURFACE:
            nEntities = this-&gt;getNSurfaces();
            break;
        case R_ENTITY_GROUP_VOLUME:
            nEntities = this-&gt;getNVolumes();
            break;
        case R_ENTITY_GROUP_VECTOR_FIELD:
            nEntities = this-&gt;getNVectorFields();
            break;
        case R_ENTITY_GROUP_SCALAR_FIELD:
            nEntities = this-&gt;getNScalarFields();
            break;
        case R_ENTITY_GROUP_STREAM_LINE:
            nEntities = this-&gt;getNStreamLines();
            break;
        case R_ENTITY_GROUP_CUT:
            nEntities = this-&gt;getNCuts();
            break;
        case R_ENTITY_GROUP_ISO:
            nEntities = this-&gt;getNIsos();
            break;
        default:
            return false;
    }
    if (nEntities == 0)
    {
        return false;
    }
    for (uint i=0;i&lt;nEntities;i++)
    {
        if (this-&gt;getSelected(elementGroupType,i) != selected)
        {
            return false;
        }
    }
    return true;
}

</t>
<t tx="leo.20201108101525.53">bool Model::getSelected() const
{
    return this-&gt;getData().getSelected();
}

</t>
<t tx="leo.20201108101525.54">bool Model::getSelected(REntityGroupType elementGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getSelected();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.55">void Model::setSelected(bool selected)
{
    if (this-&gt;isEmpty())
    {
        this-&gt;getData().setSelected(selected);
        return;
    }
    this-&gt;getData().setSelected(false);

    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        this-&gt;setSelected(R_ENTITY_GROUP_POINT,i,selected);
    }
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        this-&gt;setSelected(R_ENTITY_GROUP_LINE,i,selected);
    }
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        this-&gt;setSelected(R_ENTITY_GROUP_SURFACE,i,selected);
    }
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        this-&gt;setSelected(R_ENTITY_GROUP_VOLUME,i,selected);
    }
    for (uint i=0;i&lt;this-&gt;getNVectorFields();i++)
    {
        this-&gt;setSelected(R_ENTITY_GROUP_VECTOR_FIELD,i,selected);
    }
    for (uint i=0;i&lt;this-&gt;getNScalarFields();i++)
    {
        this-&gt;setSelected(R_ENTITY_GROUP_SCALAR_FIELD,i,selected);
    }
    for (uint i=0;i&lt;this-&gt;getNStreamLines();i++)
    {
        this-&gt;setSelected(R_ENTITY_GROUP_STREAM_LINE,i,selected);
    }
    for (uint i=0;i&lt;this-&gt;getNCuts();i++)
    {
        this-&gt;setSelected(R_ENTITY_GROUP_CUT,i,selected);
    }
    for (uint i=0;i&lt;this-&gt;getNIsos();i++)
    {
        this-&gt;setSelected(R_ENTITY_GROUP_ISO,i,selected);
    }
}

</t>
<t tx="leo.20201108101525.56">void Model::setSelected(REntityGroupType elementGroupType, uint position, bool selected)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setSelected(selected);
    }
    if (!this-&gt;isSelected())
    {
        this-&gt;getData().setSelected(false);
    }
} /* Model::setSelected */

QList&lt;SessionEntityID&gt; Model::getSelectedEntityIDs(uint modelID) const
{
    QList&lt;SessionEntityID&gt; selectedEntityIDs;
    SessionEntityID entityID;

    entityID.setMid(modelID);

    entityID.setType(R_ENTITY_GROUP_POINT);
    for (uint j=0;j&lt;this-&gt;getNPoints();j++)
    {
        if (this-&gt;getSelected(R_ENTITY_GROUP_POINT,j))
        {
            entityID.setEid(j);
            selectedEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_LINE);
    for (uint j=0;j&lt;this-&gt;getNLines();j++)
    {
        if (this-&gt;getSelected(R_ENTITY_GROUP_LINE,j))
        {
            entityID.setEid(j);
            selectedEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_SURFACE);
    for (uint j=0;j&lt;this-&gt;getNSurfaces();j++)
    {
        if (this-&gt;getSelected(R_ENTITY_GROUP_SURFACE,j))
        {
            entityID.setEid(j);
            selectedEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_VOLUME);
    for (uint j=0;j&lt;this-&gt;getNVolumes();j++)
    {
        if (this-&gt;getSelected(R_ENTITY_GROUP_VOLUME,j))
        {
            entityID.setEid(j);
            selectedEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_VECTOR_FIELD);
    for (uint j=0;j&lt;this-&gt;getNVectorFields();j++)
    {
        if (this-&gt;getSelected(R_ENTITY_GROUP_VECTOR_FIELD,j))
        {
            entityID.setEid(j);
            selectedEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_SCALAR_FIELD);
    for (uint j=0;j&lt;this-&gt;getNScalarFields();j++)
    {
        if (this-&gt;getSelected(R_ENTITY_GROUP_SCALAR_FIELD,j))
        {
            entityID.setEid(j);
            selectedEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_STREAM_LINE);
    for (uint j=0;j&lt;this-&gt;getNStreamLines();j++)
    {
        if (this-&gt;getSelected(R_ENTITY_GROUP_STREAM_LINE,j))
        {
            entityID.setEid(j);
            selectedEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_CUT);
    for (uint j=0;j&lt;this-&gt;getNCuts();j++)
    {
        if (this-&gt;getSelected(R_ENTITY_GROUP_CUT,j))
        {
            entityID.setEid(j);
            selectedEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_ISO);
    for (uint j=0;j&lt;this-&gt;getNIsos();j++)
    {
        if (this-&gt;getSelected(R_ENTITY_GROUP_ISO,j))
        {
            entityID.setEid(j);
            selectedEntityIDs.push_back(entityID);
        }
    }

    return selectedEntityIDs;
} /* Model::getSelectedEntityIDs(uint modelID) */

QList&lt;SessionEntityID&gt; Model::getPickedEntityIDs(uint modelID) const
{
    QList&lt;SessionEntityID&gt; pickedEntityIDs;

    const PickList &amp;rPickList = Session::getInstance().getPickList();
    if (!rPickList.isEmpty())
    {
        QVector&lt;PickItem&gt; pickItems = rPickList.getItems(modelID);
        for (int i=0;i&lt;pickItems.size();i++)
        {
            if (!pickedEntityIDs.contains(pickItems.at(i).getEntityID()))
            {
                pickedEntityIDs.append(pickItems.at(i).getEntityID());
            }
        }
    }

    return pickedEntityIDs;
} /* Model::getPickedEntityIDs(uint modelID) */

QList&lt;SessionEntityID&gt; Model::getVisibleEntityIDs(uint modelID) const
{
    QList&lt;SessionEntityID&gt; visibleEntityIDs;
    SessionEntityID entityID;

    entityID.setMid(modelID);

    entityID.setType(R_ENTITY_GROUP_POINT);
    for (uint j=0;j&lt;this-&gt;getNPoints();j++)
    {
        if (this-&gt;getVisible(R_ENTITY_GROUP_POINT,j))
        {
            entityID.setEid(j);
            visibleEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_LINE);
    for (uint j=0;j&lt;this-&gt;getNLines();j++)
    {
        if (this-&gt;getVisible(R_ENTITY_GROUP_LINE,j))
        {
            entityID.setEid(j);
            visibleEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_SURFACE);
    for (uint j=0;j&lt;this-&gt;getNSurfaces();j++)
    {
        if (this-&gt;getVisible(R_ENTITY_GROUP_SURFACE,j))
        {
            entityID.setEid(j);
            visibleEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_VOLUME);
    for (uint j=0;j&lt;this-&gt;getNVolumes();j++)
    {
        if (this-&gt;getVisible(R_ENTITY_GROUP_VOLUME,j))
        {
            entityID.setEid(j);
            visibleEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_VECTOR_FIELD);
    for (uint j=0;j&lt;this-&gt;getNVectorFields();j++)
    {
        if (this-&gt;getVisible(R_ENTITY_GROUP_VECTOR_FIELD,j))
        {
            entityID.setEid(j);
            visibleEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_SCALAR_FIELD);
    for (uint j=0;j&lt;this-&gt;getNScalarFields();j++)
    {
        if (this-&gt;getVisible(R_ENTITY_GROUP_SCALAR_FIELD,j))
        {
            entityID.setEid(j);
            visibleEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_STREAM_LINE);
    for (uint j=0;j&lt;this-&gt;getNStreamLines();j++)
    {
        if (this-&gt;getVisible(R_ENTITY_GROUP_STREAM_LINE,j))
        {
            entityID.setEid(j);
            visibleEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_CUT);
    for (uint j=0;j&lt;this-&gt;getNCuts();j++)
    {
        if (this-&gt;getVisible(R_ENTITY_GROUP_CUT,j))
        {
            entityID.setEid(j);
            visibleEntityIDs.push_back(entityID);
        }
    }

    entityID.setType(R_ENTITY_GROUP_ISO);
    for (uint j=0;j&lt;this-&gt;getNIsos();j++)
    {
        if (this-&gt;getVisible(R_ENTITY_GROUP_ISO,j))
        {
            entityID.setEid(j);
            visibleEntityIDs.push_back(entityID);
        }
    }

    return visibleEntityIDs;
} /* Model::getVisibleEntityIDs */

QSet&lt;uint&gt; Model::getElementIDs(const QList&lt;SessionEntityID&gt; &amp;entityIDs) const
{
    QSet&lt;uint&gt; elementIDs;

    elementIDs.reserve(int(this-&gt;getNElements()));
    for (int i=0;i&lt;entityIDs.size();i++)
    {
        uint entityGroupId = this-&gt;getEntityGroupID(entityIDs[i].getType(),entityIDs[i].getEid(),true);
        if (entityGroupId == RConstants::eod)
        {
            continue;
        }
        const RElementGroup *pEelementGroup = static_cast&lt;const RElementGroup*&gt;(this-&gt;getEntityGroupPtr(entityGroupId,true));
        if (!pEelementGroup)
        {
            continue;
        }
        for (uint j=0;j&lt;pEelementGroup-&gt;size();j++)
        {
            elementIDs.insert(pEelementGroup-&gt;get(j));
        }
    }

    return elementIDs;
} /* Model::getElementIDs */

QSet&lt;uint&gt; Model::getNodeIDs(const QSet&lt;uint&gt; &amp;elementIDs) const
{
    QSet&lt;uint&gt; nodeIDs;

    QVector&lt;bool&gt; nodeBook;
    nodeBook.resize(int(this-&gt;getNNodes()));
    nodeBook.fill(false);

    foreach (uint elementID, elementIDs)
    {
        const RElement &amp;rElement = this-&gt;getElement(elementID);
        for (uint i=0;i&lt;rElement.size();i++)
        {
            nodeBook[int(rElement.getNodeId(i))] = true;
        }
    }

    uint nn = 0;
    for (int i=0;i&lt;nodeBook.size();i++)
    {
        if (nodeBook[i])
        {
            nn++;
        }
    }

    nodeIDs.reserve(int(nn));

    for (int i=0;i&lt;nodeBook.size();i++)
    {
        if (nodeBook[i])
        {
            nodeIDs.insert(uint(i));
        }
    }

    return nodeIDs;
} /* Model::getNodeIDs */


uint Model::getNSlivers() const
{
    return uint(this-&gt;sliverElements.size());
} /* Model::getNSlivers */


uint Model::getNIntersected() const
{
    return uint(this-&gt;intersectedElements.size());
} /* Model::getNIntersected */


uint Model::getNHoleElements() const
{
    return uint(this-&gt;holeElements.size());
} /* Model::getNHoleEdges */


</t>
<t tx="leo.20201108101525.57">bool Model::isVisible(bool visible) const
{
    if (!this-&gt;isVisible(R_ENTITY_GROUP_POINT,visible))
    {
        return false;
    }
    if (!this-&gt;isVisible(R_ENTITY_GROUP_LINE,visible))
    {
        return false;
    }
    if (!this-&gt;isVisible(R_ENTITY_GROUP_SURFACE,visible))
    {
        return false;
    }
    if (!this-&gt;isVisible(R_ENTITY_GROUP_VOLUME,visible))
    {
        return false;
    }
    if (!this-&gt;isVisible(R_ENTITY_GROUP_VECTOR_FIELD,visible))
    {
        return false;
    }
    if (!this-&gt;isVisible(R_ENTITY_GROUP_SCALAR_FIELD,visible))
    {
        return false;
    }
    if (!this-&gt;isVisible(R_ENTITY_GROUP_STREAM_LINE,visible))
    {
        return false;
    }
    if (!this-&gt;isVisible(R_ENTITY_GROUP_CUT,visible))
    {
        return false;
    }
    if (!this-&gt;isVisible(R_ENTITY_GROUP_ISO,visible))
    {
        return false;
    }
    return true;
}

</t>
<t tx="leo.20201108101525.58">bool Model::isVisible(REntityGroupType elementGroupType,
                      bool              visible) const
{
    uint nEntities;
    switch (elementGroupType)
    {
        case R_ENTITY_GROUP_POINT:
            nEntities = this-&gt;getNPoints();
            break;
        case R_ENTITY_GROUP_LINE:
            nEntities = this-&gt;getNLines();
            break;
        case R_ENTITY_GROUP_SURFACE:
            nEntities = this-&gt;getNSurfaces();
            break;
        case R_ENTITY_GROUP_VOLUME:
            nEntities = this-&gt;getNVolumes();
            break;
        case R_ENTITY_GROUP_VECTOR_FIELD:
            nEntities = this-&gt;getNVectorFields();
            break;
        case R_ENTITY_GROUP_SCALAR_FIELD:
            nEntities = this-&gt;getNScalarFields();
            break;
        case R_ENTITY_GROUP_STREAM_LINE:
            nEntities = this-&gt;getNStreamLines();
            break;
        case R_ENTITY_GROUP_CUT:
            nEntities = this-&gt;getNCuts();
            break;
        case R_ENTITY_GROUP_ISO:
            nEntities = this-&gt;getNIsos();
            break;
        default:
            return false;
    }
    for (uint i=0;i&lt;nEntities;i++)
    {
        if (this-&gt;getVisible(elementGroupType,i) != visible)
        {
            return false;
        }
    }
    return true;
}

</t>
<t tx="leo.20201108101525.59">bool Model::getVisible(REntityGroupType elementGroupType,
                       uint             position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getVisible();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.6">void MeshGeneratorDialog::onVolumeConstraintValueChanged(double)
{
    this-&gt;updateMeshInput();
}

</t>
<t tx="leo.20201108101525.60">void Model::setVisible(REntityGroupType elementGroupType,
                       uint             position,
                       bool             visible)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setVisible(visible);
    }
}

</t>
<t tx="leo.20201108101525.61">bool Model::getDrawWire(REntityGroupType elementGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getDrawWire();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.62">void Model::setDrawWire(REntityGroupType elementGroupType, uint position, bool drawWire)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setDrawWire(drawWire);
    }
}

</t>
<t tx="leo.20201108101525.63">bool Model::getDrawEdges(REntityGroupType elementGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getDrawEdges();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.64">void Model::setDrawEdges(REntityGroupType elementGroupType, uint position, bool drawEdges)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setDrawEdges(drawEdges);
    }
}

</t>
<t tx="leo.20201108101525.65">bool Model::getDrawNodes(REntityGroupType elementGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getDrawNodes();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.66">void Model::setDrawNodes(REntityGroupType elementGroupType, uint position, bool drawNodes)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setDrawNodes(drawNodes);
    }
}

</t>
<t tx="leo.20201108101525.67">bool Model::getDrawElementNumbers(REntityGroupType elementGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getDrawElementNumbers();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.68">void Model::setDrawElementNumbers(REntityGroupType elementGroupType, uint position, bool drawElementNumbers)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setDrawElementNumbers(drawElementNumbers);
    }
}

</t>
<t tx="leo.20201108101525.69">bool Model::getDrawNodeNumbers(REntityGroupType elementGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getDrawNodeNumbers();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.7">void MeshGeneratorDialog::onMeshSizeFunctionMinValueChanged(double)
{
    this-&gt;updateMeshInput();
}

</t>
<t tx="leo.20201108101525.70">void Model::setDrawNodeNumbers(REntityGroupType elementGroupType, uint position, bool drawNodeNumbers)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setDrawNodeNumbers(drawNodeNumbers);
    }
}

</t>
<t tx="leo.20201108101525.71">bool Model::getDrawArrowHeads(REntityGroupType elementGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getDrawArrowHeads();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.72">void Model::setDrawArrowHeads(REntityGroupType elementGroupType, uint position, bool drawArrowHeads)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setDrawArrowHeads(drawArrowHeads);
    }
}

</t>
<t tx="leo.20201108101525.73">bool Model::getDrawEqualArrowLengths(REntityGroupType entityGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(entityGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getDrawEqualArrowLength();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.74">void Model::setDrawEqualArrowLengths(REntityGroupType entityGroupType, uint position, bool drawEqualArrowLengths)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(entityGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setDrawEqualArrowLength(drawEqualArrowLengths);
    }
}

</t>
<t tx="leo.20201108101525.75">bool Model::getDrawArrowFrom(REntityGroupType entityGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(entityGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getDrawArrowFrom();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.76">void Model::setDrawArrowFrom(REntityGroupType entityGroupType, uint position, bool drawArrowFrom)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(entityGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setDrawArrowFrom(drawArrowFrom);
    }
}

</t>
<t tx="leo.20201108101525.77">bool Model::getColorByPatch(REntityGroupType entityGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(entityGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getColorByPatch();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.78">void Model::setColorByPatch(REntityGroupType entityGroupType, uint position, bool colorByPatch)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(entityGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setColorByPatch(colorByPatch);
    }
}

</t>
<t tx="leo.20201108101525.79">bool Model::getColorByViewFactor(REntityGroupType entityGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(entityGroupType,position);
    if (pElementGroupData)
    {
        return pElementGroupData-&gt;getColorByViewFactor();
    }
    return false;
}

</t>
<t tx="leo.20201108101525.8">void MeshGeneratorDialog::onMeshSizeFunctionMaxValueChanged(double)
{
    this-&gt;updateMeshInput();
}

</t>
<t tx="leo.20201108101525.80">void Model::setColorByViewFactor(REntityGroupType entityGroupType, uint position, bool colorByViewFactor)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(entityGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setColorByViewFactor(colorByViewFactor);
    }
}

QColor Model::getColor(REntityGroupType elementGroupType, uint position) const
{
    const REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        int r, g, b, a;
        pElementGroupData-&gt;getColor(r,g,b,a);
        return QColor(r,g,b,a);
    }
    else
    {
        return Color::random(true);
    }
}

</t>
<t tx="leo.20201108101525.81">void Model::setColor(REntityGroupType elementGroupType, uint position, const QColor &amp;color)
{
    REntityGroupData *pElementGroupData = this-&gt;getElementGroupData(elementGroupType,position);
    if (pElementGroupData)
    {
        pElementGroupData-&gt;setColor(color.red(),color.green(),color.blue(),color.alpha());
    }
}

</t>
<t tx="leo.20201108101525.82">void Model::glDrawLock()
{
    this-&gt;drawLock.lock();
}

</t>
<t tx="leo.20201108101525.83">bool Model::glDrawTrylock()
{
    return this-&gt;drawLock.tryLock();
}

</t>
<t tx="leo.20201108101525.84">void Model::glDrawUnlock()
{
    this-&gt;drawLock.unlock();
}

</t>
<t tx="leo.20201108101525.85">void Model::glDraw(GLWidget *glWidget) const
{
    try
    {
        // Reset OpenGL list sizes.
        glWidget-&gt;getGLModelList().setNGlPointLists(this-&gt;getNPoints());
        glWidget-&gt;getGLModelList().setNGlLineLists(this-&gt;getNLines());
        glWidget-&gt;getGLModelList().setNGlSurfaceLists(this-&gt;getNSurfaces());
        glWidget-&gt;getGLModelList().setNGlVolumeLists(this-&gt;getNVolumes());
        glWidget-&gt;getGLModelList().setNGlVectorFieldLists(this-&gt;getNVectorFields());
        glWidget-&gt;getGLModelList().setNGlScalarFieldLists(this-&gt;getNScalarFields());
        glWidget-&gt;getGLModelList().setNGlStreamLineLists(this-&gt;getNStreamLines());
        glWidget-&gt;getGLModelList().setNGlCutLists(this-&gt;getNCuts());
        glWidget-&gt;getGLModelList().setNGlIsoLists(this-&gt;getNIsos());

        GLint depthFunc;
        GL_SAFE_CALL(glGetIntegerv(GL_DEPTH_FUNC, &amp;depthFunc));
        GL_SAFE_CALL(glDepthFunc(GL_LEQUAL));

        uint modelID = Session::getInstance().findModelByPtr(this);

        // Draw volume entities.
        for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
        {
            GLElementGroup glElementGroup(glWidget,this-&gt;getVolume(i),SessionEntityID(modelID,R_ENTITY_GROUP_VOLUME,i));
            glElementGroup.setParentModel(this);
            glElementGroup.setUseGlList(true);
            glElementGroup.paint();
        }

        // Draw surface entities.
        for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
        {
            GLElementGroup glElementGroup(glWidget,this-&gt;getSurface(i),SessionEntityID(modelID,R_ENTITY_GROUP_SURFACE,i));
            glElementGroup.setParentModel(this);
            glElementGroup.setSurfaceThickness(this-&gt;getSurface(i).getThickness());
            glElementGroup.setUseGlList(true);
            glElementGroup.setUseGlCullFace(glWidget-&gt;getUseGlCullFace());
            glElementGroup.paint();
        }

        // Draw line entities.
        for (uint i=0;i&lt;this-&gt;getNLines();i++)
        {
            GLElementGroup glElementGroup(glWidget,this-&gt;getLine(i),SessionEntityID(modelID,R_ENTITY_GROUP_LINE,i));
            glElementGroup.setParentModel(this);
            glElementGroup.setLineCrossArea(this-&gt;getLine(i).getCrossArea());
            glElementGroup.setUseGlList(true);
            glElementGroup.paint();
        }

        // Draw point entities.
        for (uint i=0;i&lt;this-&gt;getNPoints();i++)
        {
            GLElementGroup glElementGroup(glWidget,this-&gt;getPoint(i),SessionEntityID(modelID,R_ENTITY_GROUP_POINT,i));
            glElementGroup.setParentModel(this);
            glElementGroup.setPointVolume(this-&gt;getPoint(i).getVolume());
            glElementGroup.setUseGlList(true);
            glElementGroup.paint();
        }

        // Draw vector field entities.
        for (uint i=0;i&lt;this-&gt;getNVectorFields();i++)
        {
            GLVectorField glVectorField(glWidget,this-&gt;getVectorField(i),SessionEntityID(modelID,R_ENTITY_GROUP_VECTOR_FIELD,i));
            glVectorField.setApplyEnvironmentSettings(false);
            glVectorField.setParentModel(this);
            glVectorField.setUseGlList(true);
            glVectorField.paint();
        }

        // Draw scalar field entities.
        for (uint i=0;i&lt;this-&gt;getNScalarFields();i++)
        {
            GLScalarField glScalarField(glWidget,this-&gt;getScalarField(i),SessionEntityID(modelID,R_ENTITY_GROUP_SCALAR_FIELD,i));
            glScalarField.setApplyEnvironmentSettings(false);
            glScalarField.setParentModel(this);
            glScalarField.setUseGlList(true);
            glScalarField.paint();
        }

        // Draw stream line entities.
        for (uint i=0;i&lt;this-&gt;getNStreamLines();i++)
        {
            GLInterpolatedEntity glStreamLine(glWidget,this-&gt;getStreamLine(i),SessionEntityID(modelID,R_ENTITY_GROUP_STREAM_LINE,i));
            glStreamLine.setApplyEnvironmentSettings(false);
            glStreamLine.setParentModel(this);
            glStreamLine.setUseGlList(true);
            glStreamLine.paint();
        }

        // Draw cuts entities.
        for (uint i=0;i&lt;this-&gt;getNCuts();i++)
        {
            GLInterpolatedEntity glCut(glWidget,this-&gt;getCut(i),SessionEntityID(modelID,R_ENTITY_GROUP_CUT,i));
            glCut.setApplyEnvironmentSettings(false);
            glCut.setParentModel(this);
            glCut.setUseGlList(true);
            glCut.paint();
        }

        // Draw isos entities.
        for (uint i=0;i&lt;this-&gt;getNIsos();i++)
        {
            GLInterpolatedEntity glIso(glWidget,this-&gt;getIso(i),SessionEntityID(modelID,R_ENTITY_GROUP_ISO,i));
            glIso.setApplyEnvironmentSettings(false);
            glIso.setParentModel(this);
            glIso.setUseGlList(true);
            glIso.paint();
        }

        if (glWidget-&gt;getGLDisplayProperties().getShowModelEdges())
        {
            // Draw edge elements
            int cValue = qGray(glWidget-&gt;getGLDisplayProperties().getBgColor().rgb()) &lt; 128 ? 255 : 0;
            QColor edgeColor(cValue,cValue,cValue);

            // Draw elements only in normal mode
            for (int i=0;i&lt;this-&gt;edgeElements.size();i++)
            {
                const RNode &amp;node1 = this-&gt;getNode(this-&gt;edgeElements[i].getNodeId(0));
                const RNode &amp;node2 = this-&gt;getNode(this-&gt;edgeElements[i].getNodeId(1));

                glWidget-&gt;qglColor(edgeColor);

                GLLine line(glWidget,node1.toVector(),node2.toVector(),2.0);
                line.paint();
            }
        }

        if (glWidget-&gt;getGLDisplayProperties().getShowErrors())
        {
            // Draw hole edges.
            for (int i=0;i&lt;this-&gt;holeElements.size();i++)
            {
                const RNode &amp;node1 = this-&gt;getNode(this-&gt;holeElements[i].getNodeId(0));
                const RNode &amp;node2 = this-&gt;getNode(this-&gt;holeElements[i].getNodeId(1));
                glWidget-&gt;qglColor(QColor(255,0,0));
                GLLine(glWidget,node1.toVector(),node2.toVector(),2.0).paint();
            }

            //Draw sliver elements.
            REntityGroupData sliverGroupData;
            sliverGroupData.setDrawWire(true);
            for (int i=0;i&lt;this-&gt;sliverElements.size();i++)
            {
                GLElement glElement(glWidget,
                                    this,
                                    this-&gt;sliverElements[i],
                                    sliverGroupData,
                                    QColor(255,100,0),
                                    GL_ELEMENT_DRAW_NORMAL);
                glElement.setApplyEnvironmentSettings(false);
                glElement.setEdgeLineWidth(3.0f);
                glElement.paint();
            }

            //Draw intersected elements.
            REntityGroupData intersectedGroupData;
            intersectedGroupData.setDrawWire(true);
            for (int i=0;i&lt;this-&gt;intersectedElements.size();i++)
            {
                GLElement glElement(glWidget,
                                    this,
                                    this-&gt;intersectedElements[i],
                                    intersectedGroupData,
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to draw model. %s\n",error.getMessage().toUtf8().constData());
    }
    catch (const std::exception &amp;error)
    {
        RLogger::error("Failed to draw model. %s\n",error.what());
    }
    catch (...)
    {
        RLogger::error("Failed to draw model. Unknown exception\n");
    }
}

</t>
<t tx="leo.20201108101525.86">void Model::glDraw(GLWidget *glWidget, const QVector&lt;PickItem&gt; &amp;pickedItems) const
{
    try
    {
        GLint depthFunc;
        GLboolean lightingEnabled;
        GLfloat pointSize;

        GL_SAFE_CALL(glGetBooleanv(GL_LIGHTING, &amp;lightingEnabled));
        GL_SAFE_CALL(glGetIntegerv(GL_DEPTH_FUNC, &amp;depthFunc));
        GL_SAFE_CALL(glGetFloatv(GL_POINT_SIZE, &amp;pointSize));

        GL_SAFE_CALL(glDisable(GL_LIGHTING));
        GL_SAFE_CALL(glDepthFunc(GL_LEQUAL));
        GL_SAFE_CALL(glPointSize(10.0));

        for (int i=0;i&lt;pickedItems.size();i++)
        {
            PickItemType itemType = pickedItems[i].getItemType();
            REntityGroupType entityType = pickedItems[i].getEntityID().getType();
            uint entityID = pickedItems[i].getEntityID().getEid();
            uint elementPosition = pickedItems[i].getElementPosition();
            uint elementID = pickedItems[i].getElementID();
            uint nodePosition = pickedItems[i].getNodePosition();
            uint nodeID = pickedItems[i].getNodeID();

            if (itemType == PICK_ITEM_HOLE_ELEMENT)
            {
                glWidget-&gt;qglColor(QColor(Qt::white));

                const RNode &amp;node1 = this-&gt;getNode(this-&gt;holeElements[int(elementPosition)].getNodeId(0));
                const RNode &amp;node2 = this-&gt;getNode(this-&gt;holeElements[int(elementPosition)].getNodeId(1));

                GLLine line(glWidget,node1.toVector(),node2.toVector(),4.0);

                line.paint();

                continue;
            }

            uint groupID = this-&gt;getEntityGroupID(entityType,entityID);

            const REntityGroup *pEntity = this-&gt;getEntityGroupPtr(groupID);

            if (!pEntity)
            {
                continue;
            }

            uint displacementVarPosition = this-&gt;findVariable(pEntity-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT));
            const RVariable *pDisplacementVariable = nullptr;
            if (displacementVarPosition != RConstants::eod)
            {
                pDisplacementVariable = &amp;this-&gt;getVariable(displacementVarPosition);
            }

            if (itemType == PICK_ITEM_ELEMENT)
            {
                REntityGroupData groupData;
                groupData.setColor(255,255,255,200);
                groupData.setDrawEdges(false);
                groupData.setDrawElementNumbers(false);
                groupData.setDrawNodeNumbers(false);
                groupData.setDrawNodes(false);
                groupData.setDrawWire(false);


                if (REntityGroup::typeIsElementGroup(entityType))
                {
                    int r,g,b,a;
                    groupData.getColor(r,g,b,a);
                    GLElement glElement(glWidget,
                                        this,
                                        elementID,
                                        groupData,
                                        QColor(r,g,b,a),
                                        GL_ELEMENT_DRAW_NORMAL);
                    glElement.setDisplacementVariable(pDisplacementVariable);
                    glElement.setApplyEnvironmentSettings(false);
                    switch (entityType)
                    {
                        case R_ENTITY_GROUP_POINT:
                        {
                            glElement.setPointVolume(this-&gt;getPoint(entityID).getVolume());
                            break;
                        }
                        case R_ENTITY_GROUP_LINE:
                        {
                            glElement.setLineCrossArea(this-&gt;getLine(entityID).getCrossArea());
                            break;
                        }
                        case R_ENTITY_GROUP_SURFACE:
                        {
                            glElement.setSurfaceThickness(this-&gt;getSurface(entityID).getThickness());
                            break;
                        }
                        default:
                        {
                            break;
                        }
                    }

                    glElement.paint();
                }
                else if (REntityGroup::typeIsInterpolatedElementGroup(entityType))
                {
                    const RInterpolatedEntity *pIEntity = nullptr;

                    if (entityType == R_ENTITY_GROUP_CUT || entityType == R_ENTITY_GROUP_ISO)
                    {
                        pIEntity = static_cast&lt;const RInterpolatedEntity*&gt;(pEntity);
                    }
                    else
                    {
                        continue;
                    }

                    GLInterpolatedElement glElement(glWidget,
                                                    this,
                                                    pIEntity-&gt;at(elementPosition),
                                                    elementPosition,
                                                    groupData,
                                                    GL_ELEMENT_DRAW_NORMAL);
                    glElement.setDisplacementVariable(pDisplacementVariable);
                    glElement.setApplyEnvironmentSettings(false);
                    glElement.paint();
                }
            }
            else if (itemType == PICK_ITEM_NODE)
            {
                glWidget-&gt;qglColor(QColor(Qt::white));
                bool nodeFound = false;
                RNode node;

                if (REntityGroup::typeIsElementGroup(entityType))
                {
                    const RElement &amp;rElement = this-&gt;getElement(elementID);
                    node = this-&gt;getNode(nodeID);
                    nodeFound = true;
                    if (pDisplacementVariable)
                    {
                        std::vector&lt;RR3Vector&gt; displacementValues;
                        rElement.findDisplacementNodeValues(elementID,*pDisplacementVariable,displacementValues);
                        node.move(displacementValues[nodePosition]);
                    }
                }
                else if (REntityGroup::typeIsInterpolatedElementGroup(entityType))
                {
                    const RInterpolatedElement *pIElement = nullptr;
                    switch (entityType)
                    {
                        case R_ENTITY_GROUP_CUT:
                        {
                            pIElement = &amp;this-&gt;getCut(entityID).at(elementPosition);
                            break;
                        }
                        case R_ENTITY_GROUP_ISO:
                        {
                            pIElement = &amp;this-&gt;getIso(entityID).at(elementPosition);
                            break;
                        }
                        default:
                        {
                            continue;
                        }
                    }
                    if (pIElement)
                    {
                        node = pIElement-&gt;at(nodePosition);
                        nodeFound = true;
                        if (pDisplacementVariable)
                        {
                            std::vector&lt;RR3Vector&gt; displacementValues;
                            pIElement-&gt;findDisplacementNodeValues(this-&gt;getNodes(),this-&gt;getElements(),*pDisplacementVariable,displacementValues);
                            node.move(displacementValues[nodePosition]);
                        }
                    }
                }

                if (nodeFound)
                {
                    GLFunctions::begin(GL_POINTS);
                    GLObject::glVertexNode(node);
                    GLFunctions::end();
                }
            }
        }

        if (lightingEnabled)
        {
            GL_SAFE_CALL(glEnable(GL_LIGHTING));
        }
        GL_SAFE_CALL(glDepthFunc(GLenum(depthFunc)));
        GL_SAFE_CALL(glPointSize(pointSize));
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to draw model. %s\n",error.getMessage().toUtf8().constData());
    }
    catch (const std::exception &amp;error)
    {
        RLogger::error("Failed to draw model. %s\n",error.what());
    }
    catch (...)
    {
        RLogger::error("Failed to draw model. Unknown exception.\n");
    }
}

QMap&lt;RVariableType, PickValue&gt; Model::getPickedResultsValues(const PickItem &amp;rPickItem) const
{
    QMap&lt;RVariableType, PickValue&gt; resultsValues;

    for (uint i=0;i&lt;this-&gt;getNVariables();i++)
    {
        const RVariable &amp;rVariable = this-&gt;getVariable(i);
        const RVariable *pDisplacementVariable = this-&gt;findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT,rPickItem.getEntityID().getType(),rPickItem.getEntityID().getEid());

        if (rPickItem.getItemType() == PICK_ITEM_ELEMENT)
        {
            std::vector&lt;RRVector&gt; resultsValuesVector;
            std::vector&lt;RR3Vector&gt; positionVector;
            if (REntityGroup::typeIsElementGroup(rPickItem.getEntityID().getType()))
            {
                uint elementID = rPickItem.getElementID();
                if (elementID == RConstants::eod)
                {
                    continue;
                }

                resultsValuesVector = this-&gt;getElementResultsValues(rVariable.getType(),elementID);

                const RElement &amp;rElement = this-&gt;getElement(elementID);
                std::vector&lt;RR3Vector&gt; displacementValues;
                if (pDisplacementVariable)
                {
                    rElement.findDisplacementNodeValues(elementID,*pDisplacementVariable,displacementValues);
                }
                else
                {
                    displacementValues.resize(rElement.size(),RR3Vector(0.0,0.0,0.0));
                }
                if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
                {
                    positionVector.resize(1);
                    positionVector[0] = RR3Vector(0.0,0.0,0.0);
                    for (uint j=0;j&lt;rElement.size();j++)
                    {
                        positionVector[0][0] += this-&gt;getNode(rElement.getNodeId(j)).getX() + displacementValues[j][0];
                        positionVector[0][1] += this-&gt;getNode(rElement.getNodeId(j)).getY() + displacementValues[j][1];
                        positionVector[0][2] += this-&gt;getNode(rElement.getNodeId(j)).getZ() + displacementValues[j][2];
                    }
                    positionVector[0] *= 1.0 / double(rElement.size());
                }
                else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
                {
                    positionVector.resize(rElement.size());
                    for (uint j=0;j&lt;rElement.size();j++)
                    {
                        positionVector[j][0] = this-&gt;getNode(rElement.getNodeId(j)).getX() + displacementValues[j][0];
                        positionVector[j][1] = this-&gt;getNode(rElement.getNodeId(j)).getY() + displacementValues[j][1];
                        positionVector[j][2] = this-&gt;getNode(rElement.getNodeId(j)).getZ() + displacementValues[j][2];
                    }
                }
                else
                {
                    positionVector.resize(resultsValuesVector.size());
                }
            }
            else if (REntityGroup::typeIsInterpolatedElementGroup(rPickItem.getEntityID().getType()))
            {
                resultsValuesVector = this-&gt;getInterpolatedElementResultsValues(rVariable.getType(),
                                                                                rPickItem.getEntityID().getType(),
                                                                                rPickItem.getEntityID().getEid(),
                                                                                rPickItem.getElementPosition());
</t>
<t tx="leo.20201108101525.87">        const RInterpolatedElement *pIElement = this-&gt;getInterpolatedElement(rPickItem.getEntityID().getType(),
                                                                             rPickItem.getEntityID().getEid(),
                                                                             rPickItem.getElementPosition());
        std::vector&lt;RR3Vector&gt; displacementValues;
        if (pDisplacementVariable)
        {
            pIElement-&gt;findDisplacementNodeValues(this-&gt;getNodes(),this-&gt;getElements(),*pDisplacementVariable,displacementValues);
        }
        else
        {
            displacementValues.resize(pIElement-&gt;size(),RR3Vector(0.0,0.0,0.0));
        }
        if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            positionVector.resize(1);
            positionVector[0] = RR3Vector(0.0,0.0,0.0);
            for (uint j=0;j&lt;pIElement-&gt;size();j++)
            {
                positionVector[0][0] += pIElement-&gt;at(j).getX() + displacementValues[j][0];
                positionVector[0][1] += pIElement-&gt;at(j).getY() + displacementValues[j][1];
                positionVector[0][2] += pIElement-&gt;at(j).getZ() + displacementValues[j][2];
            }
            positionVector[0] *= 1.0 / double(pIElement-&gt;size());
        }
        else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            positionVector.resize(pIElement-&gt;size());
            for (uint j=0;j&lt;pIElement-&gt;size();j++)
            {
                positionVector[j][0] = pIElement-&gt;at(j).getX() + displacementValues[j][0];
                positionVector[j][1] = pIElement-&gt;at(j).getY() + displacementValues[j][1];
                positionVector[j][2] = pIElement-&gt;at(j).getZ() + displacementValues[j][2];
            }
        }
        else
        {
            positionVector.resize(resultsValuesVector.size());
        }
    }
    for (uint j=0;j&lt;resultsValuesVector.size();j++)
    {
        resultsValues.insertMulti(rVariable.getType(),PickValue(positionVector[j],resultsValuesVector[j]));
    }
}
else if (rPickItem.getItemType() == PICK_ITEM_NODE)
{
    RRVector resultsValuesVector;
    RR3Vector position;
    if (REntityGroup::typeIsElementGroup(rPickItem.getEntityID().getType()))
    {
        RR3Vector displacement(0.0,0.0,0.0);
        if (pDisplacementVariable)
        {
            uint elementID = rPickItem.getElementID();
            if (elementID != RConstants::eod)
            {
                const RElement &amp;rElement = this-&gt;getElement(elementID);
                std::vector&lt;RR3Vector&gt; displacementNodeValues;
                rElement.findDisplacementNodeValues(elementID,*pDisplacementVariable,displacementNodeValues);
                displacement = displacementNodeValues[rPickItem.getNodePosition()];
            }
        }

        uint nodeID = rPickItem.getNodeID();
        if (nodeID == RConstants::eod)
        {
            continue;
        }
        resultsValuesVector = this-&gt;getNodeResultsValues(rVariable.getType(),nodeID);
        position[0] = this-&gt;getNode(nodeID).getX() + displacement[0];
        position[1] = this-&gt;getNode(nodeID).getY() + displacement[1];
        position[2] = this-&gt;getNode(nodeID).getZ() + displacement[2];
    }
    else if (REntityGroup::typeIsInterpolatedElementGroup(rPickItem.getEntityID().getType()))
    {
        RR3Vector displacement(0.0,0.0,0.0);
        if (pDisplacementVariable)
        {
</t>
<t tx="leo.20201108101525.88">                    const RInterpolatedElement *pIElement = this-&gt;getInterpolatedElement(rPickItem.getEntityID().getType(),
                                                                                         rPickItem.getEntityID().getEid(),
                                                                                         rPickItem.getElementPosition());
                    if (pIElement)
                    {
                        std::vector&lt;RR3Vector&gt; displacementNodeValues;
                        pIElement-&gt;findDisplacementNodeValues(this-&gt;getNodes(),this-&gt;getElements(),*pDisplacementVariable,displacementNodeValues);
                        displacement = displacementNodeValues[rPickItem.getNodePosition()];
                    }
                }

                resultsValuesVector = this-&gt;getInterpolatedNodeResultsValues(rVariable.getType(),
                                                                             rPickItem.getEntityID().getType(),
                                                                             rPickItem.getEntityID().getEid(),
                                                                             rPickItem.getElementPosition(),
                                                                             rPickItem.getNodePosition());
                const RInterpolatedElement *pIElement = this-&gt;getInterpolatedElement(rPickItem.getEntityID().getType(),
    return resultsValues;
}

</t>
<t tx="leo.20201108101525.89">bool Model::nodeIsOnEdge(uint nodeID) const
{
    return (this-&gt;edgeNodes[int(nodeID)]);
}

</t>
<t tx="leo.20201108101525.9">void MeshGeneratorDialog::onReconstructStateChanged(int)
{
    this-&gt;updateMeshInput();
}

</t>
<t tx="leo.20201108101525.90">bool Model::elementIsOnEdge(uint elementID) const
{
    const RElement &amp;element = this-&gt;getElement(elementID);
    REntityGroupType grpType = RElementGroup::getGroupType(element.getType());
    unsigned int nEdgeNodes = 0;

    switch (grpType)
    {
        case R_ENTITY_GROUP_POINT:
            return true;
        case R_ENTITY_GROUP_LINE:
            return true;
        case R_ENTITY_GROUP_SURFACE:
            return true;
        case R_ENTITY_GROUP_VOLUME:
            nEdgeNodes = 3;
            break;
        default:
            return false;
    }

    unsigned nFoundEdgeNodes = 0;
    for (unsigned int i=0;i&lt;element.size();i++)
    {
        if (this-&gt;edgeNodes[int(element.getNodeId(i))])
        {
            nFoundEdgeNodes++;
        }
        if (nFoundEdgeNodes &gt;= nEdgeNodes)
        {
            return true;
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101525.91">bool Model::findPickedElement(const RR3Vector &amp;position, const RR3Vector &amp;direction, double tolerance, PickItem &amp;pickItem)
{
    double minDistance = 0.0;
    bool found = false;

    std::vector&lt;RNode&gt; dispNodes(this-&gt;getNodes());

#pragma omp parallel default(shared)
    {
        for (uint i=0;i&lt;this-&gt;getNEntityGroups();i++)
        {
            REntityGroupType entityType = this-&gt;getEntityGroupType(i);
            uint entityID = this-&gt;getEntityGroupPosition(i);

            const REntityGroup *pEntity = this-&gt;getEntityGroupPtr(i);
            if (!pEntity)
            {
                continue;
            }
            if (!pEntity-&gt;getData().getVisible())
            {
                continue;
            }

            uint displacementVarPosition = this-&gt;findVariable(pEntity-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT));
            const RVariable *pDisplacementVariable = nullptr;
            if (displacementVarPosition != RConstants::eod)
            {
                pDisplacementVariable = &amp;this-&gt;getVariable(displacementVarPosition);
            }

            if (REntityGroup::typeIsElementGroup(entityType))
            {
                const RElementGroup *pElementGroup = static_cast&lt;const RElementGroup*&gt;(pEntity);

#pragma omp barrier
#pragma omp for
                for (int64_t j=0;j&lt;int64_t(pElementGroup-&gt;size());j++)
                {
                    uint elementID = pElementGroup-&gt;get(uint(j));
                    const RElement &amp;rElement = this-&gt;getElement(elementID);

                    if (pDisplacementVariable)
                    {
                        std::vector&lt;RR3Vector&gt; displacementValues;
                        rElement.findDisplacementNodeValues(elementID,*pDisplacementVariable,displacementValues);
                        for (uint k=0;k&lt;rElement.size();k++)
                        {
                            uint nodeID = rElement.getNodeId(k);
                            dispNodes[nodeID].setX(this-&gt;getNode(nodeID).getX() + displacementValues[k][0]);
                            dispNodes[nodeID].setY(this-&gt;getNode(nodeID).getY() + displacementValues[k][1]);
                            dispNodes[nodeID].setZ(this-&gt;getNode(nodeID).getZ() + displacementValues[k][2]);
                        }
                    }

                    double distance;
                    if (rElement.findPickDistance(dispNodes,position,direction,tolerance,distance))
                    {
                        if (!found || minDistance &gt; distance)
                        {
                            minDistance = distance;
                            pickItem = PickItem(SessionEntityID(0,entityType,entityID),elementID,uint(j));
                            found = true;
                        }
                    }
                }
            }
            else if (REntityGroup::typeIsInterpolatedElementGroup(entityType))
            {
                const RInterpolatedEntity *pIEntity = static_cast&lt;const RInterpolatedEntity*&gt;(pEntity);

                std::vector&lt;RR3Vector&gt; nodeDisplacementValues;

#pragma omp barrier
#pragma omp for
                for (int64_t j=0;j&lt;int64_t(pIEntity-&gt;size());j++)
                {
                    RInterpolatedElement iElement(pIEntity-&gt;at(uint(j)));

                    if (pDisplacementVariable)
                    {
                        iElement.findDisplacementNodeValues(this-&gt;getNodes(),this-&gt;getElements(),*pDisplacementVariable,nodeDisplacementValues);
                        for (uint k=0;k&lt;iElement.size();k++)
                        {
                            iElement[k].move(nodeDisplacementValues[k]);
                        }
                    }

                    double distance;
                    if (iElement.findPickDistance(position,direction,tolerance,distance))
                    {
                        if (!found || minDistance &gt; distance)
                        {
                            minDistance = distance;
                            pickItem = PickItem(SessionEntityID(0,entityType,entityID),uint(j),uint(j));
                            found = true;
                        }
                    }
                }
            }
        }
    }
    return found;
}

</t>
<t tx="leo.20201108101525.92">bool Model::findPickedNode(const RR3Vector &amp;position, const RR3Vector &amp;direction, double tolerance, PickItem &amp;pickItem)
{
    double minDistance = 0.0;
    bool found = false;

    std::vector&lt;RNode&gt; dispNodes(this-&gt;getNodes());

    RSegment ray(RNode(position),RNode(position[0]+direction[0],position[1]+direction[1],position[2]+direction[2]));

#pragma omp parallel default(shared)
    {
        for (uint i=0;i&lt;this-&gt;getNEntityGroups();i++)
        {
            REntityGroupType entityType = this-&gt;getEntityGroupType(i);
            uint entityID = this-&gt;getEntityGroupPosition(i);

            const REntityGroup *pEntity = this-&gt;getEntityGroupPtr(i);
            if (!pEntity)
            {
                continue;
            }
            if (!pEntity-&gt;getData().getVisible())
            {
                continue;
            }

            uint displacementVarPosition = this-&gt;findVariable(pEntity-&gt;getData().findVariableByDisplayType(R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT));
            const RVariable *pDisplacementVariable = nullptr;
            if (displacementVarPosition != RConstants::eod)
            {
                pDisplacementVariable = &amp;this-&gt;getVariable(displacementVarPosition);
            }

            if (REntityGroup::typeIsElementGroup(entityType))
            {
                const RElementGroup *pElementGroup = static_cast&lt;const RElementGroup*&gt;(pEntity);

#pragma omp barrier
#pragma omp for
                for (int64_t j=0;j&lt;int64_t(pElementGroup-&gt;size());j++)
                {
                    uint elementID = pElementGroup-&gt;get(uint(j));
                    const RElement &amp;rElement = this-&gt;getElement(elementID);

                    if (pDisplacementVariable)
                    {
                        std::vector&lt;RR3Vector&gt; displacementValues;
                        rElement.findDisplacementNodeValues(elementID,*pDisplacementVariable,displacementValues);
                        for (uint k=0;k&lt;rElement.size();k++)
                        {
                            uint nodeID = rElement.getNodeId(k);
                            dispNodes[nodeID].setX(this-&gt;getNode(nodeID).getX() + displacementValues[k][0]);
                            dispNodes[nodeID].setY(this-&gt;getNode(nodeID).getY() + displacementValues[k][1]);
                            dispNodes[nodeID].setZ(this-&gt;getNode(nodeID).getZ() + displacementValues[k][2]);
                        }
                    }

                    for (uint k=0;k&lt;rElement.size();k++)
                    {
                        uint nodeID = rElement.getNodeId(k);
                        const RNode &amp;node = dispNodes[nodeID];

                        double u = ray.findPointDistance(node.toVector());
                        if (u &lt;= tolerance)
                        {
                            double distance = node.getDistance(RNode(position));
                            if (!found || minDistance &gt; distance)
                            {
                                minDistance = distance;
                                pickItem = PickItem(SessionEntityID(0,entityType,entityID),elementID,uint(j),nodeID,k);
                                found = true;
                            }
                        }
                    }
                }
            }
            else if (REntityGroup::typeIsInterpolatedElementGroup(entityType))
            {
                const RInterpolatedEntity *pIEntity = static_cast&lt;const RInterpolatedEntity*&gt;(pEntity);

                std::vector&lt;RR3Vector&gt; nodeDisplacementValues;

#pragma omp barrier
#pragma omp for
                for (int64_t j=0;j&lt;int64_t(pIEntity-&gt;size());j++)
                {
                    RInterpolatedElement iElement(pIEntity-&gt;at(uint(j)));

                    if (pDisplacementVariable)
                    {
                        iElement.findDisplacementNodeValues(this-&gt;getNodes(),this-&gt;getElements(),*pDisplacementVariable,nodeDisplacementValues);
                        for (uint k=0;k&lt;iElement.size();k++)
                        {
                            iElement[k].move(nodeDisplacementValues[k]);
                        }
                    }

                    for (uint k=0;k&lt;iElement.size();k++)
                    {
                        double u = ray.findPointDistance(iElement[k].toVector());
                        if (u &lt;= tolerance)
                        {
                            double distance = iElement[k].getDistance(RNode(position));
                            if (!found || minDistance &gt; distance)
                            {
                                minDistance = distance;
                                pickItem = PickItem(SessionEntityID(0,entityType,entityID),uint(j),uint(j),k,k);
                                found = true;
                            }
                        }
                    }
                }
            }
        }
    }
    return found;
}

</t>
<t tx="leo.20201108101525.93">bool Model::findPickedHoleElement(const RR3Vector &amp;position, const RR3Vector &amp;direction, double tolerance, PickItem &amp;pickItem)
{
    bool found = false;
    double minDistance = 0.0;

    for (uint i=0;i&lt;uint(this-&gt;holeElements.size());i++)
    {
        double distance;
        if (this-&gt;holeElements[int(i)].findPickDistance(this-&gt;getNodes(),position,direction,tolerance,distance))
        {
            if (!found || distance &lt; minDistance)
            {
                minDistance = distance;
                pickItem = PickItem(SessionEntityID(0,R_ENTITY_GROUP_NONE,RConstants::eod),i,i);
                found = true;
            }
        }
    }
    return found;
}

</t>
<t tx="leo.20201108101525.94">void Model::update(const RModel &amp;rModel)
{
    RModel::update(rModel);

    int consolidateActionMask = Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements;
    if (this-&gt;getNVolumes() == 0)
    {
        consolidateActionMask |= Model::ConsolidateSliverElements | Model::ConsolidateIntersectedElements;
    }
    this-&gt;consolidate(consolidateActionMask);
    // Fix missing color scales in variable data.
    for (uint i=0;i&lt;this-&gt;getNVariables();i++)
    {
        if (this-&gt;getVariable(i).getVariableData().getValueRangeName().isEmpty())
        {
            this-&gt;getVariable(i).getVariableData().setValueRangeName(ColorScale::getDefaultColorScale());
        }
    }
}

</t>
<t tx="leo.20201108101525.95">void Model::read(const QString &amp;fileName)
{
    RModel::read(fileName);
    this-&gt;setFileName(fileName);
    if (this-&gt;getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_RADIATIVE_HEAT)
    {
        try
        {
            this-&gt;loadViewFactorMatrix();
        }
        catch (const RError &amp;error)
        {
            RLogger::error("Failed to load view-factor matrix file. %s\n",error.getMessage().toUtf8().constData());
        }
    }
    else
    {
        this-&gt;unloadViewFactorMatrix();
    }
    int consolidateActionMask = Model::ConsolidateEdgeElements | Model::ConsolidateHoleElements;
    if (this-&gt;getNVolumes() == 0)
    {
        consolidateActionMask |= Model::ConsolidateSliverElements | Model::ConsolidateIntersectedElements;
    }
    this-&gt;consolidate(consolidateActionMask);
    // Fix missing color scales in variable data.
    for (uint i=0;i&lt;this-&gt;getNVariables();i++)
    {
        if (this-&gt;getVariable(i).getVariableData().getValueRangeName().isEmpty())
        {
            this-&gt;getVariable(i).getVariableData().setValueRangeName(ColorScale::getDefaultColorScale());
        }
    }
}

</t>
<t tx="leo.20201108101525.96">void Model::write(const QString &amp;fileName, bool writeLinkFile)
{
    this-&gt;setFileName(RModel::write(fileName,writeLinkFile));
}

</t>
<t tx="leo.20201108101525.97">void Model::loadViewFactorMatrix()
{
    this-&gt;viewFactorMatrix.clear();

    QString viewFactorMatrixFile = this-&gt;getProblemSetup().getRadiationSetup().getViewFactorMatrixFile();
    if (viewFactorMatrixFile.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"Missing view-factor matrix file name.");
    }

    if (!RFileManager::fileExists(viewFactorMatrixFile))
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"View-factor matrix file \'%s\' does not exist.",viewFactorMatrixFile.toUtf8().constData());
    }

    QString recentViewFactorMatrixFile = RRadiationSetup::findRecentViewFactorMatrixFile(viewFactorMatrixFile,
                                                                                         this-&gt;getTimeSolver().getCurrentTimeStep());

    if (recentViewFactorMatrixFile.isEmpty())
    {
        this-&gt;viewFactorMatrix.getHeader().setHemicubeResolution(this-&gt;getProblemSetup().getRadiationSetup().getResolution());
        this-&gt;generatePatchInputVector(this-&gt;viewFactorMatrix.getHeader().getPatchInput());
    }
    else
    {
        RLogger::info("Reading view-factor matrix from file \'%s\'\n",recentViewFactorMatrixFile.toUtf8().constData());

        try
        {
            this-&gt;viewFactorMatrix.read(recentViewFactorMatrixFile);
        }
        catch (const RError &amp;error)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                         "Failed to read view factor matrix from file \'%s\'. %s",
                         recentViewFactorMatrixFile.toUtf8().constData(),
                         error.getMessage().toUtf8().constData());
        }
    }
}

</t>
<t tx="leo.20201108101525.98">void Model::unloadViewFactorMatrix()
{
    this-&gt;viewFactorMatrix.clear();
}

</t>
<t tx="leo.20201108101525.99">void Model::consolidate(int consolidateActionMask)
{

    RLogger::info("Consolidating model\n");
    RLogger::indent();
    try
    {
        if (consolidateActionMask &amp; Model::ConsolidateSurfaceNeighbors || this-&gt;getNElements() != this-&gt;surfaceNeigs.size())
        {
            this-&gt;setSurfaceNeighbors(this-&gt;findSurfaceNeighbors());
            this-&gt;syncSurfaceNormals();
            consolidateActionMask |= Model::ConsolidateMeshInput;
            consolidateActionMask |= Model::ConsolidateEdgeElements;
            consolidateActionMask |= Model::ConsolidateHoleElements;
            consolidateActionMask |= Model::ConsolidateSliverElements;
        }
        if (consolidateActionMask &amp; Model::ConsolidateVolumeNeighbors || this-&gt;getNElements() != this-&gt;volumeNeigs.size())
        {
            this-&gt;setVolumeNeighbors(this-&gt;findVolumeNeighbors());
            consolidateActionMask |= Model::ConsolidateMeshInput;
        }
        if (consolidateActionMask &amp; Model::ConsolidateEdgeNodes || this-&gt;getNNodes() != uint(this-&gt;edgeNodes.size()))
        {
            this-&gt;edgeNodes = this-&gt;findEdgeNodes();
            consolidateActionMask |= Model::ConsolidateMeshInput;
        }
        if (consolidateActionMask &amp; Model::ConsolidateEdgeElements)
        {
            this-&gt;edgeElements = this-&gt;findEdgeElements(30.0);
        }
        if (consolidateActionMask &amp; Model::ConsolidateHoleElements)
        {
            this-&gt;holeElements = this-&gt;findHoleElements();
        }
        if (consolidateActionMask &amp; Model::ConsolidateSliverElements)
        {
            this-&gt;updateSliverElements(Model::SliverElementEdgeRatio);
        }
        if (consolidateActionMask &amp; Model::ConsolidateIntersectedElements)
        {
            this-&gt;updateIntersectedElements();
        }
        if (consolidateActionMask &amp; Model::ConsolidateMeshInput)
        {
            this-&gt;initializeMeshInput();
        }
    }
    catch (const RError &amp;rError)
    {
        RLogger::error("Failed to consolidate model. %s\n",rError.getMessage().toUtf8().constData());
    }

    RLogger::unindent();
}

QString Model::buildDataFileName(const QString &amp;format, bool withTimeStep) const
{
    QString fileName;
    if (withTimeStep)
    {
        fileName = RFileManager::getFileNameWithTimeStep(this-&gt;getFileName(),this-&gt;getTimeSolver().getCurrentTimeStep()+1);
    }
    else
    {
        fileName = RFileManager::getFileNameWithOutTimeStep(this-&gt;getFileName());
    }
    QDir dataDir(MainSettings::getInstance().getDataDir());

    return QString(dataDir.filePath(QFileInfo(fileName).baseName()) + "." + format);
}

QString Model::buildDocFileName(const QString &amp;format, bool withTimeStep) const
{
    QString fileName;
    if (withTimeStep)
    {
        fileName = RFileManager::getFileNameWithTimeStep(this-&gt;getFileName(),this-&gt;getTimeSolver().getCurrentTimeStep()+1);
    }
    else
    {
        fileName = RFileManager::getFileNameWithOutTimeStep(this-&gt;getFileName());
    }
    QDir docDir(MainSettings::getInstance().getDocDir());

    return QString(docDir.filePath(QFileInfo(fileName).baseName()) + "." + format);
}

QString Model::buildTmpFileName(const QString &amp;format, bool withTimeStep) const
{
    QString fileName;
    if (withTimeStep)
    {
        fileName = RFileManager::getFileNameWithTimeStep(this-&gt;getFileName(),this-&gt;getTimeSolver().getCurrentTimeStep()+1);
    }
    else
    {
        fileName = RFileManager::getFileNameWithOutTimeStep(this-&gt;getFileName());
    }
    QDir docDir(MainSettings::getInstance().getTmpDir());

    return QString(docDir.filePath(QFileInfo(fileName).baseName()) + "." + format);
}

QString Model::buildTmpFileName(const QString &amp;format, const QString &amp;idString) const
{
    QString fileName = RFileManager::getFileNameWithOutTimeStep(this-&gt;getFileName());
    QDir docDir(MainSettings::getInstance().getTmpDir());

    if (idString.isEmpty())
    {
        return QString(docDir.filePath(QFileInfo(fileName).baseName()) + "." + format);
    }
    else
    {
        return QString(docDir.filePath(QFileInfo(fileName).baseName()) + "-" + idString + "." + format);
    }
}

QString Model::buildScreenShotFileName(const QString &amp;format) const
{
    return this-&gt;buildDocFileName(format,true);
}

QString Model::buildAnimationFileName(const QString &amp;format) const
{
    return this-&gt;buildDocFileName(format,false);
}

QList&lt;QString&gt; Model::getRecordFiles(bool onlyExistingFiles) const
{
    uint nRecords = 0;

    if (this-&gt;getTimeSolver().getEnabled())
    {
        nRecords = this-&gt;getTimeSolver().getNTimeSteps();
    }
    else
    {
        if (this-&gt;getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_STRESS_MODAL)
        {
            nRecords = this-&gt;getProblemSetup().getModalSetup().getNModesToExtract();
            if (this-&gt;getProblemSetup().getModalSetup().getMethod() == R_MODAL_DOMINANT_MODE)
            {
                nRecords = 1;
            }
        }
    }

    QList&lt;QString&gt; recordFiles;

    for (uint j=0;j&lt;nRecords;j++)
    {
        QString recordFileName(RFileManager::getFileNameWithTimeStep(this-&gt;getFileName(),j+1));
        if (RFileManager::fileExists(recordFileName) || !onlyExistingFiles)
        {
            recordFiles.append(recordFileName);
        }
    }
    return recordFiles;
}

QList&lt;QString&gt; Model::getDocumentFiles() const
{
    QList&lt;QString&gt; documentFiles;

    if (this-&gt;getFileName().isEmpty())
    {
        return documentFiles;
    }

    QFileInfo fi(RFileManager::getFileNameWithOutTimeStep(this-&gt;getFileName()));
    QDir docDir(MainSettings::getInstance().getDocDir());

    QList&lt;QString&gt; documentFormats = MainSettings::getSupportedDocumentFormats();
    QList&lt;QString&gt; imageFormats = MainSettings::getSupportedImageFormats();
    QList&lt;QString&gt; videoFormats = MainSettings::getSupportedVideoFormats();

    QString baseName(fi.baseName());

    QStringList filters;

    for (int i=0;i&lt;documentFormats.size();i++)
    {
        filters &lt;&lt; baseName + "*." + documentFormats[i];
    }
    for (int i=0;i&lt;imageFormats.size();i++)
    {
        filters &lt;&lt; baseName + "*." + imageFormats[i];
    }
    for (int i=0;i&lt;videoFormats.size();i++)
    {
        filters &lt;&lt; baseName + "*." + videoFormats[i];
    }

    foreach (QString file, docDir.entryList(filters, QDir::Files))
    {
        documentFiles.append(docDir.absoluteFilePath(file));
    }

    return documentFiles;
}


uint Model::getUndoStackSize() const
{
    return uint(this-&gt;undoStack.size());
}

</t>
<t tx="leo.20201108101526.1">void ModelRecordsSelector::onRecordFinished(void)
{
    QTimer::singleShot(this-&gt;recordIndicator?0:1000, this, SLOT(loadNextRecord()));
}

</t>
<t tx="leo.20201108101526.10">bool ModelRecordsTree::isLast(void)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        uint modelID = modelIDs[i];
        bool marked = false;

        QTreeWidgetItemIterator it(this);
        while (*it)
        {
            if ((*it)-&gt;data(ModelRecordsTree::IsRecord,Qt::UserRole).toBool() &amp;&amp;
                (*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
            {
                if ((*it)-&gt;data(ModelRecordsTree::Marked,Qt::UserRole).toBool())
                {
                    marked = true;
                }
                else
                {
                    if (marked)
                    {
                        return false;
                    }
                }
            }
            ++it;
        }
    }
    return true;
}

</t>
<t tx="leo.20201108101526.100">int PointInsideSurfaceDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        ModelActionInput modelActionInput(this-&gt;modelID);
        modelActionInput.setCheckPointInsideSurface(this-&gt;position-&gt;getPosition(),this-&gt;entityIDs);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }

    return retVal;
}
</t>
<t tx="leo.20201108101526.11">void ModelRecordsTree::markCurrent(void)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        uint modelID = modelIDs[i];

        QTreeWidgetItemIterator it(this);
        while (*it)
        {
            if ((*it)-&gt;data(ModelRecordsTree::IsRecord,Qt::UserRole).toBool() &amp;&amp;
                (*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
            {
                if ((*it)-&gt;data(ModelRecordsTree::Marked,Qt::UserRole).toBool())
                {
                    emit this-&gt;recordMarked((*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt(),
                                            (*it)-&gt;text(ModelRecordsTree::PathFileName));
                }
            }
            ++it;
        }
    }
}

</t>
<t tx="leo.20201108101526.12">void ModelRecordsTree::markPrevious(void)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        uint modelID = modelIDs[i];

        QTreeWidgetItem *prevItem = nullptr;

        QTreeWidgetItemIterator it(this);
        while (*it)
        {
            if ((*it)-&gt;data(ModelRecordsTree::Marked,Qt::UserRole).toBool() &amp;&amp;
                (*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
            {
                if (prevItem)
                {
                    (*it)-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,QVariant(false));
                    prevItem-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,QVariant(true));
                }
                break;
            }
            if ((*it)-&gt;data(ModelRecordsTree::IsRecord,Qt::UserRole).toBool() &amp;&amp;
                (*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
            {
                prevItem = (*it);
            }
            ++it;
        }
    }
}

</t>
<t tx="leo.20201108101526.13">void ModelRecordsTree::markNext(void)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        uint modelID = modelIDs[i];

        bool markItem = false;

        QTreeWidgetItem *prevItem = nullptr;

        QTreeWidgetItemIterator it(this);
        while (*it)
        {
            if (markItem)
            {
                if ((*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
                {
                    prevItem-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,false);
                    (*it)-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,true);
                }
                break;
            }
            if ((*it)-&gt;data(ModelRecordsTree::Marked,Qt::UserRole).toBool() &amp;&amp;
                (*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
            {
                modelID = (*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt();
                prevItem = (*it);
                markItem = true;
            }
            ++it;
        }
    }
}

</t>
<t tx="leo.20201108101526.14">void ModelRecordsTree::markFirst(void)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        uint modelID = modelIDs[i];
        bool isFirst = true;

        QTreeWidgetItemIterator it(this);
        while (*it)
        {
            if ((*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID &amp;&amp;
                (*it)-&gt;data(ModelRecordsTree::IsRecord,Qt::UserRole).toBool())
            {
                (*it)-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,isFirst);
                isFirst = false;
            }
            ++it;
        }
    }
}

</t>
<t tx="leo.20201108101526.15">void ModelRecordsTree::markLast(void)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        uint modelID = modelIDs[i];
        uint itemID1 = 0;
        uint itemID2 = 0;
        QTreeWidgetItem *lastItem = nullptr;

        QTreeWidgetItemIterator it(this);
        while (*it)
        {
            if ((*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
            {
                lastItem = (*it);
                itemID1++;
            }
            ++it;
        }

        if (lastItem &amp;&amp; !lastItem-&gt;data(ModelRecordsTree::Marked,Qt::UserRole).toBool())
        {
            lastItem-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,true);

            QTreeWidgetItemIterator it(this);
            while (*it)
            {
                if ((*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
                {
                    itemID2++;
                    if (itemID1 != itemID2)
                    {
                        (*it)-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,false);
                    }
                }
                ++it;
            }
        }
    }
}

</t>
<t tx="leo.20201108101526.16">void ModelRecordsTree::populate(void)
{
    if (!Session::getInstance().trylock())
    {
        return;
    }

    this-&gt;blockSignals(true);

    QList&lt;QTreeWidgetItem*&gt; selectedItemList = this-&gt;selectedItems();

    QMap&lt;ModelRecordsTreeRecordID,bool&gt; selectedIDs;

    for (int i=0;i&lt;selectedItemList.size();i++)
    {
        ModelRecordsTreeRecordID recordID(selectedItemList.at(i)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt(),
                                          selectedItemList.at(i)-&gt;data(ModelRecordsTree::IsRecord,Qt::UserRole).toBool(),
                                          selectedItemList.at(i)-&gt;data(ModelRecordsTree::RecordNumber,Qt::DisplayRole).toUInt());
        selectedIDs[recordID] = true;
    }

    uint nTopLevelItems = this-&gt;topLevelItemCount();

    uint nModels = Session::getInstance().getNModels();

    for (uint i=0;i&lt;nModels;i++)
    {
        Model &amp;rModel = Session::getInstance().getModel(i);

        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setFirstColumnSpanned(true);
        item-&gt;setData(ModelRecordsTree::ModelID,Qt::UserRole,QVariant(i));
        item-&gt;setData(ModelRecordsTree::IsRecord,Qt::UserRole,QVariant(false));
        item-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,QVariant(false));
        item-&gt;setText(ModelRecordsTree::Marked,rModel.getName());

        if (selectedIDs.constFind(ModelRecordsTreeRecordID(i,false,0)) != selectedIDs.constEnd())
        {
            this-&gt;setCurrentItem(item);
        }

        QList&lt;QString&gt; recordFiles = rModel.getRecordFiles(false);

        for (int j=0;j&lt;recordFiles.size();j++)
        {
            if (QFile::exists(recordFiles[j]))
            {
                QFileInfo fi(recordFiles[j]);
                QString elipsizeFileName = fi.baseName();

                QTreeWidgetItem *childItem = new QTreeWidgetItem(item);
                childItem-&gt;setData(ModelRecordsTree::ModelID,Qt::UserRole,QVariant(i));
                childItem-&gt;setData(ModelRecordsTree::IsRecord,Qt::UserRole,QVariant(true));
                childItem-&gt;setData(ModelRecordsTree::RecordNumber,Qt::DisplayRole,QVariant(j+1));
                childItem-&gt;setText(ModelRecordsTree::RecordFileName,elipsizeFileName);
                childItem-&gt;setText(ModelRecordsTree::PathFileName,recordFiles[j]);
                uint recordNumber = 0;
                if (rModel.getTimeSolver().getEnabled())
                {
                    recordNumber = rModel.getTimeSolver().getCurrentTimeStep();
                }
                else
                {
                    if (rModel.getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_STRESS_MODAL)
                    {
                        recordNumber = rModel.getProblemSetup().getModalSetup().getMode();
                    }
                }
                if (Session::getInstance().isModelSelected(i) &amp;&amp; recordNumber == uint(j))
                {
                    childItem-&gt;setIcon(ModelRecordsTree::Marked,QIcon(":/icons/media/pixmaps/range-play_play.svg"));
                    childItem-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,QVariant(true));
                }
                else
                {
                    childItem-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,QVariant(false));
                }

                if (selectedIDs.constFind(ModelRecordsTreeRecordID(i,true,j+1)) != selectedIDs.constEnd())
                {
                    this-&gt;setCurrentItem(childItem);
                }
            }
        }
        item-&gt;setExpanded(true);
    }

    for (uint i=0;i&lt;nTopLevelItems;i++)
    {
        this-&gt;takeTopLevelItem(0);
    }

    this-&gt;resizeColumnToContents(ModelRecordsTree::RecordNumber);
    this-&gt;resizeColumnToContents(ModelRecordsTree::RecordFileName);
    this-&gt;resizeColumnToContents(ModelRecordsTree::Marked);

    this-&gt;blockSignals(false);

    Session::getInstance().unlock();
}

</t>
<t tx="leo.20201108101526.17">void ModelRecordsTree::onModelSelectionChanged(uint modelID)
{
    this-&gt;blockSignals(true);
    QTreeWidgetItemIterator it(this);
    while (*it)
    {
        if ((*it)-&gt;data(ModelRecordsTree::IsRecord,Qt::UserRole).toBool() &amp;&amp;
            (*it)-&gt;data(ModelRecordsTree::Marked,Qt::UserRole).toBool() &amp;&amp;
            (*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
        {
            if (Session::getInstance().isModelSelected(modelID))
            {
                (*it)-&gt;setIcon(ModelRecordsTree::Marked,QIcon(":/icons/media/pixmaps/range-play_play.svg"));
            }
            else
            {
                (*it)-&gt;setData(ModelRecordsTree::Marked,Qt::DecorationRole,QVariant());
            }
        }
        ++it;
    }
    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101526.18">void ModelRecordsTree::onModelChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101526.19">void ModelRecordsTree::onItemChanged(QTreeWidgetItem *item, int column)
{
    if (column != ModelRecordsTree::Marked)
    {
        return;
    }

    bool recordMarkedIndicator = false;

    this-&gt;blockSignals(true);

    if (item-&gt;data(ModelRecordsTree::Marked,Qt::UserRole).toBool() &amp;&amp;
        Session::getInstance().isModelSelected(item-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt()))
    {
        item-&gt;setIcon(ModelRecordsTree::Marked,QIcon(":/icons/media/pixmaps/range-play_play.svg"));
        this-&gt;setCurrentItem(item);
        this-&gt;scrollToItem(item);
        recordMarkedIndicator = true;
    }
    else
    {
        item-&gt;setData(ModelRecordsTree::Marked,Qt::DecorationRole,QVariant());
    }

    this-&gt;blockSignals(false);

    if (recordMarkedIndicator)
    {
        emit this-&gt;recordMarked(item-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt(),
                                item-&gt;text(ModelRecordsTree::PathFileName));
    }
}

</t>
<t tx="leo.20201108101526.2">void ModelRecordsSelector::onUpdateJobFinished(void)
{
    if (this-&gt;recordIndicator)
    {
        // Take screen-shot
        Session::getInstance().setTakeScreenShot(this-&gt;updateModelID,Session::getInstance().getModel(this-&gt;updateModelID).buildScreenShotFileName(),false);
    }
    if (this-&gt;markNextIndicator)
    {
        emit this-&gt;recordFinished();
    }
}

</t>
<t tx="leo.20201108101526.20">void ModelRecordsTree::onItemActivated(QTreeWidgetItem *item, int)
{
    uint modelID = item-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt();

    QTreeWidgetItemIterator it(this);
    while (*it)
    {
        if ((*it)-&gt;data(ModelRecordsTree::IsRecord,Qt::UserRole).toBool() &amp;&amp;
            (*it)-&gt;data(ModelRecordsTree::Marked,Qt::UserRole).toBool() &amp;&amp;
            (*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
        {
            (*it)-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,false);
        }
        ++it;
    }
    if (!item-&gt;data(ModelRecordsTree::Marked,Qt::UserRole).toBool())
    {
        item-&gt;setData(ModelRecordsTree::Marked,Qt::UserRole,true);
    }
}
</t>
<t tx="leo.20201108101526.21">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model_statistics_dialog.cpp                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   24-th November 2016                                      *
 *                                                                   *
 *  DESCRIPTION: Model statistics dialog class definition            *
 *********************************************************************/

#include &lt;QIcon&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "model_statistics_dialog.h"
#include "session.h"

ModelStatisticsDialog::ModelStatisticsDialog(uint modelID, QWidget *parent)
    : QDialog(parent)
{
    QIcon closeIcon(":/icons/file/pixmaps/range-close.svg");

    this-&gt;setWindowTitle(tr("Model statistics"));
    this-&gt;resize(860,600);

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    QTextBrowser *textBrowser = new QTextBrowser;
    this-&gt;produceStatistics(modelID,textBrowser);
    textBrowser-&gt;setLineWrapMode(QTextEdit::NoWrap);
    QTextCursor textCursor = textBrowser-&gt;textCursor();
    textCursor.setPosition(0);
    textBrowser-&gt;setTextCursor(textCursor);
    mainLayout-&gt;addWidget(textBrowser);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *closeButton = new QPushButton(closeIcon, tr("Close"));
    closeButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(closeButton);

    QObject::connect(closeButton,&amp;QPushButton::clicked,this,&amp;ModelStatisticsDialog::reject);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.22">int ModelStatisticsDialog::exec(void)
{
    int retVal = QDialog::exec();
    return retVal;
}

</t>
<t tx="leo.20201108101526.23">void ModelStatisticsDialog::produceStatistics(uint modelID, QTextBrowser *textBrowser)
{
    const Model &amp;rModel = Session::getInstance().getModel(modelID);

    QString content;

    content += "&lt;h1&gt;" + rModel.getName() + "&lt;/h1&gt;";
    content += "&lt;table  border=\"0\"&gt;";
    content += ModelStatisticsDialog::generateTableRow(tr("Number of nodes"),QString::number(rModel.getNNodes()));
    content += ModelStatisticsDialog::generateTableRow(tr("Number&amp;nbsp;of&amp;nbsp;elements"),QString::number(rModel.getNElements()));

    RStatistics nodeDistanceStatistics = rModel.findNodeDistanceStatistics();

    content += "&lt;tr&gt;&lt;th align=\"center\" colspan=\"2\"&gt;"+ tr("Node distance statistics") +"&lt;/th&gt;&lt;/tr&gt;";

    content += ModelStatisticsDialog::generateTableRow(tr("Minimum"),QString::number(nodeDistanceStatistics.getMin()));
    content += ModelStatisticsDialog::generateTableRow(tr("Maximum"),QString::number(nodeDistanceStatistics.getMax()));
    content += ModelStatisticsDialog::generateTableRow(tr("Average"),QString::number(nodeDistanceStatistics.getAvg()));
    content += ModelStatisticsDialog::generateTableRow(tr("Median"),QString::number(nodeDistanceStatistics.getMed()));
    content += ModelStatisticsDialog::generateTableRow(tr("Percentile") +" 5",QString::number(nodeDistanceStatistics.getP05()));
    content += ModelStatisticsDialog::generateTableRow(tr("Percentile") +" 95",QString::number(nodeDistanceStatistics.getP95()));

    content += "&lt;tr&gt;&lt;th align=\"center\" colspan=\"2\"&gt;"+ tr("Geometry statistics") +"&lt;/th&gt;&lt;/tr&gt;";

    double lineLength(0.0);
    for (uint i=0;i&lt;rModel.getNLines();i++)
    {
        lineLength += rModel.getLine(i).findLength(rModel.getNodes(),rModel.getElements());
    }
    double surfaceArea(0.0);
    for (uint i=0;i&lt;rModel.getNSurfaces();i++)
    {
        surfaceArea += rModel.getSurface(i).findArea(rModel.getNodes(),rModel.getElements());
    }
    double volume(0.0);
    for (uint i=0;i&lt;rModel.getNVolumes();i++)
    {
        volume += rModel.getVolume(i).findVolume(rModel.getNodes(),rModel.getElements());
    }

    content += ModelStatisticsDialog::generateTableRow(tr("Line length"),QString::number(lineLength));
    content += ModelStatisticsDialog::generateTableRow(tr("Surface area"),QString::number(surfaceArea));
    content += ModelStatisticsDialog::generateTableRow(tr("Total volume"),QString::number(volume));

    double xc(0.0), yc(0.0), zc(0.0);
    rModel.findNodeCenter(xc,yc,zc);
    content += ModelStatisticsDialog::generateTableRow(tr("Model center"),"["+ QString::number(xc,'e') + " " + QString::number(yc,'e') + " " + QString::number(zc,'e') +"]");

    double xr[2], yr[2], zr[2];
    rModel.findNodeLimits(xr[0],xr[1],yr[0],yr[1],zr[0],zr[1]);
    content += ModelStatisticsDialog::generateTableRow(tr("Model center"),"["+ QString::number(xr[0],'e') + " " + QString::number(yr[0],'e') + " " + QString::number(zr[0],'e') +"] : ["+ QString::number(xr[1],'e') + " " + QString::number(yr[1],'e') + " " + QString::number(zr[1],'e') +"]");
    content += ModelStatisticsDialog::generateTableRow(tr("Model size"),"["+ QString::number(xr[1]-xr[0],'e') + " " + QString::number(yr[1]-yr[0],'e') + " " + QString::number(zr[1]-zr[0],'e') +"]");

    content += "&lt;/table&gt;";

    textBrowser-&gt;insertHtml(content);
}

QString ModelStatisticsDialog::generateTableRow(const QString &amp;label, const QString &amp;value)
{
    return QString("&lt;tr&gt;&lt;th align=\"left\" nowrap&gt;" + label + "&lt;/th&gt;&lt;td align=\"right\"&gt;&lt;pre&gt;" + value + "&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;");
}
</t>
<t tx="leo.20201108101526.24">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model_tree.cpp                                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   25-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Model tree class definition                         *
 *********************************************************************/


#include &lt;rmlib.h&gt;

#include "model_tree.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.25">typedef enum _ModelTreeEntity
{
    MODEL_TREE_NONE = 0,
    MODEL_TREE_MODEL,
    MODEL_TREE_GROUP_POINT,
    MODEL_TREE_GROUP_LINE,
    MODEL_TREE_GROUP_SURFACE,
    MODEL_TREE_GROUP_VOLUME,
    MODEL_TREE_GROUP_VECTOR_FIELD,
    MODEL_TREE_GROUP_SCALAR_FIELD,
    MODEL_TREE_GROUP_STREAM_LINE,
    MODEL_TREE_GROUP_CUT,
    MODEL_TREE_GROUP_ISO,
    MODEL_TREE_POINT,
    MODEL_TREE_LINE,
    MODEL_TREE_SURFACE,
    MODEL_TREE_VOLUME,
    MODEL_TREE_VECTOR_FIELD,
    MODEL_TREE_SCALAR_FIELD,
    MODEL_TREE_STREAM_LINE,
    MODEL_TREE_CUT,
    MODEL_TREE_ISO,
    MODEL_TREE_N_TYPES
} ModelTreeEntity;

</t>
<t tx="leo.20201108101526.26">typedef enum _ModelTreeColumn
{
    MODEL_TREE_COLUMN_NAME = 0,
    MODEL_TREE_COLUMN_NUMBER,
    MODEL_TREE_COLUMN_TYPE,
    MODEL_TREE_COLUMN_MID,
    MODEL_TREE_COLUMN_EID,
    MODEL_TREE_N_COLUMNS
} ModelTreeColumn;

</t>
<t tx="leo.20201108101526.27">static REntityGroupType EntityTypeToGroupType(ModelTreeEntity entityType)
{
    switch (entityType)
    {
        case MODEL_TREE_POINT:
            return R_ENTITY_GROUP_POINT;
        case MODEL_TREE_LINE:
            return R_ENTITY_GROUP_LINE;
        case MODEL_TREE_SURFACE:
            return R_ENTITY_GROUP_SURFACE;
        case MODEL_TREE_VOLUME:
            return R_ENTITY_GROUP_VOLUME;
        case MODEL_TREE_VECTOR_FIELD:
            return R_ENTITY_GROUP_VECTOR_FIELD;
        case MODEL_TREE_SCALAR_FIELD:
            return R_ENTITY_GROUP_SCALAR_FIELD;
        case MODEL_TREE_STREAM_LINE:
            return R_ENTITY_GROUP_STREAM_LINE;
        case MODEL_TREE_CUT:
            return R_ENTITY_GROUP_CUT;
        case MODEL_TREE_ISO:
            return R_ENTITY_GROUP_ISO;
        default:
            return R_ENTITY_GROUP_NONE;
    }
}

ModelTree::ModelTree(ActionList *actionList,
                     QObject *parent) :
    QTreeWidget((QWidget*)parent),
    ignoreSignals(false)
{
    this-&gt;actionList = actionList;
    this-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection);

    this-&gt;setColumnCount(MODEL_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setIcon(MODEL_TREE_COLUMN_NAME,QIcon(":/icons/mime/pixmaps/range-model.svg"));
    headerItem-&gt;setText(MODEL_TREE_COLUMN_NAME,QString("Name"));
    headerItem-&gt;setText(MODEL_TREE_COLUMN_NUMBER,QString("#"));
    headerItem-&gt;setText(MODEL_TREE_COLUMN_TYPE,QString("type"));
    headerItem-&gt;setText(MODEL_TREE_COLUMN_MID,QString("modelID"));
    headerItem-&gt;setText(MODEL_TREE_COLUMN_EID,QString("entityID"));
    this-&gt;setHeaderItem(headerItem);

    this-&gt;setColumnHidden(MODEL_TREE_COLUMN_TYPE,true);
    this-&gt;setColumnHidden(MODEL_TREE_COLUMN_MID,true);
    this-&gt;setColumnHidden(MODEL_TREE_COLUMN_EID,true);

    this-&gt;setContextMenuPolicy(Qt::ActionsContextMenu);
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_SAVE));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_SAVE_AS));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_CLOSE));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_MODEL_RENAME));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_ENTITY_MERGE));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_ENTITY_REMOVE));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_SEPARATOR));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_CUT_EDIT));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_ISO_EDIT));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_STREAM_LINE_EDIT));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_SCALAR_FIELD_EDIT));
    this-&gt;addAction(this-&gt;actionList-&gt;getAction(ACTION_GEOMETRY_VECTOR_FIELD_EDIT));

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::entitySelectionChanged,
                     this,
                     &amp;ModelTree::onEntitySelectionChanged);

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::entityVisibilityChanged,
                     this,
                     &amp;ModelTree::onEntityVisibilityChanged);

    QObject::connect(this-&gt;model(),
                     &amp;QAbstractItemModel::dataChanged,
                     this,
                     &amp;ModelTree::onDataChanged);

    QObject::connect(this,
                     &amp;ModelTree::itemSelectionChanged,
                     this,
                     &amp;ModelTree::onSelectionChanged);

    QObject::connect(this,
                     &amp;ModelTree::itemExpanded,
                     this,
                     &amp;ModelTree::onItemExpanded);

    QObject::connect(this,
                     &amp;ModelTree::itemCollapsed,
                     this,
                     &amp;ModelTree::onItemExpanded);

    QObject::connect(this,
                     &amp;ModelTree::itemDoubleClicked,
                     this,
                     &amp;ModelTree::onItemDoubleClicked);

    QObject::connect(this,
                     &amp;ModelTree::itemChanged,
                     this,
                     &amp;ModelTree::onItemChanged);

    this-&gt;populate();
}

QList&lt;uint&gt; ModelTree::getSelectedModelIDs(void) const
{
    QList&lt;uint&gt; modelIDs;
    QList&lt;QTreeWidgetItem *&gt; items;

    items = this-&gt;selectedItems();
    for (int i = 0;i&lt;items.size();i++)
    {
        QVariant id = items[i]-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole);
        // Check whether the list already contains such ID
        bool foundID = false;
        for (int j=0;j&lt;modelIDs.size();j++)
        {
            if (modelIDs[j] == id.toUInt())
            {
                foundID = true;
                break;
            }
        }
        if (!foundID)
        {
            modelIDs.push_back(id.toUInt());
        }
    }

    return modelIDs;
}

</t>
<t tx="leo.20201108101526.28">void ModelTree::setIgnoreSignals(bool ignoreSignals)
{
    this-&gt;ignoreSignals = ignoreSignals;
}

</t>
<t tx="leo.20201108101526.29">void ModelTree::populate(void)
{
    this-&gt;setIgnoreSignals(true);

    this-&gt;blockSignals(true);
    for (uint i=0;i&lt;Session::getInstance().getNModels();i++)
    {
        this-&gt;insertModel(i);
    }
    this-&gt;blockSignals(false);

    this-&gt;setIgnoreSignals(false);
}

QList&lt;QTreeWidgetItem *&gt; ModelTree::getAllItems(QTreeWidgetItem *parent) const
{
    QList&lt;QTreeWidgetItem *&gt; itemList;

    int count = parent ? parent-&gt;childCount() : this-&gt;topLevelItemCount();

    for (int i=0;i&lt;count;i++)
    {
        QTreeWidgetItem *item = parent ? parent-&gt;child(i) : this-&gt;topLevelItem(i);

        itemList.append(item);
        itemList.append(this-&gt;getAllItems(item));
    }

    return itemList;
}

</t>
<t tx="leo.20201108101526.3">void ModelRecordsSelector::playToggle(bool jumpToFirst)
{
    this-&gt;markNextIndicator = !this-&gt;markNextIndicator;

    if (this-&gt;markNextIndicator)
    {
        MainWindow::getInstance()-&gt;progressAutoHideDisable();
        this-&gt;playAction-&gt;setIcon(QIcon(":/icons/media/pixmaps/range-play_pause.svg"));
        this-&gt;playAction-&gt;setText("Pause");

        this-&gt;loadNextRecord(jumpToFirst);
    }
    else
    {
        this-&gt;playAction-&gt;setIcon(QIcon(":/icons/media/pixmaps/range-play_play.svg"));
        this-&gt;playAction-&gt;setText("Play");
        this-&gt;recordAction-&gt;setEnabled(true);
        MainWindow::getInstance()-&gt;progressAutoHideEnable();
    }
}

</t>
<t tx="leo.20201108101526.30">void ModelTree::insertModel(uint modelID)
{
    const Model &amp;rModel = Session::getInstance().getModel(modelID);

    QTreeWidgetItem *itemModel = this-&gt;findModelItem(modelID,true);
    itemModel-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getName());
    itemModel-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_MODEL));
    itemModel-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

    bool modelChecked = false;
    bool modelUnChecked = false;

    for (int i=itemModel-&gt;childCount()-1;i&gt;=0;i--)
    {
        if (
            (itemModel-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() == MODEL_TREE_GROUP_POINT &amp;&amp; rModel.getNPoints() == 0)
            ||
            (itemModel-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() == MODEL_TREE_GROUP_LINE &amp;&amp; rModel.getNLines() == 0)
            ||
            (itemModel-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() == MODEL_TREE_GROUP_SURFACE &amp;&amp; rModel.getNSurfaces() == 0)
            ||
            (itemModel-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() == MODEL_TREE_GROUP_VOLUME &amp;&amp; rModel.getNVolumes() == 0)
            ||
            (itemModel-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() == MODEL_TREE_GROUP_STREAM_LINE &amp;&amp; rModel.getNStreamLines() == 0)
            ||
            (itemModel-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() == MODEL_TREE_GROUP_VECTOR_FIELD &amp;&amp; rModel.getNVectorFields() == 0)
            ||
            (itemModel-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() == MODEL_TREE_GROUP_SCALAR_FIELD &amp;&amp; rModel.getNScalarFields() == 0)
            ||
            (itemModel-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() == MODEL_TREE_GROUP_CUT &amp;&amp; rModel.getNCuts() == 0)
            ||
            (itemModel-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() == MODEL_TREE_GROUP_ISO &amp;&amp; rModel.getNIsos() == 0)
            )
        {
            itemModel-&gt;takeChild(i);
        }
    }

    if (rModel.getNPoints() &gt; 0)
    {
        QTreeWidgetItem *itemGroup = this-&gt;findEntityGroupItem(itemModel,MODEL_TREE_GROUP_POINT,true);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Points");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getNPoints()));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_POINT));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        bool itemChecked = false;
        bool itemUnChecked = false;
        for (uint i=0;i&lt;rModel.getNPoints();i++)
        {
            bool visible = rModel.getVisible(R_ENTITY_GROUP_POINT,i);

            if (visible) itemChecked = true;
            else itemUnChecked = true;

            QTreeWidgetItem *itemEntity = this-&gt;findEntityItem(itemGroup,i,true);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getPoint(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(visible?Qt::Checked:Qt::Unchecked));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getPoint(i).size()));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_POINT));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
        }
        for (int i=itemGroup-&gt;childCount()-1;i&gt;=(int)rModel.getNPoints();i--)
        {
            itemGroup-&gt;takeChild(i);
        }

        Qt::CheckState itemGroupState = Qt::Unchecked;
        if (itemChecked)
        {
            itemGroupState = Qt::Checked;
            if (itemUnChecked)
            {
                itemGroupState = Qt::PartiallyChecked;
            }
        }
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(itemGroupState));

        if (itemChecked) modelChecked = true;
        if (itemUnChecked) modelUnChecked = true;
    }

    if (rModel.getNLines() &gt; 0)
    {
        QTreeWidgetItem *itemGroup = this-&gt;findEntityGroupItem(itemModel,MODEL_TREE_GROUP_LINE,true);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Lines");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getNLines()));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_LINE));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        bool itemChecked = false;
        bool itemUnChecked = false;
        for (uint i=0;i&lt;rModel.getNLines();i++)
        {
            bool visible = rModel.getVisible(R_ENTITY_GROUP_LINE,i);

            if (visible) itemChecked = true;
            else         itemUnChecked = true;

            QTreeWidgetItem *itemEntity = this-&gt;findEntityItem(itemGroup,i,true);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getLine(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(visible?Qt::Checked:Qt::Unchecked));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getLine(i).size()));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_LINE));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
        }
        for (int i=itemGroup-&gt;childCount()-1;i&gt;=(int)rModel.getNLines();i--)
        {
            itemGroup-&gt;takeChild(i);
        }

        Qt::CheckState itemGroupState = Qt::Unchecked;
        if (itemChecked)
        {
            itemGroupState = Qt::Checked;
            if (itemUnChecked)
            {
                itemGroupState = Qt::PartiallyChecked;
            }
        }
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(itemGroupState));

        if (itemChecked) modelChecked = true;
        if (itemUnChecked) modelUnChecked = true;
    }

    if (rModel.getNSurfaces() &gt; 0)
    {
        QTreeWidgetItem *itemGroup = this-&gt;findEntityGroupItem(itemModel,MODEL_TREE_GROUP_SURFACE,true);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Surfaces");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getNSurfaces()));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_SURFACE));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        bool itemChecked = false;
        bool itemUnChecked = false;
        for (uint i=0;i&lt;rModel.getNSurfaces();i++)
        {
            bool visible = rModel.getVisible(R_ENTITY_GROUP_SURFACE,i);

            if (visible) itemChecked = true;
            else         itemUnChecked = true;

            QTreeWidgetItem *itemEntity = this-&gt;findEntityItem(itemGroup,i,true);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getSurface(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(visible?Qt::Checked:Qt::Unchecked));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getSurface(i).size()));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_SURFACE));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
        }
        for (int i=itemGroup-&gt;childCount()-1;i&gt;=(int)rModel.getNSurfaces();i--)
        {
            itemGroup-&gt;takeChild(i);
        }

        Qt::CheckState itemGroupState = Qt::Unchecked;
        if (itemChecked)
        {
            itemGroupState = Qt::Checked;
            if (itemUnChecked)
            {
                itemGroupState = Qt::PartiallyChecked;
            }
        }
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(itemGroupState));

        if (itemChecked) modelChecked = true;
        if (itemUnChecked) modelUnChecked = true;
    }

    if (rModel.getNVolumes() &gt; 0)
    {
        QTreeWidgetItem *itemGroup = this-&gt;findEntityGroupItem(itemModel,MODEL_TREE_GROUP_VOLUME,true);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Volumes");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getNVolumes()));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_VOLUME));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        bool itemChecked = false;
        bool itemUnChecked = false;
        for (uint i=0;i&lt;rModel.getNVolumes();i++)
        {
            bool visible = rModel.getVisible(R_ENTITY_GROUP_VOLUME,i);

            if (visible) itemChecked = true;
            else         itemUnChecked = true;

            QTreeWidgetItem *itemEntity = this-&gt;findEntityItem(itemGroup,i,true);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getVolume(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(visible?Qt::Checked:Qt::Unchecked));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getVolume(i).size()));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_VOLUME));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
        }
        for (int i=itemGroup-&gt;childCount()-1;i&gt;=(int)rModel.getNVolumes();i--)
        {
            itemGroup-&gt;takeChild(i);
        }

        Qt::CheckState itemGroupState = Qt::Unchecked;
        if (itemChecked)
        {
            itemGroupState = Qt::Checked;
            if (itemUnChecked)
            {
                itemGroupState = Qt::PartiallyChecked;
            }
        }
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(itemGroupState));

        if (itemChecked) modelChecked = true;
        if (itemUnChecked) modelUnChecked = true;
    }

    if (rModel.getNCuts() &gt; 0)
    {
        QTreeWidgetItem *itemGroup = this-&gt;findEntityGroupItem(itemModel,MODEL_TREE_GROUP_CUT,true);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Cuts");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getNCuts()));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_CUT));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        bool itemChecked = false;
        bool itemUnChecked = false;
        for (uint i=0;i&lt;rModel.getNCuts();i++)
        {
            bool visible = rModel.getVisible(R_ENTITY_GROUP_CUT,i);

            if (visible) itemChecked = true;
            else         itemUnChecked = true;

            QTreeWidgetItem *itemEntity = this-&gt;findEntityItem(itemGroup,i,true);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getCut(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(visible?Qt::Checked:Qt::Unchecked));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_CUT));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
        }
        for (int i=itemGroup-&gt;childCount()-1;i&gt;=(int)rModel.getNCuts();i--)
        {
            itemGroup-&gt;takeChild(i);
        }

        Qt::CheckState itemGroupState = Qt::Unchecked;
        if (itemChecked)
        {
            itemGroupState = Qt::Checked;
            if (itemUnChecked)
            {
                itemGroupState = Qt::PartiallyChecked;
            }
        }
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(itemGroupState));

        if (itemChecked) modelChecked = true;
        if (itemUnChecked) modelUnChecked = true;
    }

    if (rModel.getNIsos() &gt; 0)
    {
        QTreeWidgetItem *itemGroup = this-&gt;findEntityGroupItem(itemModel,MODEL_TREE_GROUP_ISO,true);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Isos");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getNIsos()));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_ISO));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        bool itemChecked = false;
        bool itemUnChecked = false;
        for (uint i=0;i&lt;rModel.getNIsos();i++)
        {
            bool visible = rModel.getVisible(R_ENTITY_GROUP_ISO,i);

            if (visible) itemChecked = true;
            else         itemUnChecked = true;

            QTreeWidgetItem *itemEntity = this-&gt;findEntityItem(itemGroup,i,true);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getIso(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(visible?Qt::Checked:Qt::Unchecked));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_ISO));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
        }
        for (int i=itemGroup-&gt;childCount()-1;i&gt;=(int)rModel.getNIsos();i--)
        {
            itemGroup-&gt;takeChild(i);
        }

        Qt::CheckState itemGroupState = Qt::Unchecked;
        if (itemChecked)
        {
            itemGroupState = Qt::Checked;
            if (itemUnChecked)
            {
                itemGroupState = Qt::PartiallyChecked;
            }
        }
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(itemGroupState));

        if (itemChecked) modelChecked = true;
        if (itemUnChecked) modelUnChecked = true;
    }

    if (rModel.getNStreamLines() &gt; 0)
    {
        bool itemChecked = false;
        bool itemUnChecked = false;
        QTreeWidgetItem *itemGroup = this-&gt;findEntityGroupItem(itemModel,MODEL_TREE_GROUP_STREAM_LINE,true);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Stream lines");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getNStreamLines()));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_STREAM_LINE));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        for (uint i=0;i&lt;rModel.getNStreamLines();i++)
        {
            bool visible = rModel.getVisible(R_ENTITY_GROUP_STREAM_LINE,i);

            if (visible) itemChecked = true;
            else         itemUnChecked = true;

            QTreeWidgetItem *itemEntity = this-&gt;findEntityItem(itemGroup,i,true);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getStreamLine(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(visible?Qt::Checked:Qt::Unchecked));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_STREAM_LINE));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
        }
        for (int i=itemGroup-&gt;childCount()-1;i&gt;=(int)rModel.getNStreamLines();i--)
        {
            itemGroup-&gt;takeChild(i);
        }

        Qt::CheckState itemGroupState = Qt::Unchecked;
        if (itemChecked)
        {
            itemGroupState = Qt::Checked;
            if (itemUnChecked)
            {
                itemGroupState = Qt::PartiallyChecked;
            }
        }
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(itemGroupState));

        if (itemChecked) modelChecked = true;
        if (itemUnChecked) modelUnChecked = true;
    }

    if (rModel.getNScalarFields() &gt; 0)
    {
        QTreeWidgetItem *itemGroup = this-&gt;findEntityGroupItem(itemModel,MODEL_TREE_GROUP_SCALAR_FIELD,true);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Scalar fields");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getNScalarFields()));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_SCALAR_FIELD));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        bool itemChecked = false;
        bool itemUnChecked = false;
        for (uint i=0;i&lt;rModel.getNScalarFields();i++)
        {
            bool visible = rModel.getVisible(R_ENTITY_GROUP_SCALAR_FIELD,i);

            if (visible) itemChecked = true;
            else         itemUnChecked = true;

            QTreeWidgetItem *itemEntity = this-&gt;findEntityItem(itemGroup,i,true);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getScalarField(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(visible?Qt::Checked:Qt::Unchecked));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_SCALAR_FIELD));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
        }
        for (int i=itemGroup-&gt;childCount()-1;i&gt;=(int)rModel.getNScalarFields();i--)
        {
            itemGroup-&gt;takeChild(i);
        }

        Qt::CheckState itemGroupState = Qt::Unchecked;
        if (itemChecked)
        {
            itemGroupState = Qt::Checked;
            if (itemUnChecked)
            {
                itemGroupState = Qt::PartiallyChecked;
            }
        }
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(itemGroupState));

        if (itemChecked) modelChecked = true;
        if (itemUnChecked) modelUnChecked = true;
    }

    if (rModel.getNVectorFields() &gt; 0)
    {
        QTreeWidgetItem *itemGroup = this-&gt;findEntityGroupItem(itemModel,MODEL_TREE_GROUP_VECTOR_FIELD,true);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Vector fields");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NUMBER,Qt::DisplayRole,QVariant(rModel.getNVectorFields()));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_VECTOR_FIELD));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        bool itemChecked = false;
        bool itemUnChecked = false;
        for (uint i=0;i&lt;rModel.getNVectorFields();i++)
        {
            bool visible = rModel.getVisible(R_ENTITY_GROUP_VECTOR_FIELD,i);

            if (visible) itemChecked = true;
            else         itemUnChecked = true;

            QTreeWidgetItem *itemEntity = this-&gt;findEntityItem(itemGroup,i,true);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getVectorField(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(visible?Qt::Checked:Qt::Unchecked));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_VECTOR_FIELD));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
        }
        for (int i=itemGroup-&gt;childCount()-1;i&gt;=(int)rModel.getNVectorFields();i--)
        {
            itemGroup-&gt;takeChild(i);
        }

        Qt::CheckState itemGroupState = Qt::Unchecked;
        if (itemChecked)
        {
            itemGroupState = Qt::Checked;
            if (itemUnChecked)
            {
                itemGroupState = Qt::PartiallyChecked;
            }
        }
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(itemGroupState));

        if (itemChecked) modelChecked = true;
        if (itemUnChecked) modelUnChecked = true;
    }

    Qt::CheckState modelState = Qt::Unchecked;
    if (modelChecked)
    {
        modelState = Qt::Checked;
        if (modelUnChecked)
        {
            modelState = Qt::PartiallyChecked;
        }
    }
    itemModel-&gt;setData(MODEL_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(modelState));
}

</t>
<t tx="leo.20201108101526.31">void ModelTree::removeModel(uint modelID)
{    QList&lt;QTreeWidgetItem *&gt; allItems = this-&gt;getAllItems();
     for (int i=0;i&lt;allItems.size();i++)
     {
         uint mid = allItems[i]-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt();
         if (mid &gt; modelID)
         {
             allItems[i]-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(mid-1));
         }
     }
      delete this-&gt;takeTopLevelItem(modelID);
}

QTreeWidgetItem *ModelTree::findModelItem(uint modelID, bool create)
{
    QTreeWidgetItem *item = nullptr;
    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        if (this-&gt;topLevelItem(i)-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt() == modelID)
        {
            item = this-&gt;topLevelItem(i);
        }
    }
    if (!item &amp;&amp; create)
    {
        item = new QTreeWidgetItem(this);
    }
    return item;
}

QTreeWidgetItem *ModelTree::findEntityGroupItem(QTreeWidgetItem *parentItem, int entityGroupType, bool create)
{
    QTreeWidgetItem *item = nullptr;
    for (int i=0;i&lt;parentItem-&gt;childCount();i++)
    {
        if (parentItem-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() == entityGroupType)
        {
            item = parentItem-&gt;child(i);
        }
    }
    if (!item &amp;&amp; create)
    {
        item = new QTreeWidgetItem;
        int index = 0;
        for (int i=0;i&lt;parentItem-&gt;childCount();i++)
        {
            if (parentItem-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt() &gt; entityGroupType)
            {
                break;
            }
            index = i+1;
        }
        parentItem-&gt;insertChild(index,item);
    }

    return item;
}

QTreeWidgetItem *ModelTree::findEntityItem(QTreeWidgetItem *parentItem, uint entityID, bool create)
{
    QTreeWidgetItem *item = nullptr;
    for (int i=0;i&lt;parentItem-&gt;childCount();i++)
    {
        if (parentItem-&gt;child(i)-&gt;data(MODEL_TREE_COLUMN_EID,Qt::DisplayRole).toUInt() == entityID)
        {
            item = parentItem-&gt;child(i);
        }
    }
    if (!item &amp;&amp; create)
    {
        item = new QTreeWidgetItem(parentItem);
    }
    return item;
}

</t>
<t tx="leo.20201108101526.32">void ModelTree::onModelAdded(uint modelID)
{
    this-&gt;blockSignals(true);
    this-&gt;insertModel(modelID);
    this-&gt;blockSignals(false);
    this-&gt;selectSelected();
    this-&gt;expandSelected();
    Session::getInstance().setModelSelectionChanged(modelID);
    this-&gt;actionList-&gt;processAvailability();

    for (int i=0;i&lt;MODEL_TREE_N_COLUMNS;i++)
    {
        this-&gt;resizeColumnToContents(i);
    }
}

</t>
<t tx="leo.20201108101526.33">void ModelTree::onModelRemoved(uint modelID)
{
    this-&gt;blockSignals(true);
    this-&gt;removeModel(modelID);
    this-&gt;blockSignals(false);
    emit this-&gt;itemSelectionChanged();
    Session::getInstance().setModelSelectionChanged(modelID);
    this-&gt;actionList-&gt;processAvailability();
}

</t>
<t tx="leo.20201108101526.34">void ModelTree::onModelChanged(uint modelID)
{
    this-&gt;blockSignals(true);
    this-&gt;insertModel(modelID);
    this-&gt;blockSignals(false);
    Session::getInstance().setModelSelectionChanged(modelID);
    this-&gt;actionList-&gt;processAvailability();
    this-&gt;onSelectionChanged();
}

</t>
<t tx="leo.20201108101526.35">void ModelTree::onSelectionChanged(void)
{
    QList&lt;SessionEntityID&gt; allEntityIDs = Session::getInstance().getAllEntityIDs();
    QMap&lt;SessionEntityID,bool&gt; entityIDsSelectedMap;
    QMap&lt;uint,bool&gt; emptyModelIDsSelectedMap;

    for (int i=0;i&lt;allEntityIDs.size();i++)
    {
        entityIDsSelectedMap.insert(allEntityIDs[i],false);
    }
    for (uint i=0;i&lt;Session::getInstance().getNModels();i++)
    {
        if (Session::getInstance().getModel(i).isEmpty())
        {
            emptyModelIDsSelectedMap.insert(i,false);
        }
    }

    QList&lt;QTreeWidgetItem *&gt; items = this-&gt;selectedItems();
    for (int i=0;i&lt;items.size();i++)
    {
        ModelTreeEntity type = ModelTreeEntity(items[i]-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt());
        uint mid = items[i]-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt();
        uint eid = items[i]-&gt;data(MODEL_TREE_COLUMN_EID,Qt::DisplayRole).toUInt();

        if (Session::getInstance().getModel(mid).isEmpty())
        {
            emptyModelIDsSelectedMap.insert(mid,true);
        }
        SessionEntityID entityID;
        entityID.setMid(mid);
        if (type == MODEL_TREE_MODEL)
        {
            // Select all entities
            for (int j=0;j&lt;allEntityIDs.size();j++)
            {
                if (allEntityIDs[j].getMid() == mid)
                {
                    entityIDsSelectedMap[allEntityIDs[j]] = true;
                }
            }
        }
        else if (type == MODEL_TREE_GROUP_POINT)
        {
            // Select all entities in the group
            for (int j=0;j&lt;allEntityIDs.size();j++)
            {
                if (allEntityIDs[j].getMid() == mid &amp;&amp;
                    allEntityIDs[j].getType() == R_ENTITY_GROUP_POINT)
                {
                    entityIDsSelectedMap[allEntityIDs[j]] = true;
                }
            }
        }
        else if (type == MODEL_TREE_GROUP_LINE)
        {
            // Select all entities in the group
            for (int j=0;j&lt;allEntityIDs.size();j++)
            {
                if (allEntityIDs[j].getMid() == mid &amp;&amp;
                    allEntityIDs[j].getType() == R_ENTITY_GROUP_LINE)
                {
                    entityIDsSelectedMap[allEntityIDs[j]] = true;
                }
            }
        }
        else if (type == MODEL_TREE_GROUP_SURFACE)
        {
            // Select all entities in the group
            for (int j=0;j&lt;allEntityIDs.size();j++)
            {
                if (allEntityIDs[j].getMid() == mid &amp;&amp;
                    allEntityIDs[j].getType() == R_ENTITY_GROUP_SURFACE)
                {
                    entityIDsSelectedMap[allEntityIDs[j]] = true;
                }
            }
        }
        else if (type == MODEL_TREE_GROUP_VOLUME)
        {
            // Select all entities in the group
            for (int j=0;j&lt;allEntityIDs.size();j++)
            {
                if (allEntityIDs[j].getMid() == mid &amp;&amp;
                    allEntityIDs[j].getType() == R_ENTITY_GROUP_VOLUME)
                {
                    entityIDsSelectedMap[allEntityIDs[j]] = true;
                }
            }
        }
        else if (type == MODEL_TREE_GROUP_VECTOR_FIELD)
        {
            // Select all entities in the group
            for (int j=0;j&lt;allEntityIDs.size();j++)
            {
                if (allEntityIDs[j].getMid() == mid &amp;&amp;
                    allEntityIDs[j].getType() == R_ENTITY_GROUP_VECTOR_FIELD)
                {
                    entityIDsSelectedMap[allEntityIDs[j]] = true;
                }
            }
        }
        else if (type == MODEL_TREE_GROUP_SCALAR_FIELD)
        {
            // Select all entities in the group
            for (int j=0;j&lt;allEntityIDs.size();j++)
            {
                if (allEntityIDs[j].getMid() == mid &amp;&amp;
                    allEntityIDs[j].getType() == R_ENTITY_GROUP_SCALAR_FIELD)
                {
                    entityIDsSelectedMap[allEntityIDs[j]] = true;
                }
            }
        }
        else if (type == MODEL_TREE_GROUP_STREAM_LINE)
        {
            // Select all entities in the group
            for (int j=0;j&lt;allEntityIDs.size();j++)
            {
                if (allEntityIDs[j].getMid() == mid &amp;&amp;
                    allEntityIDs[j].getType() == R_ENTITY_GROUP_STREAM_LINE)
                {
                    entityIDsSelectedMap[allEntityIDs[j]] = true;
                }
            }
        }
        else if (type == MODEL_TREE_GROUP_CUT)
        {
            // Select all entities in the group
            for (int j=0;j&lt;allEntityIDs.size();j++)
            {
                if (allEntityIDs[j].getMid() == mid &amp;&amp;
                    allEntityIDs[j].getType() == R_ENTITY_GROUP_CUT)
                {
                    entityIDsSelectedMap[allEntityIDs[j]] = true;
                }
            }
        }
        else if (type == MODEL_TREE_GROUP_ISO)
        {
            // Select all entities in the group
            for (int j=0;j&lt;allEntityIDs.size();j++)
            {
                if (allEntityIDs[j].getMid() == mid &amp;&amp;
                    allEntityIDs[j].getType() == R_ENTITY_GROUP_ISO)
                {
                    entityIDsSelectedMap[allEntityIDs[j]] = true;
                }
            }
        }
        else if (type == MODEL_TREE_POINT ||
                 type == MODEL_TREE_LINE ||
                 type == MODEL_TREE_SURFACE ||
                 type == MODEL_TREE_VOLUME ||
                 type == MODEL_TREE_VECTOR_FIELD ||
                 type == MODEL_TREE_SCALAR_FIELD ||
                 type == MODEL_TREE_STREAM_LINE ||
                 type == MODEL_TREE_CUT ||
                 type == MODEL_TREE_ISO)
        {
            entityID.setType(EntityTypeToGroupType(type));
            entityID.setEid(eid);
            entityIDsSelectedMap[entityID] = true;
        }
    }

    this-&gt;setIgnoreSignals(true);

    for (QMap&lt;SessionEntityID,bool&gt;::const_iterator iter = entityIDsSelectedMap.constBegin();
         iter != entityIDsSelectedMap.constEnd();
         ++iter) {
        SessionEntityID entityID = iter.key();
        bool selected = iter.value();
        Session::getInstance().setEntitySelected(entityID.getMid(),
                                                 entityID.getType(),
                                                 entityID.getEid(),
                                                 selected);
    }

    for (QMap&lt;uint,bool&gt;::const_iterator iter = emptyModelIDsSelectedMap.constBegin();
         iter != emptyModelIDsSelectedMap.constEnd();
         ++iter)
    {
        uint mid = iter.key();
        bool selected = iter.value();
        Session::getInstance().setModelSelected(mid,selected);
    }

    this-&gt;setIgnoreSignals(false);

    this-&gt;selectSelected();
    this-&gt;actionList-&gt;processAvailability();
}

</t>
<t tx="leo.20201108101526.36">void ModelTree::onItemChanged(QTreeWidgetItem *item, int column)
{
    ModelTreeEntity entityType = (ModelTreeEntity)item-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt();
    REntityGroupType elementGrpType = EntityTypeToGroupType(entityType);
    uint mid = item-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt();
    uint eid = item-&gt;data(MODEL_TREE_COLUMN_EID,Qt::DisplayRole).toUInt();
    QString newName = item-&gt;text(MODEL_TREE_COLUMN_NAME);
    if (column == MODEL_TREE_COLUMN_NAME)
    {
        this-&gt;setIgnoreSignals(true);
        bool visible = item-&gt;checkState(column);
        if (entityType == MODEL_TREE_MODEL)
        {
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNPoints();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_POINT,i,visible);
            }
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNLines();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_LINE,i,visible);
            }
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNSurfaces();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_SURFACE,i,visible);
            }
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNVolumes();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_VOLUME,i,visible);
            }
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNCuts();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_CUT,i,visible);
            }
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNIsos();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_ISO,i,visible);
            }
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNStreamLines();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_STREAM_LINE,i,visible);
            }
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNVectorFields();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_VECTOR_FIELD,i,visible);
            }
            Session::getInstance().getModel(mid).setName(newName);
        }
        else if (entityType == MODEL_TREE_GROUP_POINT)
        {
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNPoints();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_POINT,i,visible);
            }
        }
        else if (entityType == MODEL_TREE_GROUP_LINE)
        {
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNLines();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_LINE,i,visible);
            }
        }
        else if (entityType == MODEL_TREE_GROUP_SURFACE)
        {
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNSurfaces();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_SURFACE,i,visible);
            }
        }
        else if (entityType == MODEL_TREE_GROUP_VOLUME)
        {
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNVolumes();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_VOLUME,i,visible);
            }
        }
        else if (entityType == MODEL_TREE_GROUP_VECTOR_FIELD)
        {
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNVectorFields();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_VECTOR_FIELD,i,visible);
            }
        }
        else if (entityType == MODEL_TREE_GROUP_SCALAR_FIELD)
        {
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNScalarFields();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_SCALAR_FIELD,i,visible);
            }
        }
        else if (entityType == MODEL_TREE_GROUP_STREAM_LINE)
        {
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNStreamLines();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_STREAM_LINE,i,visible);
            }
        }
        else if (entityType == MODEL_TREE_GROUP_CUT)
        {
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNCuts();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_CUT,i,visible);
            }
        }
        else if (entityType == MODEL_TREE_GROUP_ISO)
        {
            for (uint i=0;i&lt;Session::getInstance().getModel(mid).getNIsos();i++)
            {
                Session::getInstance().setEntityVisible(mid,R_ENTITY_GROUP_ISO,i,visible);
            }
        }
        else if (entityType == MODEL_TREE_POINT ||
                 entityType == MODEL_TREE_LINE ||
                 entityType == MODEL_TREE_SURFACE ||
                 entityType == MODEL_TREE_VOLUME ||
                 entityType == MODEL_TREE_VECTOR_FIELD ||
                 entityType == MODEL_TREE_SCALAR_FIELD ||
                 entityType == MODEL_TREE_STREAM_LINE ||
                 entityType == MODEL_TREE_CUT ||
                 entityType == MODEL_TREE_ISO)
        {
            Session::getInstance().setEntityVisible(mid,elementGrpType,eid,visible);
            if (entityType == MODEL_TREE_POINT)
            {
                Session::getInstance().getModel(mid).getPoint(eid).setName(newName);
            }
            else if (entityType == MODEL_TREE_LINE)
            {
                Session::getInstance().getModel(mid).getLine(eid).setName(newName);
            }
            else if (entityType == MODEL_TREE_SURFACE)
            {
                Session::getInstance().getModel(mid).getSurface(eid).setName(newName);
            }
            else if (entityType == MODEL_TREE_VOLUME)
            {
                Session::getInstance().getModel(mid).getVolume(eid).setName(newName);
            }
            else if (entityType == MODEL_TREE_VECTOR_FIELD)
            {
                Session::getInstance().getModel(mid).getVectorField(eid).setName(newName);
            }
            else if (entityType == MODEL_TREE_SCALAR_FIELD)
            {
                Session::getInstance().getModel(mid).getScalarField(eid).setName(newName);
            }
            else if (entityType == MODEL_TREE_STREAM_LINE)
            {
                Session::getInstance().getModel(mid).getStreamLine(eid).setName(newName);
            }
            else if (entityType == MODEL_TREE_CUT)
            {
                Session::getInstance().getModel(mid).getCut(eid).setName(newName);
            }
            else if (entityType == MODEL_TREE_ISO)
            {
                Session::getInstance().getModel(mid).getIso(eid).setName(newName);
            }
        }
        this-&gt;setIgnoreSignals(false);
        Session::getInstance().setModelRenamed(mid);
    }

    this-&gt;checkVisible();
}

</t>
<t tx="leo.20201108101526.37">void ModelTree::onEntitySelectionChanged(uint             mid,
                                         REntityGroupType elementGrpType,
                                         uint             eid,
                                         bool             selected)
{
    if (this-&gt;ignoreSignals)
    {
        return;
    }
    QList&lt;QTreeWidgetItem *&gt; allItems = this-&gt;getAllItems();
    for (int i=0;i&lt;allItems.size();i++)
    {
        ModelTreeEntity entityType = (ModelTreeEntity)allItems[i]-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt();
        REntityGroupType iElementGrpType = EntityTypeToGroupType(entityType);
        uint iMid = allItems[i]-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt();
        uint iEid = allItems[i]-&gt;data(MODEL_TREE_COLUMN_EID,Qt::DisplayRole).toUInt();
        if (iMid == mid &amp;&amp; iElementGrpType == elementGrpType &amp;&amp; iEid == eid)
        {
            allItems[i]-&gt;setSelected(selected);
        }
    }
}

</t>
<t tx="leo.20201108101526.38">void ModelTree::onEntityVisibilityChanged(uint mid, REntityGroupType elementGrpType, uint eid, bool visible)
{
    if (this-&gt;ignoreSignals)
    {
        return;
    }
    QList&lt;QTreeWidgetItem *&gt; allItems = this-&gt;getAllItems();
    for (int i=0;i&lt;allItems.size();i++)
    {
        ModelTreeEntity entityType = (ModelTreeEntity)allItems[i]-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt();
        REntityGroupType iElementGrpType = EntityTypeToGroupType(entityType);
        uint iMid = allItems[i]-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt();
        uint iEid = allItems[i]-&gt;data(MODEL_TREE_COLUMN_EID,Qt::DisplayRole).toUInt();
        if (iMid == mid &amp;&amp; iElementGrpType == elementGrpType &amp;&amp; iEid == eid)
        {
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,visible?Qt::Checked:Qt::Unchecked);
        }
    }
}

</t>
<t tx="leo.20201108101526.39">void ModelTree::selectSelected(void)
{
    QList&lt;QTreeWidgetItem *&gt; allItems = this-&gt;getAllItems();
    this-&gt;blockSignals(true);
    for (int i=0;i&lt;allItems.size();i++)
    {
        ModelTreeEntity entityType = (ModelTreeEntity)allItems[i]-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt();
        REntityGroupType elementGrpType = EntityTypeToGroupType(entityType);
        uint mid = allItems[i]-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt();
        uint eid = allItems[i]-&gt;data(MODEL_TREE_COLUMN_EID,Qt::DisplayRole).toUInt();

        if (entityType == MODEL_TREE_MODEL)
        {
            bool modelSelected = Session::getInstance().getModel(mid).isSelected(true);
            allItems[i]-&gt;setSelected(modelSelected);
        }
        else if (entityType == MODEL_TREE_GROUP_POINT)
        {
            bool groupSelected = Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_POINT,true);
            allItems[i]-&gt;setSelected(groupSelected);
        }
        else if (entityType == MODEL_TREE_GROUP_LINE)
        {
            bool groupSelected = Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_LINE,true);
            allItems[i]-&gt;setSelected(groupSelected);
        }
        else if (entityType == MODEL_TREE_GROUP_SURFACE)
        {
            bool groupSelected = Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_SURFACE,true);
            allItems[i]-&gt;setSelected(groupSelected);
        }
        else if (entityType == MODEL_TREE_GROUP_VOLUME)
        {
            bool groupSelected = Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_VOLUME,true);
            allItems[i]-&gt;setSelected(groupSelected);
        }
        else if (entityType == MODEL_TREE_GROUP_VECTOR_FIELD)
        {
            bool groupSelected = Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_VECTOR_FIELD,true);
            allItems[i]-&gt;setSelected(groupSelected);
        }
        else if (entityType == MODEL_TREE_GROUP_SCALAR_FIELD)
        {
            bool groupSelected = Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_SCALAR_FIELD,true);
            allItems[i]-&gt;setSelected(groupSelected);
        }
        else if (entityType == MODEL_TREE_GROUP_STREAM_LINE)
        {
            bool groupSelected = Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_STREAM_LINE,true);
            allItems[i]-&gt;setSelected(groupSelected);
        }
        else if (entityType == MODEL_TREE_GROUP_CUT)
        {
            bool groupSelected = Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_CUT,true);
            allItems[i]-&gt;setSelected(groupSelected);
        }
        else if (entityType == MODEL_TREE_GROUP_ISO)
        {
            bool groupSelected = Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_ISO,true);
            allItems[i]-&gt;setSelected(groupSelected);
        }
        else if (entityType == MODEL_TREE_POINT ||
                 entityType == MODEL_TREE_LINE ||
                 entityType == MODEL_TREE_SURFACE ||
                 entityType == MODEL_TREE_VOLUME ||
                 entityType == MODEL_TREE_VECTOR_FIELD ||
                 entityType == MODEL_TREE_SCALAR_FIELD ||
                 entityType == MODEL_TREE_STREAM_LINE ||
                 entityType == MODEL_TREE_CUT ||
                 entityType == MODEL_TREE_ISO)
        {
            bool entitySelected = Session::getInstance().getModel(mid).getSelected(elementGrpType,eid);
            allItems[i]-&gt;setSelected(entitySelected);
        }
        else
        {
            RError error(R_ERROR_APPLICATION,R_ERROR_REF,"Unknown entity type \'%d\'",entityType);
            RLogger::warning("%s\n",error.getMessage().toUtf8().constData());
        }
    }
    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101526.4">void ModelRecordsSelector::loadNextRecord(bool jumpToFirst)
{
    if (!jumpToFirst &amp;&amp; (this-&gt;tree-&gt;isLast() || !this-&gt;markNextIndicator))
    {
        if (this-&gt;recordIndicator)
        {
            QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();
            for (int i=0;i&lt;selectedModelIDs.size();i++)
            {
                RProgressInitialize("Creating a video file");
                this-&gt;createAnimation(selectedModelIDs.at(i));
                RProgressFinalize();
            }
        }
        this-&gt;markNextIndicator = false;
        this-&gt;recordIndicator = false;
        this-&gt;playAction-&gt;setIcon(QIcon(":/icons/media/pixmaps/range-play_play.svg"));
        this-&gt;playAction-&gt;setText("Play");
        this-&gt;recordAction-&gt;setEnabled(true);
        MainWindow::getInstance()-&gt;progressAutoHideEnable();
    }
    else
    {
        if (jumpToFirst)
        {
            if (this-&gt;tree-&gt;isFirst())
            {
                this-&gt;tree-&gt;markCurrent();
            }
            else
            {
                this-&gt;tree-&gt;markFirst();
            }
        }
        else
        {
            this-&gt;tree-&gt;markNext();
        }
    }
}

</t>
<t tx="leo.20201108101526.40">void ModelTree::expandSelected(void)
{

    QList&lt;QTreeWidgetItem *&gt; allItems = this-&gt;getAllItems();
    this-&gt;blockSignals(true);
    for (int i=0;i&lt;allItems.size();i++)
    {
        ModelTreeEntity entityType = ModelTreeEntity(allItems[i]-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt());
        uint mid = allItems[i]-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt();

        bool expand = false;
        switch (entityType) {
            case MODEL_TREE_MODEL:
                expand = (!Session::getInstance().getModel(mid).isSelected(false));
                break;
            case MODEL_TREE_GROUP_POINT:
                expand = (!Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_POINT,false));
                break;
            case MODEL_TREE_GROUP_LINE:
                expand = (!Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_LINE,false));
                break;
            case MODEL_TREE_GROUP_SURFACE:
                expand = (!Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_SURFACE,false));
                break;
            case MODEL_TREE_GROUP_VOLUME:
                expand = (!Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_VOLUME,false));
                break;
            case MODEL_TREE_GROUP_VECTOR_FIELD:
                expand = (!Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_VECTOR_FIELD,false));
                break;
            case MODEL_TREE_GROUP_SCALAR_FIELD:
                expand = (!Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_SCALAR_FIELD,false));
                break;
            case MODEL_TREE_GROUP_STREAM_LINE:
                expand = (!Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_STREAM_LINE,false));
                break;
            case MODEL_TREE_GROUP_CUT:
                expand = (!Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_CUT,false));
                break;
            case MODEL_TREE_GROUP_ISO:
                expand = (!Session::getInstance().getModel(mid).isSelected(R_ENTITY_GROUP_ISO,false));
                break;
            default:
                break;
        }
        if (expand)
        {
            allItems[i]-&gt;setExpanded(true);
        }
    }
    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101526.41">void ModelTree::checkVisible(void)
{
    QList&lt;QTreeWidgetItem *&gt; allItems = this-&gt;getAllItems();
    bool visible;
    bool hidden;
    Qt::CheckState checkState;
    this-&gt;blockSignals(true);
    for (int i=0;i&lt;allItems.size();i++)
    {
        ModelTreeEntity entityType = (ModelTreeEntity)allItems[i]-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt();
        REntityGroupType elementGrpType = EntityTypeToGroupType(entityType);
        uint mid = allItems[i]-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt();
        uint eid = allItems[i]-&gt;data(MODEL_TREE_COLUMN_EID,Qt::DisplayRole).toUInt();

        checkState = Qt::PartiallyChecked;
        if (entityType == MODEL_TREE_MODEL)
        {
            visible = Session::getInstance().getModel(mid).isVisible(true);
            hidden = Session::getInstance().getModel(mid).isVisible(false);
            if (visible)
            {
                checkState = Qt::Checked;
            }
            if (hidden)
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
        else if (entityType == MODEL_TREE_GROUP_POINT)
        {
            visible = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_POINT,true);
            hidden = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_POINT,false);
            if (visible)
            {
                checkState = Qt::Checked;
            }
            if (hidden)
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
        else if (entityType == MODEL_TREE_GROUP_LINE)
        {
            visible = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_LINE,true);
            hidden = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_LINE,false);
            if (visible)
            {
                checkState = Qt::Checked;
            }
            if (hidden)
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
        else if (entityType == MODEL_TREE_GROUP_SURFACE)
        {
            visible = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_SURFACE,true);
            hidden = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_SURFACE,false);
            if (visible)
            {
                checkState = Qt::Checked;
            }
            if (hidden)
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
        else if (entityType == MODEL_TREE_GROUP_VOLUME)
        {
            visible = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_VOLUME,true);
            hidden = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_VOLUME,false);
            if (visible)
            {
                checkState = Qt::Checked;
            }
            if (hidden)
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
        else if (entityType == MODEL_TREE_GROUP_VECTOR_FIELD)
        {
            visible = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_VECTOR_FIELD,true);
            hidden = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_VECTOR_FIELD,false);
            if (visible)
            {
                checkState = Qt::Checked;
            }
            if (hidden)
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
        else if (entityType == MODEL_TREE_GROUP_SCALAR_FIELD)
        {
            visible = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_SCALAR_FIELD,true);
            hidden = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_SCALAR_FIELD,false);
            if (visible)
            {
                checkState = Qt::Checked;
            }
            if (hidden)
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
        else if (entityType == MODEL_TREE_GROUP_STREAM_LINE)
        {
            visible = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_STREAM_LINE,true);
            hidden = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_STREAM_LINE,false);
            if (visible)
            {
                checkState = Qt::Checked;
            }
            if (hidden)
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
        else if (entityType == MODEL_TREE_GROUP_CUT)
        {
            visible = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_CUT,true);
            hidden = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_CUT,false);
            if (visible)
            {
                checkState = Qt::Checked;
            }
            if (hidden)
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
        else if (entityType == MODEL_TREE_GROUP_ISO)
        {
            visible = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_ISO,true);
            hidden = Session::getInstance().getModel(mid).isVisible(R_ENTITY_GROUP_ISO,false);
            if (visible)
            {
                checkState = Qt::Checked;
            }
            if (hidden)
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
        else if (entityType == MODEL_TREE_POINT ||
                 entityType == MODEL_TREE_LINE ||
                 entityType == MODEL_TREE_SURFACE ||
                 entityType == MODEL_TREE_VOLUME ||
                 entityType == MODEL_TREE_VECTOR_FIELD ||
                 entityType == MODEL_TREE_SCALAR_FIELD ||
                 entityType == MODEL_TREE_STREAM_LINE ||
                 entityType == MODEL_TREE_CUT ||
                 entityType == MODEL_TREE_ISO)
        {
            if (Session::getInstance().getModel(mid).getVisible(elementGrpType,eid))
            {
                checkState = Qt::Checked;
            }
            else
            {
                checkState = Qt::Unchecked;
            }
            allItems[i]-&gt;setCheckState(MODEL_TREE_COLUMN_NAME,checkState);
        }
    }
    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101526.42">void ModelTree::onDataChanged(QModelIndex topleft, QModelIndex bottomRight)
{
    for (int i=topleft.column();i&lt;bottomRight.column();i++)
    {
        this-&gt;resizeColumnToContents(i);
    }
}

</t>
<t tx="leo.20201108101526.43">void ModelTree::onItemExpanded(QTreeWidgetItem *item)
{
    for (int i=0;i&lt;item-&gt;columnCount();i++)
    {
        this-&gt;resizeColumnToContents(i);
    }
}

</t>
<t tx="leo.20201108101526.44">void ModelTree::onItemDoubleClicked(QTreeWidgetItem *item, int column)
{
    bool isEditable = false;

    ModelTreeEntity entityType = ModelTreeEntity(item-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt());

    if (column == MODEL_TREE_COLUMN_NAME)
    {
        if (entityType == MODEL_TREE_POINT ||
            entityType == MODEL_TREE_LINE ||
            entityType == MODEL_TREE_SURFACE ||
            entityType == MODEL_TREE_VOLUME ||
            entityType == MODEL_TREE_VECTOR_FIELD ||
            entityType == MODEL_TREE_SCALAR_FIELD ||
            entityType == MODEL_TREE_STREAM_LINE ||
            entityType == MODEL_TREE_CUT ||
            entityType == MODEL_TREE_ISO)
        {
            isEditable = true;
        }
    }

    this-&gt;blockSignals(true);
    if (isEditable)
    {
        item-&gt;setFlags(item-&gt;flags() | Qt::ItemIsEditable);
    }
    else
    {
        if (item-&gt;flags() &amp; Qt::ItemIsEditable)
        {
            item-&gt;setFlags(item-&gt;flags() ^ Qt::ItemIsEditable);
        }
    }
    this-&gt;blockSignals(false);
}
</t>
<t tx="leo.20201108101526.45">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model_tree_simple.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Simple model tree class definition                  *
 *********************************************************************/

#include "model_tree_simple.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.46">typedef enum _ModelTreeSimpleEntity
{
    MODEL_TREE_NONE = 0,
    MODEL_TREE_MODEL,
    MODEL_TREE_GROUP_POINT,
    MODEL_TREE_GROUP_LINE,
    MODEL_TREE_GROUP_SURFACE,
    MODEL_TREE_GROUP_VOLUME,
    MODEL_TREE_GROUP_VECTOR_FIELD,
    MODEL_TREE_GROUP_SCALAR_FIELD,
    MODEL_TREE_GROUP_STREAM_LINE,
    MODEL_TREE_GROUP_CUT,
    MODEL_TREE_GROUP_ISO,
    MODEL_TREE_POINT,
    MODEL_TREE_LINE,
    MODEL_TREE_SURFACE,
    MODEL_TREE_VOLUME,
    MODEL_TREE_VECTOR_FIELD,
    MODEL_TREE_SCALAR_FIELD,
    MODEL_TREE_STREAM_LINE,
    MODEL_TREE_CUT,
    MODEL_TREE_ISO,
    MODEL_TREE_N_TYPES
} ModelTreeSimpleEntity;

</t>
<t tx="leo.20201108101526.47">typedef enum _ModelTreeSimpleColumn
{
    MODEL_TREE_COLUMN_NAME = 0,
    MODEL_TREE_COLUMN_TYPE,
    MODEL_TREE_COLUMN_MID,
    MODEL_TREE_COLUMN_EID,
    MODEL_TREE_N_COLUMNS
} ModelTreeSimpleColumn;

</t>
<t tx="leo.20201108101526.48">static REntityGroupType EntityTypeToGroupType(ModelTreeSimpleEntity entityType)
{
    switch (entityType)
    {
        case MODEL_TREE_POINT:
            return R_ENTITY_GROUP_POINT;
        case MODEL_TREE_LINE:
            return R_ENTITY_GROUP_LINE;
        case MODEL_TREE_SURFACE:
            return R_ENTITY_GROUP_SURFACE;
        case MODEL_TREE_VOLUME:
            return R_ENTITY_GROUP_VOLUME;
        case MODEL_TREE_VECTOR_FIELD:
            return R_ENTITY_GROUP_VECTOR_FIELD;
        case MODEL_TREE_SCALAR_FIELD:
            return R_ENTITY_GROUP_SCALAR_FIELD;
        case MODEL_TREE_STREAM_LINE:
            return R_ENTITY_GROUP_STREAM_LINE;
        case MODEL_TREE_CUT:
            return R_ENTITY_GROUP_CUT;
        case MODEL_TREE_ISO:
            return R_ENTITY_GROUP_ISO;
        default:
            return R_ENTITY_GROUP_NONE;
    }
}

ModelTreeSimple::ModelTreeSimple(uint modelID, REntityGroupTypeMask modelEntitiesMask, QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection);

    this-&gt;setColumnCount(MODEL_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(MODEL_TREE_COLUMN_NAME,QString("Model"));
    headerItem-&gt;setText(MODEL_TREE_COLUMN_TYPE,QString("type"));
    headerItem-&gt;setText(MODEL_TREE_COLUMN_MID,QString("modelID"));
    headerItem-&gt;setText(MODEL_TREE_COLUMN_EID,QString("entityID"));
    this-&gt;setHeaderItem(headerItem);

    this-&gt;setColumnHidden(MODEL_TREE_COLUMN_TYPE,true);
    this-&gt;setColumnHidden(MODEL_TREE_COLUMN_MID,true);
    this-&gt;setColumnHidden(MODEL_TREE_COLUMN_EID,true);

    this-&gt;addModel(modelID,modelEntitiesMask);

    QObject::connect(this,&amp;ModelTreeSimple::itemSelectionChanged,this,&amp;ModelTreeSimple::onSelectionChanged);
}

</t>
<t tx="leo.20201108101526.49">void ModelTreeSimple::selectEntity(uint modelID, REntityGroupType entityGroupType, uint entityID)
{
    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        QTreeWidgetItem *topItem = this-&gt;topLevelItem(i);
        for (int j=0;j&lt;topItem-&gt;childCount();j++)
        {
            QTreeWidgetItem *groupItem = topItem-&gt;child(j);
            for (int k=0;k&lt;groupItem-&gt;childCount();k++)
            {
                QTreeWidgetItem *entityItem = groupItem-&gt;child(k);
                uint mid = entityItem-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt();
                uint eid = entityItem-&gt;data(MODEL_TREE_COLUMN_EID,Qt::DisplayRole).toUInt();
                REntityGroupType gid = EntityTypeToGroupType(ModelTreeSimpleEntity(entityItem-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toUInt()));
                if (modelID == mid &amp;&amp; entityGroupType == gid &amp;&amp; entityID == eid)
                {
                    entityItem-&gt;setSelected(true);
                }
            }
        }
    }
}

QList&lt;SessionEntityID&gt; ModelTreeSimple::getSelected(void) const
{
    QList&lt;SessionEntityID&gt; selectedIDs;

    QList&lt;QTreeWidgetItem*&gt; items = this-&gt;selectedItems();

    for (int i=0;i&lt;items.size();i++)
    {
        ModelTreeSimpleEntity type = ModelTreeSimpleEntity(items[i]-&gt;data(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole).toInt());
        uint mid = items[i]-&gt;data(MODEL_TREE_COLUMN_MID,Qt::DisplayRole).toUInt();
        uint eid = items[i]-&gt;data(MODEL_TREE_COLUMN_EID,Qt::DisplayRole).toUInt();

        REntityGroupType grpType = EntityTypeToGroupType(type);

        if (grpType != R_ENTITY_GROUP_NONE)
        {
            selectedIDs.append(SessionEntityID(mid,grpType,eid));
        }
    }

    return selectedIDs;
}

</t>
<t tx="leo.20201108101526.5">void ModelRecordsSelector::onRecordVideo(void)
{
    VideoSettingsDialog videoSettingsDialog(&amp;this-&gt;videoSettings);
    if (videoSettingsDialog.exec() == QDialog::Accepted)
    {
        this-&gt;recordIndicator = true;
        this-&gt;recordAction-&gt;setDisabled(true);
        this-&gt;playToggle(true);
    }
}
</t>
<t tx="leo.20201108101526.50">void ModelTreeSimple::addModel(uint modelID, REntityGroupTypeMask modelEntitiesMask)
{
    const Model &amp;rModel = Session::getInstance().getModel(modelID);

    this-&gt;blockSignals(true);
    QTreeWidgetItem *itemModel = new QTreeWidgetItem(this);
    itemModel-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getName());
    itemModel-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_MODEL));
    itemModel-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

    if (rModel.getNPoints() &gt; 0 &amp;&amp; modelEntitiesMask &amp; R_ENTITY_GROUP_POINT)
    {
        QTreeWidgetItem *itemGroup = new QTreeWidgetItem(itemModel);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Points");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_POINT));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        for (uint i=0;i&lt;rModel.getNPoints();i++)
        {
            QTreeWidgetItem *itemEntity = new QTreeWidgetItem(itemGroup);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getPoint(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_POINT));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
            if (rModel.getPoint(i).getData().getSelected())
            {
                itemEntity-&gt;setSelected(true);
            }
        }
    }

    if (rModel.getNLines() &gt; 0 &amp;&amp; modelEntitiesMask &amp; R_ENTITY_GROUP_LINE)
    {
        QTreeWidgetItem *itemGroup = new QTreeWidgetItem(itemModel);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Lines");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_LINE));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        for (uint i=0;i&lt;rModel.getNLines();i++)
        {
            QTreeWidgetItem *itemEntity = new QTreeWidgetItem(itemGroup);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getLine(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_LINE));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
            if (rModel.getLine(i).getData().getSelected())
            {
                itemEntity-&gt;setSelected(true);
            }
        }
    }

    if (rModel.getNSurfaces() &gt; 0 &amp;&amp; modelEntitiesMask &amp; R_ENTITY_GROUP_SURFACE)
    {
        QTreeWidgetItem *itemGroup = new QTreeWidgetItem(itemModel);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Surfaces");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_SURFACE));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        for (uint i=0;i&lt;rModel.getNSurfaces();i++)
        {
            QTreeWidgetItem *itemEntity = new QTreeWidgetItem(itemGroup);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getSurface(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_SURFACE));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
            if (rModel.getSurface(i).getData().getSelected())
            {
                itemEntity-&gt;setSelected(true);
            }
        }
    }

    if (rModel.getNVolumes() &gt; 0 &amp;&amp; modelEntitiesMask &amp; R_ENTITY_GROUP_VOLUME)
    {
        QTreeWidgetItem *itemGroup = new QTreeWidgetItem(itemModel);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Volumes");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_VOLUME));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        for (uint i=0;i&lt;rModel.getNVolumes();i++)
        {
            QTreeWidgetItem *itemEntity = new QTreeWidgetItem(itemGroup);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getVolume(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_VOLUME));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
            if (rModel.getVolume(i).getData().getSelected())
            {
                itemEntity-&gt;setSelected(true);
            }
        }
    }

    if (rModel.getNCuts() &gt; 0 &amp;&amp; modelEntitiesMask &amp; R_ENTITY_GROUP_CUT)
    {
        QTreeWidgetItem *itemGroup = new QTreeWidgetItem(itemModel);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Cuts");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_CUT));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        for (uint i=0;i&lt;rModel.getNCuts();i++)
        {
            QTreeWidgetItem *itemEntity = new QTreeWidgetItem(itemGroup);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getCut(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_CUT));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
            if (rModel.getCut(i).getData().getSelected())
            {
                itemEntity-&gt;setSelected(true);
            }
        }
    }

    if (rModel.getNIsos() &gt; 0 &amp;&amp; modelEntitiesMask &amp; R_ENTITY_GROUP_ISO)
    {
        QTreeWidgetItem *itemGroup = new QTreeWidgetItem(itemModel);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Isos");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_ISO));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        for (uint i=0;i&lt;rModel.getNIsos();i++)
        {
            QTreeWidgetItem *itemEntity = new QTreeWidgetItem(itemGroup);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getIso(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_ISO));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
            if (rModel.getIso(i).getData().getSelected())
            {
                itemEntity-&gt;setSelected(true);
            }
        }
    }

    if (rModel.getNStreamLines() &gt; 0 &amp;&amp; modelEntitiesMask &amp; R_ENTITY_GROUP_STREAM_LINE)
    {
        QTreeWidgetItem *itemGroup = new QTreeWidgetItem(itemModel);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Stream lines");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_STREAM_LINE));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        for (uint i=0;i&lt;rModel.getNStreamLines();i++)
        {
            QTreeWidgetItem *itemEntity = new QTreeWidgetItem(itemGroup);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getStreamLine(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_STREAM_LINE));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
            if (rModel.getStreamLine(i).getData().getSelected())
            {
                itemEntity-&gt;setSelected(true);
            }
        }
    }

    if (rModel.getNScalarFields() &gt; 0 &amp;&amp; modelEntitiesMask &amp; R_ENTITY_GROUP_SCALAR_FIELD)
    {
        QTreeWidgetItem *itemGroup = new QTreeWidgetItem(itemModel);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Scalar fields");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_SCALAR_FIELD));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        for (uint i=0;i&lt;rModel.getNScalarFields();i++)
        {
            QTreeWidgetItem *itemEntity = new QTreeWidgetItem(itemGroup);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getScalarField(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_SCALAR_FIELD));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
            if (rModel.getScalarField(i).getData().getSelected())
            {
                itemEntity-&gt;setSelected(true);
            }
        }
    }

    if (rModel.getNVectorFields() &gt; 0 &amp;&amp; modelEntitiesMask &amp; R_ENTITY_GROUP_VECTOR_FIELD)
    {
        QTreeWidgetItem *itemGroup = new QTreeWidgetItem(itemModel);
        itemGroup-&gt;setText(MODEL_TREE_COLUMN_NAME, "Vector fields");
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_GROUP_VECTOR_FIELD));
        itemGroup-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));

        for (uint i=0;i&lt;rModel.getNVectorFields();i++)
        {
            QTreeWidgetItem *itemEntity = new QTreeWidgetItem(itemGroup);
            itemEntity-&gt;setText(MODEL_TREE_COLUMN_NAME, rModel.getVectorField(i).getName());
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_TYPE,Qt::DisplayRole,QVariant(MODEL_TREE_VECTOR_FIELD));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_MID,Qt::DisplayRole,QVariant(modelID));
            itemEntity-&gt;setData(MODEL_TREE_COLUMN_EID,Qt::DisplayRole,QVariant(i));
            if (rModel.getVectorField(i).getData().getSelected())
            {
                itemEntity-&gt;setSelected(true);
            }
        }
    }

    this-&gt;expandAll();

    this-&gt;blockSignals(false);

    this-&gt;onSelectionChanged();
}

</t>
<t tx="leo.20201108101526.51">void ModelTreeSimple::onSelectionChanged(void)
{
    this-&gt;blockSignals(true);

    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        QTreeWidgetItem *itemModel = this-&gt;topLevelItem(i);

        int nGroupsSelected = 0;
        for (int j=0;j&lt;itemModel-&gt;childCount();j++)
        {
            QTreeWidgetItem *itemGroup = itemModel-&gt;child(j);
            if (itemModel-&gt;isSelected())
            {
                itemGroup-&gt;setSelected(true);
            }

            int nEntitiesSelected = 0;
            for (int k=0;k&lt;itemGroup-&gt;childCount();k++)
            {
                QTreeWidgetItem *itemEntity = itemGroup-&gt;child(k);
                if (itemGroup-&gt;isSelected())
                {
                    itemEntity-&gt;setSelected(true);
                }
                if (itemEntity-&gt;isSelected())
                {
                    nEntitiesSelected++;
                }
            }
            if (nEntitiesSelected == itemGroup-&gt;childCount())
            {
                itemGroup-&gt;setSelected(true);
            }

            if (itemGroup-&gt;isSelected())
            {
                nGroupsSelected++;
            }
        }
        if (nGroupsSelected == itemModel-&gt;childCount())
        {
            itemModel-&gt;setSelected(true);
        }
    }

    this-&gt;blockSignals(false);
}
</t>
<t tx="leo.20201108101526.52">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   monitoring_points_dialog.h                               *
 *  GROUP:  Range                                                    *
 *  TYPE:   header file (*.h)                                        *
 *  DATE:   12-th March 20134                                        *
 *                                                                   *
 *  DESCRIPTION: Monitoring points class declaration                 *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;
#include &lt;QComboBox&gt;

#include &lt;rmlib.h&gt;

#include "monitoring_points_dialog.h"
#include "session.h"
#include "variable_selector.h"

MonitoringPointsDialog::MonitoringPointsDialog(uint modelID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID)
{
    const RMonitoringPointManager &amp;monitoringPointsManager = Session::getInstance().getModel(this-&gt;modelID).getMonitoringPointManager();

    this-&gt;setWindowTitle(tr("Define monitoring points"));
    this-&gt;resize(600,300);

    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    int mainLayoutRow = 0;

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout(mainLayout);

    this-&gt;tableWidget = new QTableWidget(0,4);
    this-&gt;tableWidget-&gt;setHorizontalHeaderLabels(QStringList() &lt;&lt; tr("Variable") &lt;&lt; "X" &lt;&lt; "Y" &lt;&lt; "Z");
    for (uint i=0;i&lt;monitoringPointsManager.size();i++)
    {
        this-&gt;addMonitoringPoint(monitoringPointsManager[i]);
    }
    mainLayout-&gt;addWidget(this-&gt;tableWidget, mainLayoutRow++, 0, 1, 1);

    QHBoxLayout *actionButtonsLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(actionButtonsLayout, mainLayoutRow++, 0, 1, 1);

    QPushButton *addButton = new QPushButton(tr("Add"));
    actionButtonsLayout-&gt;addWidget(addButton);

    this-&gt;removeButton = new QPushButton(tr("Remove"));
    this-&gt;removeButton-&gt;setEnabled(this-&gt;tableWidget-&gt;selectedItems().size() &gt; 0);
    actionButtonsLayout-&gt;addWidget(this-&gt;removeButton);

    this-&gt;usePickedButton = new QPushButton(tr("Set coordinates from picked element/node"));
    this-&gt;usePickedButton-&gt;setEnabled(!Session::getInstance().getPickList().isEmpty() &amp;&amp; this-&gt;tableWidget-&gt;selectedItems().size() &gt; 0);
    mainLayout-&gt;addWidget(this-&gt;usePickedButton, mainLayoutRow++, 0, 1, 1);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRow++, 0, 1, 1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(this-&gt;tableWidget,&amp;QTableWidget::itemSelectionChanged,this,&amp;MonitoringPointsDialog::onItemSelectionChanged);
    QObject::connect(addButton,&amp;QPushButton::clicked,this,&amp;MonitoringPointsDialog::onAddClicked);
    QObject::connect(this-&gt;removeButton,&amp;QPushButton::clicked,this,&amp;MonitoringPointsDialog::onRemoveClicked);
    QObject::connect(this-&gt;usePickedButton,&amp;QPushButton::clicked,this,&amp;MonitoringPointsDialog::onUsePickedClicked);
    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;MonitoringPointsDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;MonitoringPointsDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.53">int MonitoringPointsDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        Session::getInstance().storeCurentModelVersion(this-&gt;modelID,tr("Set monitoring points"));

        RMonitoringPointManager &amp;monitoringPointsManager = Session::getInstance().getModel(this-&gt;modelID).getMonitoringPointManager();
        monitoringPointsManager.clear();

        for (int i=0;i&lt;this-&gt;tableWidget-&gt;rowCount();i++)
        {
            VariableSelector *variableSelector = dynamic_cast&lt;VariableSelector*&gt;(this-&gt;tableWidget-&gt;cellWidget(i,0));
            QTableWidgetItem *xItem = this-&gt;tableWidget-&gt;item(i,1);
            QTableWidgetItem *yItem = this-&gt;tableWidget-&gt;item(i,2);
            QTableWidgetItem *zItem = this-&gt;tableWidget-&gt;item(i,3);

            RVariableType variableType = variableSelector-&gt;getCurrentVariableType();
            double x = xItem-&gt;text().toDouble();
            double y = yItem-&gt;text().toDouble();
            double z = zItem-&gt;text().toDouble();

            monitoringPointsManager.push_back(RMonitoringPoint(variableType,RR3Vector(x,y,z)));
        }
        Session::getInstance().setModelChanged(this-&gt;modelID);
    }

    return retVal;
}

</t>
<t tx="leo.20201108101526.54">void MonitoringPointsDialog::addMonitoringPoint(const RMonitoringPoint &amp;monitoringPoint)
{
    int row = this-&gt;tableWidget-&gt;rowCount();

    this-&gt;tableWidget-&gt;insertRow(row);

    VariableSelector *variableSelector = new VariableSelector(RProblem::getVariableTypes(Session::getInstance().getModel(this-&gt;modelID).getProblemTaskTree().getProblemTypeMask()));
    variableSelector-&gt;setCurrentVariableType(monitoringPoint.getVariableType());
    this-&gt;tableWidget-&gt;setCellWidget(row,0,variableSelector);

    QTableWidgetItem *xItem = new QTableWidgetItem(QString::number(monitoringPoint.getPosition()[0]));
    this-&gt;tableWidget-&gt;setItem(row,1,xItem);

    QTableWidgetItem *yItem = new QTableWidgetItem(QString::number(monitoringPoint.getPosition()[1]));
    this-&gt;tableWidget-&gt;setItem(row,2,yItem);

    QTableWidgetItem *zItem = new QTableWidgetItem(QString::number(monitoringPoint.getPosition()[2]));
    this-&gt;tableWidget-&gt;setItem(row,3,zItem);
}

QList&lt;int&gt; MonitoringPointsDialog::findSelectedRows(void) const
{
    QList&lt;QTableWidgetItem*&gt; selectedItems = this-&gt;tableWidget-&gt;selectedItems();
    QMap&lt;int,bool&gt; rowBook;

    for (int i=0;i&lt;selectedItems.size();i++)
    {
        rowBook[selectedItems.at(i)-&gt;row()] = true;
    }

    QList&lt;int&gt; rowList = rowBook.uniqueKeys();
    std::sort(rowList.begin(),rowList.end());

    return rowList;
}

RR3Vector MonitoringPointsDialog::findPickedPosition(void) const
{
    const PickList &amp;pickList = Session::getInstance().getPickList();

    const QVector&lt;PickItem&gt; &amp;pickItems = pickList.getItems();

    for (int i=0;i&lt;pickItems.size();i++)
    {
        const SessionEntityID &amp;pickEntityID = pickItems[i].getEntityID();

        if (pickEntityID.getMid() != this-&gt;modelID)
        {
            continue;
        }

        if (pickItems[i].getItemType() == PICK_ITEM_NODE)
        {
            return Session::getInstance().getModel(pickEntityID.getMid()).getNode(pickItems[i].getNodeID()).toVector();
        }
        else if (pickItems[i].getItemType() == PICK_ITEM_ELEMENT)
        {
            double cx, cy, cz;
            const Model &amp;rModel = Session::getInstance().getModel(pickEntityID.getMid());
            rModel.getElement(pickItems[i].getElementID()).findCenter(rModel.getNodes(),cx,cy,cz);
            return RR3Vector(cx, cy, cz);
        }
    }

    return RR3Vector();
}

</t>
<t tx="leo.20201108101526.55">void MonitoringPointsDialog::onItemSelectionChanged(void)
{
    this-&gt;removeButton-&gt;setEnabled(this-&gt;tableWidget-&gt;selectedItems().size() &gt; 0);
    this-&gt;usePickedButton-&gt;setEnabled(this-&gt;tableWidget-&gt;selectedItems().size() &gt; 0);
}

</t>
<t tx="leo.20201108101526.56">void MonitoringPointsDialog::onAddClicked(void)
{
    this-&gt;addMonitoringPoint(RMonitoringPoint());
}

</t>
<t tx="leo.20201108101526.57">void MonitoringPointsDialog::onRemoveClicked(void)
{
    QList&lt;int&gt; selectedRows = this-&gt;findSelectedRows();
    for(int i=selectedRows.count()-1;i&gt;=0;i--)
    {
        this-&gt;tableWidget-&gt;removeRow(selectedRows.at(i));
    }
}

</t>
<t tx="leo.20201108101526.58">void MonitoringPointsDialog::onUsePickedClicked(void)
{
    RR3Vector position = this-&gt;findPickedPosition();

    QList&lt;int&gt; selectedRows = this-&gt;findSelectedRows();
    for (int i=0;i&lt;selectedRows.size();i++)
    {
        this-&gt;tableWidget-&gt;item(selectedRows.at(i),1)-&gt;setText(QString::number(position[0]));
        this-&gt;tableWidget-&gt;item(selectedRows.at(i),2)-&gt;setText(QString::number(position[1]));
        this-&gt;tableWidget-&gt;item(selectedRows.at(i),3)-&gt;setText(QString::number(position[2]));
    }
}
</t>
<t tx="leo.20201108101526.59">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   monitoring_point_graph_dialog.cpp                        *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-th March 2014                                         *
 *                                                                   *
 *  DESCRIPTION: Monitoring point graph dialog class definition      *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include "monitoring_point_graph_dialog.h"
#include "graph_dialog.h"

MonitoringPointGraphDialog::MonitoringPointGraphDialog(const QString &amp;monitoringFileName, QWidget *parent) :
    QDialog(parent)
{
    try
    {
        this-&gt;readDataFromFile(monitoringFileName);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to read monitoring point data from file \'%s\'. %s.\n",
                       monitoringFileName.toUtf8().constData(),
                       error.getMessage().toUtf8().constData());
    }

    QIcon closeIcon(":/icons/file/pixmaps/range-close.svg");

    this-&gt;setWindowTitle(tr("Monitoring point"));
    this-&gt;resize(600,400);

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    uint mainLayoutRowCount = 0;

    QLabel *label = new QLabel("Source: &lt;i&gt;" + monitoringFileName + "&lt;/i&gt;");
    mainLayout-&gt;addWidget(label, mainLayoutRowCount++, 0, 1, 1);

    this-&gt;monitoringPointsCombo = new QComboBox;
    QList&lt;RMonitoringPoint&gt; keys = this-&gt;data.keys();
    for (int i=0;i&lt;keys.size();i++)
    {
        QString text(RVariable::getName(keys[i].getVariableType())
                     + " [" + QString::number(keys[i].getPosition()[0])
                     + "; " + QString::number(keys[i].getPosition()[1])
                     + "; " + QString::number(keys[i].getPosition()[2]) + "]");
        this-&gt;monitoringPointsCombo-&gt;addItem(text);
    }
    mainLayout-&gt;addWidget(this-&gt;monitoringPointsCombo, mainLayoutRowCount++, 0, 1, 1);

    this-&gt;connect(this-&gt;monitoringPointsCombo,
                  SIGNAL(currentIndexChanged(int)),
                  this,
                  SLOT(onCurrentIndexChanged(int)));

    this-&gt;valuesTree = new QTreeWidget;
    this-&gt;populateValuesTree();
    mainLayout-&gt;addWidget(this-&gt;valuesTree, mainLayoutRowCount++, 0, 1, 1);

    QPushButton *showGraphButton = new QPushButton(tr("Display in graph"));
    mainLayout-&gt;addWidget(showGraphButton, mainLayoutRowCount++, 0, 1, 1);

    QObject::connect(showGraphButton,&amp;QPushButton::clicked,this,&amp;MonitoringPointGraphDialog::onDisplayInGraphClicked);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRowCount++, 0, 1, 1);

    buttonsLayout-&gt;addStretch(1);

    QPushButton *closeButton = new QPushButton(closeIcon, tr("Close"));
    closeButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(closeButton);

    QObject::connect(closeButton,&amp;QPushButton::clicked,this,&amp;QDialog::reject);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.6">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   model_records_tree.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th September 2013                                      *
 *                                                                   *
 *  DESCRIPTION: Model records tree class definition                 *
 *********************************************************************/

#include &lt;QMap&gt;

#include "model_records_tree.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.60">int MonitoringPointGraphDialog::exec(void)
{
    int retVal = QDialog::exec();

    return retVal;
}

</t>
<t tx="leo.20201108101526.61">void MonitoringPointGraphDialog::readDataFromFile(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"Empty file name was provided");
    }

    RFile file(fileName,RFile::ASCII);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RMonitoringPoint monitoringPoint;
    while (!file.getTextStream().atEnd())
    {
        uint iteration;
        RRVector valueVector;
        try
        {
            monitoringPoint.readRecordFromFile(file,iteration,valueVector);
        }
        catch (const RError &amp;error)
        {
            if (file.getTextStream().atEnd())
            {
                continue;
            }
            file.close();
            throw error;
        }
        this-&gt;data[monitoringPoint].append(valueVector);
    }

    file.close();
}

</t>
<t tx="leo.20201108101526.62">void MonitoringPointGraphDialog::populateValuesTree(void)
{
    this-&gt;valuesTree-&gt;clear();

    int index = this-&gt;monitoringPointsCombo-&gt;currentIndex();
    if (index &lt; 0)
    {
        return;
    }
    QList&lt;RMonitoringPoint&gt; keys = this-&gt;data.keys();
    QVector&lt;RRVector&gt; &amp;values = this-&gt;data[keys[index]];

    uint nColumns = 0;
    for (int i=0;i&lt;values.size();i++)
    {
        nColumns = std::max(nColumns,uint(values[i].size()));
    }

    this-&gt;valuesTree-&gt;setColumnCount(nColumns+1);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(0,"#");
    for (uint i=0;i&lt;nColumns;i++)
    {
        headerItem-&gt;setText(i+1,QString::number(i+1));
    }
    this-&gt;valuesTree-&gt;setHeaderItem(headerItem);

    for (int i=0;i&lt;values.size();i++)
    {
        QTreeWidgetItem *item = new QTreeWidgetItem(this-&gt;valuesTree);
        item-&gt;setText(0,QString::number(i+1));
        for (uint j=0;j&lt;values[i].size();j++)
        {
            item-&gt;setText(j+1,QString::number(values[i][j]));
        }
    }

    for (uint i=0;i&lt;nColumns+1;i++)
    {
        this-&gt;valuesTree-&gt;resizeColumnToContents(i);
    }
}

</t>
<t tx="leo.20201108101526.63">void MonitoringPointGraphDialog::displayInGraph(void)
{
    GraphObject *graphObject = new GraphObject;

    GraphData &amp;rGraphData = graphObject-&gt;getData();

    rGraphData.setTitle(this-&gt;monitoringPointsCombo-&gt;currentText());
    rGraphData.setTypeMask(GRAPH_LINES);
    rGraphData.setXLabel(tr("Iteration"));
    rGraphData.setYLabel(tr("Value"));

    int index = this-&gt;monitoringPointsCombo-&gt;currentIndex();
    if (index &gt;= 0)
    {
        QList&lt;RMonitoringPoint&gt; keys = this-&gt;data.keys();
        QVector&lt;RRVector&gt; &amp;values = this-&gt;data[keys[index]];
        for (int i=0;i&lt;values.size();i++)
        {
            RRVector &amp;rValues = this-&gt;data[keys[index]][i];
            rGraphData[i].resize(rValues.size());
            for (uint j=0;j&lt;rValues.size();j++)
            {
                rGraphData[i][j] = this-&gt;data[keys[index]][i][j];
            }
        }
    }

    GraphDialog graphDialog(graphObject,this);
    graphDialog.getGraphWidget()-&gt;setShowPointer(true,true,true);
    graphDialog.exec();
}

</t>
<t tx="leo.20201108101526.64">void MonitoringPointGraphDialog::onCurrentIndexChanged(int)
{
    this-&gt;populateValuesTree();
}

</t>
<t tx="leo.20201108101526.65">void MonitoringPointGraphDialog::onDisplayInGraphClicked(void)
{
    this-&gt;displayInGraph();
}
</t>
<t tx="leo.20201108101526.66">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   move_node_dialog.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th February 2015                                      *
 *                                                                   *
 *  DESCRIPTION: Move node dialog class definition                   *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QScrollArea&gt;

#include "move_node_dialog.h"
#include "position_widget.h"
#include "session.h"

MoveNodeDialog::MoveNodeDialog(uint modelID, const QList&lt;uint&gt; &amp;nodeIDs, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    nodeIDs(nodeIDs)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Move node"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QScrollArea *scrollArea = new QScrollArea;
    scrollArea-&gt;setWidgetResizable(true);
    mainLayout-&gt;addWidget(scrollArea);

    QWidget *containerWidget = new QWidget;
    scrollArea-&gt;setWidget(containerWidget);

    QVBoxLayout *containerLayout = new QVBoxLayout(containerWidget);

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    for (int i=0;i&lt;nodeIDs.size();i++)
    {
        QString labelStr = tr("Node") + QString(" # ") + QString::number(this-&gt;nodeIDs[i]);
        PositionWidget *positionWidget = new PositionWidget(labelStr,rModel.getNode(this-&gt;nodeIDs[i]).toVector(),true);
        positionWidget-&gt;hidePickButton();
        containerLayout-&gt;addWidget(positionWidget);

        QObject::connect(positionWidget,&amp;PositionWidget::changed,this,&amp;MoveNodeDialog::onPositionChanged);

        this-&gt;positionWidgets.append(positionWidget);
    }

    containerLayout-&gt;addStretch(1);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setEnabled(false);
    this-&gt;okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(cancelButton, &amp;QPushButton::clicked, this, &amp;QDialog::reject);
    QObject::connect(okButton, &amp;QPushButton::clicked, this, &amp;QDialog::accept);

    Session::getInstance().setBeginDrawMoveNodes(this-&gt;findNodeIdPositionMap());
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.67">int MoveNodeDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        Session::getInstance().storeCurentModelVersion(this-&gt;modelID,tr("Move node"));
        Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

        for (int i=0;i&lt;this-&gt;nodeIDs.size();i++)
        {
            RR3Vector position(this-&gt;positionWidgets[i]-&gt;getPosition());

            rModel.getNode(this-&gt;nodeIDs[i]).set(position[0],position[1],position[2]);
        }
    }

    Session::getInstance().setEndDrawMoveNodes();
    Session::getInstance().setModelChanged(this-&gt;modelID);

    return retVal;
}

QMap&lt;SessionNodeID, RR3Vector&gt; MoveNodeDialog::findNodeIdPositionMap(void) const
{
    QMap&lt;SessionNodeID, RR3Vector&gt; nodeIDMap;

    for (int i=0;i&lt;this-&gt;nodeIDs.size();i++)
    {
        nodeIDMap.insert(SessionNodeID(this-&gt;modelID,this-&gt;nodeIDs[i]),this-&gt;positionWidgets[i]-&gt;getPosition());
    }

    return nodeIDMap;
}

</t>
<t tx="leo.20201108101526.68">void MoveNodeDialog::onPositionChanged(const RR3Vector &amp;)
{
    this-&gt;okButton-&gt;setEnabled(true);
    Session::getInstance().setBeginDrawMoveNodes(this-&gt;findNodeIdPositionMap());
}
</t>
<t tx="leo.20201108101526.69">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   new_model_dialog.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   31-st August 2012                                        *
 *                                                                   *
 *  DESCRIPTION: New model dialog class definition                   *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "model.h"
#include "new_model_dialog.h"
#include "model_io.h"
#include "job_manager.h"

NewModelDialog::NewModelDialog(QWidget *parent) :
    QDialog(parent)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Create a new model"));
    this-&gt;resize(300,-1);

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *labelName = new QLabel(tr("Name:"));
    mainLayout-&gt;addWidget(labelName, 0, 0, 1, 1);

    this-&gt;editName = new QLineEdit;
    this-&gt;editName-&gt;setPlaceholderText(tr("New model name"));
    mainLayout-&gt;addWidget(this-&gt;editName, 0, 1, 1, 1);

    QLabel *labelDesc = new QLabel(tr("Description:"));
    mainLayout-&gt;addWidget(labelDesc, 1, 0, 1, 1);

    this-&gt;editDesc = new QLineEdit;
    this-&gt;editDesc-&gt;setPlaceholderText(tr("New model description"));
    mainLayout-&gt;addWidget(this-&gt;editDesc, 1, 1, 1, 1);

    QSpacerItem *spacer = new QSpacerItem(-1,-1,QSizePolicy::Expanding,QSizePolicy::Expanding);
    mainLayout-&gt;addItem(spacer, 2, 0, 1, 2);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, 3, 0, 1, 2);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;NewModelDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;NewModelDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.7">class ModelRecordsTreeRecordID
{
    public:
        ModelRecordsTreeRecordID(uint modelID,bool isRecord,uint recordNumber)
            : modelID(modelID)
            , isRecord(isRecord)
            , recordNumber(recordNumber)
        {
        }
        @others
};

ModelRecordsTree::ModelRecordsTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setColumnCount(ModelRecordsTree::NColumns);
    this-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;setRootIsDecorated(false);
    this-&gt;setAutoScroll(false);
    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(ModelRecordsTree::RecordNumber,QString(tr("Record")));
    headerItem-&gt;setText(ModelRecordsTree::RecordFileName,QString(tr("File name")));
    headerItem-&gt;setIcon(ModelRecordsTree::Marked,QIcon(":/icons/media/pixmaps/range-play_play.svg"));
    this-&gt;setHeaderItem(headerItem);

    this-&gt;setColumnHidden(ModelRecordsTree::ModelID,true);
    this-&gt;setColumnHidden(ModelRecordsTree::IsRecord,true);
    this-&gt;setColumnHidden(ModelRecordsTree::PathFileName,true);

    this-&gt;populate();

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelSelectionChanged,
                     this,
                     &amp;ModelRecordsTree::onModelSelectionChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelAdded,
                     this,
                     &amp;ModelRecordsTree::onModelChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelChanged,
                     this,
                     &amp;ModelRecordsTree::onModelChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelRemoved,
                     this,
                     &amp;ModelRecordsTree::onModelChanged);
    QObject::connect(this,
                     &amp;ModelRecordsTree::itemChanged,
                     this,
                     &amp;ModelRecordsTree::onItemChanged);
    QObject::connect(this,
                     &amp;ModelRecordsTree::itemActivated,
                     this,
                     &amp;ModelRecordsTree::onItemActivated);

    QTimer *timer = new QTimer(this);
    QObject::connect(timer,
                     &amp;QTimer::timeout,
                     this,
                     &amp;ModelRecordsTree::populate);
    timer-&gt;start(1000);
}

</t>
<t tx="leo.20201108101526.70">int NewModelDialog::exec(void)
{
    int retVal = this-&gt;QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        Model *pNewModel = new Model;
        pNewModel-&gt;setName(this-&gt;getName());
        pNewModel-&gt;setDescription(this-&gt;getDescription());

        JobManager::getInstance().submit(new ModelIO(MODEL_IO_ADD, QString(), pNewModel));
    }
    return retVal;
}

QString NewModelDialog::getName(void) const
{
    return this-&gt;editName-&gt;text().isEmpty() ? tr("New model") : this-&gt;editName-&gt;text();
}

QString NewModelDialog::getDescription(void) const
{
    return this-&gt;editDesc-&gt;text().isEmpty() ? tr("New model") : this-&gt;editDesc-&gt;text();
}
</t>
<t tx="leo.20201108101526.71">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   pick_details_tree.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th June 2013                                          *
 *                                                                   *
 *  DESCRIPTION: Pick details tree class definition                  *
 *********************************************************************/

#include &lt;QHBoxLayout&gt;

#include "pick_details_tree.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.72">typedef enum _PickDetailsTreeColumn
{
    PICK_DETAILS_TREE_COLUMN_1 = 0,
    PICK_DETAILS_TREE_COLUMN_2,
    PICK_DETAILS_TREE_COLUMN_3,
    PICK_DETAILS_TREE_COLUMN_4,
    PICK_DETAILS_TREE_COLUMN_5,
    PICK_DETAILS_TREE_N_COLUMNS
} PickDetailsTreeColumn;

PickDetailsTree::PickDetailsTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setColumnCount(PICK_DETAILS_TREE_N_COLUMNS);
    this-&gt;setHeaderHidden(true);

    this-&gt;populate();

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::pickListChanged,
                     this,
                     &amp;PickDetailsTree::onPickListChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelAdded,
                     this,
                     &amp;PickDetailsTree::onPickListChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelRemoved,
                     this,
                     &amp;PickDetailsTree::onPickListChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelChanged,
                     this,
                     &amp;PickDetailsTree::onPickListChanged);
    QObject::connect(this,
                     &amp;PickDetailsTree::itemExpanded,
                     this,
                     &amp;PickDetailsTree::onItemExpanded);
}

</t>
<t tx="leo.20201108101526.73">void PickDetailsTree::populate(void)
{
    this-&gt;clear();

    const QVector&lt;PickItem&gt; &amp;rPickItems = Session::getInstance().getPickList().getItems();

    for (int i=0;i&lt;rPickItems.size();i++)
    {
        QTreeWidgetItem *topItem = new QTreeWidgetItem(this);
        QString itemText;

        const Model &amp;rModel = Session::getInstance().getModel(rPickItems[i].getEntityID().getMid());

        const SessionEntityID &amp;rEntityID = rPickItems[i].getEntityID();
        uint elementID = rPickItems[i].getElementID();
        uint nodeID = rPickItems[i].getNodeID();

        switch (rPickItems[i].getItemType())
        {
            case PICK_ITEM_ELEMENT:
            {
                QTreeWidgetItem *childItem = nullptr;

                // Type
                childItem = new QTreeWidgetItem(topItem);
                childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_1,tr("Family:"));
                childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_2,REntityGroup::getTypeName(rEntityID.getType()));

                // Nodes
                if (REntityGroup::typeIsElementGroup(rEntityID.getType()))
                {
                    itemText = tr("Element") + " # " + QString::number(elementID);
                    const RElement &amp;rElement = rModel.getElement(elementID);
                    for (uint j=0;j&lt;rElement.size();j++)
                    {
                        const RNode &amp;rNode = rModel.getNode(rElement.getNodeId(j));

                        childItem = new QTreeWidgetItem(topItem);
                        childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_1,tr("Node ") + QString::number(j+1) + ":");
                        childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_2,QString::number(rNode.getX()));
                        childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_3,QString::number(rNode.getY()));
                        childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_4,QString::number(rNode.getZ()));
                        childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_5,"[m]");
                    }

                    std::vector&lt;RElement&gt; edgeElements = rElement.generateEdgeElements();

                    for (uint j=0;j&lt;edgeElements.size();j++)
                    {
                        double edgeLength = 0.0;

                        if (edgeElements[j].findLength(rModel.getNodes(),edgeLength))
                        {
                            childItem = new QTreeWidgetItem(topItem);
                            childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_1,tr("Edge ") + QString::number(edgeElements[j].getNodeId(0)) + "-" + QString::number(edgeElements[j].getNodeId(1)) + ":");
                            childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_2,QString::number(edgeLength));
                            childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_5,"[m]");
                        }
                    }
                }
                else
                {
                    itemText = tr("Interpolated element") + " # " + QString::number(rPickItems[i].getElementPosition());
                    const RInterpolatedElement *pIElement = nullptr;
                    switch (rEntityID.getType())
                    {
                        case R_ENTITY_GROUP_CUT:
                            pIElement = &amp;rModel.getCut(rEntityID.getEid()).at(rPickItems[i].getElementPosition());
                            break;
                        case R_ENTITY_GROUP_ISO:
                            pIElement = &amp;rModel.getIso(rEntityID.getEid()).at(rPickItems[i].getElementPosition());
                            break;
                        default:
                            break;
                    }
                    if (!pIElement)
                    {
                        continue;
                    }
                    for (uint j=0;j&lt;pIElement-&gt;size();j++)
                    {
                        const RInterpolatedNode &amp;rINode = pIElement-&gt;at(j);

                        childItem = new QTreeWidgetItem(topItem);
                        childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_1,tr("Node ") + QString::number(j+1) + ":");
                        childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_2,QString::number(rINode.getX()));
                        childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_3,QString::number(rINode.getY()));
                        childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_4,QString::number(rINode.getZ()));
                        childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_5,"[m]");
                    }
                }

                break;
            }
            case PICK_ITEM_NODE:
            {
                QTreeWidgetItem *childItem = nullptr;

                if (REntityGroup::typeIsElementGroup(rEntityID.getType()))
                {
                    itemText = tr("Node") + " # " + QString::number(nodeID);

                    const RNode &amp;rNode = rModel.getNode(nodeID);

                    childItem = new QTreeWidgetItem(topItem);
                    childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_1,tr("Coordinates") + ":");
                    childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_2,QString::number(rNode.getX()));
                    childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_3,QString::number(rNode.getY()));
                    childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_4,QString::number(rNode.getZ()));
                    childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_5,"[m]");
                }
                else if (REntityGroup::typeIsInterpolatedElementGroup(rEntityID.getType()))
                {
                    itemText = tr("Interpolated node") + " # " + QString::number(rPickItems[i].getElementPosition()) + " / " + QString::number(rPickItems[i].getNodePosition());
                }

                // Type
                childItem = new QTreeWidgetItem(topItem);
                childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_1,tr("Family") + ":");
                childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_5,REntityGroup::getTypeName(rEntityID.getType()));

                break;
            }
            case PICK_ITEM_HOLE_ELEMENT:
            {
                itemText = tr("Edge") + " # " + QString::number(rPickItems[i].getElementPosition());
                break;
            }
            default:
            {
                continue;
            }
        }

        QMap&lt;RVariableType, PickValue&gt; resultsValues = rModel.getPickedResultsValues(rPickItems[i]);
        if (resultsValues.size() &gt; 0)
        {
            QTreeWidgetItem *childItem = new QTreeWidgetItem(topItem);
            childItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_1,"Computed results");
            childItem-&gt;setFirstColumnSpanned(true);

            QMap&lt;RVariableType, PickValue&gt;::iterator iter;

            for (iter = resultsValues.begin(); iter != resultsValues.end(); ++iter)
            {
                RVariableType variableType = RVariableType(iter.key());
                RRVector values(iter.value().getValues());

                QTreeWidgetItem *variableItem = new QTreeWidgetItem(childItem);
                variableItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_1,RVariable::getName(variableType));

                if (values.size() == 1)
                {
                    variableItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_2,QString::number(values[0]));
                    variableItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_5,"[" +RVariable::getUnits(variableType) + "]");
                }
                else if (values.size() == 2)
                {
                    variableItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_2,QString::number(values[0]));
                    variableItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_3,QString::number(values[1]));
                    variableItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_5,"[" + RVariable::getUnits(variableType) + "]");
                }
                else if (values.size() == 3)
                {
                    variableItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_2,QString::number(values[0]));
                    variableItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_3,QString::number(values[1]));
                    variableItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_4,QString::number(values[2]));
                    variableItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_5,"[" + RVariable::getUnits(variableType) + "]");
                }
            }
        }

        topItem-&gt;setText(PICK_DETAILS_TREE_COLUMN_1,itemText);
        topItem-&gt;setFirstColumnSpanned(true);
        topItem-&gt;setExpanded(true);
    }

    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        this-&gt;topLevelItem(i)-&gt;setForeground(PICK_DETAILS_TREE_COLUMN_1,this-&gt;palette().brush(QPalette::Active,QPalette::Text));
        QFont font(this-&gt;topLevelItem(i)-&gt;font(PICK_DETAILS_TREE_COLUMN_1));
        font.setBold(true);
        this-&gt;topLevelItem(i)-&gt;setFont(PICK_DETAILS_TREE_COLUMN_1,font);

        for (int j=0;j&lt;this-&gt;topLevelItem(i)-&gt;childCount();j++)
        {
            this-&gt;topLevelItem(i)-&gt;child(j)-&gt;setForeground(PICK_DETAILS_TREE_COLUMN_1,this-&gt;palette().brush(QPalette::Active,QPalette::Text));
            QFont font(this-&gt;topLevelItem(i)-&gt;child(j)-&gt;font(PICK_DETAILS_TREE_COLUMN_1));
            font.setBold(true);
            this-&gt;topLevelItem(i)-&gt;child(j)-&gt;setFont(PICK_DETAILS_TREE_COLUMN_1,font);
        }
    }

    this-&gt;resizeColumnsToContent();
}

</t>
<t tx="leo.20201108101526.74">void PickDetailsTree::onPickListChanged(void)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101526.75">void PickDetailsTree::onItemExpanded(QTreeWidgetItem *)
{
    this-&gt;resizeColumnsToContent();
}

</t>
<t tx="leo.20201108101526.76">void PickDetailsTree::resizeColumnsToContent(void)
{
    this-&gt;resizeColumnToContents(PICK_DETAILS_TREE_COLUMN_5);
    this-&gt;resizeColumnToContents(PICK_DETAILS_TREE_COLUMN_4);
    this-&gt;resizeColumnToContents(PICK_DETAILS_TREE_COLUMN_3);
    this-&gt;resizeColumnToContents(PICK_DETAILS_TREE_COLUMN_2);
    this-&gt;resizeColumnToContents(PICK_DETAILS_TREE_COLUMN_1);
}
</t>
<t tx="leo.20201108101526.77">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   pick_item.cpp                                            *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   31-st October 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Pick item class definition                          *
 *********************************************************************/

#include "pick_item.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.78">void PickItem::_init(const PickItem *pPickItem)
{
    if (pPickItem)
    {
        this-&gt;entityID = pPickItem-&gt;entityID;
        this-&gt;elementID = pPickItem-&gt;elementID;
        this-&gt;elementPosition = pPickItem-&gt;elementPosition;
        this-&gt;nodeID = pPickItem-&gt;nodeID;
        this-&gt;nodePosition = pPickItem-&gt;nodePosition;
    }
}

PickItem::PickItem()
    : entityID(SessionEntityID())
    , elementID(RConstants::eod)
    , elementPosition(RConstants::eod)
    , nodeID(RConstants::eod)
    , nodePosition(RConstants::eod)
{
    this-&gt;_init();
}

PickItem::PickItem(const SessionEntityID &amp;entityID, uint elementID, uint elementPosition, uint nodeID, uint nodePosition)
    : entityID(entityID)
    , elementID(elementID)
    , elementPosition(elementPosition)
    , nodeID(nodeID)
    , nodePosition(nodePosition)
{
    this-&gt;_init();
}

PickItem::PickItem(const PickItem &amp;pickItem)
{
    this-&gt;_init(&amp;pickItem);
}

PickItem::~PickItem()
{
}

PickItem &amp;PickItem::operator =(const PickItem &amp;pickItem)
{
    this-&gt;_init(&amp;pickItem);
    return (*this);
}

</t>
<t tx="leo.20201108101526.79">const SessionEntityID &amp;PickItem::getEntityID(void) const
{
    return this-&gt;entityID;
}

uint PickItem::getElementID(void) const
{
    return this-&gt;elementID;
}

uint PickItem::getElementPosition(void) const
{
    return this-&gt;elementPosition;
}

uint PickItem::getNodeID(void) const
{
    return this-&gt;nodeID;
}

uint PickItem::getNodePosition(void) const
{
    return this-&gt;nodePosition;
}

PickItemType PickItem::getItemType(void) const
{
    if (this-&gt;entityID.getType() != R_ENTITY_GROUP_NONE)
    {
        if (this-&gt;elementPosition != RConstants::eod &amp;&amp; this-&gt;elementID != RConstants::eod)
        {
            if (this-&gt;nodePosition != RConstants::eod &amp;&amp; this-&gt;nodeID != RConstants::eod)
            {
                return PICK_ITEM_NODE;
            }
            return PICK_ITEM_ELEMENT;
        }
    }
    else
    {
        if (this-&gt;elementPosition != RConstants::eod &amp;&amp; this-&gt;elementID != RConstants::eod)
        {
            return PICK_ITEM_HOLE_ELEMENT;
        }
    }
    return PICK_ITEM_NONE;
}

</t>
<t tx="leo.20201108101526.8">    bool operator &lt; (const ModelRecordsTreeRecordID &amp;rModelRecordsTreeRecordID) const
    {
        if (this-&gt;modelID &lt; rModelRecordsTreeRecordID.modelID)
        {
            return true;
        }
        if (this-&gt;isRecord &lt; rModelRecordsTreeRecordID.isRecord)
        {
            return true;
        }
        if (this-&gt;recordNumber &lt; rModelRecordsTreeRecordID.recordNumber)
        {
            return true;
        }
        return false;
    }

public:
    uint modelID;
    bool isRecord;
    uint recordNumber;
</t>
<t tx="leo.20201108101526.80">bool PickItem::operator ==(const PickItem &amp;pickItem)
{
    return (this-&gt;entityID == pickItem.entityID &amp;&amp;
            this-&gt;elementPosition == pickItem.elementPosition &amp;&amp;
            this-&gt;elementID == pickItem.elementID &amp;&amp;
            this-&gt;nodePosition == pickItem.nodePosition &amp;&amp;
            this-&gt;nodeID == pickItem.nodeID);
}
</t>
<t tx="leo.20201108101526.81">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   pick_list.cpp                                            *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   31-st October 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Pick list class definition                          *
 *********************************************************************/

#include &lt;QMap&gt;

#include "pick_list.h"

PickList::PickList(QObject *parent)
    : QObject(parent)
    , multipleSelection(true)
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.82">bool PickList::getMultipleSelection() const
{
    return this-&gt;multipleSelection;
}

</t>
<t tx="leo.20201108101526.83">void PickList::setMultipleSelection(bool multipleSelection)
{
    this-&gt;multipleSelection = multipleSelection;
}

</t>
<t tx="leo.20201108101526.84">const QVector&lt;PickItem&gt; &amp;PickList::getItems(void) const
{
    return this-&gt;items;
}

QVector&lt;PickItem&gt; PickList::getItems(uint modelID) const
{
    QVector&lt;PickItem&gt; modelItems;
    QVector&lt;PickItem&gt;::const_iterator iter = this-&gt;items.begin();

    while (iter != this-&gt;items.end())
    {
        const PickItem *pPickItem = iter;
        if (pPickItem-&gt;getEntityID().getMid() == modelID)
        {
            modelItems.append(*iter);
        }
        ++iter;
    }

    return modelItems;
}

uint PickList::getNItems(PickItemType type, uint modelID) const
{
    uint nItems = 0;
    QVector&lt;PickItem&gt;::const_iterator iter = this-&gt;items.begin();

    while (iter != this-&gt;items.end())
    {
        const PickItem *pPickItem = iter;
        if (pPickItem-&gt;getItemType() == type)
        {
            if (modelID == RConstants::eod || modelID == pPickItem-&gt;getEntityID().getMid())
            {
                nItems++;
            }
        }
        ++iter;
    }
    return nItems;
}

</t>
<t tx="leo.20201108101526.85">bool PickList::isEmpty(void) const
{
    return this-&gt;items.isEmpty();
}

</t>
<t tx="leo.20201108101526.86">bool PickList::isEmpty(uint modelID, REntityGroupType elementGroupType) const
{
    QVector&lt;PickItem&gt;::const_iterator iter = this-&gt;items.begin();

    while (iter != this-&gt;items.end())
    {
        const PickItem *pPickItem = iter;
        if (pPickItem-&gt;getEntityID().getMid() == modelID)
        {
            if (elementGroupType == R_ENTITY_GROUP_NONE || pPickItem-&gt;getEntityID().getType() == elementGroupType)
            {
                return false;
            }
        }
        ++iter;
    }
    return true;
}

QList&lt;uint&gt; PickList::getModelIDs(void) const
{
    QList&lt;uint&gt; modelIDs;
    QVector&lt;PickItem&gt;::const_iterator iter;
    QMap&lt;uint,uint&gt; modelIDcnt;
    uint modelID;

    iter = this-&gt;items.begin();
    while (iter != this-&gt;items.end())
    {
        const PickItem *pPickItem = iter;
        modelID = pPickItem-&gt;getEntityID().getMid();
        modelIDcnt[modelID]++;
        if (modelIDcnt[modelID] == 1)
        {
            modelIDs.append(modelID);
        }
        ++iter;
    }

    return modelIDs;
}

</t>
<t tx="leo.20201108101526.87">bool PickList::registerItem(const PickItem &amp;pickItem)
{
    QVector&lt;PickItem&gt;::iterator iter = this-&gt;items.begin();

    bool itemErased = false;

    while (iter != this-&gt;items.end())
    {
        PickItem *pPickItem = iter;
        if ((*pPickItem) == pickItem)
        {
            this-&gt;items.erase(iter);
            itemErased = true;
        }
        else
        {
            ++iter;
        }
    }

    if (!this-&gt;multipleSelection)
    {
        iter = this-&gt;items.begin();
        while (iter != this-&gt;items.end())
        {
            PickItem *pPickItem = iter;
            if (pPickItem-&gt;getEntityID().getMid() == pickItem.getEntityID().getMid())
            {
                iter = this-&gt;items.erase(iter);
            }
            else
            {
                ++iter;
            }
        }
    }

    if (!itemErased)
    {
        this-&gt;items.append(pickItem);
    }

    emit this-&gt;pickListChanged();

    return (!itemErased);
}

</t>
<t tx="leo.20201108101526.88">void PickList::addItem(const PickItem &amp;pickItem)
{
    QVector&lt;PickItem&gt;::iterator iter = this-&gt;items.begin();

    while (iter != this-&gt;items.end())
    {
        PickItem *pPickItem = iter;
        if ((*pPickItem) == pickItem)
        {
            return;
        }
        else
        {
            ++iter;
        }
    }

    if (!this-&gt;multipleSelection)
    {
        iter = this-&gt;items.begin();
        while (iter != this-&gt;items.end())
        {
            PickItem *pPickItem = iter;
            if (pPickItem-&gt;getEntityID().getMid() == pickItem.getEntityID().getMid())
            {
                iter = this-&gt;items.erase(iter);
            }
            else
            {
                ++iter;
            }
        }
    }

    this-&gt;items.append(pickItem);

    emit this-&gt;pickListChanged();
}

</t>
<t tx="leo.20201108101526.89">void PickList::removeItem(const PickItem &amp;pickItem)
{
    QVector&lt;PickItem&gt;::iterator iter = this-&gt;items.begin();

    while (iter != this-&gt;items.end())
    {
        PickItem *pPickItem = iter;
        if ((*pPickItem) == pickItem)
        {
            this-&gt;items.erase(iter);
        }
        else
        {
            ++iter;
        }
    }

    emit this-&gt;pickListChanged();
}

</t>
<t tx="leo.20201108101526.9">bool ModelRecordsTree::isFirst(void)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        uint modelID = modelIDs[i];

        QTreeWidgetItemIterator it(this);
        while (*it)
        {
            if ((*it)-&gt;data(ModelRecordsTree::IsRecord,Qt::UserRole).toBool() &amp;&amp;
                (*it)-&gt;data(ModelRecordsTree::ModelID,Qt::UserRole).toUInt() == modelID)
            {
                if ((*it)-&gt;data(ModelRecordsTree::Marked,Qt::UserRole).toBool())
                {
                    return true;
                }
                break;
            }
            ++it;
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101526.90">void PickList::removeItems(uint modelID)
{
    QVector&lt;PickItem&gt;::iterator iter = this-&gt;items.begin();

    while (iter != this-&gt;items.end())
    {
        PickItem *pPickItem = iter;
        if (pPickItem-&gt;getEntityID().getMid() == modelID)
        {
            this-&gt;items.erase(iter);
        }
        else
        {
            ++iter;
        }
    }

    emit this-&gt;pickListChanged();
}

</t>
<t tx="leo.20201108101526.91">bool PickList::hasItem(const PickItem &amp;pickItem)
{
    QVector&lt;PickItem&gt;::iterator iter = this-&gt;items.begin();

    while (iter != this-&gt;items.end())
    {
        PickItem *pPickItem = iter;
        if ((*pPickItem) == pickItem)
        {
            return true;
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101526.92">void PickList::clear(void)
{
    this-&gt;items.clear();

    emit this-&gt;pickListChanged();
}
</t>
<t tx="leo.20201108101526.93">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   pick_value.cpp                                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th April 2016                                         *
 *                                                                   *
 *  DESCRIPTION: Pick value class definition                         *
 *********************************************************************/

#include "pick_value.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101526.94">void PickValue::_init(const PickValue *pPickValue)
{
    if (pPickValue)
    {
        this-&gt;position = pPickValue-&gt;position;
        this-&gt;values = pPickValue-&gt;values;
    }
}

PickValue::PickValue()
{
    this-&gt;_init();
}

PickValue::PickValue(const RR3Vector &amp;position, const RRVector &amp;values)
    : position(position)
    , values(values)
{
    this-&gt;_init();
}

PickValue::PickValue(const PickValue &amp;pickValue)
{
    this-&gt;_init(&amp;pickValue);
}

PickValue::~PickValue()
{

}

PickValue &amp;PickValue::operator =(const PickValue &amp;pickValue)
{
    this-&gt;_init(&amp;pickValue);
    return (*this);
}

</t>
<t tx="leo.20201108101526.95">const RR3Vector &amp;PickValue::getPosition(void) const
{
    return this-&gt;position;
}

</t>
<t tx="leo.20201108101526.96">void PickValue::setPosition(const RR3Vector &amp;position)
{
    this-&gt;position = position;
}

</t>
<t tx="leo.20201108101526.97">const RRVector &amp;PickValue::getValues(void) const
{
    return this-&gt;values;
}

</t>
<t tx="leo.20201108101526.98">void PickValue::setValues(const RRVector &amp;values)
{
    this-&gt;values = values;
}
</t>
<t tx="leo.20201108101526.99">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   point_inside_surface_dialog.cpp                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   27-th March 2015                                         *
 *                                                                   *
 *  DESCRIPTION: Check if point is inside surface dialog class       *
 *               definition                                          *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;

#include "point_inside_surface_dialog.h"
#include "model_action.h"
#include "job_manager.h"
#include "session.h"

PointInsideSurfaceDialog::PointInsideSurfaceDialog(uint modelID, const QList&lt;SessionEntityID&gt; &amp;entityIDs, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityIDs(entityIDs)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Union"));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    this-&gt;position = new PositionWidget(tr("Point position"),RR3Vector(0.0,0.0,0.0));
    this-&gt;position-&gt;hideButtons();
    this-&gt;position-&gt;hideSliders();
    mainLayout-&gt;addWidget(this-&gt;position);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;QDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;QDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.1">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   position_widget.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   30-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Position widget class definition                    *
 *********************************************************************/

#include &lt;cmath&gt;
#include &lt;float.h&gt;

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;

#include "position_widget.h"
#include "session.h"

#define MINIMUM_VALUE (-DBL_MAX*0.1)
#define MAXIMUM_VALUE (DBL_MAX*0.1)

PositionWidget::PositionWidget(const QString &amp;title, const RR3Vector &amp;position, bool horizontalLayout, QWidget *parent)
    : QGroupBox(title, parent)
    , horizontalLayout(horizontalLayout)
    , showButtonBox(true)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QGridLayout *layout = new QGridLayout;
    this-&gt;setLayout(layout);

    QLabel *xLabel = new QLabel("X:");

    this-&gt;xSlider = new QSlider(Qt::Horizontal);

    this-&gt;xLineEdit = new ValueLineEdit(MINIMUM_VALUE,MAXIMUM_VALUE);

    QLabel *xUnitsLabel = new QLabel("[m]");

    QLabel *yLabel = new QLabel("Y:");

    this-&gt;ySlider = new QSlider(Qt::Horizontal);

    this-&gt;yLineEdit = new ValueLineEdit(MINIMUM_VALUE,MAXIMUM_VALUE);

    QLabel *yUnitsLabel = new QLabel("[m]");

    QLabel *zLabel = new QLabel("Z:");

    this-&gt;zSlider = new QSlider(Qt::Horizontal);

    this-&gt;zLineEdit = new ValueLineEdit(MINIMUM_VALUE,MAXIMUM_VALUE);

    QLabel *zUnitsLabel = new QLabel("[m]");

    this-&gt;setPosition(position);

    this-&gt;pickButton = new QPushButton(tr("Set from picked element/node"));
    this-&gt;pickButton-&gt;setDisabled(Session::getInstance().getPickList().isEmpty());

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);

    this-&gt;cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(this-&gt;cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setDisabled(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    if (horizontalLayout)
    {
        layout-&gt;addWidget(this-&gt;xLineEdit, 0, 0, 1, 1);
        layout-&gt;addWidget(this-&gt;yLineEdit, 0, 1, 1, 1);
        layout-&gt;addWidget(this-&gt;zLineEdit, 0, 2, 1, 1);
        layout-&gt;addWidget(this-&gt;pickButton, 0, 3, 1, 1);
        layout-&gt;addWidget(new QWidget,1,0,1,4);
        layout-&gt;setRowStretch(1,1);
        this-&gt;pickButton-&gt;setText(tr("Use picked"));
    }
    else
    {
        layout-&gt;addWidget(xLabel, 0, 0, 1, 1);
        layout-&gt;addWidget(this-&gt;xSlider, 0, 1, 1, 1);
        layout-&gt;addWidget(this-&gt;xLineEdit, 0, 2, 1, 1);
        layout-&gt;addWidget(xUnitsLabel, 0, 3, 1, 1);
        layout-&gt;addWidget(yLabel, 1, 0, 1, 1);
        layout-&gt;addWidget(this-&gt;ySlider, 1, 1, 1, 1);
        layout-&gt;addWidget(this-&gt;yLineEdit, 1, 2, 1, 1);
        layout-&gt;addWidget(yUnitsLabel, 1, 3, 1, 1);
        layout-&gt;addWidget(zLabel, 2, 0, 1, 1);
        layout-&gt;addWidget(this-&gt;zSlider, 2, 1, 1, 1);
        layout-&gt;addWidget(this-&gt;zLineEdit, 2, 2, 1, 1);
        layout-&gt;addWidget(zUnitsLabel, 2, 3, 1, 1);
        layout-&gt;addWidget(this-&gt;pickButton, 3, 0, 1, 4);
        layout-&gt;addLayout(buttonsLayout,4,0,1,4);

        layout-&gt;addWidget(new QWidget,5,0,1,4);
        layout-&gt;setRowStretch(5,1);
    }

    this-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Maximum);

    QObject::connect(this-&gt;xSlider,
                     &amp;QSlider::valueChanged,
                     this,
                     &amp;PositionWidget::onXSliderValueChanged);
    QObject::connect(this-&gt;ySlider,
                     &amp;QSlider::valueChanged,
                     this,
                     &amp;PositionWidget::onYSliderValueChanged);
    QObject::connect(this-&gt;zSlider,
                     &amp;QSlider::valueChanged,
                     this,
                     &amp;PositionWidget::onZSliderValueChanged);

    QObject::connect(this-&gt;xLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;PositionWidget::onXLineEditValueChanged);
    QObject::connect(this-&gt;yLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;PositionWidget::onYLineEditValueChanged);
    QObject::connect(this-&gt;zLineEdit,
                     &amp;ValueLineEdit::valueChanged,
                     this,
                     &amp;PositionWidget::onZLineEditValueChanged);

    QObject::connect(this-&gt;pickButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;PositionWidget::onPickButtonClicked);

    QObject::connect(this-&gt;cancelButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;PositionWidget::onCancelButtonClicked);
    QObject::connect(this-&gt;okButton,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;PositionWidget::onOkButtonClicked);

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::pickListChanged,
                     this,
                     &amp;PositionWidget::onPickListChanged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.10">void PositionWidget::setZRange(double zMin, double zMax)
{
    this-&gt;zLineEdit-&gt;setRange(zMin,zMax);
    this-&gt;setPosition(this-&gt;getPosition());
}

RR3Vector PositionWidget::getPosition() const
{
    RR3Vector position;

    position[0] = this-&gt;xLineEdit-&gt;getValue();
    position[1] = this-&gt;yLineEdit-&gt;getValue();
    position[2] = this-&gt;zLineEdit-&gt;getValue();

    return position;
}

</t>
<t tx="leo.20201108101527.11">void PositionWidget::setPosition(const RR3Vector &amp;position)
{
    this-&gt;setSlidersPosition(position);

    this-&gt;xLineEdit-&gt;blockSignals(true);
    this-&gt;xLineEdit-&gt;setValue(position[0]);
    this-&gt;xLineEdit-&gt;blockSignals(false);

    this-&gt;yLineEdit-&gt;blockSignals(true);
    this-&gt;yLineEdit-&gt;setValue(position[1]);
    this-&gt;yLineEdit-&gt;blockSignals(false);

    this-&gt;zLineEdit-&gt;blockSignals(true);
    this-&gt;zLineEdit-&gt;setValue(position[2]);
    this-&gt;zLineEdit-&gt;blockSignals(false);

    if (!this-&gt;showButtonBox)
    {
        emit this-&gt;changed(position);
    }
}

</t>
<t tx="leo.20201108101527.12">void PositionWidget::setSlidersPosition(const RR3Vector &amp;position)
{
    int xnsp = 0;
    int ynsp = 0;
    int znsp = 0;

    this-&gt;findSliderPositions(position,xnsp,ynsp,znsp);

    this-&gt;xSlider-&gt;blockSignals(true);
    this-&gt;xSlider-&gt;setValue(xnsp);
    this-&gt;xSlider-&gt;blockSignals(false);

    this-&gt;ySlider-&gt;blockSignals(true);
    this-&gt;ySlider-&gt;setValue(ynsp);
    this-&gt;ySlider-&gt;blockSignals(false);

    this-&gt;zSlider-&gt;blockSignals(true);
    this-&gt;zSlider-&gt;setValue(znsp);
    this-&gt;zSlider-&gt;blockSignals(false);

    if (this-&gt;horizontalLayout)
    {
        emit this-&gt;changed(position);
    }
}

</t>
<t tx="leo.20201108101527.13">void PositionWidget::findSliderPositions(const RR3Vector &amp;position, int &amp;x, int &amp;y, int &amp;z)
{
    int xMin = this-&gt;xSlider-&gt;minimum();
    int xMax = this-&gt;xSlider-&gt;maximum();
    int yMin = this-&gt;ySlider-&gt;minimum();
    int yMax = this-&gt;ySlider-&gt;maximum();
    int zMin = this-&gt;zSlider-&gt;minimum();
    int zMax = this-&gt;zSlider-&gt;maximum();

    double vxMin = this-&gt;xLineEdit-&gt;getMinimum();
    double vxMax = this-&gt;xLineEdit-&gt;getMaximum();
    double vyMin = this-&gt;yLineEdit-&gt;getMinimum();
    double vyMax = this-&gt;yLineEdit-&gt;getMaximum();
    double vzMin = this-&gt;zLineEdit-&gt;getMinimum();
    double vzMax = this-&gt;zLineEdit-&gt;getMaximum();

    double xRate = (position[0] - vxMin) / (vxMax - vxMin);
    double yRate = (position[1] - vyMin) / (vyMax - vyMin);
    double zRate = (position[2] - vzMin) / (vzMax - vzMin);

    x = qRound(xRate * double(xMax - xMin) + double(xMin));
    y = qRound(yRate * double(yMax - yMin) + double(yMin));
    z = qRound(zRate * double(zMax - zMin) + double(zMin));
}

</t>
<t tx="leo.20201108101527.14">void PositionWidget::onXSliderValueChanged(int value)
{
    int min = this-&gt;xSlider-&gt;minimum();
    int max = this-&gt;xSlider-&gt;maximum();
    double vMin = this-&gt;xLineEdit-&gt;getMinimum();
    double vMax = this-&gt;xLineEdit-&gt;getMaximum();

    double rate = double(value - min) / double(max - min);

    this-&gt;xLineEdit-&gt;blockSignals(true);
    this-&gt;xLineEdit-&gt;setValue(rate*(vMax-vMin)+vMin);
    this-&gt;xLineEdit-&gt;blockSignals(false);

    if (!this-&gt;showButtonBox)
    {
        emit this-&gt;changed(this-&gt;getPosition());
    }
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101527.15">void PositionWidget::onYSliderValueChanged(int value)
{
    int min = this-&gt;ySlider-&gt;minimum();
    int max = this-&gt;ySlider-&gt;maximum();
    double vMin = this-&gt;yLineEdit-&gt;getMinimum();
    double vMax = this-&gt;yLineEdit-&gt;getMaximum();

    double rate = double(value - min) / double(max - min);

    this-&gt;yLineEdit-&gt;blockSignals(true);
    this-&gt;yLineEdit-&gt;setValue(rate*(vMax-vMin)+vMin);
    this-&gt;yLineEdit-&gt;blockSignals(false);

    if (!this-&gt;showButtonBox)
    {
        emit this-&gt;changed(this-&gt;getPosition());
    }
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101527.16">void PositionWidget::onZSliderValueChanged(int value)
{
    int min = this-&gt;zSlider-&gt;minimum();
    int max = this-&gt;zSlider-&gt;maximum();
    double vMin = this-&gt;zLineEdit-&gt;getMinimum();
    double vMax = this-&gt;zLineEdit-&gt;getMaximum();

    double rate = double(value - min) / double(max - min);

    this-&gt;zLineEdit-&gt;blockSignals(true);
    this-&gt;zLineEdit-&gt;setValue(rate*(vMax-vMin)+vMin);
    this-&gt;zLineEdit-&gt;blockSignals(false);

    if (!this-&gt;showButtonBox)
    {
        emit this-&gt;changed(this-&gt;getPosition());
    }
    this-&gt;okButton-&gt;setEnabled(true);
}

</t>
<t tx="leo.20201108101527.17">void PositionWidget::onXLineEditValueChanged(double)
{
    this-&gt;setSlidersPosition(this-&gt;getPosition());
    this-&gt;okButton-&gt;setEnabled(true);
    emit this-&gt;changed(this-&gt;getPosition());
}

</t>
<t tx="leo.20201108101527.18">void PositionWidget::onYLineEditValueChanged(double)
{
    this-&gt;setSlidersPosition(this-&gt;getPosition());
    this-&gt;okButton-&gt;setEnabled(true);
    emit this-&gt;changed(this-&gt;getPosition());
}

</t>
<t tx="leo.20201108101527.19">void PositionWidget::onZLineEditValueChanged(double)
{
    this-&gt;setSlidersPosition(this-&gt;getPosition());
    this-&gt;okButton-&gt;setEnabled(true);
    emit this-&gt;changed(this-&gt;getPosition());
}

</t>
<t tx="leo.20201108101527.2">void PositionWidget::showSliders()
{
    this-&gt;xSlider-&gt;show();
    this-&gt;ySlider-&gt;show();
    this-&gt;zSlider-&gt;show();
}

</t>
<t tx="leo.20201108101527.20">void PositionWidget::onPickButtonClicked()
{
    const PickList &amp;pickList = Session::getInstance().getPickList();

    const QVector&lt;PickItem&gt; &amp;pickItems = pickList.getItems();

    for (int i=0;i&lt;pickItems.size();i++)
    {
        const SessionEntityID &amp;pickEntityID = pickItems[i].getEntityID();

        if (pickItems[i].getItemType() == PICK_ITEM_NODE)
        {
            this-&gt;setPosition(Session::getInstance().getModel(pickEntityID.getMid()).getNode(pickItems[i].getNodeID()).toVector());
            this-&gt;okButton-&gt;setEnabled(true);

            return;
        }
        else if (pickItems[i].getItemType() == PICK_ITEM_ELEMENT)
        {
            double cx, cy, cz;
            const Model &amp;rModel = Session::getInstance().getModel(pickEntityID.getMid());
            rModel.getElement(pickItems[i].getElementID()).findCenter(rModel.getNodes(),cx,cy,cz);
            this-&gt;setPosition(RR3Vector(cx, cy, cz));
            this-&gt;okButton-&gt;setEnabled(true);

            return;
        }
    }
}

</t>
<t tx="leo.20201108101527.21">void PositionWidget::onOkButtonClicked()
{
    emit this-&gt;changed(this-&gt;getPosition());
    emit this-&gt;closed();
}

</t>
<t tx="leo.20201108101527.22">void PositionWidget::onCancelButtonClicked()
{
    emit this-&gt;closed();
}

</t>
<t tx="leo.20201108101527.23">void PositionWidget::onPickListChanged()
{
    this-&gt;pickButton-&gt;setDisabled(Session::getInstance().getPickList().isEmpty());
}
</t>
<t tx="leo.20201108101527.24">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   problem_selector_dialog.cpp                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th February 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Problem selector dialog class definition            *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "problem_selector_dialog.h"
#include "session.h"

ProblemSelectorDialog::ProblemSelectorDialog(QWidget *parent) :
    QDialog(parent)
{
    this-&gt;setWindowTitle(QString("Problem type selector"));

    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    int mainLayoutRow = 0;

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *messageLabel = new QLabel("Select problem types");
    mainLayout-&gt;addWidget(messageLabel, mainLayoutRow++, 0);

    this-&gt;problemTree = new ProblemSelectorTree(this);
    this-&gt;problemTree-&gt;setSizeAdjustPolicy(QAbstractScrollArea::AdjustToContents);
    this-&gt;problemTree-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::MinimumExpanding);
    mainLayout-&gt;addWidget(this-&gt;problemTree, mainLayoutRow++, 0);

    QObject::connect(this-&gt;problemTree,&amp;ProblemSelectorTree::changed,this,&amp;ProblemSelectorDialog::onProblemTreeChanged);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRow++, 0, 1, 1);

    this-&gt;cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(this-&gt;cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setDisabled(true);
    this-&gt;okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(this-&gt;cancelButton,&amp;QPushButton::clicked,this,&amp;ProblemSelectorDialog::reject);
    QObject::connect(this-&gt;okButton,&amp;QPushButton::clicked,this,&amp;ProblemSelectorDialog::accept);
}

RProblemTypeMask ProblemSelectorDialog::exec(void)
{
    if (QDialog::exec() == QDialog::Accepted)
    {
        return this-&gt;problemTree-&gt;findProblemTypeMask();
    }

    return R_PROBLEM_NONE;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.25">void ProblemSelectorDialog::onProblemTreeChanged(void)
{
    this-&gt;okButton-&gt;setEnabled(this-&gt;problemTree-&gt;checkProblemIsChecked());
}
</t>
<t tx="leo.20201108101527.26">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   problem_selector_tree.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th November 2015                                       *
 *                                                                   *
 *  DESCRIPTION: Problem selector tree class definition              *
 *********************************************************************/

#include &lt;QMessageBox&gt;

#include "session.h"
#include "problem_selector_tree.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.27">typedef enum _ProblemSelectorTreeColumn
{
    PROBLEM_TREE_COLUMN_NAME = 0,
    PROBLEM_TREE_COLUMN_DESC,
    PROBLEM_TREE_N_COLUMNS
} ProblemSelectorTreeColumn;

ProblemSelectorTree::ProblemSelectorTree(QWidget *parent)
    : QTreeWidget(parent)
{
    this-&gt;setRootIsDecorated(false);
    this-&gt;setSelectionMode(QAbstractItemView::NoSelection);

    this-&gt;setColumnCount(PROBLEM_TREE_N_COLUMNS);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(PROBLEM_TREE_COLUMN_NAME,QString("Name"));
    headerItem-&gt;setText(PROBLEM_TREE_COLUMN_DESC,QString("Description"));
    this-&gt;setHeaderItem(headerItem);

    this-&gt;resizeColumnToContents(PROBLEM_TREE_COLUMN_NAME);

    std::vector&lt;RProblemType&gt; prbList(RProblem::getTypes(R_PROBLEM_ALL));

    for (uint i=0;i&lt;prbList.size();i++)
    {
        QTreeWidgetItem *itemModel = new QTreeWidgetItem(this);
        itemModel-&gt;setText(PROBLEM_TREE_COLUMN_NAME, RProblem::getName(prbList[i]));
        itemModel-&gt;setData(PROBLEM_TREE_COLUMN_NAME,Qt::CheckStateRole,QVariant(Qt::Unchecked));
        itemModel-&gt;setData(PROBLEM_TREE_COLUMN_NAME,Qt::UserRole,QVariant(prbList[i]));
        itemModel-&gt;setText(PROBLEM_TREE_COLUMN_DESC, RProblem::getDesc(prbList[i]));

        QFont font = itemModel-&gt;font(PROBLEM_TREE_COLUMN_NAME);
        font.setBold(true);
        itemModel-&gt;setFont(PROBLEM_TREE_COLUMN_NAME,font);
    }
    for (int i=0;i&lt;PROBLEM_TREE_N_COLUMNS;i++)
    {
        this-&gt;resizeColumnToContents(i);
    }

    QObject::connect(this,&amp;QTreeWidget::itemChanged,this,&amp;ProblemSelectorTree::onTreeWidgetItemChanged);
}

RProblemTypeMask ProblemSelectorTree::findProblemTypeMask(void)
{
    RProblemTypeMask prbTypeMask = R_PROBLEM_NONE;
    int nItems = this-&gt;topLevelItemCount();
    for (int j=0;j&lt;nItems;j++)
    {
        QTreeWidgetItem *item = this-&gt;topLevelItem(j);
        Qt::CheckState checkState = item-&gt;checkState(PROBLEM_TREE_COLUMN_NAME);
        if (checkState == Qt::Checked)
        {
            prbTypeMask |= RProblemType(item-&gt;data(PROBLEM_TREE_COLUMN_NAME,Qt::UserRole).toInt());
        }
    }
    return prbTypeMask;
}

</t>
<t tx="leo.20201108101527.28">bool ProblemSelectorTree::checkProblemIsChecked(void) const
{
    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        QTreeWidgetItem *topItem = this-&gt;topLevelItem(i);
        Qt::CheckState checkState = topItem-&gt;checkState(PROBLEM_TREE_COLUMN_NAME);
        if (checkState == Qt::Checked || checkState == Qt::PartiallyChecked)
        {
            return true;
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101527.29">void ProblemSelectorTree::checkCheckedTreeWidgetItem(QTreeWidgetItem *item)
{
    RProblemType problemType = RProblemType(item-&gt;data(PROBLEM_TREE_COLUMN_NAME,Qt::UserRole).toInt());

    RProblemTypeMask excludedProblemTypeMask = RProblem::getExcludedProblemTypeMask(problemType);
    RProblemTypeMask requiredProblemTypeMask = RProblem::getRequiredProblemTypeMask(problemType);

    QList&lt;RProblemType&gt; excludedProblemTypes;

    int nItems = this-&gt;topLevelItemCount();

    for (int i=0;i&lt;nItems;i++)
    {
        QTreeWidgetItem *topItem = this-&gt;topLevelItem(i);
        Qt::CheckState checkState = topItem-&gt;checkState(PROBLEM_TREE_COLUMN_NAME);
        if (checkState == Qt::Checked || checkState == Qt::PartiallyChecked)
        {
            RProblemType selectedProblemType = RProblemType(topItem-&gt;data(PROBLEM_TREE_COLUMN_NAME,Qt::UserRole).toInt());
            if (selectedProblemType &amp; excludedProblemTypeMask)
            {
                excludedProblemTypes.append(selectedProblemType);
            }
        }
        else
        {
            RProblemType unselectedProblemType = RProblemType(topItem-&gt;data(PROBLEM_TREE_COLUMN_NAME,Qt::UserRole).toInt());
            if (unselectedProblemType &amp; requiredProblemTypeMask)
            {
                this-&gt;blockSignals(true);
                topItem-&gt;setCheckState(PROBLEM_TREE_COLUMN_NAME,Qt::Checked);
                this-&gt;blockSignals(false);
            }
        }
    }

    if (excludedProblemTypes.size() &gt; 0)
    {
        QString message;

        message += "Problem type &lt;b&gt;" + RProblem::getName(problemType) + "&lt;/b&gt; is incompatible with following selected problem types:";
        for (int i=0;i&lt;excludedProblemTypes.size();i++)
        {
            message += "&lt;br/&gt;- &lt;b&gt;" + RProblem::getName(excludedProblemTypes[i]) + "&lt;/b&gt;";
        }

        QMessageBox::warning(this,tr("Incompatible problems selected"),message);
        this-&gt;blockSignals(true);
        item-&gt;setCheckState(PROBLEM_TREE_COLUMN_NAME,Qt::Unchecked);
        this-&gt;blockSignals(false);

        return;
    }
}

</t>
<t tx="leo.20201108101527.3">void PositionWidget::hideSliders()
{
    this-&gt;xSlider-&gt;hide();
    this-&gt;ySlider-&gt;hide();
    this-&gt;zSlider-&gt;hide();
}

</t>
<t tx="leo.20201108101527.30">void ProblemSelectorTree::checkUncheckedTreeWidgetItem(QTreeWidgetItem *item)
{
    RProblemType problemType = RProblemType(item-&gt;data(PROBLEM_TREE_COLUMN_NAME,Qt::UserRole).toInt());

    for (int i=0;i&lt;this-&gt;topLevelItemCount();i++)
    {
        QTreeWidgetItem *topItem = this-&gt;topLevelItem(i);
        Qt::CheckState checkState = topItem-&gt;checkState(PROBLEM_TREE_COLUMN_NAME);
        if (checkState == Qt::Checked || checkState == Qt::PartiallyChecked)
        {
            RProblemType selectedProblemType = RProblemType(topItem-&gt;data(PROBLEM_TREE_COLUMN_NAME,Qt::UserRole).toInt());
            RProblemTypeMask requiredProblemTypeMask = RProblem::getRequiredProblemTypeMask(selectedProblemType);

            if (problemType &amp; requiredProblemTypeMask)
            {
                topItem-&gt;setCheckState(PROBLEM_TREE_COLUMN_NAME,Qt::Unchecked);
            }
        }
    }
}

</t>
<t tx="leo.20201108101527.31">void ProblemSelectorTree::onTreeWidgetItemChanged(QTreeWidgetItem *item)
{
    if (item-&gt;checkState(PROBLEM_TREE_COLUMN_NAME) == Qt::Unchecked)
    {
        this-&gt;checkUncheckedTreeWidgetItem(item);
    }
    else
    {
        this-&gt;checkCheckedTreeWidgetItem(item);
    }

    emit this-&gt;changed();
}

</t>
<t tx="leo.20201108101527.32">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   problem_task_dialog.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th November 2015                                       *
 *                                                                   *
 *  DESCRIPTION: Problem task dialog class definition                *
 *********************************************************************/

#include &lt;QHBoxLayout&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "session.h"
#include "problem_task_dialog.h"

ProblemTaskDialog::ProblemTaskDialog(uint modelID, QWidget *parent)
    : QDialog(parent)
    , modelID(modelID)
{
    Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    this-&gt;setWindowTitle(QString("Problem task flow"));
    this-&gt;resize(600,300);

    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *messageLabel = new QLabel;
    messageLabel-&gt;setText(tr("Problem task flow for model:") + " &lt;b&gt;" + rModel.getName() + "&lt;/b&gt;");
    mainLayout-&gt;addWidget(messageLabel);

    this-&gt;taskTree = new ProblemTaskTree(rModel.getProblemTaskTree(),this);
    mainLayout-&gt;addWidget(this-&gt;taskTree);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    this-&gt;cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    this-&gt;cancelButton-&gt;setDisabled(rModel.getProblemTaskTree().getProblemTypeMask() == R_PROBLEM_NONE);
    buttonsLayout-&gt;addWidget(this-&gt;cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setDisabled(true);
    this-&gt;okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(this-&gt;taskTree,&amp;ProblemTaskTree::changed,this,&amp;ProblemTaskDialog::onProblemTaskTreeChanged);
    QObject::connect(this-&gt;cancelButton,&amp;QPushButton::clicked,this,&amp;ProblemTaskDialog::reject);
    QObject::connect(this-&gt;okButton,&amp;QPushButton::clicked,this,&amp;ProblemTaskDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.33">int ProblemTaskDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        Session::getInstance().getModel(this-&gt;modelID).setProblemTaskTree(this-&gt;taskTree-&gt;getProblemTaskTree());

        RLogger::info("Problem task flow have changed for model \'%s\'\n", Session::getInstance().getModel(this-&gt;modelID).getName().toUtf8().constData());

        Session::getInstance().setProblemSelectionChanged(this-&gt;modelID);
    }
    return retVal;
}

</t>
<t tx="leo.20201108101527.34">void ProblemTaskDialog::closeEvent(QCloseEvent *e)
{
    if (Session::getInstance().getModel(this-&gt;modelID).getProblemTaskTree().getProblemTypeMask() == R_PROBLEM_NONE)
    {
        e-&gt;ignore();
    }
    else
    {
        QDialog::closeEvent(e);
    }
}

</t>
<t tx="leo.20201108101527.35">void ProblemTaskDialog::keyPressEvent(QKeyEvent *e)
{
    // Ignore ESC key.
    if (e-&gt;key() == Qt::Key_Escape &amp;&amp; (Session::getInstance().getModel(this-&gt;modelID).getProblemTaskTree().getProblemTypeMask() == R_PROBLEM_NONE))
    {
        e-&gt;ignore();
    }
    else
    {
        QDialog::keyPressEvent(e);
    }
}

</t>
<t tx="leo.20201108101527.36">void ProblemTaskDialog::onProblemTaskTreeChanged(void)
{
    RProblemTaskItem problemTaskTree = this-&gt;taskTree-&gt;getProblemTaskTree();
    this-&gt;okButton-&gt;setEnabled(problemTaskTree.getNChildren() &gt; 0);
}

</t>
<t tx="leo.20201108101527.37">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   problem_task_tree.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th November 2015                                       *
 *                                                                   *
 *  DESCRIPTION: Problem task tree class definition                  *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QVBoxLayout&gt;

#include "problem_selector_dialog.h"
#include "problem_task_tree.h"

ProblemTaskTree::ProblemTaskTree(const RProblemTaskItem &amp;rTaskTree, QWidget *parent)
    : QWidget(parent)
{
    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout(mainLayout);

    this-&gt;treeWidget = new QTreeWidget;
    mainLayout-&gt;addWidget(this-&gt;treeWidget,0,0,1,1);

    this-&gt;treeWidget-&gt;setRootIsDecorated(true);
    this-&gt;treeWidget-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;treeWidget-&gt;setColumnCount(ProblemTaskTree::N_COLUMNS);
    this-&gt;treeWidget-&gt;setHeaderHidden(true);

    this-&gt;addTaskItemToWidget(0,rTaskTree);

    this-&gt;treeWidget-&gt;expandAll();

    this-&gt;treeWidget-&gt;resizeColumnToContents(ProblemTaskTree::NAME);
    this-&gt;treeWidget-&gt;resizeColumnToContents(ProblemTaskTree::VALUE);

    QObject::connect(this-&gt;treeWidget,&amp;QTreeWidget::itemSelectionChanged,
                     this,&amp;ProblemTaskTree::onItemSelectionChanged);

    QObject::connect(this-&gt;treeWidget,&amp;QTreeWidget::itemChanged,
                     this,&amp;ProblemTaskTree::onItemChanged);

    QObject::connect(this-&gt;treeWidget,&amp;QTreeWidget::itemDoubleClicked,
                     this,&amp;ProblemTaskTree::onItemDoubleClicked);

    QVBoxLayout *buttonsLayout = new QVBoxLayout;
    mainLayout-&gt;addLayout(buttonsLayout,0,1,1,1);

    this-&gt;upButton = new QPushButton(tr("Up"));
    this-&gt;upButton-&gt;setDisabled(true);
    buttonsLayout-&gt;addWidget(this-&gt;upButton);

    QObject::connect(this-&gt;upButton,&amp;QPushButton::clicked,this,&amp;ProblemTaskTree::onUpButtonClicked);

    this-&gt;downButton = new QPushButton(tr("Down"));
    this-&gt;downButton-&gt;setDisabled(true);
    buttonsLayout-&gt;addWidget(this-&gt;downButton);

    QObject::connect(this-&gt;downButton,&amp;QPushButton::clicked,this,&amp;ProblemTaskTree::onDownButtonClicked);

    this-&gt;indentButton = new QPushButton("&gt;");
    this-&gt;indentButton-&gt;setDisabled(true);
    buttonsLayout-&gt;addWidget(this-&gt;indentButton);

    QObject::connect(this-&gt;indentButton,&amp;QPushButton::clicked,this,&amp;ProblemTaskTree::onIndentButtonClicked);

    this-&gt;unindentButton = new QPushButton("&lt;");
    this-&gt;unindentButton-&gt;setDisabled(true);
    buttonsLayout-&gt;addWidget(this-&gt;unindentButton);

    QObject::connect(this-&gt;unindentButton,&amp;QPushButton::clicked,this,&amp;ProblemTaskTree::onUnindentButtonClicked);

    this-&gt;deleteButton = new QPushButton("Remove");
    this-&gt;deleteButton-&gt;setDisabled(true);
    buttonsLayout-&gt;addWidget(this-&gt;deleteButton);

    QObject::connect(this-&gt;deleteButton,&amp;QPushButton::clicked,this,&amp;ProblemTaskTree::onDeleteButtonClicked);

    QPushButton *addProblem = new QPushButton(tr("Add problem type"));
    mainLayout-&gt;addWidget(addProblem,1,0,1,2);

    QObject::connect(addProblem,&amp;QPushButton::clicked,this,&amp;ProblemTaskTree::onAddProblemButtonClicked);
}

RProblemTaskItem ProblemTaskTree::getProblemTaskTree(void) const
{
    RProblemTaskItem taskTree;

    ProblemTaskTree::addWidgetItemToTree(taskTree,this-&gt;treeWidget-&gt;topLevelItem(0));

    return taskTree.getChild(0);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.38">void ProblemTaskTree::addTaskItemToWidget(QTreeWidgetItem *parent, const RProblemTaskItem &amp;taskItem)
{
    QTreeWidgetItem *item;
    if (parent)
    {
        item = new QTreeWidgetItem(parent);
    }
    else
    {
        item = new QTreeWidgetItem(this-&gt;treeWidget);
    }

    item-&gt;setData(ProblemTaskTree::NAME,Qt::UserRole,QVariant(taskItem.getProblemType()));
    item-&gt;setData(ProblemTaskTree::VALUE,Qt::UserRole,QVariant(taskItem.getNIterations()));

    if (taskItem.getProblemType() == R_PROBLEM_NONE)
    {
        item-&gt;setText(ProblemTaskTree::NAME,"# of iterations:");
        item-&gt;setText(ProblemTaskTree::VALUE,QString::number(taskItem.getNIterations()));

        for (uint i=0;i&lt;taskItem.getNChildren();i++)
        {
            this-&gt;addTaskItemToWidget(item,taskItem.getChild(i));
        }
    }
    else
    {
        item-&gt;setText(ProblemTaskTree::NAME,RProblem::getName(taskItem.getProblemType()));
        item-&gt;setFirstColumnSpanned(true);
    }
}

</t>
<t tx="leo.20201108101527.39">void ProblemTaskTree::removeItem(QTreeWidgetItem *item)
{
    QTreeWidgetItem *parentItem = item-&gt;parent();

    delete parentItem-&gt;takeChild(parentItem-&gt;indexOfChild(item));

    if (parentItem-&gt;childCount() == 0 &amp;&amp; parentItem-&gt;parent())
    {
        this-&gt;removeItem(parentItem);
    }
}

</t>
<t tx="leo.20201108101527.4">void PositionWidget::showPickButton()
{
    this-&gt;pickButton-&gt;show();
}

</t>
<t tx="leo.20201108101527.40">void ProblemTaskTree::addWidgetItemToTree(RProblemTaskItem &amp;taskItem, const QTreeWidgetItem *item)
{
    RProblemType problemType = RProblemType(item-&gt;data(ProblemTaskTree::NAME,Qt::UserRole).toInt());
    uint nIterations = item-&gt;data(ProblemTaskTree::VALUE,Qt::UserRole).toUInt();

    RProblemTaskItem newItem(problemType);
    newItem.setNIterations(nIterations);

    if (problemType == R_PROBLEM_NONE)
    {
        for (int i=0;i&lt;item-&gt;childCount();i++)
        {
            ProblemTaskTree::addWidgetItemToTree(newItem,item-&gt;child(i));
        }
    }

    taskItem.addChild(newItem);
}

</t>
<t tx="leo.20201108101527.41">void ProblemTaskTree::onItemSelectionChanged(void)
{
    QList&lt;QTreeWidgetItem*&gt; selectedItems = this-&gt;treeWidget-&gt;selectedItems();

    if (selectedItems.size() != 1)
    {
        this-&gt;upButton-&gt;setDisabled(true);
        this-&gt;downButton-&gt;setDisabled(true);
        this-&gt;indentButton-&gt;setDisabled(true);
        this-&gt;unindentButton-&gt;setDisabled(true);
        this-&gt;deleteButton-&gt;setDisabled(true);
        return;
    }

    bool canGoUp = true;
    bool canGoDown = true;
    bool canIndent = true;
    bool canUnindent = true;
    bool canDelete = true;


    if (selectedItems[0]-&gt;parent())
    {
        if (!selectedItems[0]-&gt;parent()-&gt;parent())
        {
            canUnindent = false;
            if (selectedItems[0]-&gt;parent()-&gt;indexOfChild(selectedItems[0]) == 0)
            {
                canGoUp = false;
            }
            if (selectedItems[0]-&gt;parent()-&gt;indexOfChild(selectedItems[0]) == selectedItems[0]-&gt;parent()-&gt;childCount() - 1)
            {
                canGoDown = false;
            }
        }
        canDelete = true;
    }
    else
    {
        canGoUp = false;
        canGoDown = false;
        canIndent = false;
        canUnindent = false;
        canDelete = false;
    }

    this-&gt;upButton-&gt;setEnabled(canGoUp);
    this-&gt;downButton-&gt;setEnabled(canGoDown);
    this-&gt;indentButton-&gt;setEnabled(canIndent);
    this-&gt;unindentButton-&gt;setEnabled(canUnindent);
    this-&gt;deleteButton-&gt;setEnabled(canDelete);
}

</t>
<t tx="leo.20201108101527.42">void ProblemTaskTree::onItemChanged(QTreeWidgetItem *item, int column)
{
    if (column != ProblemTaskTree::VALUE)
    {
        return;
    }

    bool ok;

    uint nIterations = item-&gt;text(column).toUInt(&amp;ok);

    if (ok &amp;&amp; nIterations &gt; 0)
    {
        item-&gt;setData(ProblemTaskTree::VALUE,Qt::UserRole,nIterations);
        emit this-&gt;changed();
    }
    else
    {
        nIterations = item-&gt;data(ProblemTaskTree::VALUE,Qt::UserRole).toUInt();
        item-&gt;setText(ProblemTaskTree::VALUE,QString::number(nIterations));
    }
}

</t>
<t tx="leo.20201108101527.43">void ProblemTaskTree::onItemDoubleClicked(QTreeWidgetItem *item, int column)
{
    this-&gt;treeWidget-&gt;blockSignals(true);

    bool isEditable = false;

    if (column == ProblemTaskTree::VALUE)
    {
        isEditable = (RProblemType(item-&gt;data(ProblemTaskTree::NAME,Qt::UserRole).toInt()) == R_PROBLEM_NONE);
    }

    if (isEditable)
    {
        item-&gt;setFlags(item-&gt;flags() | Qt::ItemIsEditable);
    }
    else
    {
        if (item-&gt;flags() &amp; Qt::ItemIsEditable)
        {
            item-&gt;setFlags(item-&gt;flags() ^ Qt::ItemIsEditable);
        }
    }
    this-&gt;treeWidget-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101527.44">void ProblemTaskTree::onUpButtonClicked(void)
{
    QList&lt;QTreeWidgetItem*&gt; selectedItems = this-&gt;treeWidget-&gt;selectedItems();

    if (selectedItems.size() != 1)
    {
        return;
    }

    QTreeWidgetItem *item = selectedItems[0];
    QTreeWidgetItem *parent = item-&gt;parent();
    int index = parent-&gt;indexOfChild(item);
    if (index == 0)
    {
        QTreeWidgetItem *topParent = parent-&gt;parent();
        if (!topParent)
        {
            return;
        }
        int parentIndex = topParent-&gt;indexOfChild(parent);
        item = parent-&gt;takeChild(index);
        if (parent-&gt;childCount() == 0)
        {
            delete topParent-&gt;takeChild(parentIndex);
        }
        topParent-&gt;insertChild(parentIndex,item);
    }
    else
    {
        item = parent-&gt;takeChild(index);
        if (parent-&gt;child(index-1)-&gt;childCount() &gt; 0)
        {
            parent-&gt;child(index-1)-&gt;addChild(item);
        }
        else
        {
            parent-&gt;insertChild(index-1,item);
        }
    }

    if (RProblemType(item-&gt;data(ProblemTaskTree::NAME,Qt::UserRole).toInt()) != R_PROBLEM_NONE)
    {
        item-&gt;setFirstColumnSpanned(true);
    }
    if (item-&gt;childCount() &gt; 0)
    {
        item-&gt;setExpanded(true);
    }

    this-&gt;treeWidget-&gt;setCurrentItem(item);
    this-&gt;treeWidget-&gt;resizeColumnToContents(ProblemTaskTree::NAME);
    this-&gt;treeWidget-&gt;resizeColumnToContents(ProblemTaskTree::VALUE);

    emit this-&gt;changed();
}

</t>
<t tx="leo.20201108101527.45">void ProblemTaskTree::onDownButtonClicked(void)
{
    QList&lt;QTreeWidgetItem*&gt; selectedItems = this-&gt;treeWidget-&gt;selectedItems();

    if (selectedItems.size() != 1)
    {
        return;
    }

    QTreeWidgetItem *item = selectedItems[0];
    QTreeWidgetItem *parent = item-&gt;parent();
    int index = parent-&gt;indexOfChild(item);
    if (index == parent-&gt;childCount()-1)
    {
        QTreeWidgetItem *topParent = parent-&gt;parent();
        if (!topParent)
        {
            return;
        }
        int parentIndex = topParent-&gt;indexOfChild(parent);
        item = parent-&gt;takeChild(index);
        topParent-&gt;insertChild(parentIndex+1,item);
        if (parent-&gt;childCount() == 0)
        {
            delete topParent-&gt;takeChild(parentIndex);
        }
    }
    else
    {
        item = parent-&gt;takeChild(index);
        if (parent-&gt;child(index)-&gt;childCount() &gt; 0)
        {
            parent-&gt;child(index)-&gt;insertChild(0,item);
        }
        else
        {
            parent-&gt;insertChild(index+1,item);
        }
    }

    if (RProblemType(item-&gt;data(ProblemTaskTree::NAME,Qt::UserRole).toInt()) != R_PROBLEM_NONE)
    {
        item-&gt;setFirstColumnSpanned(true);
    }
    if (item-&gt;childCount() &gt; 0)
    {
        item-&gt;setExpanded(true);
    }

    this-&gt;treeWidget-&gt;setCurrentItem(item);
    this-&gt;treeWidget-&gt;resizeColumnToContents(ProblemTaskTree::NAME);
    this-&gt;treeWidget-&gt;resizeColumnToContents(ProblemTaskTree::VALUE);

    emit this-&gt;changed();
}

</t>
<t tx="leo.20201108101527.46">void ProblemTaskTree::onIndentButtonClicked(void)
{
    QList&lt;QTreeWidgetItem*&gt; selectedItems = this-&gt;treeWidget-&gt;selectedItems();

    if (selectedItems.size() != 1)
    {
        return;
    }

    QTreeWidgetItem *item = selectedItems[0];
    QTreeWidgetItem *parent = item-&gt;parent();
    int index = parent-&gt;indexOfChild(item);
    item = parent-&gt;takeChild(index);
    QTreeWidgetItem *newItem = new QTreeWidgetItem;

    newItem-&gt;setText(ProblemTaskTree::NAME,"# of iterations:");
    newItem-&gt;setText(ProblemTaskTree::VALUE,QString::number(1));

    newItem-&gt;setData(ProblemTaskTree::NAME,Qt::UserRole,QVariant(R_PROBLEM_NONE));
    newItem-&gt;setData(ProblemTaskTree::VALUE,Qt::UserRole,QVariant(1));

    parent-&gt;insertChild(index,newItem);
    newItem-&gt;addChild(item);

    newItem-&gt;setExpanded(true);

    if (RProblemType(item-&gt;data(ProblemTaskTree::NAME,Qt::UserRole).toInt()) != R_PROBLEM_NONE)
    {
        item-&gt;setFirstColumnSpanned(true);
    }
    if (item-&gt;childCount() &gt; 0)
    {
        item-&gt;setExpanded(true);
    }

    this-&gt;treeWidget-&gt;setCurrentItem(item);
    this-&gt;treeWidget-&gt;resizeColumnToContents(ProblemTaskTree::NAME);
    this-&gt;treeWidget-&gt;resizeColumnToContents(ProblemTaskTree::VALUE);

    emit this-&gt;changed();
}

</t>
<t tx="leo.20201108101527.47">void ProblemTaskTree::onUnindentButtonClicked(void)
{
    QList&lt;QTreeWidgetItem*&gt; selectedItems = this-&gt;treeWidget-&gt;selectedItems();

    if (selectedItems.size() != 1)
    {
        return;
    }

    QTreeWidgetItem *item = selectedItems[0];
    QTreeWidgetItem *parent = item-&gt;parent();
    QTreeWidgetItem *topParent = parent-&gt;parent();
    int index = parent-&gt;indexOfChild(item);
    int parentIndex = topParent-&gt;indexOfChild(parent);
    item = parent-&gt;takeChild(index);
    if (parent-&gt;childCount() == 0)
    {
        delete topParent-&gt;takeChild(parentIndex);
    }
    topParent-&gt;insertChild(parentIndex,item);

    if (RProblemType(item-&gt;data(ProblemTaskTree::NAME,Qt::UserRole).toInt()) != R_PROBLEM_NONE)
    {
        item-&gt;setFirstColumnSpanned(true);
    }
    if (item-&gt;childCount() &gt; 0)
    {
        item-&gt;setExpanded(true);
    }

    this-&gt;treeWidget-&gt;setCurrentItem(item);
    this-&gt;treeWidget-&gt;resizeColumnToContents(ProblemTaskTree::NAME);
    this-&gt;treeWidget-&gt;resizeColumnToContents(ProblemTaskTree::VALUE);

    emit this-&gt;changed();
}

</t>
<t tx="leo.20201108101527.48">void ProblemTaskTree::onDeleteButtonClicked(void)
{
    QList&lt;QTreeWidgetItem*&gt; selectedItems = this-&gt;treeWidget-&gt;selectedItems();

    if (selectedItems.size() != 1)
    {
        return;
    }

    this-&gt;removeItem(selectedItems[0]);

    emit this-&gt;changed();
}

</t>
<t tx="leo.20201108101527.49">void ProblemTaskTree::onAddProblemButtonClicked(void)
{
    ProblemSelectorDialog problemSelectorDialog(this);
    RProblemTypeMask problemTypeMask = problemSelectorDialog.exec();

    QTreeWidgetItem *item = this-&gt;treeWidget-&gt;topLevelItem(this-&gt;treeWidget-&gt;topLevelItemCount()-1);

    std::vector&lt;RProblemType&gt; problemTypes = RProblem::getTypes(problemTypeMask);
    RProblem::sortTypesByDependency(problemTypes);
    for (uint i=0;i&lt;problemTypes.size();i++)
    {
        RProblemTaskItem taskItem(problemTypes[i]);
        this-&gt;addTaskItemToWidget(item,taskItem);
    }
}

</t>
<t tx="leo.20201108101527.5">void PositionWidget::hidePickButton()
{
    this-&gt;pickButton-&gt;hide();
}

</t>
<t tx="leo.20201108101527.50">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   problem_tree.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th July 2014                                           *
 *                                                                   *
 *  DESCRIPTION: Problem tree class definition                       *
 *********************************************************************/

#include "problem_tree.h"
#include "session.h"
#include "mesh_setup_widget.h"
#include "modal_setup_widget.h"
#include "radiation_setup_widget.h"
#include "time_solver_setup_widget.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.51">typedef enum _ProblemTreeColumn
{
    PROBLEM_TREE_COLUMN_1 = 0,
    PROBLEM_TREE_N_COLUMNS
} ProblemTreeColumn;

ProblemTree::ProblemTree(QWidget *parent) :
    QTreeWidget(parent)
{
    this-&gt;setColumnCount(PROBLEM_TREE_N_COLUMNS);
    this-&gt;setSelectionMode(QAbstractItemView::NoSelection);
    this-&gt;setRootIsDecorated(false);
    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(PROBLEM_TREE_COLUMN_1,QString(tr("Problem setup")));
    this-&gt;setHeaderItem(headerItem);
    this-&gt;setHeaderHidden(true);

    this-&gt;setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);

    this-&gt;populate();

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::problemSelectionChanged,
                     this,
                     &amp;ProblemTree::onProblemChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelChanged,
                     this,
                     &amp;ProblemTree::onModelChanged);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::modelSelectionChanged,
                     this,
                     &amp;ProblemTree::onModelSelectionChanged);


}

</t>
<t tx="leo.20201108101527.52">void ProblemTree::populate(void)
{
    this-&gt;clear();

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    if (modelIDs.size() == 0)
    {
        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setText(PROBLEM_TREE_COLUMN_1,tr("No model is selected!"));
        item-&gt;setForeground(PROBLEM_TREE_COLUMN_1,QColor(Qt::red));
        return;
    }
    else if (modelIDs.size() &gt; 1)
    {
        QTreeWidgetItem *item = new QTreeWidgetItem(this);
        item-&gt;setText(PROBLEM_TREE_COLUMN_1,tr("Multiple models are selected!"));
        item-&gt;setForeground(PROBLEM_TREE_COLUMN_1,QColor(Qt::red));
        return;
    }

    const Model &amp;rModel = Session::getInstance().getModel(modelIDs[0]);

    if (RProblem::getTimeSolverEnabled(rModel.getProblemTaskTree().getProblemTypeMask()))
    {
        QTreeWidgetItem *itemTimeSolver = new QTreeWidgetItem(this);
        TimeSolverSetupWidget *timeSolverWidget = new TimeSolverSetupWidget(rModel.getTimeSolver());
        this-&gt;setItemWidget(itemTimeSolver,PROBLEM_TREE_COLUMN_1,timeSolverWidget);
        QObject::connect(timeSolverWidget,&amp;TimeSolverSetupWidget::changed,this,&amp;ProblemTree::onTimeSolverChanged);
    }

    if (rModel.getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_STRESS_MODAL)
    {
        QTreeWidgetItem *modalSetup = new QTreeWidgetItem(this);
        ModalSetupWidget *modalSetupWidget = new ModalSetupWidget(rModel.getProblemSetup().getModalSetup());
        this-&gt;setItemWidget(modalSetup,PROBLEM_TREE_COLUMN_1,modalSetupWidget);
        QObject::connect(modalSetupWidget,&amp;ModalSetupWidget::changed,this,&amp;ProblemTree::onModalSetupChanged);
    }

    if (rModel.getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_RADIATIVE_HEAT)
    {
        QString vfFileName = rModel.buildDataFileName(RViewFactorMatrix::getDefaultFileExtension(true),rModel.getTimeSolver().getEnabled());

        QTreeWidgetItem *itemRadiationSetup = new QTreeWidgetItem(this);
        RadiationSetupWidget *radiationSetupWidget = new RadiationSetupWidget(rModel.getProblemSetup().getRadiationSetup(),vfFileName);
        this-&gt;setItemWidget(itemRadiationSetup,PROBLEM_TREE_COLUMN_1,radiationSetupWidget);
        QObject::connect(radiationSetupWidget,&amp;RadiationSetupWidget::changed,this,&amp;ProblemTree::onRadiationSetupChanged);
    }

    if (rModel.getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_MESH)
    {
        QTreeWidgetItem *meshSetup = new QTreeWidgetItem(this);
        MeshSetupWidget *meshSetupWidget = new MeshSetupWidget(rModel.getProblemSetup().getMeshSetup(),
                                                               RProblem::getVariableTypes(rModel.getProblemTaskTree().getProblemTypeMask()));
        this-&gt;setItemWidget(meshSetup,PROBLEM_TREE_COLUMN_1,meshSetupWidget);
        QObject::connect(meshSetupWidget,&amp;MeshSetupWidget::changed,this,&amp;ProblemTree::onMeshSetupChanged);
    }
}

</t>
<t tx="leo.20201108101527.53">void ProblemTree::onModelChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101527.54">void ProblemTree::onProblemChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101527.55">void ProblemTree::onModelSelectionChanged(uint)
{
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101527.56">void ProblemTree::onTimeSolverChanged(const RTimeSolver &amp;timeSolver)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().getModel(modelIDs[i]).setTimeSolver(timeSolver);
        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
}

</t>
<t tx="leo.20201108101527.57">void ProblemTree::onModalSetupChanged(const RModalSetup &amp;modalSetup)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().getModel(modelIDs[i]).getProblemSetup().setModalSetup(modalSetup);
        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
}

</t>
<t tx="leo.20201108101527.58">void ProblemTree::onRadiationSetupChanged(const RRadiationSetup &amp;radiationSetup)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().getModel(modelIDs[i]).getProblemSetup().setRadiationSetup(radiationSetup);
        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
}

</t>
<t tx="leo.20201108101527.59">void ProblemTree::onMeshSetupChanged(const RMeshSetup &amp;meshSetup)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().getModel(modelIDs[i]).getProblemSetup().setMeshSetup(meshSetup);
        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
}
</t>
<t tx="leo.20201108101527.6">void PositionWidget::showButtons()
{
    this-&gt;showButtonBox = true;
    this-&gt;cancelButton-&gt;show();
    this-&gt;okButton-&gt;show();
}

</t>
<t tx="leo.20201108101527.60">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   progress.cpp                                             *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-1h January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Progress functions                                  *
 *********************************************************************/

#include &lt;string&gt;
#include &lt;rblib.h&gt;

#include &lt;qmath.h&gt;

#include "progress.h"

static void progressPrintHandler (double fraction);

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.61">static void progressInitializeHandler (const QString &amp;message,
                                       bool           pulseType);

static void progressFinalizeHandler (const QString &amp;message);

void Progress::initialize (void)
{
    RProgress::getInstance().setProgressInitializeHandler(progressInitializeHandler);
    RProgress::getInstance().setProgressFinalizeHandler(progressFinalizeHandler);
    RProgress::getInstance().setProgressPrintHandler(progressPrintHandler);
}

Progress &amp; Progress::getInstance(void)
{
    static Progress progress;
    return progress;
}

</t>
<t tx="leo.20201108101527.62">void Progress::print(double fraction)
{
    emit this-&gt;progress(fraction);
}

</t>
<t tx="leo.20201108101527.63">void Progress::emitProgressInitialize(const QString &amp;message,
                                      bool           pulseType)
{
    emit this-&gt;progressInitialize(message,pulseType);
}

</t>
<t tx="leo.20201108101527.64">void Progress::emitProgressFinalize(const QString &amp;message)
{
    emit this-&gt;progressFinalize(message);
}

</t>
<t tx="leo.20201108101527.65">static void progressPrintHandler (double fraction)
{
    static double lastValue = 0.0;
    if (qAbs(qFloor(fraction*100) - lastValue) &gt;= 1)
    {
        lastValue = qFloor(fraction*100);
        Progress::getInstance().print(fraction);
    }
}

</t>
<t tx="leo.20201108101527.66">static void progressInitializeHandler (const QString &amp;message,
                                       bool           pulseType)
{
    Progress::getInstance().emitProgressInitialize(message,pulseType);
}

</t>
<t tx="leo.20201108101527.67">static void progressFinalizeHandler (const QString &amp;message)
{
    Progress::getInstance().emitProgressFinalize(message);
}
</t>
<t tx="leo.20201108101527.68">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   progress_bar.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   23-1h November 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Progress bar class definition                       *
 *********************************************************************/

#include "progress_bar.h"

ProgressBar::ProgressBar(QWidget *parent)
    : QProgressBar(parent)
    , autoHide(true)
{
    this-&gt;setTextVisible(true);
    this-&gt;pulseTimer = new QTimer(this);
    this-&gt;pulseTimer-&gt;setInterval(100);
    QObject::connect(this-&gt;pulseTimer,&amp;QTimer::timeout,this,&amp;ProgressBar::pulse);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.69">void ProgressBar::startPulse(void)
{
    this-&gt;setRange(0,0);
    this-&gt;QProgressBar::setValue(0);
    this-&gt;pulseTimer-&gt;start();
}

</t>
<t tx="leo.20201108101527.7">void PositionWidget::hideButtons()
{
    this-&gt;showButtonBox = false;
    this-&gt;cancelButton-&gt;hide();
    this-&gt;okButton-&gt;hide();
}

</t>
<t tx="leo.20201108101527.70">void ProgressBar::stopPulse(void)
{
    if (this-&gt;pulseTimer-&gt;isActive())
    {
        this-&gt;pulseTimer-&gt;stop();
    }
}

</t>
<t tx="leo.20201108101527.71">void ProgressBar::setValue(int value)
{
    this-&gt;setFormat(this-&gt;message + " (" + QString::number(value) + " %)");
    this-&gt;QProgressBar::setValue(value);
}

</t>
<t tx="leo.20201108101527.72">void ProgressBar::setMessage(const QString &amp;message)
{
    this-&gt;message = message;
    this-&gt;setFormat(this-&gt;message);
}

</t>
<t tx="leo.20201108101527.73">void ProgressBar::setAutoHide(bool autoHide)
{
    this-&gt;autoHide = autoHide;
    if (this-&gt;autoHide &amp;&amp; this-&gt;value() == 100)
    {
        this-&gt;hide();
    }
    else
    {
        this-&gt;show();
    }
}

</t>
<t tx="leo.20201108101527.74">void ProgressBar::hide(void)
{
    if (this-&gt;autoHide)
    {
        this-&gt;QProgressBar::hide();
    }
}

</t>
<t tx="leo.20201108101527.75">void ProgressBar::pulse(void)
{
    this-&gt;QProgressBar::setValue(this-&gt;value() + 2);
}
</t>
<t tx="leo.20201108101527.76">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   push_button.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   2-nd August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Custom push button class definition                 *
 *********************************************************************/

#include "push_button.h"

PushButton::PushButton(uint id, const QString &amp;text, QWidget *parent) :
    QPushButton(text, parent),
    id(id)
{
    QObject::connect(this,&amp;QPushButton::clicked,this,&amp;PushButton::onClicked);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.77">void PushButton::onClicked(void)
{
    emit this-&gt;clicked(int(this-&gt;id));
}
</t>
<t tx="leo.20201108101527.78">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   quit_dialog.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Quit dialog class definition                        *
 *********************************************************************/

#include &lt;QIcon&gt;
#include &lt;QLabel&gt;
#include &lt;QGridLayout&gt;
#include &lt;QPushButton&gt;

#include "quit_dialog.h"
#include "solver_manager.h"

QuitDialog::QuitDialog (QWidget *parent) : QDialog(parent)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon quitIcon(":/icons/file/pixmaps/range-shutdown.svg");

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    connect (cancelButton, SIGNAL(clicked()), this, SLOT(reject()));

    QPushButton *quitButton = new QPushButton(quitIcon, tr("Quit"));
    quitButton-&gt;setDefault(true);
    connect (quitButton, SIGNAL(clicked()), this, SLOT(accept()));

    QString quitMessage(tr("Are you sure you want to quit?"));
    if (SolverManager::getInstance().getNRunning() &gt; 0)
    {
        quitMessage += "&lt;br/&gt;" + tr("If you quit now solver will continue executing in the background.");
    }

    QLabel *quitLabel = new QLabel(quitMessage);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    buttonsLayout-&gt;addWidget(cancelButton);
    buttonsLayout-&gt;addWidget(quitButton);

    QGridLayout *mainLayout = new QGridLayout;
    mainLayout-&gt;addWidget(quitLabel, 0, 0);
    mainLayout-&gt;addLayout(buttonsLayout, 1, 0, 1, 1);

    this-&gt;setLayout (mainLayout);

    this-&gt;setWindowTitle(tr("Quit?"));

} /* QuitDialog::QuitDialog */

@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.79">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   tradiation_setup_widget.cpp                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   11-th May 2016                                           *
 *                                                                   *
 *  DESCRIPTION: Radiation setup widget class definition             *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QGroupBox&gt;
#include &lt;QLabel&gt;
#include &lt;QComboBox&gt;
#include &lt;QPushButton&gt;
#include &lt;QMessageBox&gt;

#include "session.h"
#include "job_manager.h"
#include "model_action.h"
#include "main_window.h"
#include "radiation_setup_widget.h"

RadiationSetupWidget::RadiationSetupWidget(const RRadiationSetup &amp;radiationSetup, const QString &amp;defaultViewFactorFileName, QWidget *parent)
    : QWidget(parent)
    , radiationSetup(radiationSetup)
    , defaultViewFactorFileName(defaultViewFactorFileName)
{
    RRadiationResolution radiationResolution = this-&gt;radiationSetup.getResolution();

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
    const Model &amp;rModel = Session::getInstance().getModel(modelIDs[0]);

    QString viewFactorFile(this-&gt;radiationSetup.getViewFactorMatrixFile());
    if (viewFactorFile.isEmpty())
    {
        viewFactorFile = rModel.buildDataFileName(RViewFactorMatrix::getDefaultFileExtension(true),rModel.getTimeSolver().getEnabled());
        this-&gt;radiationSetup.setViewFactorMatrixFile(viewFactorFile);
    }

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QGroupBox *radiationGroupBox = new QGroupBox(tr("Radiation setup"));
    mainLayout-&gt;addWidget(radiationGroupBox);

    QGridLayout *radiationLayout = new QGridLayout;
    radiationGroupBox-&gt;setLayout(radiationLayout);

    uint crow = 0;

    QLabel *resolutionLabel = new QLabel(tr("Resolution"));
    resolutionLabel-&gt;setSizePolicy(QSizePolicy(QSizePolicy::Maximum,QSizePolicy::Expanding));
    radiationLayout-&gt;addWidget(resolutionLabel,crow,0,1,1);

    QComboBox *resolutionCombo = new QComboBox;
    resolutionCombo-&gt;setSizePolicy(QSizePolicy(QSizePolicy::Expanding,QSizePolicy::Expanding));
    resolutionCombo-&gt;addItem(RRadiationSetup::getResolutionText(R_RADIATION_RESOLUTION_LOW));
    resolutionCombo-&gt;addItem(RRadiationSetup::getResolutionText(R_RADIATION_RESOLUTION_MEDIUM));
    resolutionCombo-&gt;addItem(RRadiationSetup::getResolutionText(R_RADIATION_RESOLUTION_HIGH));
    if (radiationResolution &lt;= R_RADIATION_RESOLUTION_LOW)
    {
        resolutionCombo-&gt;setCurrentIndex(0);
    }
    else if (radiationResolution &gt;= R_RADIATION_RESOLUTION_HIGH)
    {
        resolutionCombo-&gt;setCurrentIndex(2);
    }
    else
    {
        resolutionCombo-&gt;setCurrentIndex(1);
    }
    radiationLayout-&gt;addWidget(resolutionCombo,crow,1,1,1);
    crow++;

    this-&gt;connect(resolutionCombo,SIGNAL(currentIndexChanged(int)),SLOT(onResolutionChanged(int)));


    QGroupBox *customVfFile = new QGroupBox(tr("Custom view-factor file"));
    customVfFile-&gt;setCheckable(true);
    radiationLayout-&gt;addWidget(customVfFile,crow,0,1,2);
    crow++;

    QObject::connect(customVfFile,&amp;QGroupBox::toggled,this,&amp;RadiationSetupWidget::onCustomViewFactorFileToggled);

    QHBoxLayout *customVfLayout = new QHBoxLayout;
    customVfFile-&gt;setLayout(customVfLayout);

    this-&gt;viewFactorFileButton = new FileChooserButton(
                                                    "View-factor file:",
                                                    FileChooserButton::OpenFile,
                                                    this,
                                                    "Select view-factor file",
                                                    viewFactorFile,
                                                    "View-factor files (*." + RViewFactorMatrix::getDefaultFileExtension(true) + ");;Any files (*)");
    this-&gt;viewFactorFileButton-&gt;setShowLabel(false);
    customVfLayout-&gt;addWidget(this-&gt;viewFactorFileButton);

    QObject::connect(this-&gt;viewFactorFileButton,
                     &amp;FileChooserButton::fileNameChanged,
                     this,
                     &amp;RadiationSetupWidget::onViewFactorFileChanged);

    bool patchesOK = false, viewFactorsOK = false;

    RViewFactorMatrixHeader viewFactorMatrixHeader;

    rModel.generateViewFactorMatrixHeader(viewFactorMatrixHeader);

    if (viewFactorMatrixHeader.getPatchInput() == rModel.getViewFactorMatrix().getHeader().getPatchInput() &amp;&amp;
        viewFactorMatrixHeader.getPatchInput().size() == rModel.getNSurfaces() &amp;&amp;
        viewFactorMatrixHeader.getNElements() == rModel.getNElements())
    {
        patchesOK = true;
        if (viewFactorMatrixHeader.getHemicubeResolution() == rModel.getViewFactorMatrix().getHeader().getHemicubeResolution() &amp;&amp;
            rModel.getViewFactorMatrix().getPatchBook().getNPatches() == rModel.getViewFactorMatrix().size())
        {
            viewFactorsOK = true;
        }
    }

    if (!patchesOK)
    {
        QLabel *patchStatusLabel = new QLabel;
        patchStatusLabel-&gt;setText("&lt;font color=#ff0000&gt;" + tr("Surface patches need to be generated.") + "&lt;/font&gt;");
        radiationLayout-&gt;addWidget(patchStatusLabel,crow++,0,1,2);

        QPushButton *regeneratePatches = new QPushButton(tr("Regenerate patches"));
        radiationLayout-&gt;addWidget(regeneratePatches,crow++,0,1,2);

        QObject::connect(regeneratePatches,
                         &amp;QPushButton::clicked,
                         this,
                         &amp;RadiationSetupWidget::regeneratePatches);
    }

    if (!viewFactorsOK)
    {
        QLabel *viewFactorsStatusLabel = new QLabel;
        viewFactorsStatusLabel-&gt;setText("&lt;font color=#ff0000&gt;" + tr("View-factors need to be calculated.") + "&lt;/font&gt;");
        radiationLayout-&gt;addWidget(viewFactorsStatusLabel,crow++,0,1,2);

        QPushButton *recalculateViewFactors = new QPushButton(tr("Recalculate view-factors"));
        radiationLayout-&gt;addWidget(recalculateViewFactors,crow++,0,1,2);

        QObject::connect(recalculateViewFactors,
                         &amp;QPushButton::clicked,
                         this,
                         &amp;RadiationSetupWidget::recalculateViewFactors);
    }

    QPushButton *clearViewFactorMatrix = new QPushButton(tr("Clear view-factor matrix"));
    radiationLayout-&gt;addWidget(clearViewFactorMatrix,crow++,0,1,2);

    QObject::connect(clearViewFactorMatrix,
                     &amp;QPushButton::clicked,
                     this,
                     &amp;RadiationSetupWidget::clearViewFactorMatrix);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.8">void PositionWidget::setXRange(double xMin, double xMax)
{
    this-&gt;xLineEdit-&gt;setRange(xMin,xMax);
    this-&gt;setPosition(this-&gt;getPosition());
}

</t>
<t tx="leo.20201108101527.80">void RadiationSetupWidget::onResolutionChanged(int index)
{
    RRadiationResolution radiationResolution;
    if (index == 0)
    {
        radiationResolution = R_RADIATION_RESOLUTION_LOW;
    }
    else if (index == 1)
    {
        radiationResolution = R_RADIATION_RESOLUTION_MEDIUM;
    }
    else
    {
        radiationResolution = R_RADIATION_RESOLUTION_HIGH;
    }

    this-&gt;radiationSetup.setResolution(radiationResolution);
    emit this-&gt;changed(this-&gt;radiationSetup);
}

</t>
<t tx="leo.20201108101527.81">void RadiationSetupWidget::onCustomViewFactorFileToggled(bool checked)
{
    if (!checked)
    {
//        this-&gt;viewFactorFileButton-&gt;setFileName(this-&gt;defaultViewFactorFileName);
        this-&gt;radiationSetup.setViewFactorMatrixFile(this-&gt;defaultViewFactorFileName);
        emit this-&gt;changed(this-&gt;radiationSetup);
    }
}

</t>
<t tx="leo.20201108101527.82">void RadiationSetupWidget::onViewFactorFileChanged(const QString &amp;fileName)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Model &amp;rModel = Session::getInstance().getModel(modelIDs[i]);
        rModel.getProblemSetup().getRadiationSetup().setViewFactorMatrixFile(fileName);

        if (rModel.getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_RADIATIVE_HEAT)
        {
            rModel.loadViewFactorMatrix();
        }
        else
        {
            rModel.unloadViewFactorMatrix();
        }

        Session::getInstance().setProblemChanged(modelIDs[i]);
    }
}

</t>
<t tx="leo.20201108101527.83">void RadiationSetupWidget::regeneratePatches(void)
{
    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        ModelActionInput modelActionInput(modelIDs[i]);
        modelActionInput.setGeneratePatches();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101527.84">void RadiationSetupWidget::recalculateViewFactors(void)
{
    if (QMessageBox::question(MainWindow::getInstance(),
                              tr("Calculate view-factors"),
                              tr("Are you sure you want to calculate view-factors?\nThis operation can take long time."),
                              QMessageBox::No,
                              QMessageBox::Yes) == QMessageBox::No)
    {
        return;
    }

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        ModelActionInput modelActionInput(modelIDs[i]);
        modelActionInput.setCalculateViewFactors();

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101527.85">void RadiationSetupWidget::clearViewFactorMatrix(void)
{
    if (QMessageBox::question(MainWindow::getInstance(),
                              tr("Clear view-factor matrix"),
                              tr("Are you sure you want to clear view-factor matrix?\n"
                                 "This operation will clear all generated patches and calculated view-factors."
                                 " It will also delete all view-factor matrix file."),
                              QMessageBox::No,
                              QMessageBox::Yes) == QMessageBox::No)
    {
        return;
    }

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        Session::getInstance().getModel(modelIDs[i]).getViewFactorMatrix().clear();
        try
        {
            const QString &amp;fileName = Session::getInstance().getModel(modelIDs[i]).getProblemSetup().getRadiationSetup().getViewFactorMatrixFile();
            RLogger::info("Removing file \'%s\'\n",fileName.toUtf8().constData());
            RFileManager::remove(fileName);
        }
        catch (const RError &amp;error)
        {
            RLogger::error("Failed to delete view-factor matrix file. %s",error.getMessage().toUtf8().constData());
        }

        Session::getInstance().setModelChanged(modelIDs[i]);
    }
}
</t>
<t tx="leo.20201108101527.86">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   remove_entity_dialog.cpp                                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th December 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Remove entity dialog class definition               *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;
#include &lt;QGroupBox&gt;

#include "remove_entity_dialog.h"
#include "session.h"
#include "model_action.h"
#include "job_manager.h"

RemoveEntityDialog::RemoveEntityDialog(REntityGroupTypeMask entityTypeMask, QWidget *parent) :
    QDialog(parent),
    entityTypeMask(entityTypeMask)
{
    QIcon closeIcon(":/icons/file/pixmaps/range-close.svg");
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QString windowTitleStr = tr("Remove entities");
    this-&gt;setWindowTitle(tr(windowTitleStr.toUtf8().constData()));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    uint nMainLayoutRows = 0;

    QLabel *listLabel = new QLabel(tr("Following entities will be removed:"));
    mainLayout-&gt;addWidget(listLabel, ++nMainLayoutRows, 0, 1, 1);

    QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;modelIDs.size();i++)
    {
        QList&lt;SessionEntityID&gt; selectedEntities = this-&gt;findEntities(modelIDs[i]);

        QList&lt;SessionEntityID&gt; selectedPoints = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_POINT);
        QList&lt;SessionEntityID&gt; selectedLines = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_LINE);
        QList&lt;SessionEntityID&gt; selectedSurfaces = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_SURFACE);
        QList&lt;SessionEntityID&gt; selectedVolumes = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_VOLUME);
        QList&lt;SessionEntityID&gt; selectedCuts = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_CUT);
        QList&lt;SessionEntityID&gt; selectedIsos = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_ISO);
        QList&lt;SessionEntityID&gt; selectedStreamLines = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_STREAM_LINE);
        QList&lt;SessionEntityID&gt; selectedVectorFields = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_VECTOR_FIELD);
        QList&lt;SessionEntityID&gt; selectedScalarFields = SessionEntityID::filterList(selectedEntities,R_ENTITY_GROUP_SCALAR_FIELD);

        Model &amp;rModel = Session::getInstance().getModel(modelIDs[i]);

        QGroupBox *modelGroupBox= new QGroupBox;
        modelGroupBox-&gt;setTitle(rModel.getName());
        mainLayout-&gt;addWidget(modelGroupBox, ++nMainLayoutRows, 0, 1, 1);

        QGridLayout *modelGroupLayout = new QGridLayout;
        modelGroupBox-&gt;setLayout(modelGroupLayout);

        QString text = "&lt;dl&gt;";
        if (selectedPoints.size())
        {
            text += "&lt;dt&gt;" + tr("Points:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedPoints.size();j++)
            {
                text += rModel.getPoint(selectedPoints[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedLines.size())
        {
            text += "&lt;dt&gt;" + tr("Lines:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedLines.size();j++)
            {
                text += rModel.getLine(selectedLines[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedSurfaces.size())
        {
            text += "&lt;dt&gt;" + tr("Surfaces:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedSurfaces.size();j++)
            {
                text += rModel.getSurface(selectedSurfaces[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedVolumes.size())
        {
            text += "&lt;dt&gt;" + tr("Volumes:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedVolumes.size();j++)
            {
                text += rModel.getVolume(selectedVolumes[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedCuts.size())
        {
            text += "&lt;dt&gt;" + tr("Cuts:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedCuts.size();j++)
            {
                text += rModel.getCut(selectedCuts[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedIsos.size())
        {
            text += "&lt;dt&gt;" + tr("ISOs:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedIsos.size();j++)
            {
                text += rModel.getIso(selectedIsos[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedStreamLines.size())
        {
            text += "&lt;dt&gt;" + tr("Stream lines:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedStreamLines.size();j++)
            {
                text += rModel.getStreamLine(selectedStreamLines[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedVectorFields.size())
        {
            text += "&lt;dt&gt;" + tr("Vector fields:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedVectorFields.size();j++)
            {
                text += rModel.getVectorField(selectedVectorFields[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        if (selectedScalarFields.size())
        {
            text += "&lt;dt&gt;" + tr("Scalar fields:");
            text += "&lt;dd&gt;";
            for (int j=0;j&lt;selectedScalarFields.size();j++)
            {
                text += rModel.getScalarField(selectedScalarFields[j].getEid()).getName() + QString(",&amp;nbsp;");
            }
        }
        text += "&lt;/dl&gt;";

        QLabel *modelLabel = new QLabel(text);
        modelGroupLayout-&gt;addWidget(modelLabel,1,0,1,1);
    }

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, ++nMainLayoutRows, 0, 1, 1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;RemoveEntityDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;RemoveEntityDialog::accept);

    this-&gt;layout()-&gt;setSizeConstraint(QLayout::SetFixedSize);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.87">int RemoveEntityDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        QList&lt;uint&gt; modelIDs = Session::getInstance().getSelectedModelIDs();
        for (int i=0;i&lt;modelIDs.size();i++)
        {
            ModelActionInput modelActionInput(modelIDs[i]);
            modelActionInput.setRemoveEntities(this-&gt;findEntities(modelIDs[i]));

            ModelAction *modelAction = new ModelAction;
            modelAction-&gt;setAutoDelete(true);
            modelAction-&gt;addAction(modelActionInput);
            JobManager::getInstance().submit(modelAction);
        }
    }

    return retVal;
}

QList&lt;SessionEntityID&gt; RemoveEntityDialog::findEntities(uint mid) const
{
    QList&lt;SessionEntityID&gt; selectedEntities = Session::getInstance().getSelectedEntityIDs();

    for (int i=selectedEntities.size()-1;i&gt;=0;i--)
    {
        if (selectedEntities[i].getMid() == mid
            &amp;&amp;
            selectedEntities[i].getType() &amp; this-&gt;entityTypeMask)
        {
            continue;
        }
        selectedEntities.erase(selectedEntities.begin()+i);
    }

    return selectedEntities;
}
</t>
<t tx="leo.20201108101527.88">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rename_model_dialog.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   3-rd February 2018                                       *
 *                                                                   *
 *  DESCRIPTION: Rename model dialog class definition                *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "rename_model_dialog.h"
#include "session.h"

RenameModelDialog::RenameModelDialog(uint modelId, QWidget *parent)
    : QDialog(parent)
    , modelId(modelId)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Rename model"));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *labelName = new QLabel(tr("Name:"));
    mainLayout-&gt;addWidget(labelName, 0, 0, 1, 1);

    this-&gt;editName = new QLineEdit(Session::getInstance().getModel(this-&gt;modelId).getName());
    this-&gt;editName-&gt;setPlaceholderText(tr("Model name"));
    mainLayout-&gt;addWidget(this-&gt;editName, 0, 1, 1, 1);

    QLabel *labelDesc = new QLabel(tr("Description:"));
    mainLayout-&gt;addWidget(labelDesc, 1, 0, 1, 1);

    this-&gt;editDesc = new QLineEdit(Session::getInstance().getModel(this-&gt;modelId).getDescription());
    this-&gt;editDesc-&gt;setPlaceholderText(tr("Model description"));
    mainLayout-&gt;addWidget(this-&gt;editDesc, 1, 1, 1, 1);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, 2, 0, 1, 2);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;RenameModelDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;RenameModelDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101527.89">int RenameModelDialog::exec(void)
{
    int retVal = this-&gt;QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        Session::getInstance().getModel(this-&gt;modelId).setName(this-&gt;getName());
        Session::getInstance().getModel(this-&gt;modelId).setDescription(this-&gt;getDescription());
        Session::getInstance().setModelChanged(this-&gt;modelId);
    }
    return retVal;
}

QString RenameModelDialog::getName(void) const
{
    return this-&gt;editName-&gt;text().isEmpty() ? tr("New model") : this-&gt;editName-&gt;text();
}

QString RenameModelDialog::getDescription(void) const
{
    return this-&gt;editDesc-&gt;text().isEmpty() ? tr("New model") : this-&gt;editDesc-&gt;text();
}
</t>
<t tx="leo.20201108101527.9">void PositionWidget::setYRange(double yMin, double yMax)
{
    this-&gt;yLineEdit-&gt;setRange(yMin,yMax);
    this-&gt;setPosition(this-&gt;getPosition());
}

</t>
<t tx="leo.20201108101528.1">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   report_dialog.cpp                                        *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-st August 2013                                        *
 *                                                                   *
 *  DESCRIPTION: Report dialog class definition                      *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QGroupBox&gt;
#include &lt;QLabel&gt;

#include &lt;rblib.h&gt;

#include "session.h"
#include "main_settings.h"
#include "job_manager.h"
#include "report_dialog.h"
#include "report_generator.h"
#include "file_chooser_button.h"

bool ReportDialog::htmlFileEnabled = true;
bool ReportDialog::pdfFileEnabled = true;
bool ReportDialog::odfFileEnabled = true;

ReportDialog::ReportDialog(uint modelID, QWidget *parent)
    : QDialog(parent)
    , modelID(modelID)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Create report"));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    uint rowCount = 0;

    QLabel *titleLabel = new QLabel(tr("Generate report for model") + " &lt;b&gt;" + Session::getInstance().getModel(this-&gt;modelID).getName() + "&lt;/b&gt;");
    mainLayout-&gt;addWidget(titleLabel, rowCount++, 0, 1, 1);

    QGroupBox *fileGroupBox = new QGroupBox(tr("File"));
    mainLayout-&gt;addWidget(fileGroupBox, rowCount++, 0, 1, 1);

    QVBoxLayout *fileLayout = new QVBoxLayout;
    fileGroupBox-&gt;setLayout(fileLayout);

    QString htmlFileName = Session::getInstance().getModel(this-&gt;modelID).buildDocFileName("html");
    QString odfFileName = Session::getInstance().getModel(this-&gt;modelID).buildDocFileName("odf");
    QString pdfFileName = Session::getInstance().getModel(this-&gt;modelID).buildDocFileName("pdf");

    this-&gt;htmlGroupBox = new QGroupBox("HyperText Markup Language (HTML)");
    this-&gt;htmlGroupBox-&gt;setCheckable(true);
    this-&gt;htmlGroupBox-&gt;setChecked(ReportDialog::htmlFileEnabled);
    fileLayout-&gt;addWidget(this-&gt;htmlGroupBox);

    QVBoxLayout *htmlFileLayout = new QVBoxLayout;
    this-&gt;htmlGroupBox-&gt;setLayout(htmlFileLayout);

    this-&gt;htmlFileChooserButton = new FileChooserButton("Report file:",
                                                        FileChooserButton::SaveFile,
                                                        this,
                                                        "Select file",
                                                        htmlFileName,
                                                        "HTML files (*.html *.htm);;Any files (*)");
    htmlFileLayout-&gt;addWidget(this-&gt;htmlFileChooserButton);

    this-&gt;odfGroupBox = new QGroupBox("Portable Document Format (ODF)");
    this-&gt;odfGroupBox-&gt;setCheckable(true);
    this-&gt;odfGroupBox-&gt;setChecked(ReportDialog::odfFileEnabled);
    fileLayout-&gt;addWidget(this-&gt;odfGroupBox);

    QVBoxLayout *odfFileLayout = new QVBoxLayout;
    this-&gt;odfGroupBox-&gt;setLayout(odfFileLayout);

    this-&gt;odfFileChooserButton = new FileChooserButton("Report file:",
                                                       FileChooserButton::SaveFile,
                                                       this,"Select file",
                                                       odfFileName,
                                                       "ODF files (*.odf);;Any files (*)");
    odfFileLayout-&gt;addWidget(this-&gt;odfFileChooserButton);

    this-&gt;pdfGroupBox = new QGroupBox("Portable Document Format (PDF)");
    this-&gt;pdfGroupBox-&gt;setCheckable(true);
    this-&gt;pdfGroupBox-&gt;setChecked(ReportDialog::pdfFileEnabled);
    fileLayout-&gt;addWidget(this-&gt;pdfGroupBox);

    QVBoxLayout *pdfFileLayout = new QVBoxLayout;
    this-&gt;pdfGroupBox-&gt;setLayout(pdfFileLayout);

    this-&gt;pdfFileChooserButton = new FileChooserButton("Report file:",
                                                       FileChooserButton::SaveFile,
                                                       this,
                                                       "Select file",
                                                       pdfFileName,
                                                       "PDF files (*.pdf);;Any files (*)");
    pdfFileLayout-&gt;addWidget(this-&gt;pdfFileChooserButton);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, rowCount++, 0, 1, 1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;ReportDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;ReportDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.10">void ResultsVariableSelector::populate(RVariableType selectedVariableType)
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    this-&gt;blockSignals(true);
    this-&gt;clear();

    uint itemIndex = 0;
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);
        uint nVariables = model.getNVariables();

        for (uint j=0;j&lt;nVariables;j++)
        {
            RVariable &amp;variable = model.getVariable(j);

            QString sizeType;

            if (variable.getNVectors() == 1)
            {
                sizeType = "Scalar";
            }
            else if (variable.getNVectors() &gt; 1)
            {
                sizeType = "Vector [" + QString::number(variable.getNVectors()) + "]";
            }
            else
            {
                sizeType = "Unknown";
            }

            this-&gt;addItem(variable.getName() + " - " + sizeType,QVariant(variable.getType()));

            if (selectedVariableType == variable.getType())
            {
                this-&gt;setCurrentIndex(itemIndex);
            }
            itemIndex++;
        }
    }

    this-&gt;blockSignals(false);

    // Force signal even if current index has not changed.
    emit this-&gt;currentIndexChanged(this-&gt;currentIndex());
}

</t>
<t tx="leo.20201108101528.100">void Session::clear()
{
    RLogger::trace("void Session::clear()\n");
    RLogger::info("Closing session\n");
    this-&gt;fileName.clear();

    while (this-&gt;getNModels() &gt; 0)
    {
        RLogger::indent();
        RLogger::info("Closing model \'%s\'\n",this-&gt;getModel(this-&gt;getNModels()-1).getName().toUtf8().constData());

        Session::getInstance().removeModel(this-&gt;getNModels()-1);

        RLogger::unindent();
    }
}

</t>
<t tx="leo.20201108101528.101">void Session::storeCurentModelVersion(uint modelID, const QString &amp;message)
{
    RLogger::trace("void Session::storeCurentModelVersion(uint modelID, const QString &amp;message)\n");
    this-&gt;getModel(modelID).storeCurentVersion(MainSettings::getInstance().getApplicationSettings()-&gt;getNHistoryRecords(),message);
}

</t>
<t tx="leo.20201108101528.102">bool Session::isUndoAvailable() const
{
    RLogger::trace("bool Session::isUndoAvailable()\n");
    QList&lt;uint&gt; selectedModelIDs = this-&gt;getSelectedModelIDs();
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        if (this-&gt;getModel(selectedModelIDs[i]).getUndoStackSize() &gt; 0)
        {
            return true;
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101528.103">bool Session::isRedoAvailable() const
{
    RLogger::trace("bool Session::isRedoAvailable()\n");
    QList&lt;uint&gt; selectedModelIDs = this-&gt;getSelectedModelIDs();
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        if (this-&gt;getModel(selectedModelIDs[i]).getRedoStackSize() &gt; 0)
        {
            return true;
        }
    }
    return false;
}

QString Session::getUndoTooltip() const
{
    RLogger::trace("QString Session::getUndoTooltip()\n");
    QString undoMessage;

    QList&lt;uint&gt; selectedModelIDs = this-&gt;getSelectedModelIDs();
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        if (!undoMessage.isEmpty())
        {
            undoMessage += "; ";
        }
        undoMessage += this-&gt;getModel(selectedModelIDs[i]).getUndoActionMessage();
    }
    undoMessage = tr("Undo") + (undoMessage.isEmpty() ? QString() : ": " + undoMessage);
    return undoMessage;
}

QString Session::getRedoTooltip() const
{
    RLogger::trace("QString Session::getRedoTooltip()\n");
    QString redoMessage;

    QList&lt;uint&gt; selectedModelIDs = this-&gt;getSelectedModelIDs();
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        if (!redoMessage.isEmpty())
        {
            redoMessage += "; ";
        }
        redoMessage += this-&gt;getModel(selectedModelIDs[i]).getRedoActionMessage();
    }
    redoMessage = tr("Redo") + (redoMessage.isEmpty() ? QString() : ": " + redoMessage);
    return redoMessage;
}

QString Session::getDefaultFileExtension()
{
    RLogger::trace("QString Session::getDefaultFileExtension()\n");
    return "ras";
}

QString Session::getDefaultFileName()
{
    RLogger::trace("QString Session::getDefaultFileName()\n");
    QDir sesionDir = MainSettings::getInstancePtr()-&gt;getSessionDir();
    return sesionDir.filePath(QString("default.") + Session::getDefaultFileExtension());
}

</t>
<t tx="leo.20201108101528.104">bool Session::selectedModelsHasEntities(REntityGroupTypeMask entityTypeMask)
{
    RLogger::trace("bool Session::selectedModelsHasEntities(REntityGroupTypeMask entityTypeMask)\n");

    foreach (uint modelID, Session::getInstance().getSelectedModelIDs())
    {
        if (((entityTypeMask &amp; R_ENTITY_GROUP_POINT) &amp;&amp; Session::getInstance().getModel(modelID).getNPoints())
            ||
            ((entityTypeMask &amp; R_ENTITY_GROUP_LINE) &amp;&amp; Session::getInstance().getModel(modelID).getNLines())
            ||
            ((entityTypeMask &amp; R_ENTITY_GROUP_SURFACE) &amp;&amp; Session::getInstance().getModel(modelID).getNSurfaces())
            ||
            ((entityTypeMask &amp; R_ENTITY_GROUP_VOLUME) &amp;&amp; Session::getInstance().getModel(modelID).getNVolumes())
            ||
            ((entityTypeMask &amp; R_ENTITY_GROUP_CUT) &amp;&amp; Session::getInstance().getModel(modelID).getNCuts())
            ||
            ((entityTypeMask &amp; R_ENTITY_GROUP_ISO) &amp;&amp; Session::getInstance().getModel(modelID).getNIsos())
            ||
            ((entityTypeMask &amp; R_ENTITY_GROUP_STREAM_LINE) &amp;&amp; Session::getInstance().getModel(modelID).getNStreamLines())
            ||
            ((entityTypeMask &amp; R_ENTITY_GROUP_SCALAR_FIELD) &amp;&amp; Session::getInstance().getModel(modelID).getNScalarFields())
            ||
            ((entityTypeMask &amp; R_ENTITY_GROUP_VECTOR_FIELD) &amp;&amp; Session::getInstance().getModel(modelID).getNVectorFields()))
        {
            return true;
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101528.105">bool Session::selectedModelsHasEntitySelected(REntityGroupType entityGroupType)
{
    RLogger::trace("bool Session::selectedModelsHasEntitySelected(REntityGroupType entityGroupType)\n");

    foreach (uint modelID, Session::getInstance().getSelectedModelIDs())
    {
        foreach (SessionEntityID sessionID, Session::getInstance().getModel(modelID).getSelectedEntityIDs(modelID))
        {
            if (sessionID.getType() == entityGroupType)
            {
                return true;
            }
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101528.106">void Session::onPickListChanged()
{
    RLogger::trace("void Session::onPickListChanged()\n");
    emit this-&gt;pickListChanged();
}

</t>
<t tx="leo.20201108101528.107">void Session::onModelAdded(uint modelID)
{
    RLogger::trace("void Session::onModelAdded(uint modelID)\n");
    this-&gt;getModel(modelID).createDependentEntities();
}

</t>
<t tx="leo.20201108101528.108">void Session::onModelChanged(uint modelID)
{
    RLogger::trace("void Session::onModelChanged(uint modelID)\n");
    this-&gt;getModel(modelID).createDependentEntities();
}

</t>
<t tx="leo.20201108101528.109">void Session::onNHistoryRecordsChanged(uint nHistoryRecords)
{
    RLogger::trace("void Session::onNHistoryRecordsChanged(uint nHistoryRecords)\n");
    for (uint i=0;i&lt;this-&gt;getNModels();i++)
    {
        this-&gt;getModel(i).updateHistoryStackSize(nHistoryRecords);
    }
    emit this-&gt;nHistoryRecordsChanged(nHistoryRecords);
}

</t>
<t tx="leo.20201108101528.11">void ResultsVariableSelector::onResultsChanged(uint)
{
    RVariableType selectedVariableType = RVariableType(this-&gt;itemData(this-&gt;currentIndex()).toInt());
    this-&gt;clear();
    this-&gt;populate(selectedVariableType);
}
</t>
<t tx="leo.20201108101528.110">void Session::onSoftwareUpdateFileSaved(uint downloadID, const QString &amp;fileName)
{
    RLogger::trace("void Session::onSoftwareUpdateFileSaved(uint downloadID, const QString &amp;fileName)\n");
    RLogger::info("Opening downloaded file \'%s\' (id=\'%u\')\n",fileName.toUtf8().constData(),downloadID);

    if (!QDesktopServices::openUrl(QUrl("file:///" + fileName)))
    {
        RLogger::error("Failed to open the file \'%s\'\n",fileName.toUtf8().constData());
    }
}
</t>
<t tx="leo.20201108101528.111">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   session_entity_id.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Session Entity ID class definition                  *
 *********************************************************************/

#include "session_entity_id.h"

SessionEntityID::SessionEntityID()
    : mid(0)
    , type(R_ENTITY_GROUP_NONE)
    , eid(0)
{
    this-&gt;_init();
}

SessionEntityID::SessionEntityID(uint mid, REntityGroupType type, uint eid)
    : mid(mid)
    , type(type)
    , eid(eid)
{
}

SessionEntityID::SessionEntityID(const SessionEntityID &amp;sessonEntityID)
{
    this-&gt;_init(&amp;sessonEntityID);
}

SessionEntityID::~SessionEntityID()
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.112">void SessionEntityID::_init(const SessionEntityID *pSessionEntityID)
{
    if (pSessionEntityID)
    {
        this-&gt;setType(pSessionEntityID-&gt;getType());
        this-&gt;setMid(pSessionEntityID-&gt;getMid());
        this-&gt;setEid(pSessionEntityID-&gt;getEid());
    }
}

SessionEntityID &amp; SessionEntityID::operator =(const SessionEntityID &amp;sessonEntityID)
{
    this-&gt;_init(&amp;sessonEntityID);
    return (*this);
}

</t>
<t tx="leo.20201108101528.113">bool SessionEntityID::operator ==(const SessionEntityID &amp;sessionEntityID) const
{
    if (this-&gt;getType() == sessionEntityID.getType() &amp;&amp;
        this-&gt;getMid() == sessionEntityID.getMid() &amp;&amp;
        this-&gt;getEid() == sessionEntityID.getEid())
    {
        return true;
    }
    else
    {
        return false;
    }
}

</t>
<t tx="leo.20201108101528.114">bool SessionEntityID::operator &lt;(const SessionEntityID &amp;sessionEntityID) const
{
    if (this-&gt;getMid() &gt; sessionEntityID.getMid())
    {
        return false;
    }
    else if (this-&gt;getMid() &lt; sessionEntityID.getMid())
    {
        return true;
    }
    else
    {
        if (this-&gt;getType() &gt; sessionEntityID.getType())
        {
            return false;
        }
        else if (this-&gt;getType() &lt; sessionEntityID.getType())
        {
            return true;
        }
        else
        {
            if (this-&gt;getEid() &gt;= sessionEntityID.getEid())
            {
                return false;
            }
            else
            {
                return true;
            }
        }
    }
}

</t>
<t tx="leo.20201108101528.115">bool SessionEntityID::operator &gt;(const SessionEntityID &amp;sessionEntityID) const
{
    if (this-&gt;getMid() &lt; sessionEntityID.getMid())
    {
        return false;
    }
    else if (this-&gt;getMid() &gt; sessionEntityID.getMid())
    {
        return true;
    }
    else
    {
        if (this-&gt;getType() &lt; sessionEntityID.getType())
        {
            return false;
        }
        else if (this-&gt;getType() &gt; sessionEntityID.getType())
        {
            return true;
        }
        else
        {
            if (this-&gt;getEid() &lt;= sessionEntityID.getEid())
            {
                return false;
            }
            else
            {
                return true;
            }
        }
    }
}

uint SessionEntityID::getMid(void) const
{
    return this-&gt;mid;
}

</t>
<t tx="leo.20201108101528.116">void SessionEntityID::setMid(uint mid)
{
    this-&gt;mid = mid;
}

REntityGroupType SessionEntityID::getType(void) const
{
    return this-&gt;type;
}

</t>
<t tx="leo.20201108101528.117">void SessionEntityID::setType(REntityGroupType type)
{
    this-&gt;type = type;
}

uint SessionEntityID::getEid(void) const
{
    return this-&gt;eid;
}

</t>
<t tx="leo.20201108101528.118">void SessionEntityID::setEid(uint eid)
{
    this-&gt;eid = eid;
}

QList&lt;SessionEntityID&gt; SessionEntityID::filterList(const QList&lt;SessionEntityID&gt; &amp;entityList, REntityGroupTypeMask entityGroupTypeMask)
{
    QList&lt;SessionEntityID&gt; filteredList;

    for (int i=0;i&lt;entityList.size();i++)
    {
        if (entityList[i].getType() &amp; entityGroupTypeMask)
        {
            filteredList.push_back(entityList[i]);
        }
    }

    return filteredList;
}

QList&lt;uint&gt; SessionEntityID::getEntityIDs(const QList&lt;SessionEntityID&gt; &amp;entityList, REntityGroupTypeMask entityGroupTypeMask)
{
    QList&lt;uint&gt; entityIDs;

    for (int i=0;i&lt;entityList.size();i++)
    {
        if (entityList[i].getType() &amp; entityGroupTypeMask)
        {
            entityIDs.push_back(entityList[i].getEid());
        }
    }

    return entityIDs;
}
</t>
<t tx="leo.20201108101528.119">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   session_node_id.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   24-th February 2015                                      *
 *                                                                   *
 *  DESCRIPTION: Session Node ID class definition                    *
 *********************************************************************/

#include "session_node_id.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.12">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   results_variable_tree.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th February 2013                                      *
 *                                                                   *
 *  DESCRIPTION: Results variable tree class definition              *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QCheckBox&gt;
#include &lt;QGroupBox&gt;
#include &lt;QPushButton&gt;
#include &lt;QMessageBox&gt;

#include &lt;rblib.h&gt;

#include "color_scale.h"
#include "results_variable_tree.h"
#include "session.h"
#include "graph_dialog.h"
#include "graph_object.h"
#include "main_window.h"
#include "model_action.h"
#include "job_manager.h"
#include "value_scale.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.120">void SessionNodeID::_init(const SessionNodeID *pSessionNodeID)
{
    if (pSessionNodeID)
    {
        this-&gt;mid = pSessionNodeID-&gt;mid;
        this-&gt;nid = pSessionNodeID-&gt;nid;
    }
}

SessionNodeID::SessionNodeID()
    : mid(0)
    , nid(0)
{
    this-&gt;_init();
}

SessionNodeID::SessionNodeID(uint mid, uint nid)
    : mid(mid)
    , nid(nid)
{
    this-&gt;_init();
}

SessionNodeID::SessionNodeID(const SessionNodeID &amp;sessionNodeID)
{
    this-&gt;_init(&amp;sessionNodeID);
}

SessionNodeID::~SessionNodeID()
{
}

SessionNodeID &amp;SessionNodeID::operator =(const SessionNodeID &amp;sessionNodeID)
{
    this-&gt;_init(&amp;sessionNodeID);
    return (*this);
}

</t>
<t tx="leo.20201108101528.121">bool SessionNodeID::operator ==(const SessionNodeID &amp;sessionNodeID) const
{
    return (this-&gt;mid == sessionNodeID.mid &amp;&amp; this-&gt;nid == sessionNodeID.nid);
}

</t>
<t tx="leo.20201108101528.122">bool SessionNodeID::operator &lt;(const SessionNodeID &amp;sessionNodeID) const
{
    if (this-&gt;mid &gt; sessionNodeID.mid)
    {
        return false;
    }
    else if (this-&gt;mid &lt; sessionNodeID.mid)
    {
        return true;
    }
    if (this-&gt;nid &lt; sessionNodeID.nid)
    {
        return true;
    }
    return false;
}

</t>
<t tx="leo.20201108101528.123">bool SessionNodeID::operator &gt;(const SessionNodeID &amp;sessionNodeID) const
{
    if (this-&gt;mid &lt; sessionNodeID.mid)
    {
        return false;
    }
    else if (this-&gt;mid &gt; sessionNodeID.mid)
    {
        return true;
    }
    if (this-&gt;nid &gt; sessionNodeID.nid)
    {
        return true;
    }
    return false;
}

uint SessionNodeID::getMid(void) const
{
    return this-&gt;mid;
}

</t>
<t tx="leo.20201108101528.124">void SessionNodeID::setMid(uint mid)
{
    this-&gt;mid = mid;
}

uint SessionNodeID::getNid(void) const
{
    return this-&gt;nid;
}

</t>
<t tx="leo.20201108101528.125">void SessionNodeID::setNid(uint nid)
{
    this-&gt;nid = nid;
}
</t>
<t tx="leo.20201108101528.126">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   shortcut_line_edit.h                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   header file (*.h)                                        *
 *  DATE:   11-th September 2014                                     *
 *                                                                   *
 *  DESCRIPTION: Shortcut line edit class declaration                *
 *********************************************************************/

#include &lt;QKeyEvent&gt;

#include "shortcut_line_edit.h"

ShortcutLineEdit::ShortcutLineEdit(QWidget *parent) :
    QLineEdit(parent)
{
    this-&gt;setClearButtonEnabled(true);

    QObject::connect(this,
                     &amp;QLineEdit::textChanged,
                     this,
                     &amp;ShortcutLineEdit::onTextChanged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.127">void ShortcutLineEdit::keyPressEvent(QKeyEvent *keyEvent)
{
    QString grab;
    bool emitSignal = false;

    int modifiers = keyEvent-&gt;modifiers();

    if (modifiers &amp; Qt::ControlModifier)
    {
        grab.append("Ctrl+");
    }
    if (modifiers &amp; Qt::ShiftModifier)
    {
        grab.append("Shift+");
    }
    if (modifiers &amp; Qt::AltModifier)
    {
        grab.append("Alt+");
    }
    if (QChar(keyEvent-&gt;key()).isLetter())
    {
        grab.append(QChar(keyEvent-&gt;key()).toUpper());
        emitSignal = true;
    }
    this-&gt;setText(grab);

    if (emitSignal)
    {
        emit this-&gt;shortcutChanged(this-&gt;text());
    }
}

</t>
<t tx="leo.20201108101528.128">void ShortcutLineEdit::onTextChanged(const QString &amp;text)
{
    if (text.isEmpty())
    {
        emit this-&gt;shortcutChanged(this-&gt;text());
    }
}
</t>
<t tx="leo.20201108101528.129">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   solver_manager.cpp                                       *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   10-th December 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Solver manager class definition                     *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "session.h"
#include "solver_manager.h"

const QString solverTaskServerName("RANGE_SOLVER_TASK_SERVER");

SolverManager::SolverManager(QObject *parent)
    : JobManager(parent)
    , taskServer(0)
{
    this-&gt;taskServerName = "RANGE_SOLVER_TASK_SERVER_" + Session::getInstance().getID();
    this-&gt;taskServer = new QLocalServer(this);
    if (!this-&gt;taskServer-&gt;listen(this-&gt;taskServerName))
    {
        RLogger::warning("Local server failed to listen: %s\n", this-&gt;taskServer-&gt;errorString().toUtf8().constData());
    }
    RLogger::info("Listening on: %s\n", this-&gt;taskServer-&gt;serverName().toUtf8().constData());
    QObject::connect(this-&gt;taskServer, &amp;QLocalServer::newConnection, this, &amp;SolverManager::onSolverTaskNewConnection);
}

SolverManager &amp;SolverManager::getInstance(void)
{
    static SolverManager solverManager;
    return solverManager;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.13">typedef enum _ResultsVariableTreeColumn
{
    RESULTS_VARIABLE_TREE_COLUMN_1 = 0,
    RESULTS_VARIABLE_TREE_N_COLUMNS
} ResultsVariableTreeColumn;

ResultsVariableTree::ResultsVariableTree(QWidget *parent) :
    QTreeWidget(parent),
    variableType(R_VARIABLE_NONE)
{
    this-&gt;setColumnCount(RESULTS_VARIABLE_TREE_N_COLUMNS);
    this-&gt;setSelectionMode(QAbstractItemView::NoSelection);
    this-&gt;setRootIsDecorated(false);
    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(RESULTS_VARIABLE_TREE_COLUMN_1,QString(tr("Results display properties")));
    this-&gt;setHeaderItem(headerItem);
    this-&gt;setHeaderHidden(true);

    this-&gt;setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);

    this-&gt;connect(this,
                  SIGNAL(variableDataChanged(uint,RVariableType)),
                  SLOT(onVariableDataChanged(uint,RVariableType)));
    this-&gt;connect(this,
                  SIGNAL(variableDataChanged(SessionEntityID,RVariableType)),
                  SLOT(onVariableDataChanged(SessionEntityID,RVariableType)));
}

</t>
<t tx="leo.20201108101528.130">const QString &amp;SolverManager::getTaskServerName(void) const
{
    return this-&gt;taskServerName;
}

</t>
<t tx="leo.20201108101528.131">void SolverManager::submit(SolverTask *solverTask)
{
    if (!this-&gt;isSolverQueued(solverTask-&gt;getModelID()))
    {
        QObject::connect(solverTask,
                         &amp;SolverTask::readyReadStandardOutput,
                         this,
                         &amp;SolverManager::onReadyReadStandardOutput);
        QObject::connect(solverTask,
                         &amp;SolverTask::readyReadStandardError,
                         this,
                         &amp;SolverManager::onReadyReadStandardError);

        this-&gt;lastLogFileName = solverTask-&gt;getLogFileName();

        this-&gt;JobManager::submit(solverTask);
    }
}

</t>
<t tx="leo.20201108101528.132">bool SolverManager::isSolverQueued(uint modelID) const
{
    for (int i=0;i&lt;this-&gt;waitingJobs.size();i++)
    {
        SolverTask *solverTask = static_cast&lt;SolverTask*&gt;(this-&gt;waitingJobs[i]);
        if (solverTask-&gt;getModelID() == modelID)
        {
            return true;
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101528.133">void SolverManager::stopRunningTasks(void)
{
    if (!this-&gt;runningJobs.isEmpty())
    {
        foreach (Job *task, this-&gt;runningJobs)
        {
            SolverTask *solverTask = dynamic_cast&lt;SolverTask*&gt;(task);
            RLogger::info("Stopping solver task (#%s).\n",solverTask-&gt;getTaskID().toString().toUtf8().constData());
            QString message = solverTask-&gt;getStopCommand();
            foreach (QLocalSocket *localSocket, this-&gt;taskClients)
            {
                QByteArray block;
                QDataStream out(&amp;block, QIODevice::WriteOnly);
                out.setVersion(QDataStream::Qt_5_6);
                RLogger::info("Sendig signal: %s\n",message.toUtf8().constData());
                out &lt;&lt; quint32(message.size());
                out &lt;&lt; message;
                localSocket-&gt;write(block);
                localSocket-&gt;flush();
            }
        }
    }
}

</t>
<t tx="leo.20201108101528.134">void SolverManager::killRunningTasks(void)
{
    if (!this-&gt;runningJobs.isEmpty())
    {
        foreach (Job *task, this-&gt;runningJobs)
        {
            SolverTask *solverTask = dynamic_cast&lt;SolverTask*&gt;(task);
            RLogger::info("Killing solver task (#%s).\n",solverTask-&gt;getTaskID().toString().toUtf8().constData());
            solverTask-&gt;kill();
        }
    }
}

</t>
<t tx="leo.20201108101528.135">const QString &amp;SolverManager::getLastLogFileName(void) const
{
    return this-&gt;lastLogFileName;
}

</t>
<t tx="leo.20201108101528.136">void SolverManager::stopServer(void)
{
    QObject::disconnect(this-&gt;taskServer, &amp;QLocalServer::newConnection, this, &amp;SolverManager::onSolverTaskNewConnection);
    this-&gt;taskServer-&gt;close();
}

</t>
<t tx="leo.20201108101528.137">void SolverManager::onReadyReadStandardOutput(const QString &amp;message)
{
    emit this-&gt;readyReadStandardOutput(message);
}

</t>
<t tx="leo.20201108101528.138">void SolverManager::onReadyReadStandardError(const QString &amp;message)
{
    emit this-&gt;readyReadStandardError(message);
}

</t>
<t tx="leo.20201108101528.139">void SolverManager::onSolverTaskNewConnection(void)
{
    RLogger::info("Task client connected\n");
    while (this-&gt;taskServer-&gt;hasPendingConnections())
    {
        this-&gt;taskClients.append(this-&gt;taskServer-&gt;nextPendingConnection());
    }
}
</t>
<t tx="leo.20201108101528.14">void ResultsVariableTree::populate(void)
{
    if (this-&gt;variableType == R_VARIABLE_NONE)
    {
        return;
    }

    QString rangeName;
    double minValue = 0.0;
    double maxValue = 0.0;
    double scaleValue = 1.0;
    Qt::CheckState applyAsScalarState = Qt::Unchecked;
    Qt::CheckState applyAsDisplacementState = Qt::Unchecked;
    Qt::CheckState displayRangeState = Qt::Unchecked;
    uint nApplyAsScalar = 0;
    uint nApplyAsDisplacement = 0;
    uint nApplyTotal = 0;
    QString appliesOnStr;

    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;selectedEntityIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedEntityIDs[i].getMid());

        const REntityGroup *pEntityGroup = nullptr;

        switch (selectedEntityIDs[i].getType())
        {
            case R_ENTITY_GROUP_POINT:
                pEntityGroup = model.getPointPtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_LINE:
                pEntityGroup = model.getLinePtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_SURFACE:
                pEntityGroup = model.getSurfacePtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_VOLUME:
                pEntityGroup = model.getVolumePtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_VECTOR_FIELD:
                pEntityGroup = model.getVectorFieldPtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_SCALAR_FIELD:
                pEntityGroup = model.getScalarFieldPtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_STREAM_LINE:
                pEntityGroup = model.getStreamLinePtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_CUT:
                pEntityGroup = model.getCutPtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_ISO:
                pEntityGroup = model.getIsoPtr(selectedEntityIDs[i].getEid());
                break;
            default:
                break;
        }

        if (!pEntityGroup)
        {
            continue;
        }
        const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = pEntityGroup-&gt;getData().getVariableData();
        const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt;::const_iterator it = egVarData.find(this-&gt;variableType);

        if (it == egVarData.end())
        {
            continue;
        }

        if (REntityGroupVariableDisplayTypeMask(it-&gt;second) &amp; R_ENTITY_GROUP_VARIABLE_DISPLAY_SCALAR)
        {
            nApplyAsScalar++;
        }
        if (REntityGroupVariableDisplayTypeMask(it-&gt;second) &amp; R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT)
        {
            nApplyAsDisplacement++;
        }

        nApplyTotal++;
    }

    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    bool appliesOnNode = false;
    bool appliesOnElement = false;
    bool isVector = false;
    uint nActiveModels = 0;
    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);
        uint nVariables = model.getNVariables();

        for (uint j=0;j&lt;nVariables;j++)
        {
            RVariable &amp;rVariable = model.getVariable(j);
            if (rVariable.getType() != this-&gt;variableType)
            {
                continue;
            }

            if (rVariable.getNVectors() &gt; 1)
            {
                isVector = true;
            }

            switch (rVariable.getApplyType())
            {
                case R_VARIABLE_APPLY_NODE:
                    appliesOnNode = true;
                    break;
                case R_VARIABLE_APPLY_ELEMENT:
                    appliesOnElement = true;
                    break;
                default:
                    break;
            }

            RVariableData &amp;variableData = rVariable.getVariableData();

            if (nActiveModels == 0)
            {
                minValue = variableData.getMinDisplayValue();
                maxValue = variableData.getMaxDisplayValue();
                scaleValue = variableData.getScale();
                rangeName = variableData.getValueRangeName();

                displayRangeState = variableData.getDisplayValueRange() ? Qt::Checked : Qt::Unchecked;
            }
            else
            {
                minValue = std::min(minValue,variableData.getMinDisplayValue());
                maxValue = std::max(maxValue,variableData.getMaxDisplayValue());
                if ((variableData.getDisplayValueRange() &amp;&amp; displayRangeState == Qt::Unchecked)
                    ||
                    (!variableData.getDisplayValueRange() &amp;&amp; displayRangeState == Qt::Checked))
                {
                    displayRangeState = Qt::PartiallyChecked;
                }
            }

            nActiveModels ++;
        }
    }

    if (nApplyAsScalar &gt; 0)
    {
        if (nApplyAsScalar == nApplyTotal)
        {
            applyAsScalarState = Qt::Checked;
        }
        else
        {
            applyAsScalarState = Qt::PartiallyChecked;
        }
    }
    if (nApplyAsDisplacement &gt; 0 &amp;&amp; isVector)
    {
        if (nApplyAsDisplacement == nApplyTotal)
        {
            applyAsDisplacementState = Qt::Checked;
        }
        else
        {
            applyAsDisplacementState = Qt::PartiallyChecked;
        }
    }

    if (appliesOnNode &amp;&amp; appliesOnElement)
    {
        appliesOnStr = tr("Results are displayed on nodes and elements");
    }
    else if (appliesOnNode &amp;&amp; !appliesOnElement)
    {
        appliesOnStr = tr("Results are displayed on nodes");
    }
    else if (!appliesOnNode &amp;&amp; appliesOnElement)
    {
        appliesOnStr = tr("Results are displayed on elements");
    }
    else
    {
        appliesOnStr = tr("Results can not be displayed");
    }

    this-&gt;blockSignals(true);

    QTreeWidgetItem *item;

    if (nActiveModels &gt; 1)
    {
        item = new QTreeWidgetItem(this);
        item-&gt;setText(RESULTS_VARIABLE_TREE_COLUMN_1,tr("Editing values for multiple models"));
        item-&gt;setForeground(RESULTS_VARIABLE_TREE_COLUMN_1,QBrush(Qt::red));
    }

    // -----------------------------------------------------------------
    // APPLY ON

    item = new QTreeWidgetItem(this);
    item-&gt;setText(RESULTS_VARIABLE_TREE_COLUMN_1,appliesOnStr);

    // -----------------------------------------------------------------
    // APPLY AS

    item = new QTreeWidgetItem(this);
    QGroupBox *applyAsGroupBox= new QGroupBox("Apply as ...");
    QGridLayout *applyAsLayout = new QGridLayout;

    uint crow = 0;

    this-&gt;applyAsScalarCheckBox = new QCheckBox(REntityGroupData::getVariableDisplayName(R_ENTITY_GROUP_VARIABLE_DISPLAY_SCALAR));
    this-&gt;applyAsScalarCheckBox-&gt;setCheckState(applyAsScalarState);
    applyAsLayout-&gt;addWidget(this-&gt;applyAsScalarCheckBox,crow,0,1,1);

    QObject::connect(this-&gt;applyAsScalarCheckBox,&amp;QCheckBox::stateChanged,this,&amp;ResultsVariableTree::onApplyAsScalarStateChanged);

    crow++;

    this-&gt;applyAsDisplacementCheckBox = new QCheckBox(REntityGroupData::getVariableDisplayName(R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT));
    this-&gt;applyAsDisplacementCheckBox-&gt;setCheckState(applyAsDisplacementState);
    applyAsLayout-&gt;addWidget(this-&gt;applyAsDisplacementCheckBox,crow,0,1,1);

    this-&gt;applyAsDisplacementCheckBox-&gt;setEnabled(isVector);

    QObject::connect(this-&gt;applyAsDisplacementCheckBox,&amp;QCheckBox::stateChanged,this,&amp;ResultsVariableTree::onApplyAsDisplacementStateChanged);

    crow++;

    applyAsGroupBox-&gt;setLayout(applyAsLayout);

    this-&gt;setItemWidget(item,RESULTS_VARIABLE_TREE_COLUMN_1,applyAsGroupBox);

    // -----------------------------------------------------------------
    // DISPLAY RANGE

    item = new QTreeWidgetItem(this);
    QGroupBox *rangeGroupBox= new QGroupBox("Display range");
    QGridLayout *rangeLayout = new QGridLayout;

    crow = 0;

    // Maximum
    this-&gt;maxValueScale = new ValueScale(tr("Maximum"));
    this-&gt;maxValueScale-&gt;setValue(maxValue);
    rangeLayout-&gt;addWidget(this-&gt;maxValueScale,crow,0,1,2);

    QObject::connect(this-&gt;maxValueScale,&amp;ValueScale::valueChanged,this,&amp;ResultsVariableTree::onRangeMaxValueChanged);

    crow++;

    // Minimum
    this-&gt;minValueScale = new ValueScale(tr("Minimum"));
    this-&gt;minValueScale-&gt;setValue(minValue);
    rangeLayout-&gt;addWidget(this-&gt;minValueScale,crow,0,1,2);

    QObject::connect(this-&gt;minValueScale,&amp;ValueScale::valueChanged,this,&amp;ResultsVariableTree::onRangeMinValueChanged);

    crow++;

    // Set default min max ranges.
    QPushButton *rangeAutoFillButton = new QPushButton(tr("Set default min/max values"));
    rangeLayout-&gt;addWidget(rangeAutoFillButton,crow,0,1,2);

    QObject::connect(rangeAutoFillButton,&amp;QPushButton::clicked,this,&amp;ResultsVariableTree::onRangeAutofillClicked);

    crow++;

    // Show graph of computed values.
    QPushButton *rangeGraphButton = new QPushButton(tr("Show graph values"));
    rangeLayout-&gt;addWidget(rangeGraphButton,crow,0,1,2);

    QObject::connect(rangeGraphButton,&amp;QPushButton::clicked,this,&amp;ResultsVariableTree::onRangeGraphClicked);

    crow++;

    // Color-Scale name
    QLabel *colorScaleLabelLabel = new QLabel(tr("Color scale:"));
    rangeLayout-&gt;addWidget(colorScaleLabelLabel,crow,0,1,1);

    this-&gt;colorScaleComboBox = new ColorScaleComboBox;
    rangeLayout-&gt;addWidget(this-&gt;colorScaleComboBox,crow,1,1,1);

    this-&gt;colorScaleComboBox-&gt;setColorScaleName(rangeName);

    this-&gt;connect(this-&gt;colorScaleComboBox,SIGNAL(currentIndexChanged(int)),SLOT(onColorScaleChanged(int)));

    crow++;

    // Display Value range.

    QCheckBox *displayRangeCheckBox = new QCheckBox("Display value range");
    displayRangeCheckBox-&gt;setCheckState(displayRangeState);
    rangeLayout-&gt;addWidget(displayRangeCheckBox,crow,0,1,2);

    QObject::connect(displayRangeCheckBox,&amp;QCheckBox::stateChanged,this,&amp;ResultsVariableTree::onRangeDisplayStateChanged);

    crow++;

    rangeGroupBox-&gt;setLayout(rangeLayout);

    this-&gt;setItemWidget(item,RESULTS_VARIABLE_TREE_COLUMN_1,rangeGroupBox);

    // -----------------------------------------------------------------
    // SCALE

    item = new QTreeWidgetItem(this);

    ValueScale *valueScale = new ValueScale(tr("Scale"));
    valueScale-&gt;setValue(scaleValue);
    valueScale-&gt;setEnabled(isVector);
    this-&gt;setItemWidget(item,RESULTS_VARIABLE_TREE_COLUMN_1,valueScale);

    QObject::connect(valueScale,&amp;ValueScale::valueChanged,this,&amp;ResultsVariableTree::onVariableScaleChanged);

    // -----------------------------------------------------------------
    // VARIABLE ACTIONS

    item = new QTreeWidgetItem(this);
    QGroupBox *actionsGroupBox= new QGroupBox("Actions");
    QGridLayout *actionsLayout = new QGridLayout;

    if (appliesOnElement)
    {
        QPushButton *applyOnNodeButton = new QPushButton(tr("Display on nodes"));
        actionsLayout-&gt;addWidget(applyOnNodeButton);
        QObject::connect(applyOnNodeButton,&amp;QPushButton::clicked,this,&amp;ResultsVariableTree::onApplyOnNodeClicked);
    }

    QPushButton *removeVariableButton = new QPushButton(QIcon(":/icons/file/pixmaps/range-cancel.svg"),tr("Remove variable"));
    actionsLayout-&gt;addWidget(removeVariableButton);
    QObject::connect(removeVariableButton,&amp;QPushButton::clicked,this,&amp;ResultsVariableTree::onRemoveVariableClicked);

    actionsGroupBox-&gt;setLayout(actionsLayout);
    this-&gt;setItemWidget(item,RESULTS_VARIABLE_TREE_COLUMN_1,actionsGroupBox);

    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101528.15">void ResultsVariableTree::processApplyAsStates(void)
{
    QList&lt;SessionEntityID&gt; selectedEntityIDs = Session::getInstance().getSelectedEntityIDs();

    for (int i=0;i&lt;selectedEntityIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedEntityIDs[i].getMid());

        REntityGroup *pEntityGroup = nullptr;

        switch (selectedEntityIDs[i].getType())
        {
            case R_ENTITY_GROUP_POINT:
                pEntityGroup = model.getPointPtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_LINE:
                pEntityGroup = model.getLinePtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_SURFACE:
                pEntityGroup = model.getSurfacePtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_VOLUME:
                pEntityGroup = model.getVolumePtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_VECTOR_FIELD:
                pEntityGroup = model.getVectorFieldPtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_SCALAR_FIELD:
                pEntityGroup = model.getScalarFieldPtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_STREAM_LINE:
                pEntityGroup = model.getStreamLinePtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_CUT:
                pEntityGroup = model.getCutPtr(selectedEntityIDs[i].getEid());
                break;
            case R_ENTITY_GROUP_ISO:
                pEntityGroup = model.getIsoPtr(selectedEntityIDs[i].getEid());
                break;
            default:
                break;
        }

        if (!pEntityGroup)
        {
            continue;
        }
        std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;egVarData = pEntityGroup-&gt;getData().getVariableData();

        egVarData.erase(this-&gt;variableType);

        if (this-&gt;applyAsScalarCheckBox-&gt;checkState() == Qt::Checked)
        {
            egVarData[this-&gt;variableType] |= R_ENTITY_GROUP_VARIABLE_DISPLAY_SCALAR;
        }
        if (this-&gt;applyAsDisplacementCheckBox-&gt;checkState() == Qt::Checked)
        {
            egVarData[this-&gt;variableType] |= R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT;
        }

        emit this-&gt;variableDataChanged(selectedEntityIDs[i],this-&gt;variableType);
    }
}

</t>
<t tx="leo.20201108101528.16">void ResultsVariableTree::onResultsVariableSelected(RVariableType variableType)
{
    this-&gt;variableType = variableType;
    this-&gt;clear();
    this-&gt;populate();
}

</t>
<t tx="leo.20201108101528.17">void ResultsVariableTree::onApplyAsScalarStateChanged(int)
{
    this-&gt;processApplyAsStates();
}

</t>
<t tx="leo.20201108101528.18">void ResultsVariableTree::onApplyAsDisplacementStateChanged(int)
{
    this-&gt;processApplyAsStates();
}

</t>
<t tx="leo.20201108101528.19">void ResultsVariableTree::onApplyOnNodeClicked(void)
{
    if (QMessageBox::question(this,
                              tr("Display on nodes?"),
                              tr("Are you sure you want to change display from elements to nodes?"),
                              QMessageBox::No,
                              QMessageBox::Yes) == QMessageBox::No)
    {
        return;
    }

    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        ModelActionInput modelActionInput(selectedModelIDs[i]);
        modelActionInput.setApplyVariableOnNode(this-&gt;variableType);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101528.2">int ReportDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        ReportDialog::htmlFileEnabled = this-&gt;htmlGroupBox-&gt;isChecked();
        ReportDialog::odfFileEnabled = this-&gt;odfGroupBox-&gt;isChecked();
        ReportDialog::pdfFileEnabled = this-&gt;pdfGroupBox-&gt;isChecked();

        ReportGenerator *reportGenerator = new ReportGenerator(this-&gt;modelID);

        if (ReportDialog::htmlFileEnabled)
        {
            reportGenerator-&gt;addExportType(ReportGenerator::HTML,this-&gt;htmlFileChooserButton-&gt;getFileName());
        }
        if (ReportDialog::odfFileEnabled)
        {
            reportGenerator-&gt;addExportType(ReportGenerator::ODF,this-&gt;odfFileChooserButton-&gt;getFileName());
        }
        if (ReportDialog::pdfFileEnabled)
        {
            reportGenerator-&gt;addExportType(ReportGenerator::PDF,this-&gt;pdfFileChooserButton-&gt;getFileName());
        }

        JobManager::getInstance().submit(reportGenerator);
    }

    return retVal;
}
</t>
<t tx="leo.20201108101528.20">void ResultsVariableTree::onRemoveVariableClicked(void)
{
    if (QMessageBox::question(this,
                              tr("Remove variable?"),
                              tr("Are you sure you want to remove selected variable?"),
                              QMessageBox::No,
                              QMessageBox::Yes) == QMessageBox::No)
    {
        return;
    }

    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        ModelActionInput modelActionInput(selectedModelIDs[i]);
        modelActionInput.setRemoveVariable(this-&gt;variableType);

        ModelAction *modelAction = new ModelAction;
        modelAction-&gt;setAutoDelete(true);
        modelAction-&gt;addAction(modelActionInput);
        JobManager::getInstance().submit(modelAction);
    }
}

</t>
<t tx="leo.20201108101528.21">void ResultsVariableTree::onColorScaleChanged(int index)
{
    const QString &amp;name = this-&gt;colorScaleComboBox-&gt;itemData(index-1).toString();
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);
        uint nVariables = model.getNVariables();

        for (uint j=0;j&lt;nVariables;j++)
        {
            RVariable &amp;variable = model.getVariable(j);
            if (variable.getType() != this-&gt;variableType)
            {
                continue;
            }
            variable.getVariableData().setValueRangeName(name);
            emit this-&gt;variableDataChanged(selectedModelIDs[i],this-&gt;variableType);
        }
    }
}

</t>
<t tx="leo.20201108101528.22">void ResultsVariableTree::onRangeMinValueChanged(double minValue)
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);
        uint nVariables = model.getNVariables();

        for (uint j=0;j&lt;nVariables;j++)
        {
            RVariable &amp;variable = model.getVariable(j);
            if (variable.getType() != this-&gt;variableType)
            {
                continue;
            }
            double minDisplayValue = minValue;
            double maxDisplayValue = std::max(minValue,variable.getVariableData().getMaxDisplayValue());
            variable.getVariableData().setMinMaxDisplayValue(minDisplayValue,maxDisplayValue);
            if (this-&gt;maxValueScale-&gt;getValue() != maxDisplayValue)
            {
                this-&gt;blockSignals(true);
                this-&gt;maxValueScale-&gt;setValue(maxDisplayValue);
                this-&gt;blockSignals(false);
            }
            emit this-&gt;variableDataChanged(selectedModelIDs[i],this-&gt;variableType);
        }
    }
}

</t>
<t tx="leo.20201108101528.23">void ResultsVariableTree::onRangeMaxValueChanged(double maxValue)
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);
        uint nVariables = model.getNVariables();

        for (uint j=0;j&lt;nVariables;j++)
        {
            RVariable &amp;variable = model.getVariable(j);
            if (variable.getType() != this-&gt;variableType)
            {
                continue;
            }
            double minDisplayValue = std::min(maxValue,variable.getVariableData().getMinDisplayValue());
            double maxDisplayValue = maxValue;
            variable.getVariableData().setMinMaxDisplayValue(minDisplayValue,maxDisplayValue);
            if (this-&gt;minValueScale-&gt;getValue() != minDisplayValue)
            {
                this-&gt;blockSignals(true);
                this-&gt;minValueScale-&gt;setValue(minDisplayValue);
                this-&gt;blockSignals(false);
            }
            emit this-&gt;variableDataChanged(selectedModelIDs[i],this-&gt;variableType);
        }
    }
}

</t>
<t tx="leo.20201108101528.24">void ResultsVariableTree::onRangeDisplayStateChanged(int state)
{
    bool displayRange;

    Qt::CheckState displayRangeState = Qt::CheckState(state);

    if (displayRangeState == Qt::Checked)
    {
        displayRange = true;
    }
    else if (displayRangeState == Qt::Unchecked)
    {
        displayRange = false;
    }
    else
    {
        return;
    }

    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);
        uint nVariables = model.getNVariables();

        for (uint j=0;j&lt;nVariables;j++)
        {
            RVariable &amp;variable = model.getVariable(j);
            if (variable.getType() != this-&gt;variableType)
            {
                continue;
            }
            variable.getVariableData().setDisplayValueRange(displayRange);
            emit this-&gt;variableDataChanged(selectedModelIDs[i],this-&gt;variableType);
        }
    }
}

</t>
<t tx="leo.20201108101528.25">void ResultsVariableTree::onRangeAutofillClicked(void)
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    double minDisplayValue = 0.0;
    double maxDisplayValue = 0.0;
    bool firstValue = true;

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);

        unsigned int variablePos = model.findVariable(this-&gt;variableType);
        if (variablePos == RConstants::eod)
        {
            continue;
        }
        RVariable &amp;variable =  model.getVariable(variablePos);

        double minValue = variable.getMinValue();
        double maxValue = variable.getMaxValue();

        if (firstValue)
        {
            minDisplayValue = minValue;
            maxDisplayValue = maxValue;
            firstValue = false;
        }

        minDisplayValue = std::min(minValue,minDisplayValue);
        maxDisplayValue = std::max(maxValue,maxDisplayValue);
    }

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);
        uint nVariables = model.getNVariables();

        for (uint j=0;j&lt;nVariables;j++)
        {
            RVariable &amp;rVariable = model.getVariable(j);
            if (rVariable.getType() != this-&gt;variableType)
            {
                continue;
            }
            rVariable.getVariableData().setMinMaxDisplayValue(minDisplayValue,maxDisplayValue);
            this-&gt;blockSignals(true);
            this-&gt;minValueScale-&gt;setValue(minDisplayValue);
            this-&gt;maxValueScale-&gt;setValue(maxDisplayValue);
            this-&gt;blockSignals(false);
            emit this-&gt;variableDataChanged(selectedModelIDs[i],this-&gt;variableType);
        }
    }
}

</t>
<t tx="leo.20201108101528.26">void ResultsVariableTree::onRangeGraphClicked(void)
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    RRVector values;

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);
        uint nVariables = model.getNVariables();

        for (uint j=0;j&lt;nVariables;j++)
        {
            RVariable &amp;variable = model.getVariable(j);
            if (variable.getType() != this-&gt;variableType)
            {
                continue;
            }

            values.append(variable.getValues());
        }
    }

    RRMatrix distValues = RStatistics::findDistributedValues(values);

    GraphObject *graphObject = new GraphObject;

    GraphData &amp;rGraphData = graphObject-&gt;getData();

    rGraphData.setTitle(RVariable::getName(this-&gt;variableType));
    rGraphData.setXLabel("Value");
    rGraphData.setYLabel("Population");
    rGraphData.setTypeMask(GRAPH_BARS);

    for (uint i=0;i&lt;distValues.getNColumns();i++)
    {
        RRVector &amp;rValues = rGraphData[distValues[0][i]];
        rValues.resize(1);
        rValues[0] = distValues[1][i];
    }

    rGraphData.setLimits(this-&gt;minValueScale-&gt;getValue(),
                         this-&gt;maxValueScale-&gt;getValue());

    GraphDialog graphDialog(graphObject,MainWindow::getInstance());
    graphDialog.getGraphWidget()-&gt;setPaintGraphLimits(true);
    graphDialog.getGraphWidget()-&gt;setShowPointer(true,true,true);
    graphDialog.exec();

    this-&gt;blockSignals(true);
    this-&gt;minValueScale-&gt;setValue(rGraphData.getLLimit());
    this-&gt;maxValueScale-&gt;setValue(rGraphData.getULimit());
    this-&gt;blockSignals(false);

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        emit this-&gt;variableDataChanged(selectedModelIDs[i],this-&gt;variableType);
    }
}

</t>
<t tx="leo.20201108101528.27">void ResultsVariableTree::onVariableScaleChanged(double scale)
{
    QList&lt;uint&gt; selectedModelIDs = Session::getInstance().getSelectedModelIDs();

    for (int i=0;i&lt;selectedModelIDs.size();i++)
    {
        Model &amp;model = Session::getInstance().getModel(selectedModelIDs[i]);
        uint nVariables = model.getNVariables();

        for (uint j=0;j&lt;nVariables;j++)
        {
            RVariable &amp;rVariable = model.getVariable(j);
            if (rVariable.getType() != this-&gt;variableType)
            {
                continue;
            }
            rVariable.getVariableData().setScale(scale);
            emit this-&gt;variableDataChanged(selectedModelIDs[i],this-&gt;variableType);
        }
    }
}

</t>
<t tx="leo.20201108101528.28">void ResultsVariableTree::onVariableDataChanged(uint mid, RVariableType variableType)
{
    Session::getInstance().setVariableDataChanged(mid,variableType);
}

</t>
<t tx="leo.20201108101528.29">void ResultsVariableTree::onVariableDataChanged(const SessionEntityID &amp;entityID, RVariableType variableType)
{
    Session::getInstance().setVariableDataChanged(entityID,variableType);
}
</t>
<t tx="leo.20201108101528.3">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   report_generator.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th February 2014                                      *
 *                                                                   *
 *  DESCRIPTION: Report generator class definition                   *
 *********************************************************************/

#include &lt;QTextCursor&gt;

#include &lt;rblib.h&gt;

#include "report_generator.h"
#include "session.h"

ReportGenerator::ReportGenerator(uint modelID, QObject *parent)
    : DocumentGenerator(parent)
    , modelID(modelID)
{
    RLogger::trace("ReportGenerator::ReportGenerator(uint modelID, QObject *parent)\n");
    this-&gt;setEnableHeaderCounters(false);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.30">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rra_request_input.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th November 2016                                      *
 *                                                                   *
 *  DESCRIPTION: Remote Range API request input class definition     *
 *********************************************************************/

#include "rra_request_input.h"
#include "main_settings.h"

RRARequestInput::RRARequestInput() : HttpRequestInput(RRARequestInput::findUrl(),"POST")
{

}

QString RRARequestInput::findUrl(void)
{
    return MainSettings::getInstance().getApplicationSettings()-&gt;getRangeApiServer() + "/";
}

RRARequestInput *RRARequestInput::requestLatestSoftwareVersion(void)
{
    RRARequestInput *pInput = new RRARequestInput;

    pInput-&gt;type = AVAILABLE_SOFTWARE;
    pInput-&gt;addVariable("pageMode","false");
    pInput-&gt;addVariable("data","available_software");
    pInput-&gt;addVariable("direct","true");
    pInput-&gt;addVariable("product_type",QSysInfo::productType());

    return pInput;
}

RRARequestInput *RRARequestInput::logIn(const QString &amp;account, const QString &amp;password)
{
    RRARequestInput *pInput = new RRARequestInput;

    pInput-&gt;type = LOGIN;
    pInput-&gt;addVariable("pageMode","false");
    pInput-&gt;addVariable("action","login");
    pInput-&gt;addVariable("username",account);
    pInput-&gt;addVariable("password",password);

    return pInput;
}

RRARequestInput *RRARequestInput::logOut(const QString &amp;account)
{
    RRARequestInput *pInput = new RRARequestInput;

    pInput-&gt;type = LOGOUT;
    pInput-&gt;addVariable("pageMode","false");
    pInput-&gt;addVariable("action","logout");
    pInput-&gt;addVariable("username",account);

    return pInput;
}

RRARequestInput *RRARequestInput::sendUsageInfo(const QString &amp;usageInfo)
{
    RRARequestInput *pInput = new RRARequestInput;

    pInput-&gt;type = SEND_USAGE_INFO;
    pInput-&gt;addVariable("pageMode","false");
    pInput-&gt;addVariable("action","usage_info");
//    pInput-&gt;addVariable("usage_info",usageInfo.toHtmlEscaped());
    pInput-&gt;addVariable("usage_info",usageInfo);

    return pInput;
}

RRARequestInput *RRARequestInput::sendCrashReport(const QString &amp;crashReport)
{
    RRARequestInput *pInput = new RRARequestInput;

    pInput-&gt;type = SEND_CRASH_REPORT;
    pInput-&gt;addVariable("pageMode","false");
    pInput-&gt;addVariable("action","crash_report");
    pInput-&gt;addVariable("crash_report",crashReport);

    return pInput;
}

RRARequestInput::Type RRARequestInput::getType(void) const
{
    return this-&gt;type;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.31">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rra_request_worker.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th November 2016                                      *
 *                                                                   *
 *  DESCRIPTION: Remote Range API request worker class definition    *
 *********************************************************************/

#include &lt;QJsonDocument&gt;
#include &lt;QJsonObject&gt;
#include &lt;QJsonArray&gt;

#include "rra_request_worker.h"

RRARequestWorker::RRARequestWorker(QNetworkAccessManager *networkAccessManager, QObject *parent)
    : HttpRequestWorker(networkAccessManager,parent)
{
    QObject::connect(this,&amp;HttpRequestWorker::finished,this,&amp;RRARequestWorker::onHttpRequestFinished);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.32">void RRARequestWorker::availableSoftware(void)
{
    RRARequestInput *pInput = RRARequestInput::requestLatestSoftwareVersion();
    this-&gt;requestType = pInput-&gt;getType();
    this-&gt;execute(pInput);
}

</t>
<t tx="leo.20201108101528.33">void RRARequestWorker::logIn(const QString &amp;account, const QString &amp;password)
{
    RRARequestInput *pInput = RRARequestInput::logIn(account,password);
    this-&gt;requestType = pInput-&gt;getType();
    this-&gt;execute(pInput);
}

</t>
<t tx="leo.20201108101528.34">void RRARequestWorker::logOut(const QString &amp;account)
{
    RRARequestInput *pInput = RRARequestInput::logOut(account);
    this-&gt;requestType = pInput-&gt;getType();
    this-&gt;execute(pInput);
}

</t>
<t tx="leo.20201108101528.35">void RRARequestWorker::sendUsageInfo(const QString &amp;usageInfo)
{
    RRARequestInput *pInput = RRARequestInput::sendUsageInfo(usageInfo);
    this-&gt;requestType = pInput-&gt;getType();
    this-&gt;execute(pInput);
}

</t>
<t tx="leo.20201108101528.36">void RRARequestWorker::sendCrashReport(const QString &amp;crashReport)
{
    RRARequestInput *pInput = RRARequestInput::sendCrashReport(crashReport);
    this-&gt;requestType = pInput-&gt;getType();
    this-&gt;execute(pInput);
}

</t>
<t tx="leo.20201108101528.37">void RRARequestWorker::onHttpRequestFinished(void)
{
    if (this-&gt;getErrorType() != QNetworkReply::NoError)
    {
        // an error occurred
        emit this-&gt;failed(this-&gt;requestType,"RRA communication error: " + this-&gt;getError());
        return;
    }

    // communication was successful
    QString html, status;
    QStringList messages;
    QStringList warnings;
    QStringList errors;

    if (!RRARequestWorker::processJSon(this-&gt;getResponse(),html,status,messages,warnings,errors))
    {
        // an error occurred
        int responseSize = 255;
        QString response(this-&gt;getResponse());
        if (response.size() &gt; responseSize)
        {
            response.truncate(responseSize);
            response += "...";
        }
        emit this-&gt;failed(this-&gt;requestType,"RRA unexpected results: " + response);
        return;
    }

    QString responseMessages;
    if (messages.size() &gt; 0)
    {
        if (!responseMessages.isEmpty())
        {
            responseMessages += " ";
        }
        responseMessages += "Messages: " + messages.join(' ');
    }
    if (warnings.size() &gt; 0)
    {
        if (!responseMessages.isEmpty())
        {
            responseMessages += " ";
        }
        responseMessages += "Warnings: " + warnings.join(' ');
    }
    if (errors.size() &gt; 0)
    {
        if (!responseMessages.isEmpty())
        {
            responseMessages += " ";
        }
        responseMessages += "Errors: " + errors.join(' ');
    }

    if (status != "success")
    {
        // an error occurred
        emit this-&gt;failed(this-&gt;requestType,"RRA error status: " + status + ". " + responseMessages);
        return;
    }

    switch (this-&gt;requestType)
    {
        case RRARequestInput::AVAILABLE_SOFTWARE:
        {
            QStringList elements = html.split('|');
            if (elements.size() == 2)
            {
                emit this-&gt;availableSoftware(RVersion(elements.at(0)),elements.at(1),responseMessages);
            }
            else
            {
                emit this-&gt;failed(this-&gt;requestType,tr("Unexpected response."));
            }
            return;
        }
        case RRARequestInput::LOGIN:
        {
            emit this-&gt;loginStatus(QString(html),true,responseMessages);
            return;
        }
        case RRARequestInput::LOGOUT:
        {
            emit this-&gt;loginStatus(QString(html),false,responseMessages);
            return;
        }
        case RRARequestInput::SEND_USAGE_INFO:
        {
            emit this-&gt;usage(QString(html),responseMessages);
            return;
        }
        case RRARequestInput::SEND_CRASH_REPORT:
        {
            emit this-&gt;crashReport(QString(html),responseMessages);
            return;
        }
    }
}

</t>
<t tx="leo.20201108101528.38">bool RRARequestWorker::processJSon(const QByteArray &amp;byteArray, QString &amp;html, QString &amp;status, QStringList &amp;messages, QStringList &amp;warnings, QStringList &amp;errors)
{
    QJsonDocument jdoc(QJsonDocument::fromJson(byteArray));
    QJsonObject json = jdoc.object();

    QStringList dataKeys;

    if (json.contains("data") &amp;&amp; json["data"].isObject())
    {
        dataKeys.append("data");
    }
    if (json.contains("action") &amp;&amp; json["action"].isObject())
    {
        dataKeys.append("action");
    }

    if (dataKeys.isEmpty())
    {
        return false;
    }

    if (!json.contains("messages") ||
        !json.contains("warnings") ||
        !json.contains("errors"))
    {
        return false;
    }
    if (!json["messages"].isArray() ||
        !json["warnings"].isArray() ||
        !json["errors"].isArray())
    {
        return false;
    }

    foreach (const QString &amp;dataKey, dataKeys)
    {
        QJsonObject jsonData = json[dataKey].toObject();

        if (!jsonData.contains("html") || !jsonData.contains("status"))
        {
            return false;
        }

        if (!jsonData["status"].isString())
        {
            return false;
        }

        if (jsonData["html"].isString())
        {
            html = jsonData["html"].toString();
        }
        status = jsonData["status"].toString();
    }

    QJsonArray jsonMessages = json["messages"].toArray();
    QJsonArray jsonWarnings = json["warnings"].toArray();
    QJsonArray jsonErrors = json["errors"].toArray();

    for (int i=0;i&lt;jsonMessages.size();i++)
    {
        if (!jsonMessages.at(i).isString())
        {
            return false;
        }
        messages.append(jsonMessages.at(i).toString());
    }

    for (int i=0;i&lt;jsonWarnings.size();i++)
    {
        if (!jsonWarnings.at(i).isString())
        {
            return false;
        }
        warnings.append(jsonWarnings.at(i).toString());
    }

    for (int i=0;i&lt;jsonErrors.size();i++)
    {
        if (!jsonErrors.at(i).isString())
        {
            return false;
        }
        errors.append(jsonErrors.at(i).toString());
    }

    return true;
}
</t>
<t tx="leo.20201108101528.39">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rra_session.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th July 2016                                           *
 *                                                                   *
 *  DESCRIPTION: Remote Range API session class definition           *
 *********************************************************************/

#include &lt;QTimer&gt;

#include &lt;rblib.h&gt;

#include "rra_session.h"
#include "main_settings.h"
#include "usage_info.h"

const int RRASession::relaxInterval = 1000;
const int RRASession::timeoutInterval = 10000;

RRASession::RRASession(QObject *parent)
    : QObject(parent)
    , isRunning(false)
    , availableSoftwareVersion(RVendor::version)
    , loggedIn(false)
{
    this-&gt;networkAccessManager = new QNetworkAccessManager(this);

    this-&gt;rraRequestWorker = new RRARequestWorker(this-&gt;networkAccessManager,this);

    this-&gt;connect(this-&gt;rraRequestWorker,SIGNAL(availableSoftware(RVersion,QString,QString)),SLOT(onRraAvailableSoftware(RVersion,QString,QString)));
    QObject::connect(this-&gt;rraRequestWorker,&amp;RRARequestWorker::loginStatus,this,&amp;RRASession::onRraLoginStatus);
    QObject::connect(this-&gt;rraRequestWorker,&amp;RRARequestWorker::failed,this,&amp;RRASession::onRraFailed);
}

RRARequestInput::Type RRASession::getNextType(RRARequestInput::Type type)
{
    switch (type)
    {
        case RRARequestInput::AVAILABLE_SOFTWARE:
//            return RRARequestInput::LOGIN;
//        case RRARequestInput::LOGIN:
//            return RRARequestInput::LOGOUT;
//        case RRARequestInput::LOGOUT:
            return RRARequestInput::SEND_USAGE_INFO;
        case RRARequestInput::SEND_USAGE_INFO:
        default:
            return RRARequestInput::AVAILABLE_SOFTWARE;
    }
}

RRASession &amp;RRASession::getInstance()
{
    static RRASession rraSession;
    return rraSession;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.4">void ReportGenerator::generateTitle(void)
{
    RLogger::trace("void ReportGenerator::generateTitle(void)\n");
    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    QTextCursor cursor(this-&gt;docTitle);

    QTextBlockFormat blockFormat;
    blockFormat.setAlignment(Qt::AlignCenter);

    cursor.insertBlock(blockFormat);
    cursor.insertText("Analysis Report",ReportGenerator::getH1Format());
    cursor.insertBlock();
    cursor.insertText(rModel.getName(),ReportGenerator::getH2Format());
    cursor.insertBlock(blockFormat);
    std::vector&lt;RProblemType&gt; problemTypes = RProblem::getTypes(rModel.getProblemTaskTree().getProblemTypeMask());
    QString problemTypeList;
    for (uint i=0;i&lt;problemTypes.size();i++)
    {
        if (i &gt; 0)
        {
            problemTypeList += ", ";
        }
        problemTypeList += RProblem::getName(problemTypes[i]);
    }
    cursor.insertText(problemTypeList,ReportGenerator::getH3Format());
    cursor.insertBlock(blockFormat);
    cursor.insertBlock(blockFormat);
    cursor.insertText(QDateTime::currentDateTimeUtc().toLocalTime().toString("MMMM d, yyyy"),ReportGenerator::getTextFormat());
}

</t>
<t tx="leo.20201108101528.40">void RRASession::start(void)
{
    if (this-&gt;isRunning)
    {
        RLogger::warning("RRA Session is already running.\n");
        return;
    }
    QTimer::singleShot(RRASession::relaxInterval,Qt::VeryCoarseTimer,this,&amp;RRASession::submitNextRequest);
    this-&gt;isRunning = true;
}

</t>
<t tx="leo.20201108101528.41">void RRASession::stop(void)
{
    if (!this-&gt;isRunning)
    {
        RLogger::warning("RRA Session is not running.\n");
        return;
    }
    this-&gt;isRunning = false;
}

</t>
<t tx="leo.20201108101528.42">const RVersion &amp;RRASession::getAvailableSoftwareVersion(void) const
{
    return this-&gt;availableSoftwareVersion;
}

</t>
<t tx="leo.20201108101528.43">const QString &amp;RRASession::getAvailableSoftwareLink(void) const
{
    return this-&gt;availableSoftwareLink;
}

</t>
<t tx="leo.20201108101528.44">void RRASession::submitCrashReport(const QString &amp;crashReport)
{
    this-&gt;rraRequestWorker-&gt;sendCrashReport(crashReport);
}

</t>
<t tx="leo.20201108101528.45">void RRASession::submitNextRequest(void)
{
    if (!MainSettings::getInstancePtr()-&gt;getApplicationSettings()-&gt;getRangeApiAllowed())
    {
        if (this-&gt;isRunning)
        {
            QTimer::singleShot(RRASession::relaxInterval,Qt::VeryCoarseTimer,this,&amp;RRASession::submitNextRequest);
        }
        return;
    }

    switch (this-&gt;nextRequest)
    {
        case RRARequestInput::AVAILABLE_SOFTWARE:
        {
            this-&gt;rraRequestWorker-&gt;availableSoftware();
            break;
        }
        case RRARequestInput::LOGIN:
        {
            this-&gt;rraRequestWorker-&gt;logIn(MainSettings::getInstancePtr()-&gt;getApplicationSettings()-&gt;getRangeAccount(),
                                          MainSettings::getInstancePtr()-&gt;getApplicationSettings()-&gt;getRangePassword());
            break;
        }
        case RRARequestInput::LOGOUT:
        {
            this-&gt;rraRequestWorker-&gt;logOut(MainSettings::getInstancePtr()-&gt;getApplicationSettings()-&gt;getRangeAccount());
            break;
        }
        case RRARequestInput::SEND_USAGE_INFO:
        {
            if (MainSettings::getInstancePtr()-&gt;getApplicationSettings()-&gt;getSendUsageInfo())
            {
                this-&gt;rraRequestWorker-&gt;sendUsageInfo(UsageInfo::getInstance().getReport());
            }
            break;
        }
        case RRARequestInput::SEND_CRASH_REPORT:
        {
            break;
        }
    }

    this-&gt;nextRequest = RRASession::getNextType(this-&gt;nextRequest);
}

</t>
<t tx="leo.20201108101528.46">void RRASession::onRraAvailableSoftware(const RVersion &amp;version, const QString &amp;link, const QString &amp;responseMessage)
{
    if (!responseMessage.isEmpty())
    {
        RLogger::info("RRA response: %s\n",responseMessage.toUtf8().constData());
    }
    if (this-&gt;availableSoftwareVersion != version || this-&gt;availableSoftwareLink != link)
    {
        this-&gt;availableSoftwareVersion = version;
        this-&gt;availableSoftwareLink = link;
        RLogger::info("Latest available version: %s\n",this-&gt;availableSoftwareVersion.toString().toUtf8().constData());
        emit this-&gt;availableSoftware(this-&gt;availableSoftwareVersion,this-&gt;availableSoftwareLink);
    }
    QTimer::singleShot(RRASession::relaxInterval,Qt::VeryCoarseTimer,this,&amp;RRASession::submitNextRequest);
}

</t>
<t tx="leo.20201108101528.47">void RRASession::onRraLoginStatus(const QString &amp;status, bool loggedIn, const QString &amp;responseMessage)
{
    if (!responseMessage.isEmpty())
    {
        RLogger::info("RRA response: %s\n",responseMessage.toUtf8().constData());
    }
    if (this-&gt;loggedIn != loggedIn)
    {
        this-&gt;loggedIn = loggedIn;
        RLogger::info("%s\n",status.toUtf8().constData());
        if (this-&gt;loggedIn)
        {
            emit this-&gt;signedIn();
        }
        else
        {
            emit this-&gt;signedOut();
        }
    }
    QTimer::singleShot(RRASession::relaxInterval,Qt::VeryCoarseTimer,this,&amp;RRASession::submitNextRequest);
}

</t>
<t tx="leo.20201108101528.48">void RRASession::onRraFailed(RRARequestInput::Type type, const QString &amp;errorMessage)
{
    QString requestStr;

    switch (type)
    {
        case RRARequestInput::AVAILABLE_SOFTWARE:
        {
            requestStr = "available software";
            break;
        }
        case RRARequestInput::LOGIN:
        {
            requestStr = "log in";
            break;
        }
        case RRARequestInput::LOGOUT:
        {
            requestStr = "log out";
            break;
        }
        case RRARequestInput::SEND_USAGE_INFO:
        {
            requestStr = "usage info";
            break;
        }
        case RRARequestInput::SEND_CRASH_REPORT:
        {
            requestStr = "crash report";
            break;
        }
    }

    RLogger::error("Failed to process RRA request (%s): %s\n",requestStr.toUtf8().constData(),errorMessage.toUtf8().constData());

    QTimer::singleShot(RRASession::relaxInterval,Qt::VeryCoarseTimer,this,&amp;RRASession::submitNextRequest);
}
</t>
<t tx="leo.20201108101528.49">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   scalar_field_dialog.cpp                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Scalar field dialog class definition         *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include "session.h"
#include "scalar_field_dialog.h"

ScalarFieldDialog::ScalarFieldDialog(uint modelID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityID(RConstants::eod)
{
    this-&gt;createDialog();
}

ScalarFieldDialog::ScalarFieldDialog(uint modelID, uint entityID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityID(entityID)
{
    this-&gt;createDialog();
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.5">void ReportGenerator::generateBody(void)
{
    RLogger::trace("void ReportGenerator::generateBody(void)\n");
    this-&gt;generateModelChapter();
    this-&gt;generateProblemChapter();
    this-&gt;generateResultsChapter();
}

</t>
<t tx="leo.20201108101528.50">int ScalarFieldDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        RVariableType varType = this-&gt;getVariableType();
        QList&lt;SessionEntityID&gt; entities = this-&gt;modelTree-&gt;getSelected();

        if (varType != R_VARIABLE_NONE &amp;&amp; entities.size() &gt; 0)
        {
            Session::getInstance().storeCurentModelVersion(this-&gt;modelID,tr("Create scalar field"));

            if (this-&gt;entityID != RConstants::eod)
            {
                RScalarField &amp;scalarField = Session::getInstance().getModel(this-&gt;modelID).getScalarField(this-&gt;entityID);

                scalarField.clearElementGroupIDs();

                scalarField.setVariableType(varType);

                for (int i=0;i&lt;entities.size();i++)
                {
                    uint elementGroupId = Session::getInstance().getModel(this-&gt;modelID).getEntityGroupID(entities[i].getType(),
                                                                                                          entities[i].getEid());
                    if (elementGroupId == RConstants::eod)
                    {
                        continue;
                    }
                    scalarField.addElementGroupID(elementGroupId);
                }
                scalarField.setMaxPointSize(double(this-&gt;pointSizeSpin-&gt;value()));

                RLogger::info("Modified Scalar field \'%s\'\n",scalarField.getName().toUtf8().constData());
            }
            else
            {
                RScalarField scalarField;

                scalarField.setName(RVariable::getName(varType));
                scalarField.setVariableType(varType);

                for (int i=0;i&lt;entities.size();i++)
                {
                    uint elementGroupId = Session::getInstance().getModel(this-&gt;modelID).getElementGroupID(entities[i].getType(),
                                                                                                           entities[i].getEid());
                    scalarField.addElementGroupID(elementGroupId);
                }
                scalarField.setMaxPointSize(double(this-&gt;pointSizeSpin-&gt;value()));

                Session::getInstance().getModel(this-&gt;modelID).addScalarField(scalarField);
                RLogger::info("Created new Scalar field \'%s\'\n",scalarField.getName().toUtf8().constData());
            }

            Session::getInstance().setModelChanged(this-&gt;modelID);
        }
    }

    return retVal;
}

</t>
<t tx="leo.20201108101528.51">void ScalarFieldDialog::createDialog(void)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;resize(500,400);

    QString windowTitleStr = tr("Scalar field editor");
    this-&gt;setWindowTitle(tr(windowTitleStr.toUtf8().constData()));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);


    QLabel *titleLabel = new QLabel;
    if (this-&gt;entityID == RConstants::eod)
    {
        titleLabel-&gt;setText(tr("Create new Scalar field."));
    }
    else
    {
        titleLabel-&gt;setText(tr("Modify Scalar field:") + " &lt;b&gt;" + Session::getInstance().getModel(modelID).getScalarField(entityID).getName() + "&lt;/b&gt;");
    }

    uint rowCount = 0;

    mainLayout-&gt;addWidget(titleLabel, rowCount, 0, 1, 1);

    rowCount++;

    REntityGroupTypeMask typeMask = R_ENTITY_GROUP_POINT
                                  | R_ENTITY_GROUP_LINE
                                  | R_ENTITY_GROUP_SURFACE
                                  | R_ENTITY_GROUP_VOLUME
                                  | R_ENTITY_GROUP_CUT
                                  | R_ENTITY_GROUP_ISO
                                  | R_ENTITY_GROUP_STREAM_LINE;

    this-&gt;modelTree = new ModelTreeSimple(this-&gt;modelID,typeMask,this);
    if (this-&gt;entityID != RConstants::eod)
    {
        Model &amp;rModel = Session::getInstance().getModel(modelID);
        RScalarField &amp;rScalarField = rModel.getScalarField(entityID);
        const std::vector&lt;unsigned int&gt; groupIDs = rScalarField.getElementGroupIDs();
        this-&gt;modelTree-&gt;clearSelection();
        for (uint i=0;i&lt;groupIDs.size();i++)
        {
            REntityGroupType entityGroupType;
            uint entityIDNum;
            if (rModel.getEntityID(groupIDs[i],entityGroupType,entityIDNum))
            {
                this-&gt;modelTree-&gt;selectEntity(this-&gt;modelID,entityGroupType,entityIDNum);
            }
        }
    }

    mainLayout-&gt;addWidget(this-&gt;modelTree, rowCount, 0, 1, 1);

    QObject::connect(this-&gt;modelTree,
                     &amp;QTreeWidget::itemSelectionChanged,
                     this,
                     &amp;ScalarFieldDialog::onModelTreeSelectionChanged);

    this-&gt;variableTree = new QTreeWidget(this);
    this-&gt;variableTree-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;variableTree-&gt;setColumnCount(ScalarFieldDialog::NColumns);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(ScalarFieldDialog::Name,QString("Variables"));
    headerItem-&gt;setText(ScalarFieldDialog::Type,QString("type"));
    this-&gt;variableTree-&gt;setHeaderItem(headerItem);
    this-&gt;variableTree-&gt;setColumnHidden(ScalarFieldDialog::Type,true);

    Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    for (uint i=0;i&lt;rModel.getNVariables();i++)
    {
        RVariable &amp;rVariable = rModel.getVariable(i);

        QTreeWidgetItem *itemVariable = new QTreeWidgetItem(this-&gt;variableTree);
        itemVariable-&gt;setText(ScalarFieldDialog::Name, rVariable.getName());
        itemVariable-&gt;setData(ScalarFieldDialog::Type,Qt::DisplayRole,QVariant(rVariable.getType()));
        if (this-&gt;entityID != RConstants::eod)
        {
            RScalarField &amp;rScalarField = Session::getInstance().getModel(modelID).getScalarField(entityID);
            itemVariable-&gt;setSelected(rVariable.getType() == rScalarField.getVariableType());
        }
    }

    mainLayout-&gt;addWidget(this-&gt;variableTree, rowCount, 1, 1, 1);

    rowCount++;

    QObject::connect(this-&gt;variableTree,
                     &amp;QTreeWidget::itemSelectionChanged,
                     this,
                     &amp;ScalarFieldDialog::onVariableTreeSelectionChanged);

    QHBoxLayout *pointSizeLayout = new QHBoxLayout;
    mainLayout-&gt;addLayout(pointSizeLayout, rowCount, 0, 1, 2);

    QLabel *pointSizeLabel = new QLabel(tr("Point size in pixels:"));
    pointSizeLayout-&gt;addWidget(pointSizeLabel);

    this-&gt;pointSizeSpin = new QSpinBox;
//    this-&gt;pointSizeSpin-&gt;set
    this-&gt;pointSizeSpin-&gt;setMinimum(1);
    this-&gt;pointSizeSpin-&gt;setMaximum(100);
    if (this-&gt;entityID != RConstants::eod)
    {
        RScalarField &amp;rScalarField = Session::getInstance().getModel(modelID).getScalarField(entityID);
        this-&gt;pointSizeSpin-&gt;setValue(rScalarField.getMaxPointSize());
    }
    else
    {
        this-&gt;pointSizeSpin-&gt;setValue(5);
    }
    pointSizeLayout-&gt;addWidget(this-&gt;pointSizeSpin);

    rowCount++;

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, rowCount, 0, 1, 2);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());
    this-&gt;okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;ScalarFieldDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;ScalarFieldDialog::accept);
}

RVariableType ScalarFieldDialog::getVariableType(void) const
{
    QList&lt;QTreeWidgetItem*&gt; items = this-&gt;variableTree-&gt;selectedItems();

    if (items.size() == 0)
    {
        return R_VARIABLE_NONE;
    }

    return RVariableType(items[0]-&gt;data(ScalarFieldDialog::Type,Qt::DisplayRole).toInt());
}

</t>
<t tx="leo.20201108101528.52">void ScalarFieldDialog::onVariableTreeSelectionChanged(void)
{
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());
}

</t>
<t tx="leo.20201108101528.53">void ScalarFieldDialog::onModelTreeSelectionChanged()
{
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());
}
</t>
<t tx="leo.20201108101528.54">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   session.cpp                                              *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Session class definition                            *
 *********************************************************************/

#include &lt;QDesktopServices&gt;

#include "session.h"
#include "main_settings.h"
#include "model_io.h"
#include "job_manager.h"

Session::Session()
{
    RLogger::trace("Session::Session()\n");
    this-&gt;sessionID = QDateTime::currentDateTimeUtc().toString("yyyyMMddHHmmsszzz");
    this-&gt;downloadManager = new DownloadManager(this);
    this-&gt;drawEngine = new DrawEngine(this);

    QObject::connect(&amp;this-&gt;pickList,&amp;PickList::pickListChanged,this,&amp;Session::onPickListChanged);
    QObject::connect(this,&amp;Session::modelAdded,this,&amp;Session::onModelAdded);
    QObject::connect(this,&amp;Session::modelChanged,this,&amp;Session::onModelChanged);
    QObject::connect(MainSettings::getInstance().getApplicationSettings(),
                     &amp;ApplicationSettings::nHistoryRecordsChanged,
                     this,
                     &amp;Session::onNHistoryRecordsChanged);
}

Session &amp; Session::getInstance()
{
    // No trace - too many messages.
    static Session session;
    return session;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.55">const QString &amp;Session::getID() const
{
    return this-&gt;sessionID;
}

</t>
<t tx="leo.20201108101528.56">void Session::lock()
{
    RLogger::trace("void Session::lock()\n");
    this-&gt;mutex.lock();
}

</t>
<t tx="leo.20201108101528.57">bool Session::trylock(int timeout)
{
    RLogger::trace("bool Session::trylock(int timeout)\n");
    return this-&gt;mutex.tryLock(timeout);
}

</t>
<t tx="leo.20201108101528.58">void Session::unlock()
{
    RLogger::trace("void Session::unlock()\n");
    this-&gt;mutex.unlock();
}

DownloadManager *Session::getDownloadManager()
{
    RLogger::trace("DownloadManager *Session::getDownloadManager()\n");
    return this-&gt;downloadManager;
}

DrawEngine *Session::getDrawEngine()
{
    RLogger::trace("DrawEngine *Session::getDrawEngine()\n");
    return this-&gt;drawEngine;
}

</t>
<t tx="leo.20201108101528.59">const QString &amp;Session::getFileName() const
{
    RLogger::trace("const QString &amp;Session::getFileName() const\n");
    return this-&gt;fileName;
}

uint Session::getNModels() const
{
    RLogger::trace("uint Session::getNModels() const\n");
    return uint(this-&gt;models.size());
}

</t>
<t tx="leo.20201108101528.6">void ReportGenerator::generateModelChapter(void)
{
    RLogger::trace("void ReportGenerator::generateModelChapter(void)\n");

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    QTextCursor cursor(this-&gt;docBody);
    cursor.movePosition(QTextCursor::End);

    this-&gt;insertH1(cursor,QObject::tr("Model"));
    this-&gt;insertH2(cursor,QObject::tr("Mesh details"));

    QTextTableFormat tableFormat;
    tableFormat.setCellPadding(1);
    tableFormat.setCellSpacing(0);
    tableFormat.setBorder(1.0);
    tableFormat.setBorderStyle(QTextFrameFormat::BorderStyle_Solid);
    tableFormat.setAlignment(Qt::AlignCenter);

    cursor.insertTable(6, 2, tableFormat);

    this-&gt;insertText(cursor,QObject::tr("Number of nodes:"),true);
    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QString::number(rModel.getNNodes()),true);

    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QObject::tr("Number of elements:"),true);
    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QString::number(rModel.getNElements()),true);

    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QObject::tr("Number of point entities:"),true);
    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QString::number(rModel.getNPoints()),true);

    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QObject::tr("Number of line entities:"),true);
    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QString::number(rModel.getNLines()),true);

    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QObject::tr("Number of surface entities:"),true);
    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QString::number(rModel.getNSurfaces()),true);

    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QObject::tr("Number of volume entities:"),true);
    cursor.movePosition(QTextCursor::NextCell);
    this-&gt;insertText(cursor,QString::number(rModel.getNVolumes()),true);
}

</t>
<t tx="leo.20201108101528.60">const Model &amp; Session::getModel(uint position) const
{
//    RLogger::trace("const Model &amp; Session::getModel(uint position) const\n");
    return this-&gt;models[int(position)];
}

Model &amp; Session::getModel(uint position)
{
//    RLogger::trace("Model &amp; Session::getModel(uint position)\n");
    return this-&gt;models[int(position)];
}

</t>
<t tx="leo.20201108101528.61">const Model * Session::getModelPtr(uint position) const
{
    RLogger::trace("const Model * Session::getModelPtr(uint position) const\n");
    return &amp;this-&gt;models[int(position)];
}

Model * Session::getModelPtr(uint position)
{
    RLogger::trace("Model * Session::getModelPtr(uint position)\n");
    return &amp;this-&gt;models[int(position)];
}

</t>
<t tx="leo.20201108101528.62">void Session::addModel(const Model &amp;model)
{
    RLogger::trace("void Session::addModel(const Model &amp;model)\n");
    bool locked = this-&gt;trylock();
    this-&gt;models.push_back(model);
    this-&gt;models.last().initializeMeshInput();
    if (locked)
    {
        this-&gt;unlock();
    }
    emit this-&gt;modelAdded(uint(this-&gt;models.size()-1));
}

</t>
<t tx="leo.20201108101528.63">void Session::setModel(uint position, const Model &amp;model)
{
    RLogger::trace("void Session::setModel(uint position, const Model &amp;model)\n");
    bool locked = this-&gt;trylock();
    this-&gt;models[int(position)] = model;
    if (locked)
    {
        this-&gt;unlock();
    }
    this-&gt;setModelChanged(position);
}

</t>
<t tx="leo.20201108101528.64">void Session::removeModel(uint position)
{
    RLogger::trace("void Session::removeModel(uint position)\n");
    bool locked = this-&gt;trylock();
    this-&gt;models.removeAt(int(position));
    this-&gt;pickList.removeItems(position);
    if (locked)
    {
        this-&gt;unlock();
    }
    emit this-&gt;modelRemoved(position);
}

</t>
<t tx="leo.20201108101528.65">void Session::setModelSelected(uint modelID, bool selected)
{
    RLogger::trace("void Session::setModelSelected(uint modelID, bool selected)\n");
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNPoints();i++)
    {
        this-&gt;setEntitySelected(modelID,R_ENTITY_GROUP_POINT,i,selected,false);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNLines();i++)
    {
        this-&gt;setEntitySelected(modelID,R_ENTITY_GROUP_LINE,i,selected,false);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNSurfaces();i++)
    {
        this-&gt;setEntitySelected(modelID,R_ENTITY_GROUP_SURFACE,i,selected,false);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNVolumes();i++)
    {
        this-&gt;setEntitySelected(modelID,R_ENTITY_GROUP_VOLUME,i,selected,false);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNVectorFields();i++)
    {
        this-&gt;setEntitySelected(modelID,R_ENTITY_GROUP_VECTOR_FIELD,i,selected,false);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNScalarFields();i++)
    {
        this-&gt;setEntitySelected(modelID,R_ENTITY_GROUP_SCALAR_FIELD,i,selected,false);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNStreamLines();i++)
    {
        this-&gt;setEntitySelected(modelID,R_ENTITY_GROUP_STREAM_LINE,i,selected,false);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNCuts();i++)
    {
        this-&gt;setEntitySelected(modelID,R_ENTITY_GROUP_CUT,i,selected,false);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNIsos();i++)
    {
        this-&gt;setEntitySelected(modelID,R_ENTITY_GROUP_ISO,i,selected,false);
    }
    this-&gt;getModel(modelID).setSelected(selected);
    this-&gt;setModelSelectionChanged(modelID);
}

</t>
<t tx="leo.20201108101528.66">void Session::setEntitySelected(uint modelID, REntityGroupType elementGrpType, uint entityID, bool selected, bool notifyModel)
{
    RLogger::trace("void Session::setEntitySelected(uint modelID, REntityGroupType elementGrpType, uint entityID, bool selected, bool notifyModel)\n");
    if (this-&gt;getModel(modelID).getSelected(elementGrpType,entityID) != selected)
    {
        this-&gt;getModel(modelID).setSelected(elementGrpType,entityID,selected);
        emit this-&gt;entitySelectionChanged(modelID,elementGrpType,entityID,selected);
        if (notifyModel)
        {
            this-&gt;setModelSelectionChanged(modelID);
        }
    }
}

</t>
<t tx="leo.20201108101528.67">void Session::setEntityVisible(uint modelID, REntityGroupType elementGrpType, uint entityID, bool visible)
{
    RLogger::trace("void Session::setEntityVisible(uint modelID, REntityGroupType elementGrpType, uint entityID, bool visible)\n");
    if (this-&gt;getModel(modelID).getVisible(elementGrpType,entityID) != visible)
    {
        this-&gt;getModel(modelID).setVisible(elementGrpType,entityID,visible);
        emit this-&gt;entityVisibilityChanged(modelID,elementGrpType,entityID,visible);
        emit this-&gt;modelVisibilityChanged(modelID);
    }
}

</t>
<t tx="leo.20201108101528.68">void Session::setModelVisible(uint modelID, bool visible)
{
    RLogger::trace("void Session::setModelVisible(uint modelID, bool visible)\n");
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNPoints();i++)
    {
        this-&gt;setEntityVisible(modelID,R_ENTITY_GROUP_POINT,i,visible);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNLines();i++)
    {
        this-&gt;setEntityVisible(modelID,R_ENTITY_GROUP_LINE,i,visible);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNSurfaces();i++)
    {
        this-&gt;setEntityVisible(modelID,R_ENTITY_GROUP_SURFACE,i,visible);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNVolumes();i++)
    {
        this-&gt;setEntityVisible(modelID,R_ENTITY_GROUP_VOLUME,i,visible);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNVectorFields();i++)
    {
        this-&gt;setEntityVisible(modelID,R_ENTITY_GROUP_VECTOR_FIELD,i,visible);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNScalarFields();i++)
    {
        this-&gt;setEntityVisible(modelID,R_ENTITY_GROUP_SCALAR_FIELD,i,visible);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNStreamLines();i++)
    {
        this-&gt;setEntityVisible(modelID,R_ENTITY_GROUP_STREAM_LINE,i,visible);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNCuts();i++)
    {
        this-&gt;setEntityVisible(modelID,R_ENTITY_GROUP_CUT,i,visible);
    }
    for (uint i=0;i&lt;this-&gt;getModel(modelID).getNIsos();i++)
    {
        this-&gt;setEntityVisible(modelID,R_ENTITY_GROUP_ISO,i,visible);
    }
}

QList&lt;uint&gt; Session::getSelectedModelIDs() const
{
    RLogger::trace("QList&lt;uint&gt; Session::getSelectedModelIDs() const\n");
    QList&lt;uint&gt; selectedModelIDs;

    for (uint i=0;i&lt;this-&gt;getNModels();i++)
    {
        // Check if model is partialy selected (NOT completely unselected)
        if (!this-&gt;getModel(i).isSelected(false))
        {
            selectedModelIDs.push_back(i);
        }
    }

    return selectedModelIDs;
}

QList&lt;uint&gt; Session::getVisibleModelIDs() const
{
    RLogger::trace("QList&lt;uint&gt; Session::getVisibleModelIDs() const\n");
    QList&lt;uint&gt; visibleModelIDs;

    for (uint i=0;i&lt;this-&gt;getNModels();i++)
    {
        // Check if model is partialy visible (NOT completely unselected)
        if (!this-&gt;getModel(i).isVisible(false))
        {
            visibleModelIDs.push_back(i);
        }
    }

    return visibleModelIDs;
}

</t>
<t tx="leo.20201108101528.69">bool Session::isModelSelected(uint modelID)
{
//    RLogger::trace("bool Session::isModelSelected(uint modelID)\n");
    return (!this-&gt;getModel(modelID).isSelected(false));
}

QList&lt;SessionEntityID&gt; Session::getAllEntityIDs() const
{
    RLogger::trace("QList&lt;SessionEntityID&gt; Session::getAllEntityIDs() const\n");
    QList&lt;SessionEntityID&gt; allEntityIDs;

    for (uint i=0;i&lt;this-&gt;getNModels();i++)
    {
        allEntityIDs += this-&gt;getAllEntityIDs(i);
    }
    return allEntityIDs;
}

QList&lt;SessionEntityID&gt; Session::getAllEntityIDs(uint modelID) const
{
    RLogger::trace("QList&lt;SessionEntityID&gt; Session::getAllEntityIDs(uint modelID) const\n");
    QList&lt;SessionEntityID&gt; allEntityIDs;
    SessionEntityID entityID;

    entityID.setMid(modelID);

    entityID.setType(R_ENTITY_GROUP_POINT);
    for (uint j=0;j&lt;this-&gt;getModel(modelID).getNPoints();j++)
    {
        entityID.setEid(j);
        allEntityIDs.push_back(entityID);
    }

    entityID.setType(R_ENTITY_GROUP_LINE);
    for (uint j=0;j&lt;this-&gt;getModel(modelID).getNLines();j++)
    {
        entityID.setEid(j);
        allEntityIDs.push_back(entityID);
    }

    entityID.setType(R_ENTITY_GROUP_SURFACE);
    for (uint j=0;j&lt;this-&gt;getModel(modelID).getNSurfaces();j++)
    {
        entityID.setEid(j);
        allEntityIDs.push_back(entityID);
    }

    entityID.setType(R_ENTITY_GROUP_VOLUME);
    for (uint j=0;j&lt;this-&gt;getModel(modelID).getNVolumes();j++)
    {
        entityID.setEid(j);
        allEntityIDs.push_back(entityID);
    }

    entityID.setType(R_ENTITY_GROUP_VECTOR_FIELD);
    for (uint j=0;j&lt;this-&gt;getModel(modelID).getNVectorFields();j++)
    {
        entityID.setEid(j);
        allEntityIDs.push_back(entityID);
    }

    entityID.setType(R_ENTITY_GROUP_SCALAR_FIELD);
    for (uint j=0;j&lt;this-&gt;getModel(modelID).getNScalarFields();j++)
    {
        entityID.setEid(j);
        allEntityIDs.push_back(entityID);
    }

    entityID.setType(R_ENTITY_GROUP_STREAM_LINE);
    for (uint j=0;j&lt;this-&gt;getModel(modelID).getNStreamLines();j++)
    {
        entityID.setEid(j);
        allEntityIDs.push_back(entityID);
    }

    entityID.setType(R_ENTITY_GROUP_CUT);
    for (uint j=0;j&lt;this-&gt;getModel(modelID).getNCuts();j++)
    {
        entityID.setEid(j);
        allEntityIDs.push_back(entityID);
    }

    entityID.setType(R_ENTITY_GROUP_ISO);
    for (uint j=0;j&lt;this-&gt;getModel(modelID).getNIsos();j++)
    {
        entityID.setEid(j);
        allEntityIDs.push_back(entityID);
    }

    return allEntityIDs;
}

QList&lt;SessionEntityID&gt; Session::getSelectedEntityIDs() const
{
    RLogger::trace("QList&lt;SessionEntityID&gt; Session::getSelectedEntityIDs() const\n");
    QList&lt;SessionEntityID&gt; selectedEntityIDs;

    for (uint i=0;i&lt;this-&gt;getNModels();i++)
    {
        selectedEntityIDs += this-&gt;getModel(i).getSelectedEntityIDs(i);
    }
    return selectedEntityIDs;
}

QList&lt;SessionEntityID&gt; Session::getVisibleEntityIDs() const
{
    RLogger::trace("QList&lt;SessionEntityID&gt; Session::getVisibleEntityIDs() const\n");
    QList&lt;SessionEntityID&gt; visibleEntityIDs;

    for (uint i=0;i&lt;this-&gt;getNModels();i++)
    {
        visibleEntityIDs += this-&gt;getModel(i).getVisibleEntityIDs(i);
    }
    return visibleEntityIDs;
}

QList&lt;SessionEntityID&gt; Session::filterSelectedEntityIDs(const QList&lt;SessionEntityID&gt; selectedEntityIDs, uint modelID, REntityGroupTypeMask entityTypeMask)
{
    RLogger::trace("QList&lt;SessionEntityID&gt; Session::filterSelectedEntityIDs(const QList&lt;SessionEntityID&gt; selectedEntityIDs, uint modelID, REntityGroupTypeMask entityTypeMask)\n");
    QList&lt;SessionEntityID&gt; selectedEntities(selectedEntityIDs);

    for (int i=selectedEntities.size()-1;i&gt;=0;i--)
    {
        if (selectedEntities[i].getMid() == modelID
            &amp;&amp;
            selectedEntities[i].getType() &amp; entityTypeMask
            &amp;&amp;
            R_ENTITY_GROUP_TYPE_IS_ELEMENT(selectedEntities[i].getType()))
        {
            continue;
        }
        selectedEntities.erase(selectedEntities.begin()+i);
    }

    return selectedEntities;
}

uint Session::findModelByName(const QString &amp;modelName)
{
    RLogger::trace("uint Session::findModelByName(const QString &amp;modelName)\n");
    for (uint i=0;i&lt;this-&gt;getNModels();i++)
    {
        if (this-&gt;getModel(i).getName() == modelName)
        {
            return i;
        }
    }
    return RConstants::eod;
}

uint Session::findModelByPtr(const Model *pModel)
{
    RLogger::trace("uint Session::findModelByPtr(const Model *pModel)\n");
    for (uint i=0;i&lt;this-&gt;getNModels();i++)
    {
        if (this-&gt;getModelPtr(i) == pModel)
        {
            return i;
        }
    }
    return RConstants::eod;
}

</t>
<t tx="leo.20201108101528.7">void ReportGenerator::generateProblemChapter(void)
{
    RLogger::trace("void ReportGenerator::generateProblemChapter(void)\n");

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    QTextCursor cursor(this-&gt;docBody);
    cursor.movePosition(QTextCursor::End);

    this-&gt;insertH1(cursor,QObject::tr("Problem"));

//    RProblemTypeMask problemTypeMask = rModel.getProblemTaskTree().getProblemTypeMask();
//    if (problemTypeMask &amp; R_PROBLEM_RADIATIVE_HEAT)
//    {
//        this-&gt;insertH2(cursor,QObject::tr("Radiation setup"));
//        const RRadiationSetup &amp;radiationSetup = rModel.getProblemSetup().getRadiationSetup();
//        this-&gt;insertBold(cursor,QObject::tr("Resolution:"));
//        this-&gt;insertText(cursor,RRadiationSetup::getResolutionText(radiationSetup.getResolution()),true);
//    }

//    this-&gt;insertH2(cursor,QObject::tr("Time solver setup"));
//    const RTimeSolver &amp;timeSolver = rModel.getTimeSolver();

    this-&gt;insertH2(cursor,QObject::tr("Boundary conditions"));

    for (uint i=0;i&lt;rModel.getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = rModel.getElementGroupPtr(i);
        if (!pElementGroup)
        {
            continue;
        }

        uint nbc = pElementGroup-&gt;getNBoundaryConditions();
        if (nbc == 0)
        {
            continue;
        }

        this-&gt;insertH3(cursor,pElementGroup-&gt;getName());

        for (uint j=0;j&lt;nbc;j++)
        {
            const RBoundaryCondition &amp;bc = pElementGroup-&gt;getBoundaryCondition(j);

            this-&gt;insertH4(cursor,RBoundaryCondition::getName(bc.getType()));

            for (uint k=0;k&lt;bc.size();k++)
            {
                const RConditionComponent &amp;cc = bc.getComponent(k);

                cursor.insertTable(cc.size()+1,2,ReportGenerator::getTableFormat());

                this-&gt;insertBold(cursor,QObject::tr(cc.getKeyName().toUtf8().constData()) + " [" + cc.getKeyUnits() + "]",true);
                cursor.movePosition(QTextCursor::NextCell);

                this-&gt;insertBold(cursor,QObject::tr(cc.getValueName().toUtf8().constData()) + " [" + cc.getUnits() + "]",true);
                cursor.movePosition(QTextCursor::NextCell);

                for (uint l=0;l&lt;cc.size();l++)
                {
                    this-&gt;insertText(cursor,QString::number(cc.getKey(l)),true);
                    cursor.movePosition(QTextCursor::NextCell);

                    this-&gt;insertText(cursor,QString::number(cc.getValue(l)),true);
                    cursor.movePosition(QTextCursor::NextCell);
                }

                cursor.movePosition(QTextCursor::NextBlock);
            }

        }
    }

    this-&gt;insertH2(cursor,QObject::tr("Initial conditions"));

    for (uint i=0;i&lt;rModel.getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = rModel.getElementGroupPtr(i);
        if (!pElementGroup)
        {
            continue;
        }

        uint nic = pElementGroup-&gt;getNInitialConditions();
        if (nic == 0)
        {
            continue;
        }

        this-&gt;insertH3(cursor,pElementGroup-&gt;getName());

        for (uint j=0;j&lt;nic;j++)
        {
            const RInitialCondition &amp;ic = pElementGroup-&gt;getInitialCondition(j);

            this-&gt;insertH4(cursor,RInitialCondition::getName(ic.getType()));

            for (uint k=0;k&lt;ic.size();k++)
            {
                const RConditionComponent &amp;cc = ic.getComponent(k);

                cursor.insertTable(cc.size()+1,2,ReportGenerator::getTableFormat());

                this-&gt;insertBold(cursor,QObject::tr(cc.getKeyName().toUtf8().constData()) + " [" + cc.getKeyUnits() + "]",true);
                cursor.movePosition(QTextCursor::NextCell);

                this-&gt;insertBold(cursor,QObject::tr(cc.getValueName().toUtf8().constData()) + " [" + cc.getUnits() + "]",true);
                cursor.movePosition(QTextCursor::NextCell);

                for (uint l=0;l&lt;cc.size();l++)
                {
                    this-&gt;insertText(cursor,QString::number(cc.getKey(l)),true);
                    cursor.movePosition(QTextCursor::NextCell);

                    this-&gt;insertText(cursor,QString::number(cc.getValue(l)),true);
                    cursor.movePosition(QTextCursor::NextCell);
                }

                cursor.movePosition(QTextCursor::NextBlock);
            }

        }
    }

    this-&gt;insertH2(cursor,QObject::tr("Environment conditions"));

    for (uint i=0;i&lt;rModel.getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = rModel.getElementGroupPtr(i);
        if (!pElementGroup)
        {
            continue;
        }

        uint nec = pElementGroup-&gt;getNEnvironmentConditions();
        if (nec == 0)
        {
            continue;
        }

        this-&gt;insertH3(cursor,pElementGroup-&gt;getName());

        for (uint j=0;j&lt;nec;j++)
        {
            const REnvironmentCondition &amp;ec = pElementGroup-&gt;getEnvironmentCondition(j);

            this-&gt;insertH4(cursor,REnvironmentCondition::getName(ec.getType()));

            for (uint k=0;k&lt;ec.size();k++)
            {
                const RConditionComponent &amp;cc = ec.getComponent(k);

                cursor.insertTable(cc.size()+1,2,ReportGenerator::getTableFormat());

                this-&gt;insertBold(cursor,QObject::tr(cc.getKeyName().toUtf8().constData()) + " [" + cc.getKeyUnits() + "]",true);
                cursor.movePosition(QTextCursor::NextCell);

                this-&gt;insertBold(cursor,QObject::tr(cc.getValueName().toUtf8().constData()) + " [" + cc.getUnits() + "]",true);
                cursor.movePosition(QTextCursor::NextCell);

                for (uint l=0;l&lt;cc.size();l++)
                {
                    this-&gt;insertText(cursor,QString::number(cc.getKey(l)),true);
                    cursor.movePosition(QTextCursor::NextCell);

                    this-&gt;insertText(cursor,QString::number(cc.getValue(l)),true);
                    cursor.movePosition(QTextCursor::NextCell);
                }

                cursor.movePosition(QTextCursor::NextBlock);
            }
        }
    }

    this-&gt;insertH2(cursor,QObject::tr("Materials"));

    for (uint i=0;i&lt;rModel.getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = rModel.getElementGroupPtr(i);
        if (!pElementGroup)
        {
            continue;
        }

        this-&gt;insertH3(cursor,pElementGroup-&gt;getName());

        const RMaterial &amp;material = pElementGroup-&gt;getMaterial();

        this-&gt;insertH4(cursor,material.getName());

        for (uint k=0;k&lt;material.size();k++)
        {
            const RMaterialProperty &amp;materialProperty = material.get(k);

            this-&gt;insertH5(cursor,QObject::tr(materialProperty.getValueName().toUtf8().constData()));

            cursor.insertTable(materialProperty.size()+1,2,ReportGenerator::getTableFormat());

            this-&gt;insertBold(cursor,QObject::tr(materialProperty.getKeyName().toUtf8().constData()) + " [" + materialProperty.getKeyUnits() + "]",true);
            cursor.movePosition(QTextCursor::NextCell);

            this-&gt;insertBold(cursor,QObject::tr(materialProperty.getValueName().toUtf8().constData()) + " [" + materialProperty.getUnits() + "]",true);
            cursor.movePosition(QTextCursor::NextCell);

            for (uint l=0;l&lt;materialProperty.size();l++)
            {
                this-&gt;insertText(cursor,QString::number(materialProperty.getKey(l)),true);
                cursor.movePosition(QTextCursor::NextCell);

                this-&gt;insertText(cursor,QString::number(materialProperty.getValue(l)),true);
                cursor.movePosition(QTextCursor::NextCell);
            }

            cursor.movePosition(QTextCursor::NextBlock);
        }
    }
}

</t>
<t tx="leo.20201108101528.70">void Session::setModelSelectionChanged(uint modelID)
{
    RLogger::trace("void Session::setModelSelectionChanged(uint modelID)\n");
    emit this-&gt;modelSelectionChanged(modelID);
}

</t>
<t tx="leo.20201108101528.71">void Session::setDisplayPropertiesChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)
{
    RLogger::trace("void Session::setDisplayPropertiesChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)\n");
    emit this-&gt;displayPropertiesChanged(modelID,elementGrpType,entityID);
}

</t>
<t tx="leo.20201108101528.72">void Session::setModelChanged(uint modelID)
{
    RLogger::trace("void Session::setModelChanged(uint modelID)\n");
    emit this-&gt;modelChanged(modelID);
}

</t>
<t tx="leo.20201108101528.73">void Session::setModelRenamed(uint modelID)
{
    RLogger::trace("void Session::setModelRenamed(uint modelID)\n");
    emit this-&gt;modelRenamed(modelID);
}

</t>
<t tx="leo.20201108101528.74">void Session::setProblemChanged(uint modelID)
{
    RLogger::trace("void Session::setProblemChanged(uint modelID)\n");
    emit this-&gt;problemChanged(modelID);
}

</t>
<t tx="leo.20201108101528.75">void Session::setProblemSelectionChanged(uint modelID)
{
    RLogger::trace("void Session::setProblemSelectionChanged(uint modelID)\n");
    emit this-&gt;problemSelectionChanged(modelID);
}

</t>
<t tx="leo.20201108101528.76">void Session::setResultsChanged(uint modelID)
{
    RLogger::trace("void Session::setResultsChanged(uint modelID)\n");
    emit this-&gt;resultsChanged(modelID);
}

</t>
<t tx="leo.20201108101528.77">void Session::setBoundaryConditionChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)
{
    RLogger::trace("void Session::setBoundaryConditionChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)\n");
    emit this-&gt;boundaryConditionChanged(modelID,elementGrpType,entityID);
}

</t>
<t tx="leo.20201108101528.78">void Session::setInitialConditionChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)
{
    RLogger::trace("void Session::setInitialConditionChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)\n");
    emit this-&gt;initialConditionChanged(modelID,elementGrpType,entityID);
}

</t>
<t tx="leo.20201108101528.79">void Session::setEnvironmentConditionChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)
{
    RLogger::trace("void Session::setEnvironmentConditionChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)\n");
    emit this-&gt;environmentConditionChanged(modelID,elementGrpType,entityID);
}

</t>
<t tx="leo.20201108101528.8">void ReportGenerator::generateResultsChapter(void)
{
    RLogger::trace("void ReportGenerator::generateResultsChapter(void)\n");

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    QTextCursor cursor(this-&gt;docBody);
    cursor.movePosition(QTextCursor::End);

    this-&gt;insertH1(cursor,QObject::tr("Results"));

    this-&gt;insertBold(cursor,QObject::tr("Time-solver:"));
    this-&gt;insertText(cursor," " + QObject::tr(rModel.getTimeSolver().getEnabled() ? "enabled" : "disabled"),true);

    if (rModel.getTimeSolver().getEnabled())
    {
        this-&gt;insertBold(cursor,QObject::tr("Current time step:"));
        this-&gt;insertText(cursor," " + QString::number(rModel.getTimeSolver().getCurrentTimeStep()+1),true);
        this-&gt;insertBold(cursor,QObject::tr("Current computational time:"));
        this-&gt;insertText(cursor," " + QString::number(rModel.getTimeSolver().getCurrentTime()) + " [" + RVariable::getUnits(R_VARIABLE_TIME) + "]",true);
    }
    else
    {
        if (rModel.getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_STRESS_MODAL)
        {
            this-&gt;insertBold(cursor,QObject::tr("Current mode:"));
            this-&gt;insertText(cursor," " + QString::number(rModel.getProblemSetup().getModalSetup().getMode()+1),true);
            this-&gt;insertBold(cursor,QObject::tr("Current frequency:"));
            this-&gt;insertText(cursor," " + QString::number(rModel.getProblemSetup().getModalSetup().getFrequency()) + " [" + RVariable::getUnits(R_VARIABLE_FREQUENCY) + "]",true);
        }
    }

//    const RMonitoringPointManager &amp;monitoringPointManager = rModel.getMonitoringPointManager();

//    if (monitoringPointManager.size() &gt; 0)
//    {
//        this-&gt;insertH2(cursor,QObject::tr("Monitoring points"));

//        for (uint i=0;i&lt;monitoringPointManager.size();i++)
//        {
//            const RMonitoringPoint &amp;monitoringPoint = monitoringPointManager.at(i);
////            monitoringPoint.g
//        }
//    }

    this-&gt;insertH2(cursor,QObject::tr("Variables"));

    for (uint i=0;i&lt;rModel.getNVariables();i++)
    {
        const RVariable &amp;rVariable = rModel.getVariable(i);
        this-&gt;insertH3(cursor,rVariable.getName());

        QTextBlockFormat blockFormat;
        blockFormat.setIndent(2);

        QTextBlockFormat rightAlignment;
        rightAlignment.setAlignment(Qt::AlignRight);

        QTextTableFormat tableFormat;
        tableFormat.setCellPadding(1);
        tableFormat.setCellSpacing(0);
        tableFormat.setBorder(0.0);
        tableFormat.setHeaderRowCount(0);
        tableFormat.setBorderStyle(QTextFrameFormat::BorderStyle_None);
        tableFormat.setAlignment(Qt::AlignCenter);

        RStatistics stat(rVariable.getValues(),100,true);

        cursor.insertTable(8,2,tableFormat);

        this-&gt;insertBold(cursor,QObject::tr("Variable type:"),true);
        cursor.movePosition(QTextCursor::NextCell);
        cursor.setBlockFormat(rightAlignment);
        this-&gt;insertText(cursor,QObject::tr(rVariable.getNVectors() == 1 ? "Scalar" : "Vector"),true);
        cursor.movePosition(QTextCursor::NextCell);

        this-&gt;insertBold(cursor,QObject::tr("Units:"),true);
        cursor.movePosition(QTextCursor::NextCell);
        cursor.setBlockFormat(rightAlignment);
        this-&gt;insertText(cursor,rVariable.getUnits(),true);
        cursor.movePosition(QTextCursor::NextCell);

        this-&gt;insertBold(cursor,QObject::tr("Minimum:"),true);
        cursor.movePosition(QTextCursor::NextCell);
        cursor.setBlockFormat(rightAlignment);
        this-&gt;insertText(cursor,QString::number(stat.getMin()),true);
        cursor.movePosition(QTextCursor::NextCell);

        this-&gt;insertBold(cursor,QObject::tr("Maximum:"),true);
        cursor.movePosition(QTextCursor::NextCell);
        cursor.setBlockFormat(rightAlignment);
        this-&gt;insertText(cursor,QString::number(stat.getMax()),true);
        cursor.movePosition(QTextCursor::NextCell);

        this-&gt;insertBold(cursor,QObject::tr("Average:"),true);
        cursor.movePosition(QTextCursor::NextCell);
        cursor.setBlockFormat(rightAlignment);
        this-&gt;insertText(cursor,QString::number(stat.getAvg()),true);
        cursor.movePosition(QTextCursor::NextCell);

        this-&gt;insertBold(cursor,QObject::tr("Median:"),true);
        cursor.movePosition(QTextCursor::NextCell);
        cursor.setBlockFormat(rightAlignment);
        this-&gt;insertText(cursor,QString::number(stat.getMed()),true);
        cursor.movePosition(QTextCursor::NextCell);

        this-&gt;insertBold(cursor,QObject::tr("Percentile 5:"),true);
        cursor.movePosition(QTextCursor::NextCell);
        cursor.setBlockFormat(rightAlignment);
        this-&gt;insertText(cursor,QString::number(stat.getP05()),true);
        cursor.movePosition(QTextCursor::NextCell);

        this-&gt;insertBold(cursor,QObject::tr("Percentile 95:"),true);
        cursor.movePosition(QTextCursor::NextCell);
        cursor.setBlockFormat(rightAlignment);
        this-&gt;insertText(cursor,QString::number(stat.getP95()),true);
        cursor.movePosition(QTextCursor::NextCell);

        cursor.movePosition(QTextCursor::NextBlock);
    }

    this-&gt;insertH2(cursor,QObject::tr("Screenshot"));

    QTextBlockFormat blockFormat;
    blockFormat.setAlignment(Qt::AlignCenter);
    cursor.insertBlock(blockFormat);
    QImage modelScreenShotImage(this-&gt;takeModelScreenshot());
    cursor.insertImage(modelScreenShotImage.scaledToWidth(qCeil(double(this-&gt;printer-&gt;pageRect().width())*0.9),Qt::SmoothTransformation));
}

QImage ReportGenerator::takeModelScreenshot(void) const
{
    RLogger::trace("QImage ReportGenerator::takeModelScreenshot(void)\n");

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);
    QString screenShotFile(rModel.buildScreenShotFileName());

    Session::getInstance().setTakeScreenShot(this-&gt;modelID,screenShotFile,true);

    return QImage(screenShotFile);
}
</t>
<t tx="leo.20201108101528.80">void Session::setMaterialChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)
{
    RLogger::trace("void Session::setMaterialChanged(uint modelID, REntityGroupType elementGrpType, uint entityID)\n");
    emit this-&gt;materialChanged(modelID,elementGrpType,entityID);
}

</t>
<t tx="leo.20201108101528.81">void Session::setVariableDataChanged(uint modelID, RVariableType variableType)
{
    RLogger::trace("void Session::setVariableDataChanged(uint modelID, RVariableType variableType)\n");
    emit this-&gt;variableDataChanged(modelID,variableType);
}

</t>
<t tx="leo.20201108101528.82">void Session::setVariableDataChanged(const SessionEntityID &amp;entityID, RVariableType variableType)
{
    RLogger::trace("void Session::setVariableDataChanged(const SessionEntityID &amp;entityID, RVariableType variableType)\n");
    emit this-&gt;variableDataChanged(entityID,variableType);
}

</t>
<t tx="leo.20201108101528.83">const PickList &amp;Session::getPickList() const
{
    RLogger::trace("const PickList &amp;Session::getPickList() const\n");
    return this-&gt;pickList;
}

PickList &amp;Session::getPickList()
{
    RLogger::trace("PickList &amp;Session::getPickList()\n");
    return this-&gt;pickList;
}

</t>
<t tx="leo.20201108101528.84">void Session::setBeginDrawStreamLinePosition(const RR3Vector &amp;position)
{
    RLogger::trace("void Session::setBeginDrawStreamLinePosition(const RR3Vector &amp;position)\n");
    emit this-&gt;beginDrawStreamLinePosition(position);
}

</t>
<t tx="leo.20201108101528.85">void Session::setEndDrawStreamLinePosition()
{
    RLogger::trace("void Session::setEndDrawStreamLinePosition()\n");
    emit this-&gt;endDrawStreamLinePosition();
}

</t>
<t tx="leo.20201108101528.86">void Session::setBeginDrawScaleOrigin(const RR3Vector &amp;position)
{
    RLogger::trace("void Session::setBeginDrawScaleOrigin(const RR3Vector &amp;position)\n");
    emit this-&gt;beginDrawScaleOrigin(position);
}

</t>
<t tx="leo.20201108101528.87">void Session::setEndDrawScaleOrigin()
{
    RLogger::trace("void Session::setEndDrawScaleOrigin()\n");
    emit this-&gt;endDrawScaleOrigin();
}

</t>
<t tx="leo.20201108101528.88">void Session::setBeginDrawRotationOrigin(const RR3Vector &amp;position)
{
    RLogger::trace("void Session::setBeginDrawRotationOrigin(const RR3Vector &amp;position)\n");
    emit this-&gt;beginDrawRotationOrigin(position);
}

</t>
<t tx="leo.20201108101528.89">void Session::setEndDrawRotationOrigin()
{
    RLogger::trace("void Session::setEndDrawRotationOrigin()\n");
    emit this-&gt;endDrawRotationOrigin();
}

</t>
<t tx="leo.20201108101528.9">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   results_variable_selector.cpp                            *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   18-th March 2013                                         *
 *                                                                   *
 *  DESCRIPTION: Results variable selector class definition          *
 *********************************************************************/

#include "results_variable_selector.h"
#include "session.h"

ResultsVariableSelector::ResultsVariableSelector(QWidget *parent) :
    VariableSelector(std::vector&lt;RVariableType&gt;(),parent)
{
    this-&gt;populate();

    QObject::connect(&amp;Session::getInstance(),&amp;Session::modelAdded,this,&amp;ResultsVariableSelector::onResultsChanged);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::modelRemoved,this,&amp;ResultsVariableSelector::onResultsChanged);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::resultsChanged,this,&amp;ResultsVariableSelector::onResultsChanged);
    QObject::connect(&amp;Session::getInstance(),&amp;Session::modelSelectionChanged,this,&amp;ResultsVariableSelector::onResultsChanged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101528.90">void Session::setBeginDrawLocalDirections(const QList&lt;RLocalDirection&gt; &amp;localDirections)
{
    RLogger::trace("void Session::setBeginDrawLocalDirections(const QList&lt;RLocalDirection&gt; &amp;localDirections)\n");
    emit this-&gt;beginDrawLocalDirections(localDirections);
}

</t>
<t tx="leo.20201108101528.91">void Session::setEndDrawLocalDirections()
{
    RLogger::trace("void Session::setEndDrawLocalDirections()\n");
    emit this-&gt;endDrawLocalDirections();
}

</t>
<t tx="leo.20201108101528.92">void Session::setBeginDrawCutPlane(const RPlane &amp;plane)
{
    RLogger::trace("void Session::setBeginDrawCutPlane(const RPlane &amp;plane)\n");
    emit this-&gt;beginDrawCutPlane(plane);
}

</t>
<t tx="leo.20201108101528.93">void Session::setEndDrawCutPlane()
{
    RLogger::trace("void Session::setEndDrawCutPlane()\n");
    emit this-&gt;endDrawCutPlane();
}

</t>
<t tx="leo.20201108101528.94">void Session::setBeginDrawMoveNodes(const QMap&lt;SessionNodeID, RR3Vector&gt; &amp;nodesToMove)
{
    RLogger::trace("void Session::setBeginDrawMoveNodes(const QMap&lt;SessionNodeID, RR3Vector&gt; &amp;nodesToMove)\n");
    emit this-&gt;beginDrawMoveNodes(nodesToMove);
}

</t>
<t tx="leo.20201108101528.95">void Session::setEndDrawMoveNodes()
{
    RLogger::trace("void Session::setEndDrawMoveNodes()\n");
    emit this-&gt;endDrawMoveNodes();
}

</t>
<t tx="leo.20201108101528.96">void Session::setTakeScreenShot(uint modelID, const QString &amp;screenShotFileName, bool blocking)
{
    RLogger::trace("void Session::setTakeScreenShot(uint modelID, const QString &amp;screenShotFileName, bool blocking)\n");
    if (blocking)
    {
        emit this-&gt;takeScreenShotBlocking(modelID, screenShotFileName);
    }
    else
    {
        emit this-&gt;takeScreenShot(modelID, screenShotFileName);
    }
}

</t>
<t tx="leo.20201108101528.97">void Session::readModels(const QStringList &amp;fileNames)
{
    RLogger::info("Loading %u files\n",fileNames.size());
    RLogger::indent();
    for (int i=0;i&lt;fileNames.size();i++)
    {
        RLogger::info("Loading %u: \'%s\'\n",i+1,fileNames.at(i).toUtf8().constData());

        if (!fileNames.at(i).isEmpty())
        {
            // Read model.
            ModelIO *modelIO = new ModelIO(MODEL_IO_OPEN, fileNames.at(i));
            modelIO-&gt;setAutoDelete(true);

            JobManager::getInstance().submit(modelIO);
        }
    }
    RLogger::unindent();
}

</t>
<t tx="leo.20201108101528.98">void Session::read(const QString &amp;fileName)
{
    RLogger::trace("void Session::read(const QString &amp;fileName)\n");
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Reading session file \'%s\'.\n",fileName.toUtf8().constData());
    RLogger::indent();

    this-&gt;fileName = fileName;

    RFile sessionFile(this-&gt;fileName,RFile::ASCII);

    if (!sessionFile.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        RLogger::unindent();
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",this-&gt;fileName.toUtf8().constData());
    }

    RLogger::info("Reading session file records.\n");
    RLogger::indent();

    uint nModels = 0;
    RFileIO::readAscii(sessionFile,nModels);
    RLogger::info("Detected %u file records.\n",nModels);
    QStringList modelFileNames;
    for (uint i=0;i&lt;nModels;i++)
    {
        QString modelFileName;
        RFileIO::readAscii(sessionFile,modelFileName);

        if (modelFileName.isEmpty())
        {
            RLogger::info("File record %u is empty.\n",i+1);
        }
        else
        {
            RLogger::info("File record %u \'%s\'\n",i+1,modelFileName.toUtf8().constData());
            modelFileNames.append(modelFileName);
        }
    }
    RLogger::unindent();

    sessionFile.close();

    this-&gt;readModels(modelFileNames);

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101528.99">void Session::write(const QString &amp;fileName, bool writeModels)
{
    RLogger::trace("void Session::write(const QString &amp;fileName, bool writeModels)\n");
    RLogger::info("Writing session file \'%s\'.\n",fileName.toUtf8().constData());

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    this-&gt;fileName = fileName;

    RSaveFile sessionFile(this-&gt;fileName,RSaveFile::ASCII);

    if (!sessionFile.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",this-&gt;fileName.toUtf8().constData());
    }

    RFileIO::writeAscii(sessionFile,this-&gt;getNModels(),true);
    for (uint i=0;i&lt;this-&gt;getNModels();i++)
    {
        RFileIO::writeAscii(sessionFile,"\"" + this-&gt;getModel(i).getFileName() + "\"",true);

        if (writeModels)
        {
            if (this-&gt;getModel(i).getFileName().isEmpty())
            {
                QDir dataDir(MainSettings::getInstancePtr()-&gt;getDataDir());
                QString binaryExtension = RModel::getDefaultFileExtension(true);
                QString modelName = this-&gt;getModel(i).getName();
                if (modelName.length() == 0)
                {
                    modelName = "Model_" + QString::number(i+1);
                }
                QString modelFileName = dataDir.filePath(modelName + "." + binaryExtension);
                this-&gt;getModel(i).setFileName(modelFileName);
            }

            // Write model.
            ModelIO *modelIO = new ModelIO(MODEL_IO_SAVE, this-&gt;getModel(i).getFileName(), this-&gt;getModelPtr(i));
            modelIO-&gt;setAutoDelete(true);

            JobManager::getInstance().submit(modelIO);
        }
    }

    sessionFile.commit();
}

</t>
<t tx="leo.20201108101529.1">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   solver_process.cpp                                       *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   10-th December 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Solver process class definition                     *
 *********************************************************************/

#include &lt;rmlib.h&gt;

#include "solver_process.h"

SolverProcess::SolverProcess(QObject *parent) :
    QProcess(parent)
{
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.10">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   solver_task.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   10-th December 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Solver task class definition                        *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "model_io.h"
#include "solver_manager.h"
#include "solver_process.h"
#include "solver_task.h"
#include "session.h"
#include "main_settings.h"

SolverTask::SolverTask(const ApplicationSettings *applicationSettings, uint modelID, QObject *parent)
    : Job(parent)
    , applicationSettings(applicationSettings)
    , modelID(modelID)
    , solverProcess(0)
{
    this-&gt;taskID.generate();
    this-&gt;solverExecutable = applicationSettings-&gt;getSolverPath();

    Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    QFileInfo modelFileInfo(rModel.getFileName());

    this-&gt;modelFileName = modelFileInfo.absoluteFilePath();
    this-&gt;logFileName = rModel.buildTmpFileName("log",this-&gt;taskID.toString());
    this-&gt;convergenceFileName = rModel.buildTmpFileName("cvg",this-&gt;taskID.toString());
    this-&gt;monitoringFileName = rModel.buildTmpFileName("mon",this-&gt;taskID.toString());

    this-&gt;solverArguments.append("--file=" + this-&gt;modelFileName);
    this-&gt;solverArguments.append("--log-file=" + this-&gt;logFileName);
    this-&gt;solverArguments.append("--convergence-file=" + this-&gt;convergenceFileName);
    this-&gt;solverArguments.append("--monitoring-file=" + this-&gt;monitoringFileName);
    this-&gt;solverArguments.append("--nthreads=" + QString::number(this-&gt;applicationSettings-&gt;getNThreads()));
    this-&gt;solverArguments.append("--task-id=" + this-&gt;taskID.toString());
    this-&gt;solverArguments.append("--task-server=" + SolverManager::getInstance().getTaskServerName());
}

uint SolverTask::getModelID(void) const
{
    return this-&gt;modelID;
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.11">const SolverTaskID &amp;SolverTask::getTaskID(void) const
{
    return this-&gt;taskID;
}

SolverTaskID &amp;SolverTask::getTaskID(void)
{
    return this-&gt;taskID;
}

</t>
<t tx="leo.20201108101529.12">const QString SolverTask::getStopCommand(void) const
{
    return QString(this-&gt;taskID.toString() + ":STOP");
}

</t>
<t tx="leo.20201108101529.13">void SolverTask::kill(void)
{
    RLogger::info("Killing solver task (#%s).\n",this-&gt;taskID.toString().toUtf8().constData());
    this-&gt;solverProcess-&gt;kill();
}

</t>
<t tx="leo.20201108101529.14">const QString &amp;SolverTask::getLogFileName(void) const
{
    return this-&gt;logFileName;
}

QString SolverTask::getCommandLine(void) const
{
    QString cmdLine = this-&gt;solverExecutable;
    for (int i=0;i&lt;this-&gt;solverArguments.size();i++)
    {
        cmdLine += QString(" \"") + this-&gt;solverArguments.at(i) + QString("\"");
    }
    return cmdLine;
}

</t>
<t tx="leo.20201108101529.15">void SolverTask::run(void)
{
    try
    {
        Session::getInstance().storeCurentModelVersion(this-&gt;modelID,tr("Execute solver task"));

        RLogger::info("Solver task (#%s) - Begin\n",this-&gt;taskID.toString().toUtf8().constData());
        RLogger::indent();

        Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);
        QString modelFileName(RFileManager::getFileNameWithOutTimeStep(rModel.getFileName()));

        // Save model first.
        try
        {
            emit this-&gt;isBlocking(true);
            ModelIO::save(rModel,modelFileName,false);
            emit this-&gt;isBlocking(false);
        }
        catch (const RError &amp;error)
        {
            RLogger::error("%s File: '%s'\n",
                           error.getMessage().toUtf8().constData(),
                           modelFileName.toUtf8().constData());
            emit this-&gt;isBlocking(false);
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to start the solver because model could not be saved.");
        }

        // Execute solver
        QString cmdLine = this-&gt;getCommandLine();

        RLogger::info("Executing \'%s\'\n",cmdLine.toUtf8().constData());

        this-&gt;solverProcess = new SolverProcess(this);

        QObject::connect(this-&gt;solverProcess,
                         &amp;SolverProcess::readyReadStandardOutput,
                         this,
                         &amp;SolverTask::onProcessReadyReadStandardOutput);
        QObject::connect(this-&gt;solverProcess,
                         &amp;SolverProcess::readyReadStandardError,
                         this,
                         &amp;SolverTask::onProcessReadyReadStandardError);

        this-&gt;solverProcess-&gt;start(this-&gt;solverExecutable,this-&gt;solverArguments);

        if (!this-&gt;solverProcess-&gt;waitForFinished(-1) || this-&gt;solverProcess-&gt;exitCode() != 0)
        {
            RLogger::warning("Command \'%s\' failed with exit code = %d.\n",
                             cmdLine.toUtf8().constData(),
                             this-&gt;solverProcess-&gt;exitCode());

            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Solver execution failed.");
        }

        RLogger::info("Command \'%s\' succesfully finished.\n",cmdLine.toUtf8().constData());

        // Update model.
        try
        {
            emit this-&gt;isBlocking(true);
            ModelIO::update(rModel,modelFileName);
            emit this-&gt;isBlocking(false);
        }
        catch (const RError &amp;error)
        {
            RLogger::error("%s File: '%s'\n",
                           error.getMessage().toUtf8().constData(),
                           modelFileName.toUtf8().constData());
            emit this-&gt;isBlocking(false);
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to finish the solver because model could not be opened.");
        }

        RLogger::unindent();
        RLogger::info("Solver task (#%s) - End\n",this-&gt;taskID.toString().toUtf8().constData());

        Session::getInstance().setModelChanged(this-&gt;modelID);
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Solver task (#%s) failed: %s\n",this-&gt;taskID.toString().toUtf8().constData(),error.getMessage().toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101529.16">void SolverTask::onProcessReadyReadStandardOutput(void)
{
    emit this-&gt;readyReadStandardOutput(QString::fromLocal8Bit(this-&gt;solverProcess-&gt;readAllStandardOutput()));
}

</t>
<t tx="leo.20201108101529.17">void SolverTask::onProcessReadyReadStandardError(void)
{
    emit this-&gt;readyReadStandardError(QString::fromLocal8Bit(this-&gt;solverProcess-&gt;readAllStandardError()));
}
</t>
<t tx="leo.20201108101529.18">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   solver_task_id.cpp                                       *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   16-th August 2013                                        *
 *                                                                   *
 *  DESCRIPTION: Solver task ID class definition                     *
 *********************************************************************/

#include &lt;QDateTime&gt;

#include "solver_task_id.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.19">void SolverTaskID::_init(const SolverTaskID *pSolverTaskID)
{
    if (pSolverTaskID)
    {
        this-&gt;year = pSolverTaskID-&gt;year;
        this-&gt;month = pSolverTaskID-&gt;month;
        this-&gt;day = pSolverTaskID-&gt;day;
        this-&gt;hour = pSolverTaskID-&gt;hour;
        this-&gt;minute = pSolverTaskID-&gt;minute;
        this-&gt;counter = pSolverTaskID-&gt;counter;
    }
}

SolverTaskID::SolverTaskID()
    : year(0)
    , month(0)
    , day(0)
    , hour(0)
    , minute(0)
    , counter(0)
{
    this-&gt;_init();
}

SolverTaskID::SolverTaskID(const SolverTaskID &amp;solverTaskID)
{
    this-&gt;_init(&amp;solverTaskID);
}

SolverTaskID::~SolverTaskID()
{
}

SolverTaskID &amp;SolverTaskID::operator =(const SolverTaskID &amp;solverTaskID)
{
    this-&gt;_init(&amp;solverTaskID);
    return (*this);
}

</t>
<t tx="leo.20201108101529.2">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   solver_setup_checker.cpp                                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   2-nd June 2016                                           *
 *                                                                   *
 *  DESCRIPTION: Solver setup checker class definition               *
 *********************************************************************/


#include "main_settings.h"
#include "solver_setup_checker.h"
#include "session.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.20">bool SolverTaskID::operator ==(const SolverTaskID &amp;solverTaskID) const
{
    return (this-&gt;year == solverTaskID.year &amp;&amp;
            this-&gt;month == solverTaskID.month &amp;&amp;
            this-&gt;day == solverTaskID.day &amp;&amp;
            this-&gt;hour == solverTaskID.hour &amp;&amp;
            this-&gt;minute == solverTaskID.minute &amp;&amp;
            this-&gt;counter == solverTaskID.counter);
}

</t>
<t tx="leo.20201108101529.21">void SolverTaskID::generate(void)
{
    static SolverTaskID lastID;

    QDateTime currDateTime(QDateTime::currentDateTime());

    QDate currDate(currDateTime.date());
    QTime currTime(currDateTime.time());

    this-&gt;year = currDate.year();
    this-&gt;month = currDate.month();
    this-&gt;day = currDate.day();
    this-&gt;hour = currTime.hour();
    this-&gt;minute = currTime.minute();
    this-&gt;counter = 1;

    if (lastID.isValid())
    {
        if (this-&gt;year == lastID.year &amp;&amp;
            this-&gt;month == lastID.month &amp;&amp;
            this-&gt;day == lastID.day &amp;&amp;
            this-&gt;hour == lastID.hour &amp;&amp;
            this-&gt;minute == lastID.minute)
        {
            this-&gt;counter = lastID.counter + 1;
        }
    }

    lastID = (*this);
}

</t>
<t tx="leo.20201108101529.22">bool SolverTaskID::isValid(void) const
{
    if (this-&gt;year    &lt; 1 ||
        this-&gt;month   &lt; 1 ||
        this-&gt;day     &lt; 1 ||
        this-&gt;hour    &lt; 0 ||
        this-&gt;minute  &lt; 0 ||
        this-&gt;counter &lt; 1)
    {
        return false;
    }
    else
    {
        return true;
    }
}

</t>
<t tx="leo.20201108101529.23">const QString SolverTaskID::toString(void) const
{
    QString stringID;

    stringID.append(QString("%1").arg(this-&gt;year,4,10,QChar('0')));
    stringID.append(QString("%1").arg(this-&gt;month,2,10,QChar('0')));
    stringID.append(QString("%1").arg(this-&gt;day,2,10,QChar('0')));
    stringID.append(QString("%1").arg(this-&gt;hour,2,10,QChar('0')));
    stringID.append(QString("%1").arg(this-&gt;minute,2,10,QChar('0')));
    stringID.append(QString("%1").arg(this-&gt;counter,4,10,QChar('0')));

    return stringID;
}
</t>
<t tx="leo.20201108101529.24">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   stream_line_dialog.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   22-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Stream line dialog class definition                 *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include "session.h"
#include "stream_line_dialog.h"

StreamLineDialog::StreamLineDialog(uint modelID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityID(RConstants::eod)
{
    this-&gt;createDialog();
}

StreamLineDialog::StreamLineDialog(uint modelID, uint entityID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityID(entityID)
{
    this-&gt;createDialog();
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.25">int StreamLineDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        RVariableType varType = this-&gt;getVariableType();

        if (varType != R_VARIABLE_NONE)
        {
            Session::getInstance().storeCurentModelVersion(this-&gt;modelID,tr("Create stream line"));

            if (this-&gt;entityID != RConstants::eod)
            {
                RStreamLine &amp;streamLine = Session::getInstance().getModel(this-&gt;modelID).getStreamLine(this-&gt;entityID);

                streamLine.setVariableType(varType);
                streamLine.setPosition(this-&gt;positionWidget-&gt;getPosition());

                RLogger::info("Modified stream line \'%s\'\n",streamLine.getName().toUtf8().constData());
            }
            else
            {
                RStreamLine streamLine;

                streamLine.setName(RVariable::getName(varType));
                streamLine.setVariableType(varType);
                streamLine.setPosition(this-&gt;positionWidget-&gt;getPosition());

                Session::getInstance().getModel(this-&gt;modelID).addStreamLine(streamLine);
                RLogger::info("Created new stream line \'%s\'\n",streamLine.getName().toUtf8().constData());
            }

            Session::getInstance().setModelChanged(this-&gt;modelID);
        }
    }

    Session::getInstance().setEndDrawStreamLinePosition();

    return retVal;
}

</t>
<t tx="leo.20201108101529.26">void StreamLineDialog::createDialog(void)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;resize(400,300);

    QString windowTitleStr = tr("Stream line editor");
    this-&gt;setWindowTitle(windowTitleStr);

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *titleLabel = new QLabel;
    if (this-&gt;entityID == RConstants::eod)
    {
        titleLabel-&gt;setText(tr("Create new stream line."));
    }
    else
    {
        titleLabel-&gt;setText(tr("Modify stream line:") + " &lt;b&gt;" + Session::getInstance().getModel(modelID).getStreamLine(entityID).getName() + "&lt;/b&gt;");
    }
    mainLayout-&gt;addWidget(titleLabel, 0, 0, 1, 1);

    this-&gt;variableList = new QListWidget(this);
    this-&gt;variableList-&gt;setSelectionMode(QAbstractItemView::SingleSelection);

    Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);
    RR3Vector startPosition;

    for (uint i=0;i&lt;rModel.getNVariables();i++)
    {
        RVariable &amp;rVariable = rModel.getVariable(i);
        if (rVariable.getNVectors() &gt; 1)
        {
            QListWidgetItem *itemVariable = new QListWidgetItem(this-&gt;variableList);
            itemVariable-&gt;setText(rVariable.getName());
            itemVariable-&gt;setData(Qt::UserRole,QVariant(rVariable.getType()));
            if (this-&gt;entityID != RConstants::eod)
            {
                RStreamLine &amp;rStreamLine = Session::getInstance().getModel(this-&gt;modelID).getStreamLine(this-&gt;entityID);
                itemVariable-&gt;setSelected(rVariable.getType() == rStreamLine.getVariableType());
                startPosition = rStreamLine.getPosition();
            }
        }
    }

    mainLayout-&gt;addWidget(this-&gt;variableList, 1, 0, 1, 1);

    QObject::connect(this-&gt;variableList,
                     &amp;QListWidget::itemSelectionChanged,
                     this,
                     &amp;StreamLineDialog::onVariableListSelectionChanged);

    double xMin = 0.0;
    double xMax = 0.0;
    double yMin = 0.0;
    double yMax = 0.0;
    double zMin = 0.0;
    double zMax = 0.0;

    rModel.findNodeLimits(xMin,xMax,yMin,yMax,zMin,zMax);

    this-&gt;positionWidget = new PositionWidget("Stream line position",startPosition);
    this-&gt;positionWidget-&gt;hideButtons();
    this-&gt;positionWidget-&gt;setXRange(xMin,xMax);
    this-&gt;positionWidget-&gt;setYRange(yMin,yMax);
    this-&gt;positionWidget-&gt;setZRange(zMin,zMax);
    mainLayout-&gt;addWidget(this-&gt;positionWidget, 2, 0, 1, 1);

    QObject::connect(this-&gt;positionWidget,&amp;PositionWidget::changed,this,&amp;StreamLineDialog::onPositionChanged);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, 3, 0, 1, 1);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableList-&gt;selectedItems().size());
    this-&gt;okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;StreamLineDialog::reject);
    QObject::connect(this-&gt;okButton,&amp;QPushButton::clicked,this,&amp;StreamLineDialog::accept);

    Session::getInstance().setBeginDrawStreamLinePosition(startPosition);
}

RVariableType StreamLineDialog::getVariableType(void) const
{
    QList&lt;QListWidgetItem*&gt; items = this-&gt;variableList-&gt;selectedItems();

    if (items.size() == 0)
    {
        return R_VARIABLE_NONE;
    }

    return RVariableType(items[0]-&gt;data(Qt::UserRole).toInt());
}

</t>
<t tx="leo.20201108101529.27">void StreamLineDialog::onPositionChanged(const RR3Vector &amp;position)
{
    Session::getInstance().setBeginDrawStreamLinePosition(position);
}

</t>
<t tx="leo.20201108101529.28">void StreamLineDialog::onVariableListSelectionChanged(void)
{
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableList-&gt;selectedItems().size());
}
</t>
<t tx="leo.20201108101529.29">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   sub_window.cpp                                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   29-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Sub window class definition                         *
 *********************************************************************/

#include &lt;QFileDialog&gt;
#include &lt;QGridLayout&gt;

#include "sub_window.h"
#include "session.h"
#include "gl_display_properties_dialog.h"
#include "main_window.h"
#include "clipping_plane_widget.h"

SubWindow::SubWindow (uint modelID, QWidget *parent)
    : QMdiSubWindow(parent)
{
    this-&gt;modelID = modelID;
    this-&gt;createSubWindow();
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.3">void SolverSetupChecker::_init(const SolverSetupChecker *pSolverSetupChecker)
{
    if (pSolverSetupChecker)
    {

    }
}

SolverSetupChecker::SolverSetupChecker(const RModel &amp;rModel)
    : rModel(rModel)
{
    this-&gt;_init();
}

SolverSetupChecker::SolverSetupChecker(const SolverSetupChecker &amp;solverSetupChecker)
    : rModel(solverSetupChecker.rModel)
{
    this-&gt;_init(&amp;solverSetupChecker);
}

SolverSetupChecker::~SolverSetupChecker()
{

}

SolverSetupChecker &amp;SolverSetupChecker::operator =(const SolverSetupChecker &amp;solverSetupChecker)
{
    this-&gt;_init(&amp;solverSetupChecker);
    return (*this);
}

</t>
<t tx="leo.20201108101529.30">void SubWindow::createSubWindow(void)
{
    QString windowTitle = Session::getInstance().getModel(this-&gt;modelID).getName();
    this-&gt;setWindowTitle(windowTitle);
    this-&gt;setWindowIcon(QIcon(":/icons/logos/pixmaps/range-logo-128.png"));

    QWidget *mainWidget = new QWidget(this);
    this-&gt;setWidget(mainWidget);

    QGridLayout *gridLayoutSubwindow = new QGridLayout(mainWidget);
    this-&gt;glWidget = new GLWidget(this-&gt;getModelID());
//    QSurfaceFormat format;
//    format.setDepthBufferSize(24);
//    format.setStencilBufferSize(8);
//    format.setVersion(3, 2);
//    format.setProfile(QSurfaceFormat::CoreProfile);
//    this-&gt;glWidget-&gt;setFormat(format);
    gridLayoutSubwindow-&gt;addWidget(this-&gt;glWidget, 0, 0, 1, 1);

    int toolbarIconSize = MainSettings::getInstance().getApplicationSettings()-&gt;getToolbarIconSize();
    this-&gt;toolBar = new QToolBar(QString("Sub window toolbar"));
    this-&gt;toolBar-&gt;setIconSize(QSize(toolbarIconSize,toolbarIconSize));

    gridLayoutSubwindow-&gt;addWidget(toolBar, 1, 0, 1, 1);

    QAction *actionResetO = new QAction(this);
    actionResetO-&gt;setText(tr("Reset to original view."));
    actionResetO-&gt;setShortcut(QString("O"));
    actionResetO-&gt;setIcon(QIcon(":/icons/file/pixmaps/range-resetO.svg"));
    this-&gt;toolBar-&gt;addAction(actionResetO);
    QObject::connect(actionResetO,&amp;QAction::triggered,this,&amp;SubWindow::onResetO);

    QAction *actionResetX = new QAction(this);
    actionResetX-&gt;setText(tr("Reset to X plane."));
    actionResetX-&gt;setShortcut(QString("X"));
    actionResetX-&gt;setIcon(QIcon(":/icons/file/pixmaps/range-resetX.svg"));
    this-&gt;toolBar-&gt;addAction(actionResetX);
    QObject::connect(actionResetX,&amp;QAction::triggered,this,&amp;SubWindow::onResetX);

    QAction *actionResetY = new QAction(this);
    actionResetY-&gt;setText(tr("Reset to Y plane."));
    actionResetY-&gt;setShortcut(QString("Y"));
    actionResetY-&gt;setIcon(QIcon(":/icons/file/pixmaps/range-resetY.svg"));
    this-&gt;toolBar-&gt;addAction(actionResetY);
    QObject::connect(actionResetY,&amp;QAction::triggered,this,&amp;SubWindow::onResetY);

    QAction *actionResetZ = new QAction(this);
    actionResetZ-&gt;setText(tr("Reset to Z plane."));
    actionResetZ-&gt;setShortcut(QString("Z"));
    actionResetZ-&gt;setIcon(QIcon(":/icons/file/pixmaps/range-resetZ.svg"));
    this-&gt;toolBar-&gt;addAction(actionResetZ);
    QObject::connect(actionResetZ,&amp;QAction::triggered,this,&amp;SubWindow::onResetZ);

    this-&gt;toolBar-&gt;addSeparator();

    QAction *actionScreenshot = new QAction(this);
    actionScreenshot-&gt;setText("Take screen shot.");
    actionScreenshot-&gt;setShortcut(QString("Ctrl+P"));
    actionScreenshot-&gt;setIcon(QIcon(":/icons/file/pixmaps/range-screenshot.svg"));
    this-&gt;toolBar-&gt;addAction(actionScreenshot);
    QObject::connect(actionScreenshot,&amp;QAction::triggered,this,&amp;SubWindow::onScreenshot);

    QWidget* spacer = new QWidget();
    spacer-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
    this-&gt;toolBar-&gt;addWidget(spacer);

    QCheckBox *backSideColorCheck = new QCheckBox(tr("Back side color"));
    this-&gt;toolBar-&gt;addWidget(backSideColorCheck);

    QObject::connect(backSideColorCheck,&amp;QCheckBox::stateChanged,this,&amp;SubWindow::onBackSideColorChanged);

    ClippingPlaneWidget *clippingPlaneWidget = new ClippingPlaneWidget;
    this-&gt;toolBar-&gt;addWidget(clippingPlaneWidget);

    QAction *actionPreferences = new QAction(this);
    actionPreferences-&gt;setText("Display preferences.");
    actionPreferences-&gt;setShortcut(QString("Ctrl+P"));
    actionPreferences-&gt;setIcon(QIcon(":/icons/application/pixmaps/range-display_preferences.svg"));
    this-&gt;toolBar-&gt;addAction(actionPreferences);
    QObject::connect(actionPreferences,&amp;QAction::triggered,this,&amp;SubWindow::onPreferences);

    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::takeScreenShot,
                     this,
                     &amp;SubWindow::onSessionScreenshot);
    QObject::connect(&amp;Session::getInstance(),
                     &amp;Session::takeScreenShotBlocking,
                     this,
                     &amp;SubWindow::onSessionScreenshot,
                     Qt::BlockingQueuedConnection);

    QObject::connect(clippingPlaneWidget,
                     &amp;ClippingPlaneWidget::changed,
                     this-&gt;glWidget,
                     &amp;GLWidget::setClippingPlane);

    // Tooplbar icon size changed signal
    QObject::connect(MainSettings::getInstance().getApplicationSettings(),
                     &amp;ApplicationSettings::toolbarIconSizeChanged,
                     this,
                     &amp;SubWindow::onToolbarIconSizeChanged);
}

uint SubWindow::getModelID(void) const
{
    return this-&gt;modelID;
}

</t>
<t tx="leo.20201108101529.31">void SubWindow::setModelID(uint modelID)
{
    this-&gt;modelID = modelID;
    this-&gt;glWidget-&gt;setModelID(modelID);
}

GLWidget *SubWindow::getGlWidget(void) const
{
    return this-&gt;glWidget;
}

</t>
<t tx="leo.20201108101529.32">void SubWindow::closeEvent(QCloseEvent *closeEvent)
{
    emit closed(this-&gt;getModelID());
    closeEvent-&gt;accept();
}

</t>
<t tx="leo.20201108101529.33">void SubWindow::onResetO(void)
{
    this-&gt;glWidget-&gt;resetView(-45.0, 0.0, -135.0);
}

</t>
<t tx="leo.20201108101529.34">void SubWindow::onResetX(void)
{
    this-&gt;glWidget-&gt;resetView(-90.0, 0.0, -90.0);
}

</t>
<t tx="leo.20201108101529.35">void SubWindow::onResetY(void)
{
    this-&gt;glWidget-&gt;resetView(-90.0, 0.0, 180.0);
}

</t>
<t tx="leo.20201108101529.36">void SubWindow::onResetZ(void)
{
    this-&gt;glWidget-&gt;resetView(0.0, 0.0, 0.0);
}

</t>
<t tx="leo.20201108101529.37">void SubWindow::onScreenshot(void)
{
    this-&gt;onSessionScreenshot(this-&gt;getModelID(),QString());
}

</t>
<t tx="leo.20201108101529.38">void SubWindow::onSessionScreenshot(uint modelID, const QString &amp;fileName)
{
    if (modelID != this-&gt;getModelID())
    {
        return;
    }

    this-&gt;glWidget-&gt;takeScreenShot(fileName);
}

</t>
<t tx="leo.20201108101529.39">void SubWindow::onShowModelEdgesToggled(bool checked)
{
    this-&gt;glWidget-&gt;getGLDisplayProperties().setShowModelEdges(checked);
    this-&gt;glWidget-&gt;getGLDisplayProperties().store();
    this-&gt;glWidget-&gt;update();
}

</t>
<t tx="leo.20201108101529.4">void SolverSetupChecker::perform(QStringList &amp;warnings, QStringList &amp;errors) const
{
    warnings.clear();
    errors.clear();

    this-&gt;checkElements(warnings,errors);
    this-&gt;checkMaterials(warnings,errors);
    this-&gt;checkBoundaryConditions(warnings,errors);
}

</t>
<t tx="leo.20201108101529.40">void SubWindow::onShowErrorsToggled(bool checked)
{
    this-&gt;glWidget-&gt;getGLDisplayProperties().setShowErrors(checked);
    this-&gt;glWidget-&gt;getGLDisplayProperties().store();
    this-&gt;glWidget-&gt;update();
}

</t>
<t tx="leo.20201108101529.41">void SubWindow::onBackSideColorChanged(int state)
{
    this-&gt;glWidget-&gt;setUseGlCullFace(state == Qt::Unchecked);
}

</t>
<t tx="leo.20201108101529.42">void SubWindow::onPreferences(void)
{
    GLDisplayPropertiesDialog preferencesDialog(this-&gt;glWidget,MainWindow::getInstance());
    if (preferencesDialog.exec() == QDialog::Accepted)
    {
        this-&gt;glWidget-&gt;update();
    }
}

</t>
<t tx="leo.20201108101529.43">void SubWindow::onToolbarIconSizeChanged(int toolbarIconSize)
{
    this-&gt;toolBar-&gt;setIconSize(QSize(toolbarIconSize,toolbarIconSize));
}
</t>
<t tx="leo.20201108101529.44">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   sub_window_manager.cpp                                   *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   3-rd February 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Sub window manager class definition                 *
 *********************************************************************/

#include "session.h"
#include "sub_window_manager.h"

SubWindowManager::SubWindowManager(QMdiArea *mdiArea, QObject *parent) : QObject(parent)
{
    this-&gt;mdiArea = mdiArea;
}

uint SubWindowManager::findWindow(uint modelID)
{
    for (int i=0;i&lt;this-&gt;subWindows.size();i++)
    {
        if (this-&gt;subWindows[i]-&gt;getModelID() == modelID)
        {
            return uint(i);
        }
    }
    return uint(this-&gt;subWindows.size());
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.45">bool SubWindowManager::windowCreate(uint modelID)
{
    if (this-&gt;windowExists(modelID))
    {
        return false;
    }

    SubWindow *subWindow = new SubWindow(modelID,qobject_cast&lt;QWidget*&gt;(this-&gt;parent()));
    subWindow-&gt;setAttribute(Qt::WA_DeleteOnClose);
    this-&gt;mdiArea-&gt;addSubWindow(subWindow,Qt::SubWindow);

    if (this-&gt;subWindows.empty())
    {
        subWindow-&gt;showMaximized();
    }

    this-&gt;subWindows.append(subWindow);

    subWindow-&gt;show();

    QObject::connect(subWindow,
                     &amp;SubWindow::closed,
                     this,
                     &amp;SubWindowManager::onWindowClosed);

    emit this-&gt;windowCreated(modelID);

    return true;
}

</t>
<t tx="leo.20201108101529.46">bool SubWindowManager::windowClose(uint modelID)
{
    uint winPos = this-&gt;findWindow(modelID);
    if (winPos == this-&gt;getNWindows())
    {
        return false;
    }

    SubWindow *subWindow = this-&gt;subWindows[int(winPos)];
//    this-&gt;mdiArea-&gt;removeSubWindow(subWindow);
    delete subWindow;

    this-&gt;subWindows.removeAt(int(winPos));

    emit this-&gt;windowClosed(modelID);

    return true;
}

</t>
<t tx="leo.20201108101529.47">bool SubWindowManager::windowExists(uint modelID)
{
    uint winPos = this-&gt;findWindow(modelID);
    if (winPos == this-&gt;getNWindows())
    {
        return false;
    }
    return true;
}

uint SubWindowManager::getNWindows(void) const
{
    return this-&gt;subWindows.size();
}

</t>
<t tx="leo.20201108101529.48">void SubWindowManager::onModelAdded(uint modelID)
{
    for (int i=0;i&lt;this-&gt;subWindows.size();i++)
    {
        if (this-&gt;subWindows[i]-&gt;getModelID() &gt;= modelID)
        {
            this-&gt;subWindows[i]-&gt;setModelID(this-&gt;subWindows[i]-&gt;getModelID()+1);
        }
    }

    this-&gt;windowCreate(modelID);
}

</t>
<t tx="leo.20201108101529.49">void SubWindowManager::onModelRemoved(uint modelID)
{
    this-&gt;windowClose(modelID);

    for (int i=0;i&lt;this-&gt;subWindows.size();i++)
    {
        if (this-&gt;subWindows[i]-&gt;getModelID() &gt; modelID)
        {
            this-&gt;subWindows[i]-&gt;setModelID(this-&gt;subWindows[i]-&gt;getModelID()-1);
        }
    }
}

</t>
<t tx="leo.20201108101529.5">void SolverSetupChecker::checkElements(QStringList &amp;warnings, QStringList &amp;errors) const
{
    if (this-&gt;rModel.getNElements() == 0)
    {
        errors.append("Empty model.");
        return;
    }

    if (this-&gt;rModel.getNVolumes() == 0)
    {
        warnings.append(QObject::tr("Model does not contain any volume elements."));
    }
}

</t>
<t tx="leo.20201108101529.50">void SubWindowManager::onModelChanged(uint)
{

}

</t>
<t tx="leo.20201108101529.51">void SubWindowManager::onWindowClosed(uint modelID)
{
    Session::getInstance().setModelVisible(modelID,false);
    uint winPos = this-&gt;findWindow(modelID);
    this-&gt;subWindows.removeAt(winPos);
}
</t>
<t tx="leo.20201108101529.52">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   text_browser.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   27-th August 2013                                        *
 *                                                                   *
 *  DESCRIPTION: Text browser class definition                       *
 *********************************************************************/

#include "text_browser.h"

TextBrowser::TextBrowser(bool hasClearButton, QWidget *parent)
  : QTextBrowser(parent)
  , hasClearButton(hasClearButton)
{
    QFont font("Monospace");
    font.setStyleHint(QFont::TypeWriter);
    this-&gt;setFont(font);

    if (this-&gt;hasClearButton)
    {
        QIcon clearIcon(":/icons/file/pixmaps/range-clear.svg");

        this-&gt;clearButton = new QPushButton(clearIcon,"Clear",this);

        QObject::connect(this-&gt;clearButton,
                         &amp;QPushButton::clicked,
                         this,
                         &amp;TextBrowser::clear);
    }
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.53">void TextBrowser::resizeEvent(QResizeEvent *event)
{
    if (!this-&gt;hasClearButton)
    {
        return;
    }
    QTextBrowser::resizeEvent(event);

    int bw = this-&gt;clearButton-&gt;width();
    int bh = this-&gt;clearButton-&gt;height();
    int tw = this-&gt;width();

    int x = tw - bw - 25;
    int y = 5;

    this-&gt;clearButton-&gt;setGeometry(x,y,bw,bh);
}
</t>
<t tx="leo.20201108101529.54">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   text_browser_dialog.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   21-st September 2017                                     *
 *                                                                   *
 *  DESCRIPTION: Text browser dialog class definition                *
 *********************************************************************/

#include &lt;QHBoxLayout&gt;
#include &lt;QVBoxLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;
#include &lt;QTextBrowser&gt;

#include "text_browser_dialog.h"

TextBrowserDialog::TextBrowserDialog(const QString &amp;title,
                                     @others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.55">                                     const QString &amp;desc,
                                     const QString &amp;text,
                                     QWidget *parent)
    : QDialog(parent)
{
    QIcon closeIcon(":/icons/file/pixmaps/range-close.svg");

    this-&gt;resize(700,500);

    this-&gt;setWindowTitle(title);

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout(mainLayout);

    QLabel *titleLabel = new QLabel(desc);
    mainLayout-&gt;addWidget(titleLabel);

    QTextBrowser *textBrowser = new QTextBrowser(this);
    QFont font("Monospace");
    font.setStyleHint(QFont::TypeWriter);
    textBrowser-&gt;setFont(font);
    textBrowser-&gt;insertPlainText(text);
    mainLayout-&gt;addWidget(textBrowser);

    QTextCursor textCursor = textBrowser-&gt;textCursor();
    textCursor.movePosition(QTextCursor::Start);
    textBrowser-&gt;setTextCursor(textCursor);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *closeButton = new QPushButton(closeIcon, tr("Close"));
    buttonsLayout-&gt;addWidget(closeButton);

    QObject::connect(closeButton,&amp;QPushButton::clicked,this,&amp;TextBrowserDialog::close);
}
</t>
<t tx="leo.20201108101529.56">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   text_edit_widget.cpp                                     *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   2-nd November 2018                                       *
 *                                                                   *
 *  DESCRIPTION: Text edit widget class definition                   *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;

#include "text_edit_widget.h"

TextEditWidget::TextEditWidget(QWidget *parent)
    : QWidget(parent)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QVBoxLayout *layout = new QVBoxLayout;
    this-&gt;setLayout(layout);

    this-&gt;textEdit = new QPlainTextEdit;
    layout-&gt;addWidget(this-&gt;textEdit);

    QFont font("Monospace");
    font.setStyleHint(QFont::TypeWriter);
    this-&gt;textEdit-&gt;setFont(font);

    QObject::connect(this-&gt;textEdit,&amp;QPlainTextEdit::textChanged,this,&amp;TextEditWidget::onTextEditChanged);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    layout-&gt;addLayout(buttonsLayout);

    this-&gt;cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(this-&gt;cancelButton);

    QObject::connect(this-&gt;cancelButton,&amp;QPushButton::clicked,this,&amp;TextEditWidget::onCancelButtonClicked);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setDisabled(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(this-&gt;okButton,&amp;QPushButton::clicked,this,&amp;TextEditWidget::onOkButtonClicked);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.57">void TextEditWidget::setText(const QString &amp;text)
{
    this-&gt;textEdit-&gt;setPlainText(text);
}

</t>
<t tx="leo.20201108101529.58">void TextEditWidget::onTextEditChanged()
{
    this-&gt;okButton-&gt;setDisabled(this-&gt;textEdit-&gt;toPlainText().isEmpty());
}

</t>
<t tx="leo.20201108101529.59">void TextEditWidget::onCancelButtonClicked()
{
    emit this-&gt;closed();
}

</t>
<t tx="leo.20201108101529.6">void SolverSetupChecker::checkMaterials(QStringList &amp;warnings, QStringList &amp;errors) const
{
    RProblemTypeMask problemTypeMask = this-&gt;rModel.getProblemTaskTree().getProblemTypeMask();
    std::vector&lt;RMaterialPropertyType&gt; materialProperties = RMaterialProperty::getTypes(problemTypeMask);

    QStringList matErrors;
    // Check if entities have material group assigned.
    for (uint i=0;i&lt;this-&gt;rModel.getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = this-&gt;rModel.getElementGroupPtr(i);

        if (pElementGroup-&gt;getMaterial().size() == 0)
        {
            QString errorMessage = QObject::tr("Entity") + " &lt;b&gt;" + pElementGroup-&gt;getName() + "&lt;/b&gt; " + QObject::tr("has no material assigned.");
            matErrors.append(errorMessage);
        }
    }

    if (uint(matErrors.size()) == this-&gt;rModel.getNElementGroups())
    {
        errors.append(QObject::tr("Model has no material assigned."));
        return;
    }
    if (matErrors.size() &gt; 10)
    {
        QString errorMessage = QObject::tr("Multiple") + " " + QString::number(matErrors.size()) + " " + QObject::tr("entities have no material assigned.");
        errors.append(errorMessage);
        return;
    }
    if (matErrors.size() &gt; 0)
    {
        errors = matErrors;
        return;
    }

    // Check if entities have material properties needed for starting the solver.
    for (uint i=0;i&lt;this-&gt;rModel.getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = this-&gt;rModel.getElementGroupPtr(i);

        if (!pElementGroup-&gt;getMaterial().hasProperties(materialProperties))
        {
            QString errorMessage = QObject::tr("Entity") + " &lt;b&gt;" + pElementGroup-&gt;getName() + "&lt;/b&gt; " + QObject::tr("has material assigned which is missing required properties.");
            warnings.append(errorMessage);
        }
    }
}

</t>
<t tx="leo.20201108101529.60">void TextEditWidget::onOkButtonClicked()
{
    emit this-&gt;changed(textEdit-&gt;toPlainText());
    emit this-&gt;closed();
}
</t>
<t tx="leo.20201108101529.61">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   time_solver_setup_widget.cpp                             *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th June 2012                                          *
 *                                                                   *
 *  DESCRIPTION: Time-solver setup widget class definition           *
 *********************************************************************/

#include &lt;QGroupBox&gt;
#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QComboBox&gt;
#include &lt;QSpinBox&gt;

#include "session.h"
#include "time_solver_setup_widget.h"
#include "value_line_edit.h"

TimeSolverSetupWidget::TimeSolverSetupWidget(const RTimeSolver &amp;timeSolver, QWidget *parent)
    : QWidget(parent)
    , timeSolver(timeSolver)
{
    QHBoxLayout *mainLayout = new QHBoxLayout;
    this-&gt;setLayout(mainLayout);

    QGroupBox *groupBox = new QGroupBox(tr("Time-solver"));
    groupBox-&gt;setToolTip(tr("Enable/disable time-dependent solution."));
    groupBox-&gt;setCheckable(true);
    groupBox-&gt;setChecked(this-&gt;timeSolver.getEnabled());
    mainLayout-&gt;addWidget(groupBox);

    QObject::connect(groupBox,&amp;QGroupBox::toggled,this,&amp;TimeSolverSetupWidget::onTimeSolverEnabledChanged);

    QGridLayout *groupLayout = new QGridLayout;
    groupBox-&gt;setLayout(groupLayout);

    int groupLayoutRow = 0;

    // Time-march approximation
    QLabel *labelTimeApprox = new QLabel(tr("Time-march approximation"));
    groupLayout-&gt;addWidget(labelTimeApprox,groupLayoutRow,0);

    QComboBox *comboTimeApprox = new QComboBox();
    comboTimeApprox-&gt;addItem(RTimeSolver::getTimeMarchApproximationName(R_TIME_MARCH_CENTRAL));
    comboTimeApprox-&gt;addItem(RTimeSolver::getTimeMarchApproximationName(R_TIME_MARCH_BACKWARD));
    comboTimeApprox-&gt;addItem(RTimeSolver::getTimeMarchApproximationName(R_TIME_MARCH_FORWARD));
    comboTimeApprox-&gt;setCurrentIndex(this-&gt;timeSolver.getTimeMarchApproximation());
    comboTimeApprox-&gt;setToolTip(tr("Time-march approximation."));
    groupLayout-&gt;addWidget(comboTimeApprox,groupLayoutRow++,1);

    this-&gt;connect(comboTimeApprox,SIGNAL(currentIndexChanged(int)),SLOT(onTimeApproximationChanged(int)));

    // Start time
    QLabel *labelStartTime = new QLabel(tr("Start time"));
    groupLayout-&gt;addWidget(labelStartTime,groupLayoutRow,0);

    ValueLineEdit *lineStartTime = new ValueLineEdit;
    lineStartTime-&gt;setDoubleValidator();
    lineStartTime-&gt;setText(QString::number(this-&gt;timeSolver.getInputStartTime()));
    lineStartTime-&gt;setToolTip(tr("Start time in seconds."));
    groupLayout-&gt;addWidget(lineStartTime,groupLayoutRow++,1);

    QObject::connect(lineStartTime,&amp;ValueLineEdit::valueChanged,this,&amp;TimeSolverSetupWidget::onStartTimeChanged);

    // End time
    QLabel *labelEndTime = new QLabel(tr("End time") + " (" + tr("read only") + ")");
    groupLayout-&gt;addWidget(labelEndTime,groupLayoutRow,0);

    this-&gt;lineEndTime = new ValueLineEdit;
    this-&gt;lineEndTime-&gt;setDoubleValidator();
    this-&gt;lineEndTime-&gt;setValue(this-&gt;findEndTime());
    this-&gt;lineEndTime-&gt;setToolTip(tr("End time in seconds."));
    this-&gt;lineEndTime-&gt;setReadOnly(true);
    groupLayout-&gt;addWidget(this-&gt;lineEndTime,groupLayoutRow++,1);

    // Default time-step size
    QLabel *labelTimeStepSize = new QLabel(tr("Time-step size"));
    groupLayout-&gt;addWidget(labelTimeStepSize,groupLayoutRow,0);

    ValueLineEdit *lineTimeStepSize = new ValueLineEdit(1.0e-99,1.0e99);
    lineTimeStepSize-&gt;setText(QString::number(this-&gt;timeSolver.getInputTimeStepSize()));
    lineTimeStepSize-&gt;setToolTip(tr("Time-step size in seconds. This also determines end time."));
    groupLayout-&gt;addWidget(lineTimeStepSize,groupLayoutRow++,1);

    QObject::connect(lineTimeStepSize,&amp;ValueLineEdit::valueChanged,this,&amp;TimeSolverSetupWidget::onTimeStepSizeChanged);

    // Number of time-steps
    QLabel *labelNTimeSteps = new QLabel(tr("Number of time-steps"));
    groupLayout-&gt;addWidget(labelNTimeSteps,groupLayoutRow,0);

    QSpinBox *spinNTimeSteps = new QSpinBox;
    spinNTimeSteps-&gt;setMinimum(R_TIME_STEP_MIN_NUMBER);
    spinNTimeSteps-&gt;setMaximum(R_TIME_STEP_MAX_NUMBER);
    spinNTimeSteps-&gt;setValue(this-&gt;timeSolver.getInputNTimeSteps());
    spinNTimeSteps-&gt;setToolTip(tr("Number of time-steps to solve."));
    groupLayout-&gt;addWidget(spinNTimeSteps,groupLayoutRow++,1);

    this-&gt;connect(spinNTimeSteps,SIGNAL(valueChanged(int)),SLOT(onNTimeStepsChanged(int)));

    // Write output frequency
    QLabel *labelOutputFrequency = new QLabel(tr("Output frequency"));
    groupLayout-&gt;addWidget(labelOutputFrequency,groupLayoutRow,0);

    QSpinBox *spinOutputFrequency = new QSpinBox;
    spinOutputFrequency-&gt;setMinimum(R_TIME_MIN_OUTPUT_FREQUENCY);
    spinOutputFrequency-&gt;setMaximum(R_TIME_MAX_OUTPUT_FREQUENCY);
    spinOutputFrequency-&gt;setValue(this-&gt;timeSolver.getOutputFrequency());
    spinOutputFrequency-&gt;setToolTip(tr("Number of time-steps after which results will be written to a file."));
    groupLayout-&gt;addWidget(spinOutputFrequency,groupLayoutRow++,1);

    this-&gt;connect(spinOutputFrequency,SIGNAL(valueChanged(int)),SLOT(onOutputFrequencyChanged(int)));
}

double TimeSolverSetupWidget::findEndTime(void) const
{
    return this-&gt;timeSolver.getInputStartTime() + this-&gt;timeSolver.getInputTimeStepSize() * this-&gt;timeSolver.getInputNTimeSteps();
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.62">void TimeSolverSetupWidget::onTimeSolverEnabledChanged(bool checked)
{
    this-&gt;timeSolver.setEnabled(checked);
    emit this-&gt;changed(this-&gt;timeSolver);
}

</t>
<t tx="leo.20201108101529.63">void TimeSolverSetupWidget::onTimeApproximationChanged(int index)
{
    RTimeMarchApproximation tma = RTimeMarchApproximation(index);
    if (R_TIME_MARCH_APPROXIMATION_TYPE_IS_VALID(tma))
    {
        this-&gt;timeSolver.setTimeMarchApproximation(tma);
        emit this-&gt;changed(this-&gt;timeSolver);
    }
}

</t>
<t tx="leo.20201108101529.64">void TimeSolverSetupWidget::onStartTimeChanged(double startTime)
{
    this-&gt;timeSolver.setInputStartTime(startTime);
    this-&gt;lineEndTime-&gt;setValue(this-&gt;findEndTime());
    emit this-&gt;changed(this-&gt;timeSolver);
}

</t>
<t tx="leo.20201108101529.65">void TimeSolverSetupWidget::onTimeStepSizeChanged(double timeStepSize)
{
    this-&gt;timeSolver.setInputTimeStepSize(timeStepSize);
    this-&gt;lineEndTime-&gt;setValue(this-&gt;findEndTime());
    emit this-&gt;changed(this-&gt;timeSolver);
}

</t>
<t tx="leo.20201108101529.66">void TimeSolverSetupWidget::onNTimeStepsChanged(int nTimeSteps)
{
    this-&gt;timeSolver.setInputNTimeSteps(nTimeSteps);
    this-&gt;lineEndTime-&gt;setValue(this-&gt;findEndTime());
    emit this-&gt;changed(this-&gt;timeSolver);
}

</t>
<t tx="leo.20201108101529.67">void TimeSolverSetupWidget::onOutputFrequencyChanged(int outputFrequency)
{
    this-&gt;timeSolver.setOutputFrequency(outputFrequency);
    this-&gt;lineEndTime-&gt;setValue(this-&gt;findEndTime());
    emit this-&gt;changed(this-&gt;timeSolver);
}
</t>
<t tx="leo.20201108101529.68">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   update_dialog.cpp                                        *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   22-nd August 2016                                        *
 *                                                                   *
 *  DESCRIPTION: Update dialog class definition                      *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;

#include "update_dialog.h"
#include "session.h"

UpdateDialog::UpdateDialog(const RVersion &amp;softwareVersion, const QString &amp;softwareLink, QWidget *parent)
    : QDialog(parent)
    , softwareVersion(softwareVersion)
    , softwareLink(softwareLink)
{
    QIcon closeIcon(":/icons/file/pixmaps/range-close.svg");
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon updateIcon(":/icons/file/pixmaps/range-download.svg");

    QString windowTitleStr = tr("Software update");
    this-&gt;setWindowTitle(tr(windowTitleStr.toUtf8().constData()));

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    QString message;
    if (RVendor::version &lt; this-&gt;softwareVersion)
    {
        if (!this-&gt;softwareLink.isEmpty())
        {
            message += "&lt;big&gt;&lt;strong&gt;" + tr("Download and install latest version?") + "&lt;/strong&gt;&lt;/big&gt;&lt;br/&gt;&lt;br/&gt;";
        }
        message += tr("New version is available for download.") + "&lt;br/&gt;";
        message += tr("Installed version") + ": &lt;span style=\"color:red\"&gt;" + RVendor::version.toString() + "&lt;/span&gt;&lt;br/&gt;";
        message += tr("Available version") + ": &lt;span style=\"color:blue\"&gt;" + this-&gt;softwareVersion.toString() + "&lt;/span&gt;&lt;br/&gt;";
        message += tr("Visit") + " &lt;a href=\"" + RVendor::www + "\"&gt;" + RVendor::www + "&lt;/a&gt; " + tr("for more information.");
    }
    else
    {
        message += tr("Software is up to date.");
        this-&gt;softwareLink.clear();
    }

    QLabel *label = new QLabel(message);
    mainLayout-&gt;addWidget(label);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    if (this-&gt;softwareLink.isEmpty())
    {
        QPushButton *closeButton = new QPushButton(closeIcon, tr("Close"));
        buttonsLayout-&gt;addWidget(closeButton);

        QObject::connect(closeButton,&amp;QPushButton::clicked,this,&amp;UpdateDialog::reject);
    }
    else
    {
        QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
        buttonsLayout-&gt;addWidget(cancelButton);

        QPushButton *updateButton = new QPushButton(updateIcon, tr("Update"));
        buttonsLayout-&gt;addWidget(updateButton);

        QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;UpdateDialog::reject);
        QObject::connect(updateButton,&amp;QPushButton::clicked,this,&amp;UpdateDialog::accept);
    }
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.69">int UpdateDialog::exec()
{
    int retVal = this-&gt;QDialog::exec();
    if (retVal == QDialog::Accepted)
    {
        Session::getInstance().getDownloadManager()-&gt;append(QUrl(this-&gt;softwareLink));
        QObject::connect(Session::getInstance().getDownloadManager(),&amp;DownloadManager::fileSaved,&amp;Session::getInstance(),&amp;Session::onSoftwareUpdateFileSaved);
    }

    return retVal;
}
</t>
<t tx="leo.20201108101529.7">void SolverSetupChecker::checkBoundaryConditions(QStringList &amp;warnings, QStringList &amp;errors) const
{
    bool hasExplicit = false;
    bool hasImplicit = false;

    std::vector&lt;RProblemType&gt; problemTypes = RProblem::getTypes(this-&gt;rModel.getProblemTaskTree().getProblemTypeMask());

    for (uint i=0;i&lt;this-&gt;rModel.getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = this-&gt;rModel.getElementGroupPtr(i);

        for (uint j=0;j&lt;pElementGroup-&gt;getNBoundaryConditions();j++)
        {
            if (pElementGroup-&gt;getBoundaryCondition(j).getExplicit())
            {
                hasExplicit = true;
            }
            else
            {
                hasImplicit = true;
            }
        }
    }

    if (!hasExplicit &amp;&amp; !hasImplicit)
    {
        errors.append(QObject::tr("No boundary condition assigned."));
        return;
    }

    for (uint i=0;i&lt;problemTypes.size();i++)
    {
        if (problemTypes[i] == R_PROBLEM_MESH)
        {
            continue;
        }
        hasExplicit = hasImplicit = false;

        std::vector&lt;RBoundaryConditionType&gt; conditionTypes = RBoundaryCondition::getTypes(problemTypes[i]);

        for (uint j=0;j&lt;conditionTypes.size();j++)
        {
            if ((RBoundaryCondition::getExplicit(conditionTypes[j]) &amp;&amp; hasExplicit) ||
                (!RBoundaryCondition::getExplicit(conditionTypes[j]) &amp;&amp; hasImplicit))
            {
                continue;
            }
            for (uint k=0;k&lt;this-&gt;rModel.getNElementGroups();k++)
            {
                const RElementGroup *pElementGroup = this-&gt;rModel.getElementGroupPtr(k);

                if (pElementGroup-&gt;hasBoundaryCondition(conditionTypes[j]))
                {
                    if (RBoundaryCondition::getExplicit(conditionTypes[j]))
                    {
                        hasExplicit = true;
                    }
                    else
                    {
                        hasImplicit = true;
                    }
                    break;
                }
            }
            if (hasExplicit &amp;&amp; hasImplicit)
            {
                break;
            }
        }

        if (!hasExplicit)
        {
            warnings.append("&lt;b&gt;" + RProblem::getName(problemTypes[i]) + ":&lt;/b&gt; " + QObject::tr("No explicit boundary condition assigned."));
        }
        if (!hasImplicit)
        {
            warnings.append("&lt;b&gt;" + RProblem::getName(problemTypes[i]) + ":&lt;/b&gt; " + QObject::tr("No implicit boundary condition assigned."));
        }
    }
}
</t>
<t tx="leo.20201108101529.70">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   usage_info.cpp                                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th December 2017                                       *
 *                                                                   *
 *  DESCRIPTION: Usage info class definition                         *
 *********************************************************************/

#include "main_settings.h"
#include "session.h"
#include "usage_info.h"

UsageInfo &amp;UsageInfo::getInstance(void)
{
    static UsageInfo usageInfo;
    return usageInfo;
}

QString UsageInfo::getReport(void) const
{
    QString report;

    report += "{ ";
    report +=   "\"account:\" \"" + MainSettings::getInstance().getApplicationSettings()-&gt;getRangeAccount() + "\", ";
    report +=   "\"session:\" \"" + Session::getInstance().getID() + "\", ";
    report +=   "\"version:\" \"" + MainSettings::getInstance().getStoredVersion().toString() + "\", ";
    report +=   "\"system:\" { ";
    report +=     "\"buildAbi:\" \"" + QSysInfo::buildAbi() + "\", ";
    report +=     "\"buildCpuArchitecture:\" \"" + QSysInfo::buildCpuArchitecture() + "\", ";
    report +=     "\"currentCpuArchitecture:\" \"" + QSysInfo::currentCpuArchitecture() + "\", ";
    report +=     "\"kernelType:\" \"" + QSysInfo::kernelType() + "\", ";
    report +=     "\"kernelVersion:\" \"" + QSysInfo::kernelVersion() + "\", ";
    report +=     "\"machineHostName:\" \"" + QSysInfo::machineHostName() + "\", ";
    report +=     "\"prettyProductName:\" \"" + QSysInfo::prettyProductName() + "\", ";
    report +=     "\"productType:\" \"" + QSysInfo::productType() + "\", ";
    report +=     "\"productVersion:\" \"" + QSysInfo::productVersion() + "\" ";
    report +=   "}";
    report += "}";

    return report;
}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.71">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   value_line_edit.cpp                                      *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   18-th July 2012                                          *
 *                                                                   *
 *  DESCRIPTION: Value line edit class definition                    *
 *********************************************************************/

#include &lt;cmath&gt;
#include &lt;cfloat&gt;

#include "value_line_edit.h"

ValueLineEdit::ValueLineEdit(QWidget *parent)
    : QLineEdit(parent)
{
    this-&gt;createTimer();
    this-&gt;setDoubleValidator();
    QObject::connect(this,&amp;QLineEdit::textChanged,this,&amp;ValueLineEdit::onTextChaged);
}

ValueLineEdit::ValueLineEdit(double min, double max, QWidget *parent)
    : QLineEdit(parent)
{
    this-&gt;createTimer();
    this-&gt;setValidator(new QDoubleValidator(min,max,1000));
    QObject::connect(this,&amp;QLineEdit::textChanged,this,&amp;ValueLineEdit::onTextChaged);
}

ValueLineEdit::ValueLineEdit(int min, int max, QWidget *parent)
    : QLineEdit(parent)
{
    this-&gt;createTimer();
    this-&gt;setValidator(new QIntValidator(min, max));
    QObject::connect(this,&amp;QLineEdit::textChanged,this,&amp;ValueLineEdit::onTextChaged);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.72">void ValueLineEdit::setDoubleValidator()
{
    this-&gt;setValidator(new QDoubleValidator(-DBL_MAX,DBL_MAX,1000));
    this-&gt;paintBackground();
}

</t>
<t tx="leo.20201108101529.73">void ValueLineEdit::setIntValidator()
{
    this-&gt;setValidator(new QIntValidator(INT_MIN, INT_MAX));
    this-&gt;paintBackground();
}

</t>
<t tx="leo.20201108101529.74">void ValueLineEdit::setRange(double min, double max)
{
    this-&gt;setValidator(new QDoubleValidator(min,max,1000));
    this-&gt;paintBackground();
}

</t>
<t tx="leo.20201108101529.75">void ValueLineEdit::setRange(int min, int max)
{
    this-&gt;setValidator(new QIntValidator(min, max));
    this-&gt;paintBackground();
}

double ValueLineEdit::getMinimum() const
{
    return qobject_cast&lt;const QDoubleValidator *&gt;(this-&gt;validator())-&gt;bottom();
}

double ValueLineEdit::getMaximum() const
{
    return qobject_cast&lt;const QDoubleValidator *&gt;(this-&gt;validator())-&gt;top();
}

double ValueLineEdit::getValue() const
{
    return this-&gt;text().toDouble();
}

</t>
<t tx="leo.20201108101529.76">void ValueLineEdit::setValue(double value)
{
    this-&gt;setText(QString::number(value));
}

</t>
<t tx="leo.20201108101529.77">void ValueLineEdit::setValue(int value)
{
    this-&gt;setText(QString::number(value));
}

</t>
<t tx="leo.20201108101529.78">void ValueLineEdit::setValue(uint value)
{
    this-&gt;setText(QString::number(value));
}

QValidator::State ValueLineEdit::getValidatorState() const
{
    QString strContent = this-&gt;text();

    bool intermediateFound = false;

    for (int i=0;i&lt;strContent.length();i++)
    {
        switch (this-&gt;validator()-&gt;validate(strContent,i))
        {
            case QValidator::Invalid:
                return QValidator::Invalid;
            case QValidator::Intermediate:
                intermediateFound = true;
                break;
            case QValidator::Acceptable:
            default:
                break;
        }
    }

    if (intermediateFound)
    {
        return QValidator::Intermediate;
    }

    return QValidator::Acceptable;
}

</t>
<t tx="leo.20201108101529.79">void ValueLineEdit::createTimer()
{
    this-&gt;timer = new QTimer(this);
    QObject::connect(this-&gt;timer,
                     &amp;QTimer::timeout,
                     this,
                     &amp;ValueLineEdit::onTimeout);
}

</t>
<t tx="leo.20201108101529.8">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   solver_start_dialog.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   19-th September 2017                                     *
 *                                                                   *
 *  DESCRIPTION: Solver start dialog class definition                *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QGroupBox&gt;
#include &lt;QLabel&gt;
#include &lt;QIcon&gt;
#include &lt;QPushButton&gt;
#include &lt;QTextBrowser&gt;
#include &lt;QScrollBar&gt;
#include &lt;QLineEdit&gt;
#include &lt;QScrollArea&gt;

#include "main_settings.h"
#include "model_io.h"
#include "session.h"
#include "solver_manager.h"
#include "solver_setup_checker.h"
#include "solver_start_dialog.h"
#include "solver_task.h"

SolverStartDialog::SolverStartDialog(uint modelID, QWidget *parent)
    : QDialog(parent)
    , modelID(modelID)
{
    SolverSetupChecker solverSetupChecker(Session::getInstance().getModel(this-&gt;modelID));
    solverSetupChecker.perform(this-&gt;warnings,this-&gt;errors);

    const Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    this-&gt;pSolverTask = new SolverTask(MainSettings::getInstance().getApplicationSettings(),this-&gt;modelID);
    this-&gt;pSolverTask-&gt;setBlocking(false);

    this-&gt;setWindowTitle(QString("Start solver"));

    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QVBoxLayout *mainLayout = new QVBoxLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *messageLabel = new QLabel;
    messageLabel-&gt;setText(tr("Start solver for model:") + " &lt;b&gt;" + rModel.getName() + "&lt;/b&gt;");
    mainLayout-&gt;addWidget(messageLabel);

    if (this-&gt;warnings.size() || this-&gt;errors.size())
    {
        QTextBrowser *messagesBrowser = new QTextBrowser;
        mainLayout-&gt;addWidget(messagesBrowser);

        QString htmlMessage;

        if (this-&gt;errors.size() &gt; 0)
        {
            htmlMessage += "&lt;h3&gt;" + tr("Errors") + "&lt;/h3&gt;";
            htmlMessage += "&lt;ul&gt;";
            for (int i=0;i&lt;this-&gt;errors.size();i++)
            {
                htmlMessage += "&lt;li&gt;";
                htmlMessage += this-&gt;errors.at(i);
                htmlMessage += "&lt;/li&gt;";
            }
            htmlMessage += "&lt;/ul&gt;";
        }

        if (this-&gt;warnings.size() &gt; 0)
        {
            htmlMessage += "&lt;h3&gt;" + tr("Warnings") + "&lt;/h3&gt;";
            htmlMessage += "&lt;ul&gt;";
            for (int i=0;i&lt;this-&gt;warnings.size();i++)
            {
                htmlMessage += "&lt;li&gt;";
                htmlMessage += this-&gt;warnings.at(i);
                htmlMessage += "&lt;/li&gt;";
            }
            htmlMessage += "&lt;/ul&gt;";
        }

        messagesBrowser-&gt;insertHtml(htmlMessage);

        QTextCursor textCursor = messagesBrowser-&gt;textCursor();
        textCursor.movePosition(QTextCursor::Start);
        messagesBrowser-&gt;setTextCursor(textCursor);

        this-&gt;resize(600,400);
    }

    QLabel *commandTitleLabel = new QLabel(tr("Command line"));
    mainLayout-&gt;addWidget(commandTitleLabel);

    QScrollArea *scrollArea = new QScrollArea;
    scrollArea-&gt;setWidgetResizable(true);
    scrollArea-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Maximum);
    mainLayout-&gt;addWidget(scrollArea);

    QLabel *commandLineLabel = new QLabel(this-&gt;pSolverTask-&gt;getCommandLine());
    commandLineLabel-&gt;setTextInteractionFlags(Qt::TextSelectableByMouse);
    commandLineLabel-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Maximum);
    scrollArea-&gt;setWidget(commandLineLabel);

    this-&gt;restartSolverCheck = new QCheckBox("Restart solver / continue");
    if (Session::getInstance().getModel(this-&gt;modelID).getNVariables() == 0)
    {
        this-&gt;restartSolverCheck-&gt;setDisabled(true);
        this-&gt;restartSolverCheck-&gt;setChecked(false);
    }
    else
    {
        this-&gt;restartSolverCheck-&gt;setEnabled(true);
        this-&gt;restartSolverCheck-&gt;setChecked(rModel.getProblemSetup().getRestart());
    }
    mainLayout-&gt;addWidget(this-&gt;restartSolverCheck);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDisabled(this-&gt;errors.size() &gt; 0);
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;SolverStartDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;SolverStartDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101529.80">void ValueLineEdit::paintBackground()
{
    if (this-&gt;timer-&gt;isActive())
    {
        this-&gt;timer-&gt;stop();
    }
    switch (this-&gt;getValidatorState())
    {
        case QValidator::Invalid:
        {
            this-&gt;setStyleSheet("QLineEdit{background: red;}");
            this-&gt;timer-&gt;start(2000);
            break;
        }
        case QValidator::Intermediate:
        {
            this-&gt;setStyleSheet("QLineEdit{background: rgb(255, 200, 200);}");
            this-&gt;timer-&gt;start(2000);
            break;
        }
        case QValidator::Acceptable:
        default:
        {
            this-&gt;setStyleSheet("");
            break;
        }
    }
}

</t>
<t tx="leo.20201108101529.81">void ValueLineEdit::onTextChaged(QString text)
{
    this-&gt;paintBackground();
    emit this-&gt;valueChanged(text.toDouble());
}

</t>
<t tx="leo.20201108101529.82">void ValueLineEdit::onTimeout()
{
    QString newText = this-&gt;text();
    newText.remove(newText.length()-1,1);
    this-&gt;setText(newText);
}
</t>
<t tx="leo.20201108101529.9">int SolverStartDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        Session::getInstance().getModel(this-&gt;modelID).getProblemSetup().setRestart(this-&gt;restartSolverCheck-&gt;isChecked());
        Session::getInstance().getModel(this-&gt;modelID).getTimeSolver().harmonizeTimesWithInput(this-&gt;restartSolverCheck-&gt;isChecked());

        // Start solver task
        SolverManager::getInstance().submit(this-&gt;pSolverTask);
    }
    else
    {
        delete this-&gt;pSolverTask;
    }

    return retVal;
}
</t>
<t tx="leo.20201108101530.1">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   value_scale.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th December 2016                                      *
 *                                                                   *
 *  DESCRIPTION: Value scale widget class definition                 *
 *********************************************************************/

#include &lt;QVBoxLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QGridLayout&gt;
#include &lt;QLabel&gt;
#include &lt;QGroupBox&gt;

#include &lt;rblib.h&gt;

#include "value_scale.h"

const double ValueScale::mantisScale = 10.0;
const uint ValueScale::mantisSize = 100;
const uint ValueScale::exponentSize = 100;

ValueScale::ValueScale(const QString &amp;title, QWidget *parent)
    : QWidget(parent)
    , expandable(false)
    , mantis(1.0)
    , exponent(1.0)
    , setScaleAllowed(true)
{
    QVBoxLayout *mainLayout = new QVBoxLayout;
    mainLayout-&gt;setMargin(0);
    this-&gt;setLayout(mainLayout);

    QGroupBox *scaleGroupBox= new QGroupBox(title);
    mainLayout-&gt;addWidget(scaleGroupBox);

    QVBoxLayout *scaleLayout = new QVBoxLayout;
    scaleGroupBox-&gt;setLayout(scaleLayout);

    QHBoxLayout *editLayout = new QHBoxLayout;
    editLayout-&gt;setMargin(0);
    scaleLayout-&gt;addLayout(editLayout);

    this-&gt;scaleEdit = new ValueLineEdit(-ValueScale::mantisScale*std::pow(10,ValueScale::exponentSize),ValueScale::mantisScale*std::pow(10,ValueScale::exponentSize));
    this-&gt;scaleEdit-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Minimum);
    editLayout-&gt;addWidget(this-&gt;scaleEdit);

    this-&gt;expandButton = new QPushButton(tr("more"));
    this-&gt;expandButton-&gt;setSizePolicy(QSizePolicy::Minimum,QSizePolicy::Minimum);
    editLayout-&gt;addWidget(this-&gt;expandButton);
    if (this-&gt;expandable)
    {
        this-&gt;expandButton-&gt;show();
    }
    else
    {
        this-&gt;expandButton-&gt;hide();
    }

    this-&gt;expandWidget = new QWidget;
    scaleLayout-&gt;addWidget(expandWidget);

    QGridLayout *expandLayout = new QGridLayout;
    expandLayout-&gt;setMargin(0);
    expandWidget-&gt;setLayout(expandLayout);

    QLabel *mantisLabel = new QLabel(tr("Scale") + ":");
    mantisLabel-&gt;setSizePolicy(QSizePolicy::Minimum,QSizePolicy::Minimum);
    expandLayout-&gt;addWidget(mantisLabel,0,0,1,1);

    this-&gt;mantisSlider = new QSlider(Qt::Horizontal);
    this-&gt;mantisSlider-&gt;setRange(-100,100);
    this-&gt;mantisSlider-&gt;setPageStep(10);
    this-&gt;mantisSlider-&gt;setSingleStep(1);
    this-&gt;mantisSlider-&gt;setSizePolicy(QSizePolicy::MinimumExpanding,QSizePolicy::Minimum);
    expandLayout-&gt;addWidget(this-&gt;mantisSlider,0,1,1,2);

    this-&gt;mantisEdit = new ValueLineEdit(-ValueScale::mantisScale,ValueScale::mantisScale);
    this-&gt;mantisEdit-&gt;setSizePolicy(QSizePolicy::Minimum,QSizePolicy::Minimum);
    expandLayout-&gt;addWidget(this-&gt;mantisEdit,0,3,1,1);

    QLabel *exponentLabel = new QLabel(tr("Factor") + ":");
    exponentLabel-&gt;setSizePolicy(QSizePolicy::Minimum,QSizePolicy::Minimum);
    expandLayout-&gt;addWidget(exponentLabel,1,0,1,1);

    QLabel *scaleExponentMantisLabel = new QLabel("1.0e");
    scaleExponentMantisLabel-&gt;setSizePolicy(QSizePolicy::Minimum,QSizePolicy::Minimum);
    scaleExponentMantisLabel-&gt;setAlignment(Qt::AlignRight);
    expandLayout-&gt;addWidget(scaleExponentMantisLabel,1,1,1,1);

    this-&gt;exponentSpinBox = new QSpinBox;
    this-&gt;exponentSpinBox-&gt;setRange(-int(ValueScale::exponentSize),int(ValueScale::exponentSize));
    this-&gt;exponentSpinBox-&gt;setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Minimum);
    expandLayout-&gt;addWidget(this-&gt;exponentSpinBox,1,2,1,2);

    if (this-&gt;expandWidget-&gt;isHidden())
    {
        this-&gt;expandButton-&gt;setText(tr("more"));
    }
    else
    {
        this-&gt;expandButton-&gt;setText(tr("less"));
    }

    QObject::connect(this-&gt;scaleEdit,&amp;ValueLineEdit::valueChanged,this,&amp;ValueScale::onScaleEditChanged);

    QObject::connect(this-&gt;expandButton,&amp;QPushButton::clicked,this,&amp;ValueScale::onExpandButtonClicked);

    QObject::connect(this-&gt;mantisSlider,&amp;QSlider::valueChanged,this,&amp;ValueScale::onMantisSliderChanged);
    QObject::connect(this-&gt;mantisEdit,&amp;ValueLineEdit::valueChanged,this,&amp;ValueScale::onMantisEditChanged);

    this-&gt;connect(this-&gt;exponentSpinBox,SIGNAL(valueChanged(int)),SLOT(onExponentSpinBoxChanged(int)));

    this-&gt;setValue(1.0);
}

double ValueScale::getValue() const
{
    return this-&gt;mantis*std::pow(10.0,this-&gt;exponent);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.10">class ValueSetGeneratorStaticValues
{
    public:
        FuncType funcType;
        double a;
        double b;
        double c;
        double d;
    public:
        ValueSetGeneratorStaticValues()
        {
            this-&gt;initialize();
        }
        @others
};

QMap&lt;QString,ValueSetGeneratorStaticValues&gt; ValueSetGeneratorDialog::values = QMap&lt;QString,ValueSetGeneratorStaticValues&gt;();

</t>
<t tx="leo.20201108101530.11">void initialize(void)
{
    this-&gt;funcType = FUNC_SIN;
    this-&gt;a = 0.0;
    this-&gt;b = 1.0;
    this-&gt;c = 0.0;
    this-&gt;d = 1.0;
}
</t>
<t tx="leo.20201108101530.12">static double funcFindValue(FuncType funcType, const ValueSetGeneratorStaticValues &amp;values, double key)
{
    switch (funcType)
    {
        case FUNC_FILL_A:
        {
            return values.a;
        }
        case FUNC_LINEAR:
        {
            return values.a+values.b*key;
        }
        case FUNC_SIN:
        {
            return values.a+values.b+sin(RConstants::pi*(values.c+values.d*key));
        }
        case FUNC_COS:
        {
            return values.a+values.b+cos(RConstants::pi*(values.c+values.d*key));
        }
        default:
        {
            return 0.0;
        }
    }
}

</t>
<t tx="leo.20201108101530.13">static QString getFuncName(FuncType funcType, const QString &amp;keySymbol)
{
    switch (funcType)
    {
        case FUNC_FILL_A:
        {
            return "A";
        }
        case FUNC_LINEAR:
        {
            return "A+B*" + keySymbol;
        }
        case FUNC_SIN:
        {
            return "A+B*sin(" + QString(QChar(0xC0, 0x03)) + "*(C+D*" + keySymbol + "))";
        }
        case FUNC_COS:
        {
            return "A+B*cos(" + QString(QChar(0xC0, 0x03)) + "*(C+D*" + keySymbol + "))";
        }
        default:
        {
            return QString();
        }
    }
}

ValueSetGeneratorDialog::ValueSetGeneratorDialog(RValueTable &amp;valueTable, QWidget *parent)
    : QDialog(parent)
    , valueTable(valueTable)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    QString windowTitleStr = tr("Value set generator");
    this-&gt;setWindowTitle(tr(windowTitleStr.toUtf8().constData()));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    uint mainLayoutRowCnt = 0;

    QString key(this-&gt;valueTable.getKeyName() + "/" + this-&gt;valueTable.getValueName());
    bool isNew = !ValueSetGeneratorDialog::values.contains(key);
    ValueSetGeneratorStaticValues values = ValueSetGeneratorDialog::values[key];

    QLabel *valueLabel = new QLabel(this-&gt;valueTable.getValueName() + " = ");
    mainLayout-&gt;addWidget(valueLabel, mainLayoutRowCnt, 0, 1, 2);

    this-&gt;funcComboBox = new QComboBox;
    mainLayout-&gt;addWidget(this-&gt;funcComboBox, mainLayoutRowCnt++, 2, 1, 1);
    for (uint i=0;i&lt;uint(FUNC_N_FUNCS);i++)
    {
        this-&gt;funcComboBox-&gt;addItem(getFuncName(FuncType(i),this-&gt;valueTable.getKeyName()));
    }

    this-&gt;connect(this-&gt;funcComboBox,
                  SIGNAL(currentIndexChanged(int)),
                  SLOT(onFuncComboCurrentIndexChanged(int)));

    QLabel *aLabel = new QLabel("A = ");
    mainLayout-&gt;addWidget(aLabel, mainLayoutRowCnt, 0, 1, 1);

    this-&gt;aLineEdit = new ValueLineEdit;
    mainLayout-&gt;addWidget(this-&gt;aLineEdit, mainLayoutRowCnt++, 1, 1, 2);
    this-&gt;aLineEdit-&gt;setValue(values.a);
    if (isNew &amp;&amp; this-&gt;valueTable.size() &gt; 0)
    {
        this-&gt;aLineEdit-&gt;setValue(this-&gt;valueTable.getValue(0));
    }

    QLabel *bLabel = new QLabel("B = ");
    mainLayout-&gt;addWidget(bLabel, mainLayoutRowCnt, 0, 1, 1);

    this-&gt;bLineEdit = new ValueLineEdit;
    mainLayout-&gt;addWidget(this-&gt;bLineEdit, mainLayoutRowCnt++, 1, 1, 2);
    this-&gt;bLineEdit-&gt;setValue(values.b);

    QLabel *cLabel = new QLabel("C = ");
    mainLayout-&gt;addWidget(cLabel, mainLayoutRowCnt, 0, 1, 1);

    this-&gt;cLineEdit = new ValueLineEdit;
    mainLayout-&gt;addWidget(this-&gt;cLineEdit, mainLayoutRowCnt++, 1, 1, 2);
    this-&gt;cLineEdit-&gt;setValue(values.c);

    QLabel *dLabel = new QLabel("D = ");
    mainLayout-&gt;addWidget(dLabel, mainLayoutRowCnt, 0, 1, 1);

    this-&gt;dLineEdit = new ValueLineEdit;
    mainLayout-&gt;addWidget(this-&gt;dLineEdit, mainLayoutRowCnt++, 1, 1, 2);
    this-&gt;dLineEdit-&gt;setValue(values.d);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, mainLayoutRowCnt++, 0, 1, 3);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
//    this-&gt;okButton-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;ValueSetGeneratorDialog::reject);
    QObject::connect(this-&gt;okButton,&amp;QPushButton::clicked,this,&amp;ValueSetGeneratorDialog::accept);

    this-&gt;funcComboBox-&gt;setCurrentIndex(values.funcType);
}

</t>
<t tx="leo.20201108101530.14">int ValueSetGeneratorDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        FuncType funcType = FuncType(this-&gt;funcComboBox-&gt;currentIndex());

        ValueSetGeneratorStaticValues values;

        values.funcType = FuncType(this-&gt;funcComboBox-&gt;currentIndex());
        values.a = this-&gt;aLineEdit-&gt;getValue();
        values.b = this-&gt;bLineEdit-&gt;getValue();
        values.c = this-&gt;cLineEdit-&gt;getValue();
        values.d = this-&gt;dLineEdit-&gt;getValue();
        for (uint i=0;i&lt;this-&gt;valueTable.size();i++)
        {
            double key = this-&gt;valueTable.getKey(i);
            this-&gt;valueTable.add(key,funcFindValue(funcType,values,key));
        }

        ValueSetGeneratorDialog::values[this-&gt;valueTable.getKeyName() + "/" + this-&gt;valueTable.getValueName()] = values;
    }

    return retVal;
}

</t>
<t tx="leo.20201108101530.15">void ValueSetGeneratorDialog::onFuncComboCurrentIndexChanged(int index)
{
    this-&gt;aLineEdit-&gt;setEnabled(true);
    this-&gt;bLineEdit-&gt;setEnabled(true);
    this-&gt;cLineEdit-&gt;setEnabled(true);
    this-&gt;dLineEdit-&gt;setEnabled(true);

    switch (index)
    {
        case FUNC_FILL_A:
            this-&gt;bLineEdit-&gt;setDisabled(true);
            this-&gt;cLineEdit-&gt;setDisabled(true);
            this-&gt;dLineEdit-&gt;setDisabled(true);
            break;
        case FUNC_LINEAR:
            this-&gt;cLineEdit-&gt;setDisabled(true);
            this-&gt;dLineEdit-&gt;setDisabled(true);
            break;
        default:
            break;
    }
}
</t>
<t tx="leo.20201108101530.16">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   value_table.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   3-rd August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Value table class definition                        *
 *********************************************************************/

#include &lt;QAbstractItemModel&gt;
#include &lt;QFileDialog&gt;
#include &lt;QVector2D&gt;
#include &lt;QTextStream&gt;
#include &lt;QHeaderView&gt;

#include &lt;rblib.h&gt;

#include "main_settings.h"
#include "value_table.h"
#include "graph_dialog.h"
#include "graph_object.h"
#include "value_set_generator_dialog.h"
#include "main_window.h"

namespace ValueTableTreeTypes
{
    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.17">    typedef enum _Column
    {
        COLUMN_KEY = 0,
        COLUMN_VALUE,
        N_COLUMNS
    } Column;
}

ValueTable::ValueTable(QWidget *parent) :
    QTableWidget(parent),
    dataType(R_VARIABLE_DATA_DOUBLE)
{
    this-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection);

    this-&gt;setColumnCount(ValueTableTreeTypes::N_COLUMNS);

    this-&gt;setHorizontalHeaderItem(ValueTableTreeTypes::COLUMN_KEY,new QTableWidgetItem);
    this-&gt;setHorizontalHeaderItem(ValueTableTreeTypes::COLUMN_VALUE,new QTableWidgetItem);

    this-&gt;setKeyHeader("Key");
    this-&gt;setValueHeader("Value");

    this-&gt;resizeColumnsToContents();

    this-&gt;horizontalHeader()-&gt;setStretchLastSection(true);

    this-&gt;setContextMenuPolicy(Qt::ActionsContextMenu);

    this-&gt;insertValueAction = new QAction(this);
    this-&gt;insertValueAction-&gt;setText(tr("Insert"));
    this-&gt;addAction(this-&gt;insertValueAction);

    QObject::connect(this-&gt;insertValueAction,
                     &amp;QAction::triggered,
                     this,
                     &amp;ValueTable::onInsertValue);

    this-&gt;deleteValueAction = new QAction(this);
    this-&gt;deleteValueAction-&gt;setText(tr("Remove selected"));
    this-&gt;addAction(this-&gt;deleteValueAction);

    QObject::connect(this-&gt;deleteValueAction,
                     &amp;QAction::triggered,
                     this,
                     &amp;ValueTable::onDeleteValue);

    QAction *separator1 = new QAction(this);
    separator1-&gt;setSeparator(true);
    this-&gt;addAction(separator1);

    this-&gt;importFromFileAction = new QAction(this);
    this-&gt;importFromFileAction-&gt;setText(tr("Import from file"));
    this-&gt;importFromFileAction-&gt;setIcon(QIcon(":/icons/file/pixmaps/range-open.svg"));
    this-&gt;addAction(this-&gt;importFromFileAction);

    QObject::connect(this-&gt;importFromFileAction,
                     &amp;QAction::triggered,
                     this,
                     &amp;ValueTable::onImportFromFile);

    this-&gt;fillValuesAction = new QAction(this);
    this-&gt;fillValuesAction-&gt;setText(tr("Fill values"));
    this-&gt;addAction(this-&gt;fillValuesAction);

    QObject::connect(this-&gt;fillValuesAction,
                     &amp;QAction::triggered,
                     this,
                     &amp;ValueTable::onFillValues);

    this-&gt;viewGraphAction = new QAction(this);
    this-&gt;viewGraphAction-&gt;setText(tr("View graph"));
    this-&gt;addAction(this-&gt;viewGraphAction);

    QAction *separator2 = new QAction(this);
    separator2-&gt;setSeparator(true);
    this-&gt;addAction(separator2);

    QObject::connect(this-&gt;viewGraphAction,
                     &amp;QAction::triggered,
                     this,
                     &amp;ValueTable::onViewGraph);
}

</t>
<t tx="leo.20201108101530.18">void ValueTable::setDataType(RVariableDataType dataType)
{
    this-&gt;dataType = dataType;
}

</t>
<t tx="leo.20201108101530.19">void ValueTable::setKeyHeader(const QString &amp;header)
{
    this-&gt;horizontalHeaderItem(ValueTableTreeTypes::COLUMN_KEY)-&gt;setText(header);
    this-&gt;resizeColumnToContents(ValueTableTreeTypes::COLUMN_KEY);
}

</t>
<t tx="leo.20201108101530.2">void ValueScale::setValue(double value)
{
    this-&gt;mantis = RUtil::frexp10(value,&amp;this-&gt;exponent);
    this-&gt;mantis *= 10;
    this-&gt;exponent -= 1;
    this-&gt;mantisEdit-&gt;setValue(this-&gt;mantis);
    this-&gt;exponentSpinBox-&gt;setValue(this-&gt;exponent);
    this-&gt;scaleEdit-&gt;setValue(value);
}

</t>
<t tx="leo.20201108101530.20">void ValueTable::setValueHeader(const QString &amp;header)
{
    this-&gt;horizontalHeaderItem(ValueTableTreeTypes::COLUMN_VALUE)-&gt;setText(header);
}

</t>
<t tx="leo.20201108101530.21">void ValueTable::addValue(double key, double value, int rowNumber)
{
    int iRow = rowNumber &gt;= 0 &amp;&amp; rowNumber &lt; this-&gt;rowCount() ? rowNumber : this-&gt;rowCount();

    this-&gt;insertRow(iRow);

    QTableWidgetItem *itemKey = new QTableWidgetItem;
    itemKey-&gt;setText(QString::number(key));
    itemKey-&gt;setData(Qt::UserRole,QVariant(key));
    this-&gt;setItem(iRow,ValueTableTreeTypes::COLUMN_KEY,itemKey);

    QTableWidgetItem *itemValue = new QTableWidgetItem;
    itemValue-&gt;setData(Qt::UserRole,QVariant(value));
    if (this-&gt;dataType == R_VARIABLE_DATA_BOOLEAN)
    {
        itemValue-&gt;setData(Qt::CheckStateRole,QVariant(value != 0.0 ? Qt::Checked : Qt::Unchecked));
    }
    else
    {
        itemValue-&gt;setText(QString::number(value));
    }
    this-&gt;setItem(iRow,ValueTableTreeTypes::COLUMN_VALUE,itemValue);

    QObject::connect(this,
                     &amp;QTableWidget::itemChanged,
                     this,
                     &amp;ValueTable::onItemChanged);

    this-&gt;resizeColumnToContents(ValueTableTreeTypes::COLUMN_KEY);

    emit this-&gt;sizeChanged(uint(this-&gt;rowCount()));
}

</t>
<t tx="leo.20201108101530.22">void ValueTable::removeValue(int rowNumber)
{
    this-&gt;removeRow(rowNumber);
    emit this-&gt;sizeChanged(uint(this-&gt;rowCount()));
}

double ValueTable::getKey(uint row) const
{
    return this-&gt;item(int(row),ValueTableTreeTypes::COLUMN_KEY)-&gt;text().toDouble();
}

double ValueTable::getValue(uint row) const
{
    if (this-&gt;dataType == R_VARIABLE_DATA_BOOLEAN)
    {
        return (this-&gt;item(int(row),ValueTableTreeTypes::COLUMN_VALUE)-&gt;data(Qt::CheckStateRole).toInt() != Qt::Unchecked ? 1.0 : 0.0);
    }
    else
    {
        return this-&gt;item(int(row),ValueTableTreeTypes::COLUMN_VALUE)-&gt;text().toDouble();
    }
}

</t>
<t tx="leo.20201108101530.23">void ValueTable::onItemChanged(QTableWidgetItem *item)
{
    bool ok = true;
    double value = 0.0;

    switch (item-&gt;column())
    {
        case ValueTableTreeTypes::COLUMN_VALUE:
            if (this-&gt;dataType == R_VARIABLE_DATA_BOOLEAN)
            {
                value = item-&gt;data(Qt::CheckStateRole).toInt(&amp;ok) != Qt::Unchecked ? 1.0 : 0.0;
            }
            else
            {
                value = QString(item-&gt;text()).toDouble(&amp;ok);
            }
            if (!ok)
            {
                if (this-&gt;dataType == R_VARIABLE_DATA_BOOLEAN)
                {
                    item-&gt;setData(Qt::CheckStateRole,QVariant(value != 0.0 ? Qt::Checked : Qt::Unchecked));
                }
                else
                {
                    item-&gt;setText(QString::number(value));
                }
                break;
            }
            item-&gt;setData(Qt::UserRole,QVariant(value));
            break;
        case ValueTableTreeTypes::COLUMN_KEY:
            value = QString(item-&gt;text()).toDouble(&amp;ok);
            if (!ok)
            {
                item-&gt;setText(QString::number(value));
                break;
            }
            item-&gt;setData(Qt::UserRole,QVariant(value));
            break;
        default:
            break;
    }
}

</t>
<t tx="leo.20201108101530.24">void ValueTable::onInsertValue(void)
{
    QList&lt;QTableWidgetItem*&gt; selectionRangeList = this-&gt;selectedItems();
    QListIterator&lt;QTableWidgetItem*&gt; selectionRangeListIter(selectionRangeList);

    QList&lt;int&gt; selectedRows;

    while(selectionRangeListIter.hasNext())
    {
        int selectedRow = this-&gt;row(selectionRangeListIter.next());
        if (!selectedRows.contains(selectedRow))
        {
            selectedRows.append(selectedRow);
        }
    }

    std::sort(selectedRows.begin(), selectedRows.end(), std::greater&lt;int&gt;());

    for (int i=0;i&lt;selectedRows.size();i++)
    {
        this-&gt;addValue(this-&gt;item(selectedRows[i],ValueTableTreeTypes::COLUMN_KEY)-&gt;data(Qt::UserRole).toDouble(),
                       this-&gt;item(selectedRows[i],ValueTableTreeTypes::COLUMN_VALUE)-&gt;data(Qt::UserRole).toDouble(),
                       selectedRows[i]+1);
    }
}

</t>
<t tx="leo.20201108101530.25">void ValueTable::onDeleteValue(void)
{
    QList&lt;QTableWidgetItem*&gt; selectionRangeList = this-&gt;selectedItems();
    QListIterator&lt;QTableWidgetItem*&gt; selectionRangeListIter(selectionRangeList);

    while(selectionRangeListIter.hasNext())
    {
        this-&gt;removeValue(this-&gt;row(selectionRangeListIter.next()));
    }
}

</t>
<t tx="leo.20201108101530.26">void ValueTable::onImportFromFile(void)
{
    QString fileName = QFileDialog::getOpenFileName(dynamic_cast&lt;QWidget*&gt;(this-&gt;parent()),
                                                    tr("Open data file"),
                                                    MainSettings::getInstance().getHomeDir(),
                                                    "Any files (*)");
    if (fileName.isEmpty())
    {
        return;
    }

    while (this-&gt;rowCount() &gt; 0)
    {
        this-&gt;removeRow(0);
    }

    RLogger::info("Reading file \'%s\'\n",fileName.toUtf8().constData());

    QFile file(fileName);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        RLogger::warning("Failed to open the file \'%s\' for reading.\n", fileName.toUtf8().constData());
        return;
    }

    try
    {
        QTextStream in(&amp;file);

        bool isOdd = true;
        while (!in.atEnd())
        {
            QString line = in.readLine();
            QStringList stringList = line.split(' ',QString::SkipEmptyParts);

            QVector2D value;
            for (int i=0;i&lt;stringList.size();i++)
            {
                value[isOdd?0:1] = stringList[i].toFloat();
                if (!isOdd)
                {
                    this-&gt;addValue(double(value[0]),double(value[1]));
                }
                isOdd = !isOdd;
            }
        }
    }
    catch (...)
    {
        RLogger::warning("Failed to read the file \'%s\'.\n", fileName.toUtf8().constData());
    }
    file.close();
}

</t>
<t tx="leo.20201108101530.27">void ValueTable::onViewGraph(void)
{
    GraphObject *graphObject = new GraphObject;
    GraphData &amp;rGraphData = graphObject-&gt;getData();

    rGraphData.setTitle("Table values");
    rGraphData.setXLabel(this-&gt;horizontalHeaderItem(ValueTableTreeTypes::COLUMN_KEY)-&gt;text());
    rGraphData.setYLabel(this-&gt;horizontalHeaderItem(ValueTableTreeTypes::COLUMN_VALUE)-&gt;text());
    rGraphData.setTypeMask(GRAPH_LINES);

    double minKey = 0, maxKey = 0;
    for (int i=0;i&lt;this-&gt;rowCount();i++)
    {
        double key = this-&gt;item(i,ValueTableTreeTypes::COLUMN_KEY)-&gt;text().toDouble();
        RRVector &amp;rValues = rGraphData[key];
        rValues.resize(1);
        rValues[0] = this-&gt;item(i,ValueTableTreeTypes::COLUMN_VALUE)-&gt;text().toDouble();
        if (i==0)
        {
            minKey = maxKey = key;
        }
        minKey = std::min(minKey,key);
        maxKey = std::max(maxKey,key);
    }

    rGraphData.setLimits(minKey,maxKey);

    GraphDialog graphDialog(graphObject, MainWindow::getInstance());
    graphDialog.getGraphWidget()-&gt;setShowPointer(true,true,true);
    graphDialog.exec();
}

</t>
<t tx="leo.20201108101530.28">void ValueTable::onFillValues(void)
{
    RValueTable valueTable;
    valueTable.setKeyName(this-&gt;horizontalHeaderItem(ValueTableTreeTypes::COLUMN_KEY)-&gt;text());
    valueTable.setValueName(this-&gt;horizontalHeaderItem(ValueTableTreeTypes::COLUMN_VALUE)-&gt;text());
    for (int i=0;i&lt;this-&gt;rowCount();i++)
    {
        valueTable.add(this-&gt;item(i,ValueTableTreeTypes::COLUMN_KEY)-&gt;text().toDouble(),
                       this-&gt;item(i,ValueTableTreeTypes::COLUMN_VALUE)-&gt;text().toDouble());
    }
    ValueSetGeneratorDialog valueSetGeneratorDialog(valueTable,this);
    if (valueSetGeneratorDialog.exec() == QDialog::Accepted)
    {
        bool isSomethingSelected = (this-&gt;selectedItems().size() &gt; 0);
        for (int i=0;i&lt;this-&gt;rowCount();i++)
        {
            if (!isSomethingSelected || this-&gt;item(i,ValueTableTreeTypes::COLUMN_VALUE)-&gt;isSelected())
            {
                this-&gt;item(i,ValueTableTreeTypes::COLUMN_VALUE)-&gt;setText(QString::number(valueTable.getValue(uint(i))));
            }
        }
    }
}
</t>
<t tx="leo.20201108101530.29">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   variable_selector.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th March 2014                                         *
 *                                                                   *
 *  DESCRIPTION: Variable selector class definition                  *
 *********************************************************************/

#include "variable_selector.h"

VariableSelector::VariableSelector(const std::vector&lt;RVariableType&gt; &amp;variableTypes, QWidget *parent) :
    QComboBox(parent)
{
    this-&gt;populate(variableTypes);

    this-&gt;connect(this,SIGNAL(currentIndexChanged(int)),SLOT(onCurrentIndexChanged(int)));
}

RVariableType VariableSelector::getCurrentVariableType(void) const
{
    return RVariableType(this-&gt;currentData().toInt());
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.3">void ValueScale::onScaleEditChanged(double value)
{
    this-&gt;setScaleAllowed = false;

    this-&gt;mantis = RUtil::frexp10(value,&amp;this-&gt;exponent);
    this-&gt;mantis *= 10;
    this-&gt;exponent -= 1;
    this-&gt;blockSignals(true);
    this-&gt;mantisEdit-&gt;setValue(this-&gt;mantis);
    this-&gt;exponentSpinBox-&gt;setValue(this-&gt;exponent);
    this-&gt;blockSignals(false);

    this-&gt;setScaleAllowed = true;

    emit this-&gt;valueChanged(value);
}

</t>
<t tx="leo.20201108101530.30">bool VariableSelector::setCurrentVariableType(RVariableType variableType)
{
    for (int i=0;i&lt;this-&gt;count();i++)
    {
        if (RVariableType(this-&gt;itemData(i).toInt()) == variableType)
        {
            this-&gt;setCurrentIndex(i);
            return true;
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101530.31">void VariableSelector::populate(const std::vector&lt;RVariableType&gt; &amp;variableTypes)
{
    this-&gt;blockSignals(true);
    this-&gt;clear();

    for (uint i=0;i&lt;variableTypes.size();i++)
    {
        this-&gt;addItem(RVariable::getName(variableTypes[i]),QVariant(variableTypes[i]));
    }

    this-&gt;blockSignals(false);
}

</t>
<t tx="leo.20201108101530.32">void VariableSelector::onCurrentIndexChanged(int index)
{
    emit this-&gt;resultsVariableSelected(RVariableType(this-&gt;itemData(index).toInt()));
}
</t>
<t tx="leo.20201108101530.33">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   variable_value_edit.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   18-th July 2012                                          *
 *                                                                   *
 *  DESCRIPTION: Variable value edit class definition                *
 *********************************************************************/

#include &lt;cmath&gt;

#include &lt;QGridLayout&gt;

#include "variable_value_edit.h"

VariableValueEdit::VariableValueEdit(RVariableType variableType, QWidget *parent) :
    QWidget(parent),
    type(variableType)
{
    QGridLayout *layout = new QGridLayout;
    this-&gt;setLayout(layout);

    RVariableDataType dataType = RVariable::getDataType(this-&gt;type);

    if (dataType == R_VARIABLE_DATA_INTEGER)
    {
        this-&gt;lineEdit = new ValueLineEdit();
        this-&gt;lineEdit-&gt;setIntValidator();
        layout-&gt;addWidget(this-&gt;lineEdit);

        QObject::connect(this-&gt;lineEdit,
                         &amp;ValueLineEdit::valueChanged,
                         this,
                         &amp;VariableValueEdit::onValueChaged);
    }
    else if (dataType == R_VARIABLE_DATA_UNSIGNED_INTEGER)
    {
        this-&gt;lineEdit = new ValueLineEdit();
        this-&gt;lineEdit-&gt;setRange(0,INT_MAX);
        layout-&gt;addWidget(this-&gt;lineEdit);

        QObject::connect(this-&gt;lineEdit,
                         &amp;ValueLineEdit::valueChanged,
                         this,
                         &amp;VariableValueEdit::onValueChaged);
    }
    else if (dataType == R_VARIABLE_DATA_DOUBLE)
    {
        this-&gt;lineEdit = new ValueLineEdit();
        this-&gt;lineEdit-&gt;setDoubleValidator();
        layout-&gt;addWidget(this-&gt;lineEdit);

        QObject::connect(this-&gt;lineEdit,
                         &amp;ValueLineEdit::valueChanged,
                         this,
                         &amp;VariableValueEdit::onValueChaged);
    }
    else if (dataType == R_VARIABLE_DATA_BOOLEAN)
    {
        this-&gt;checkBox = new QCheckBox;
        layout-&gt;addWidget(this-&gt;checkBox);

        QObject::connect(this-&gt;checkBox,
                         &amp;QCheckBox::stateChanged,
                         this,
                         &amp;VariableValueEdit::onStateChaged);
    }
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.34">void VariableValueEdit::setValue(double value)
{
    RVariableDataType dataType = RVariable::getDataType(this-&gt;type);

    if (dataType == R_VARIABLE_DATA_DOUBLE)
    {
        this-&gt;lineEdit-&gt;setValue(value);
    }
    else if (dataType == R_VARIABLE_DATA_INTEGER)
    {
        this-&gt;lineEdit-&gt;setValue(int(std::ceil(value)));
    }
    else if (dataType == R_VARIABLE_DATA_UNSIGNED_INTEGER)
    {
        this-&gt;lineEdit-&gt;setValue(uint(std::ceil(value)));
    }
    else if (dataType == R_VARIABLE_DATA_BOOLEAN)
    {
        this-&gt;checkBox-&gt;setChecked(value != 0.0);
    }
}

</t>
<t tx="leo.20201108101530.35">void VariableValueEdit::onValueChaged(double value)
{
    emit this-&gt;valueChanged(this-&gt;type,value);
}

</t>
<t tx="leo.20201108101530.36">void VariableValueEdit::onStateChaged(int state)
{
    emit this-&gt;valueChanged(this-&gt;type,(state == Qt::Checked) ? 1.0 : 0.0);
}
</t>
<t tx="leo.20201108101530.37">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   vector_field_dialog.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Vector field dialog class definition                *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include "session.h"
#include "vector_field_dialog.h"

VectorFieldDialog::VectorFieldDialog(uint modelID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityID(RConstants::eod)
{
    this-&gt;createDialog();
}

VectorFieldDialog::VectorFieldDialog(uint modelID, uint entityID, QWidget *parent) :
    QDialog(parent),
    modelID(modelID),
    entityID(entityID)
{
    this-&gt;createDialog();
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.38">int VectorFieldDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        RVariableType varType = this-&gt;getVariableType();
        QList&lt;SessionEntityID&gt; entities = this-&gt;modelTree-&gt;getSelected();

        if (varType != R_VARIABLE_NONE &amp;&amp; entities.size() &gt; 0)
        {
            Session::getInstance().storeCurentModelVersion(this-&gt;modelID,tr("Create vector field"));

            if (this-&gt;entityID != RConstants::eod)
            {
                RVectorField &amp;vectorField = Session::getInstance().getModel(this-&gt;modelID).getVectorField(this-&gt;entityID);

                vectorField.clearElementGroupIDs();

                vectorField.setVariableType(varType);
                vectorField.setType3D(this-&gt;type3DCheckbox-&gt;checkState() != Qt::Unchecked);

                for (int i=0;i&lt;entities.size();i++)
                {
                    uint elementGroupId = Session::getInstance().getModel(this-&gt;modelID).getEntityGroupID(entities[i].getType(),
                                                                                                          entities[i].getEid());
                    if (elementGroupId == RConstants::eod)
                    {
                        continue;
                    }
                    vectorField.addElementGroupID(elementGroupId);
                }

                RLogger::info("Modified vector field \'%s\'\n",vectorField.getName().toUtf8().constData());
            }
            else
            {
                RVectorField vectorField;

                vectorField.setName(RVariable::getName(varType));
                vectorField.setVariableType(varType);
                Qt::CheckState type3DCheckState = this-&gt;type3DCheckbox-&gt;checkState();
                if (type3DCheckState != Qt::PartiallyChecked)
                {
                    vectorField.setType3D(type3DCheckState == Qt::Checked);
                }

                for (int i=0;i&lt;entities.size();i++)
                {
                    uint elementGroupId = Session::getInstance().getModel(this-&gt;modelID).getEntityGroupID(entities[i].getType(),
                                                                                                          entities[i].getEid());
                    if (elementGroupId == RConstants::eod)
                    {
                        continue;
                    }
                    vectorField.addElementGroupID(elementGroupId);
                }

                Session::getInstance().getModel(this-&gt;modelID).addVectorField(vectorField);
                RLogger::info("Created new vector field \'%s\'\n",vectorField.getName().toUtf8().constData());
            }

            Session::getInstance().setModelChanged(this-&gt;modelID);
        }
    }

    return retVal;
}

</t>
<t tx="leo.20201108101530.39">void VectorFieldDialog::createDialog(void)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;resize(500,400);

    QString windowTitleStr = tr("Vector field editor");
    this-&gt;setWindowTitle(tr(windowTitleStr.toUtf8().constData()));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *titleLabel = new QLabel;
    if (this-&gt;entityID == RConstants::eod)
    {
        titleLabel-&gt;setText(tr("Create new vector field."));
    }
    else
    {
        titleLabel-&gt;setText(tr("Modify vector field:")  + " &lt;b&gt;" + Session::getInstance().getModel(modelID).getVectorField(entityID).getName() + "&lt;/b&gt;");
    }
    mainLayout-&gt;addWidget(titleLabel, 0, 0, 1, 1);

    REntityGroupTypeMask typeMask = R_ENTITY_GROUP_POINT
                                  | R_ENTITY_GROUP_LINE
                                  | R_ENTITY_GROUP_SURFACE
                                  | R_ENTITY_GROUP_VOLUME
                                  | R_ENTITY_GROUP_CUT
                                  | R_ENTITY_GROUP_ISO
                                  | R_ENTITY_GROUP_STREAM_LINE;

    this-&gt;modelTree = new ModelTreeSimple(this-&gt;modelID,typeMask,this);
    if (this-&gt;entityID != RConstants::eod)
    {
        Model &amp;rModel = Session::getInstance().getModel(modelID);
        RVectorField &amp;rVectorField = rModel.getVectorField(entityID);
        const std::vector&lt;unsigned int&gt; groupIDs = rVectorField.getElementGroupIDs();
        this-&gt;modelTree-&gt;clearSelection();
        for (uint i=0;i&lt;groupIDs.size();i++)
        {
            REntityGroupType entityGroupType;
            uint entityIDNum;
            if (rModel.getEntityID(groupIDs[i],entityGroupType,entityIDNum))
            {
                this-&gt;modelTree-&gt;selectEntity(this-&gt;modelID,entityGroupType,entityIDNum);
            }
        }
    }
    mainLayout-&gt;addWidget(this-&gt;modelTree, 1, 0, 1, 1);

    QObject::connect(this-&gt;modelTree,
                     &amp;QTreeWidget::itemSelectionChanged,
                     this,
                     &amp;VectorFieldDialog::onModelTreeSelectionChanged);

    this-&gt;variableTree = new QTreeWidget(this);
    this-&gt;variableTree-&gt;setSelectionMode(QAbstractItemView::SingleSelection);
    this-&gt;variableTree-&gt;setColumnCount(VectorFieldDialog::NColumns);

    QTreeWidgetItem* headerItem = new QTreeWidgetItem();
    headerItem-&gt;setText(VectorFieldDialog::Name,QString("Variables"));
    headerItem-&gt;setText(VectorFieldDialog::Type,QString("type"));
    this-&gt;variableTree-&gt;setHeaderItem(headerItem);
    this-&gt;variableTree-&gt;setColumnHidden(VectorFieldDialog::Type,true);

    Model &amp;rModel = Session::getInstance().getModel(this-&gt;modelID);

    uint nType3D = 0;
    uint nVariables = 0;
    for (uint i=0;i&lt;rModel.getNVariables();i++)
    {
        RVariable &amp;rVariable = rModel.getVariable(i);
        if (rVariable.getNVectors() &gt; 1)
        {
            QTreeWidgetItem *itemVariable = new QTreeWidgetItem(this-&gt;variableTree);
            itemVariable-&gt;setText(VectorFieldDialog::Name, rVariable.getName());
            itemVariable-&gt;setData(VectorFieldDialog::Type,Qt::DisplayRole,QVariant(rVariable.getType()));
            if (this-&gt;entityID != RConstants::eod)
            {
                RVectorField &amp;rVectorField = Session::getInstance().getModel(modelID).getVectorField(entityID);
                itemVariable-&gt;setSelected(rVariable.getType() == rVectorField.getVariableType());
                if (rVectorField.getType3D())
                {
                    nType3D++;
                }
                nVariables++;
            }
        }
    }

    mainLayout-&gt;addWidget(this-&gt;variableTree, 1, 1, 1, 1);

    QObject::connect(this-&gt;variableTree,
                     &amp;QTreeWidget::itemSelectionChanged,
                     this,
                     &amp;VectorFieldDialog::onVariableTreeSelectionChanged);

    Qt::CheckState type3DCheckState = (this-&gt;entityID == RConstants::eod) ? Qt::Checked : Qt::Unchecked;
    if (nType3D &gt; 0)
    {
        type3DCheckState = (nType3D == nVariables) ? Qt::Checked : Qt::PartiallyChecked;
    }
    this-&gt;type3DCheckbox = new QCheckBox("3D vector field");
    this-&gt;type3DCheckbox-&gt;setCheckState(type3DCheckState);
    mainLayout-&gt;addWidget(this-&gt;type3DCheckbox, 2, 0, 1, 2);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, 3, 0, 1, 2);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    this-&gt;okButton = new QPushButton(okIcon, tr("Ok"));
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());
    this-&gt;okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(this-&gt;okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;VectorFieldDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;VectorFieldDialog::accept);
}

RVariableType VectorFieldDialog::getVariableType(void) const
{
    QList&lt;QTreeWidgetItem*&gt; items = this-&gt;variableTree-&gt;selectedItems();

    if (items.size() == 0)
    {
        return R_VARIABLE_NONE;
    }

    return RVariableType(items[0]-&gt;data(VectorFieldDialog::Type,Qt::DisplayRole).toInt());
}

</t>
<t tx="leo.20201108101530.4">void ValueScale::onExpandButtonClicked()
{
    if (this-&gt;expandWidget-&gt;isHidden())
    {
        this-&gt;expandWidget-&gt;show();
        this-&gt;expandButton-&gt;setText(tr("less"));
    }
    else
    {
        this-&gt;expandWidget-&gt;hide();
        this-&gt;expandButton-&gt;setText(tr("more"));
    }
}

</t>
<t tx="leo.20201108101530.40">void VectorFieldDialog::onVariableTreeSelectionChanged(void)
{
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());
}

</t>
<t tx="leo.20201108101530.41">void VectorFieldDialog::onModelTreeSelectionChanged()
{
    this-&gt;okButton-&gt;setEnabled(this-&gt;variableTree-&gt;selectedItems().size() &amp;&amp; this-&gt;modelTree-&gt;selectedItems().size());
}
</t>
<t tx="leo.20201108101530.42">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   video_output.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th January 2018                                        *
 *                                                                   *
 *  DESCRIPTION: Video output class definition                       *
 *               Implements a Qt style wrapper class for some        *
 *               functions from the FFmpeg library                   *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "video_output.h"

// Macro redefinition since original does not compile in c++
#undef av_err2str
#define av_err2str(errnum) \
        av_make_error_string(reinterpret_cast&lt;char*&gt;(alloca(AV_ERROR_MAX_STRING_SIZE)),\
                             AV_ERROR_MAX_STRING_SIZE, errnum)

VideoOutput::VideoOutput(QObject *parent)
    : QObject(parent)
    , formatContext(0x0)
    , outputFormat(0x0)
    , videoStream(0x0)
    , videoCodec(0x0)
    , swsContext(0x0)
    , frame(0x0)
    , streamPixFmt(AV_PIX_FMT_YUV420P) // default pix_fmt
    , streamFrameRate(25)              // 25 images/s
    , swsFlags(SWS_BICUBIC)
    , width(640)
    , height(480)
{
    // Init FFmpeg
    av_register_all();
}

VideoOutput::~VideoOutput()
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.43">bool VideoOutput::openMediaFile(int width, int height, const QString &amp;filename)
{
    // allocate the output media context
    avformat_alloc_output_context2(&amp;this-&gt;formatContext, NULL, NULL, filename.toUtf8().constData());
    if (!this-&gt;formatContext)
    {
        RLogger::warning("Could not deduce output format from file extension: using MPEG.\n");
        avformat_alloc_output_context2(&amp;this-&gt;formatContext, NULL, "mpeg", filename.toUtf8().constData());
    }
    if (!this-&gt;formatContext)
    {
        return false;
    }
    this-&gt;outputFormat = this-&gt;formatContext-&gt;oformat;
    // Add the video streams using the default format codecs
    // and initialize the codecs.
    this-&gt;videoStream = NULL;
    if (this-&gt;outputFormat-&gt;video_codec != AV_CODEC_ID_NONE)
    {
        this-&gt;videoStream = this-&gt;addStream(this-&gt;formatContext, &amp;this-&gt;videoCodec, this-&gt;outputFormat-&gt;video_codec);
    }
    // Now that all the parameters are set, we can open the audio and
    // video codecs and allocate the necessary encode buffers.
    if (this-&gt;videoStream)
    {
        this-&gt;openVideo(this-&gt;videoCodec, this-&gt;videoStream);
    }
    av_dump_format(this-&gt;formatContext, 0, filename.toUtf8().constData(), 1);
    int ret = 0;
    // open the output file, if needed
    if (!(this-&gt;outputFormat-&gt;flags &amp; AVFMT_NOFILE))
    {
       ret = avio_open(&amp;this-&gt;formatContext-&gt;pb, filename.toUtf8().constData(), AVIO_FLAG_WRITE);
       if (ret &lt; 0)
       {
           RLogger::error("Could not open '%s': %s\n", filename.toUtf8().constData(), av_err2str(ret));
           return false;
       }
    }
    // Write the stream header, if any.
    ret = avformat_write_header(this-&gt;formatContext, NULL);
    if (ret &lt; 0)
    {
        RLogger::error("Error occurred when opening output file: %s\n", av_err2str(ret));
        return false;
    }
    if (this-&gt;frame)
    {
        this-&gt;frame-&gt;pts = 0;
    }
    return avpicture_alloc(&amp;this-&gt;srcPicture, AV_PIX_FMT_RGBA, width, height) &gt;= 0;
}

</t>
<t tx="leo.20201108101530.44">bool VideoOutput::closeMediaFile()
{
    av_free(this-&gt;srcPicture.data[0]);
    // Write the trailer, if any. The trailer must be written before you
    // close the CodecContexts open when you wrote the header; otherwise
    // av_write_trailer() may try to use memory that was freed on
    // av_codec_close().
    av_write_trailer(this-&gt;formatContext);
    // Close each codec.
    if (this-&gt;videoStream)
    {
        this-&gt;closeVideo(this-&gt;videoStream);
    }
    if (this-&gt;swsContext)
    {
        sws_freeContext(this-&gt;swsContext);
        this-&gt;swsContext = 0x0;
    }
    // Free the streams.
    for (unsigned int i = 0; i &lt; this-&gt;formatContext-&gt;nb_streams; i++)
    {
        av_freep(&amp;this-&gt;formatContext-&gt;streams[i]-&gt;codec);
        av_freep(&amp;this-&gt;formatContext-&gt;streams[i]);
    }
    if (!(this-&gt;outputFormat-&gt;flags &amp; AVFMT_NOFILE))
    {
        // Close the output file.
        avio_close(this-&gt;formatContext-&gt;pb);
    }
    // free the stream
    av_free(this-&gt;formatContext);
    return true;
}

</t>
<t tx="leo.20201108101530.45">void VideoOutput::setStreamRate(uint streamFrameRate)
{
    Q_ASSERT(streamFrameRate &gt;= 24);
    Q_ASSERT(streamFrameRate &lt;= 60);
    this-&gt;streamFrameRate = streamFrameRate;
}

</t>
<t tx="leo.20201108101530.46">void VideoOutput::setResolution(uint width, uint height)
{
    Q_ASSERT(width%2  == 0);
    Q_ASSERT(height%2 == 0);
    this-&gt;width  = width;
    this-&gt;height = height;
}

</t>
<t tx="leo.20201108101530.47">bool VideoOutput::newFrame(const QImage &amp;image)
{
    const int width  = image.width();
    const int height = image.height();
    // write video frames
    for (int y=0;y&lt;height;y++)
    {
        const uint8_t *scanline = image.scanLine(y);
        for (int x=0;x&lt;width*4;x++)
        {
            this-&gt;srcPicture.data[0][y*this-&gt;srcPicture.linesize[0]+x] = scanline[x];
        }
    }
    this-&gt;writeVideoFrame(this-&gt;srcPicture, width, height, this-&gt;formatContext, this-&gt;videoStream);
    this-&gt;frame-&gt;pts += av_rescale_q(1,
                                     this-&gt;videoStream-&gt;codec-&gt;time_base,
                                     this-&gt;videoStream-&gt;time_base);
    return true;
}

AVStream *VideoOutput::addStream(AVFormatContext *inFormatContext,
                                 AVCodec **codec,
                                 AVCodecID codecId) const
{
    AVCodecContext *c;
    AVStream *st;
    // find the encoder
    *codec = avcodec_find_encoder(codecId);
    if (!(*codec))
    {
        RLogger::error("Could not find encoder for '%s'\n",avcodec_get_name(codecId));
        return 0x0;
    }
    st = avformat_new_stream(inFormatContext, *codec);
    if (!st)
    {
        RLogger::error("Could not allocate stream\n");
        return 0x0;
    }
    st-&gt;id = inFormatContext-&gt;nb_streams-1;
    c = st-&gt;codec;
    switch ((*codec)-&gt;type)
    {
        case AVMEDIA_TYPE_AUDIO:
        {
            st-&gt;id = 1;
            c-&gt;sample_fmt  = AV_SAMPLE_FMT_S16;
            c-&gt;bit_rate    = 64000;
            c-&gt;sample_rate = 44100;
            c-&gt;channels    = 2;
            break;
        }
        case AVMEDIA_TYPE_VIDEO:
        {
            avcodec_get_context_defaults3(c, *codec);
            c-&gt;codec_id = codecId;
            c-&gt;bit_rate = 400000;
            c-&gt;width    = this-&gt;width;
            c-&gt;height   = this-&gt;height;
            // timebase: This is the fundamental unit of time (in seconds) in terms
            // of which frame timestamps are represented. For fixed-fps content,
            // timebase should be 1/framerate and timestamp increments should be
            // identical to 1.
            c-&gt;time_base.den = this-&gt;streamFrameRate;
            c-&gt;time_base.num = 1;
            c-&gt;gop_size      = 12; // emit one intra frame every twelve frames at most
            c-&gt;pix_fmt       = this-&gt;streamPixFmt;
            if (c-&gt;codec_id == AV_CODEC_ID_MPEG2VIDEO)
            {
                // just for testing, we also add B frames
                c-&gt;max_b_frames = 2;
            }
            if (c-&gt;codec_id == AV_CODEC_ID_MPEG1VIDEO)
            {
                // Needed to avoid using macroblocks in which some coeffs overflow.
                // This does not happen with normal video, it just happens here as
                // the motion of the chroma plane does not match the luma plane.
                c-&gt;mb_decision = 2;
            }
            break;
        }
        default:
        {
            break;
        }
    }
    // Some formats want stream headers to be separate.
    if (inFormatContext-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)
    {
        c-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
    }
    return st;
}

</t>
<t tx="leo.20201108101530.48">bool VideoOutput::openVideo(AVCodec *codec, AVStream *stream)
{
    int ret;
    AVCodecContext *c = stream-&gt;codec;
    // open the codec
    ret = avcodec_open2(c, codec, NULL);
    if (ret &lt; 0)
    {
        RLogger::error("Could not open video codec: %s\n", av_err2str(ret));
        return false;
    }
    // allocate and init a re-usable frame
    this-&gt;frame = av_frame_alloc();
    if (!this-&gt;frame)
    {
        RLogger::error("Could not allocate video frame\n");
        return false;
    }
    // Allocate the encoded raw picture.
    ret = avpicture_alloc(&amp;this-&gt;dstPicture, c-&gt;pix_fmt, c-&gt;width, c-&gt;height);
    if (ret &lt; 0)
    {
        RLogger::error("Could not allocate picture: %s\n", av_err2str(ret));
        return false;
    }
    // copy data and linesize picture pointers to frame
    *((AVPicture *)this-&gt;frame) = this-&gt;dstPicture;
    return true;
}

</t>
<t tx="leo.20201108101530.49">bool VideoOutput::writeVideoFrame(const AVPicture &amp;src,
                                  int srcWidth,
                                  int srcHeight,
                                  AVFormatContext *inFormatContext,
                                  AVStream *stream)
{
    int ret;
    AVCodecContext *codec = stream-&gt;codec;
    if (codec-&gt;pix_fmt != AV_PIX_FMT_RGBA)
    {
        // as we only use RGBA picture, we must convert it
        // to the codec pixel format if needed
        if (!this-&gt;swsContext)
        {
            this-&gt;swsContext = sws_getContext(srcWidth,
                                              srcHeight,
                                              AV_PIX_FMT_BGRA,
                                              codec-&gt;width,
                                              codec-&gt;height,
                                              codec-&gt;pix_fmt,
                                              this-&gt;swsFlags,
                                              NULL,
                                              NULL,
                                              NULL);
            if (!this-&gt;swsContext)
            {
                RLogger::error("Could not initialize the conversion context\n");
                return false;
            }
        }
        sws_scale(this-&gt;swsContext,
                  (const uint8_t * const *)src.data,
                  src.linesize,
                  0,
                  codec-&gt;height,
                  this-&gt;dstPicture.data,
                  this-&gt;dstPicture.linesize);
    }
    if (inFormatContext-&gt;oformat-&gt;flags &amp; AVFMT_NOFILE)
    {
        // Raw video case - directly store the picture in the packet
        AVPacket pkt;
        av_init_packet(&amp;pkt);
        pkt.flags        |= AV_PKT_FLAG_KEY;
        pkt.stream_index  = stream-&gt;index;
        pkt.data          = this-&gt;dstPicture.data[0];
        pkt.size          = sizeof(AVPicture);
        ret = av_interleaved_write_frame(inFormatContext, &amp;pkt);
    }
    else
    {
        // encode the image
        AVPacket pkt;
        int gotOutput;
        av_init_packet(&amp;pkt);
        pkt.data = NULL;    // packet data will be allocated by the encoder
        pkt.size = 0;
        ret = avcodec_encode_video2(codec, &amp;pkt, this-&gt;frame, &amp;gotOutput);
        if (ret &lt; 0)
        {
            RLogger::error("Error encoding video frame: %s\n", av_err2str(ret));
            return false;
        }
        // If size is zero, it means the image was buffered.
        if (gotOutput)
        {
            if (codec-&gt;coded_frame-&gt;key_frame)
            {
                pkt.flags |= AV_PKT_FLAG_KEY;
            }
            pkt.stream_index = stream-&gt;index;
            // Write the compressed frame to the media file.
            ret = av_interleaved_write_frame(inFormatContext, &amp;pkt);
        }
        else
        {
            ret = 0;
        }
    }
    if (ret != 0)
    {
        RLogger::error("Error while writing video frame: %s\n",av_err2str(ret));
        return false;
    }
    this-&gt;frameCount++;
    return true;
}

</t>
<t tx="leo.20201108101530.5">void ValueScale::onMantisSliderChanged(int value)
{
    this-&gt;mantis = ValueScale::mantisScale * value / double(ValueScale::mantisSize);
    double scale = this-&gt;getValue();
    this-&gt;blockSignals(true);
    if (this-&gt;setScaleAllowed)
    {
        this-&gt;scaleEdit-&gt;blockSignals(true);
        this-&gt;scaleEdit-&gt;setValue(scale);
        this-&gt;scaleEdit-&gt;blockSignals(false);
    }
    this-&gt;mantisEdit-&gt;setValue(this-&gt;mantis);
    this-&gt;blockSignals(false);

    emit this-&gt;valueChanged(scale);
}

</t>
<t tx="leo.20201108101530.50">void VideoOutput::closeVideo(AVStream *stream)
{
    avcodec_close(stream-&gt;codec);
    av_free(this-&gt;dstPicture.data[0]);
    av_free(this-&gt;frame);
}
</t>
<t tx="leo.20201108101530.51">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   video_settings.cpp                                       *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   7-th January 2018                                        *
 *                                                                   *
 *  DESCRIPTION: Video settings class definition                     *
 *********************************************************************/

#include "main_settings.h"
#include "video_settings.h"

const unsigned int VideoSettings::minFps(24);
const unsigned int VideoSettings::maxFps(60);
const unsigned int VideoSettings::minFpp(1);
const unsigned int VideoSettings::maxFpp(100);

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.52">void VideoSettings::_init(const VideoSettings *pVideoSettings)
{
    if (pVideoSettings)
    {
        this-&gt;width = pVideoSettings-&gt;width;
        this-&gt;height = pVideoSettings-&gt;height;
        this-&gt;fps = pVideoSettings-&gt;fps;
        this-&gt;fpp = pVideoSettings-&gt;fpp;
    }
}

VideoSettings::VideoSettings()
    : width(1920)
    , height(1080)
    , fps(24)
    , fpp(1)
    , format(MainSettings::getDefaultVideoFormat())
{
    this-&gt;_init();
}

VideoSettings::VideoSettings(const VideoSettings &amp;videoSettings)
{
    this-&gt;_init(&amp;videoSettings);
}

VideoSettings::~VideoSettings()
{

}

VideoSettings &amp;VideoSettings::operator =(const VideoSettings &amp;videoSettings)
{
    this-&gt;_init(&amp;videoSettings);
    return (*this);
}

</t>
<t tx="leo.20201108101530.53">unsigned int VideoSettings::getWidth(void) const
{
    return this-&gt;width;
}

</t>
<t tx="leo.20201108101530.54">void VideoSettings::setWidth(unsigned int value)
{
    this-&gt;width = value;
    this-&gt;width += this-&gt;width-2*this-&gt;width%2;
}

</t>
<t tx="leo.20201108101530.55">unsigned int VideoSettings::getHeight(void) const
{
    return this-&gt;height;
}

</t>
<t tx="leo.20201108101530.56">void VideoSettings::setHeight(unsigned int value)
{
    this-&gt;height = value;
    this-&gt;height += this-&gt;height-2*this-&gt;height%2;
}

</t>
<t tx="leo.20201108101530.57">unsigned int VideoSettings::getFps(void) const
{
    return this-&gt;fps;
}

</t>
<t tx="leo.20201108101530.58">void VideoSettings::setFps(unsigned int value)
{
    this-&gt;fps = value;
}

</t>
<t tx="leo.20201108101530.59">unsigned int VideoSettings::getFpp(void) const
{
    return this-&gt;fpp;
}

</t>
<t tx="leo.20201108101530.6">void ValueScale::onMantisEditChanged(double value)
{
    this-&gt;mantis = value;
    double scale = this-&gt;getValue();
    int mantisPositon = ceil(ValueScale::mantisSize * value / ValueScale::mantisScale);
    this-&gt;blockSignals(true);
    if (this-&gt;setScaleAllowed)
    {
        this-&gt;scaleEdit-&gt;blockSignals(true);
        this-&gt;scaleEdit-&gt;setValue(scale);
        this-&gt;scaleEdit-&gt;blockSignals(false);
    }
    this-&gt;mantisSlider-&gt;setValue(mantisPositon);
    this-&gt;blockSignals(false);

    emit this-&gt;valueChanged(scale);
}

</t>
<t tx="leo.20201108101530.60">void VideoSettings::setFpp(unsigned int value)
{
    this-&gt;fpp = value;
}

QString VideoSettings::getFormat(void) const
{
    return this-&gt;format;
}

</t>
<t tx="leo.20201108101530.61">void VideoSettings::setFormat(const QString &amp;value)
{
    this-&gt;format = value;
}
</t>
<t tx="leo.20201108101530.62">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   video_settings_dialog.cpp                                *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   7-th January 2018                                        *
 *                                                                   *
 *  DESCRIPTION: Video settings dialog class definition              *
 *********************************************************************/

#include &lt;QGridLayout&gt;
#include &lt;QHBoxLayout&gt;
#include &lt;QIcon&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;
#include &lt;QSpinBox&gt;

#include "main_settings.h"
#include "video_settings_dialog.h"

VideoSettingsDialog::VideoSettingsDialog(VideoSettings *pVideoSettings, QWidget *parent)
    : QDialog(parent)
    , pVideoSettings(pVideoSettings)
{
    QIcon cancelIcon(":/icons/file/pixmaps/range-cancel.svg");
    QIcon okIcon(":/icons/file/pixmaps/range-ok.svg");

    this-&gt;setWindowTitle(tr("Video settings"));

    QGridLayout *mainLayout = new QGridLayout;
    this-&gt;setLayout (mainLayout);

    QLabel *formatLabel = new QLabel(tr("File format"));
    mainLayout-&gt;addWidget(formatLabel, 0, 0, 1, 1);

    this-&gt;formatCombo = new QComboBox;
    QList&lt;QString&gt; videoFormats = MainSettings::getSupportedVideoFormats();
    for (int i=0;i&lt;videoFormats.size();i++)
    {
        this-&gt;formatCombo-&gt;addItem(videoFormats.at(i));
        if (videoFormats.at(i) == this-&gt;pVideoSettings-&gt;getFormat())
        {
            this-&gt;formatCombo-&gt;setCurrentIndex(i);
        }
    }
    mainLayout-&gt;addWidget(this-&gt;formatCombo, 0, 1, 1, 1);

    QLabel *resolutionLabel = new QLabel(tr("Resolution"));
    mainLayout-&gt;addWidget(resolutionLabel, 1, 0, 1, 1);

    this-&gt;resolutionCombo = new QComboBox;
    this-&gt;resolutionCombo-&gt;addItem("SD (480p)");
    this-&gt;resolutionCombo-&gt;addItem("HD (720p)");
    this-&gt;resolutionCombo-&gt;addItem("Full HD (1080p)");
    this-&gt;resolutionCombo-&gt;addItem("Ultra HD (2160p)");
    this-&gt;resolutionCombo-&gt;setCurrentIndex(1);
    mainLayout-&gt;addWidget(this-&gt;resolutionCombo, 1, 1, 1, 1);

    QLabel *fpsLabel = new QLabel(tr("Frames per second"));
    mainLayout-&gt;addWidget(fpsLabel, 2, 0, 1, 1);

    this-&gt;fpsSpin = new QSpinBox;
    this-&gt;fpsSpin-&gt;setValue(int(this-&gt;pVideoSettings-&gt;getFps()));
    this-&gt;fpsSpin-&gt;setRange(int(VideoSettings::minFps),int(VideoSettings::maxFps));
    mainLayout-&gt;addWidget(this-&gt;fpsSpin, 2, 1, 1, 1);

    QLabel *fppLabel = new QLabel(tr("Frames per record"));
    mainLayout-&gt;addWidget(fppLabel, 3, 0, 1, 1);

    this-&gt;fppSpin = new QSpinBox;
    this-&gt;fppSpin-&gt;setValue(int(this-&gt;pVideoSettings-&gt;getFpp()));
    this-&gt;fppSpin-&gt;setRange(int(VideoSettings::minFpp),int(VideoSettings::maxFpp));
    mainLayout-&gt;addWidget(this-&gt;fppSpin, 3, 1, 1, 1);

    QHBoxLayout *buttonsLayout = new QHBoxLayout;
    buttonsLayout-&gt;addStretch(1);
    mainLayout-&gt;addLayout(buttonsLayout, 4, 0, 1, 2);

    QPushButton *cancelButton = new QPushButton(cancelIcon, tr("Cancel"));
    buttonsLayout-&gt;addWidget(cancelButton);

    QPushButton *okButton = new QPushButton(okIcon, tr("Ok"));
    okButton-&gt;setDefault(true);
    buttonsLayout-&gt;addWidget(okButton);

    QObject::connect(cancelButton,&amp;QPushButton::clicked,this,&amp;VideoSettingsDialog::reject);
    QObject::connect(okButton,&amp;QPushButton::clicked,this,&amp;VideoSettingsDialog::accept);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.63">int VideoSettingsDialog::exec(void)
{
    int retVal = QDialog::exec();

    if (retVal == QDialog::Accepted)
    {
        this-&gt;pVideoSettings-&gt;setFormat(MainSettings::getSupportedVideoFormats().at(this-&gt;formatCombo-&gt;currentIndex()));
        switch (this-&gt;resolutionCombo-&gt;currentIndex())
        {
            case 0:
            {
                this-&gt;pVideoSettings-&gt;setWidth(640);
                this-&gt;pVideoSettings-&gt;setHeight(480);
                break;
            }
            case 1:
            {
                this-&gt;pVideoSettings-&gt;setWidth(1280);
                this-&gt;pVideoSettings-&gt;setHeight(720);
                break;
            }
            case 2:
            {
                this-&gt;pVideoSettings-&gt;setWidth(1920);
                this-&gt;pVideoSettings-&gt;setHeight(1080);
                break;
            }
            case 3:
            {
                this-&gt;pVideoSettings-&gt;setWidth(3840);
                this-&gt;pVideoSettings-&gt;setHeight(2160);
                break;
            }
            default:
            {
                this-&gt;pVideoSettings-&gt;setWidth(1280);
                this-&gt;pVideoSettings-&gt;setHeight(720);
                break;
            }
        }
        this-&gt;pVideoSettings-&gt;setFps(uint(this-&gt;fpsSpin-&gt;value()));
        this-&gt;pVideoSettings-&gt;setFpp(uint(this-&gt;fppSpin-&gt;value()));
    }
    return retVal;
}
</t>
<t tx="leo.20201108101530.64"></t>
<t tx="leo.20201108101530.66"></t>
<t tx="leo.20201108101530.67">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_application_state.cpp                                *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   31-st March 2014                                         *
 *                                                                   *
 *  DESCRIPTION: Application state class definition                  *
 *********************************************************************/

#include "rbl_application_state.h"
#include "rbl_locker.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.68">void RApplicationState::_init(const RApplicationState *pApplicationState)
{
    if (pApplicationState)
    {
        this-&gt;stateType = pApplicationState-&gt;stateType;
    }
}

RApplicationState::RApplicationState()
{
    this-&gt;_init();
}

RApplicationState::RApplicationState(const RApplicationState &amp;applicationState)
{
    this-&gt;_init(&amp;applicationState);
}

RApplicationState::~RApplicationState()
{

}

RApplicationState &amp;RApplicationState::operator =(const RApplicationState &amp;applicationState)
{
    this-&gt;_init(&amp;applicationState);
    return (*this);
}

RApplicationState &amp;RApplicationState::getInstance(void)
{
    static RApplicationState applicationState;
    return applicationState;
}

RApplicationStateType RApplicationState::getStateType(void) const
{
    RApplicationStateType stateType;
    RLocker::lock();
    stateType = this-&gt;stateType;
    RLocker::unlock();
    return stateType;
}

</t>
<t tx="leo.20201108101530.69">void RApplicationState::setStateType(RApplicationStateType stateType)
{
    RLocker::lock();
    this-&gt;stateType = stateType;
    RLocker::unlock();
}
</t>
<t tx="leo.20201108101530.7">void ValueScale::onExponentSpinBoxChanged(int value)
{
    this-&gt;exponent = value;
    double scale = this-&gt;getValue();
    this-&gt;blockSignals(true);
    if (this-&gt;setScaleAllowed)
    {
        this-&gt;scaleEdit-&gt;blockSignals(true);
        this-&gt;scaleEdit-&gt;setValue(scale);
        this-&gt;scaleEdit-&gt;blockSignals(false);
    }
    this-&gt;blockSignals(false);

    emit this-&gt;valueChanged(scale);
}
</t>
<t tx="leo.20201108101530.70">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_arguments_parser.cpp                                 *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th August 2013                                        *
 *                                                                   *
 *  DESCRIPTION: Arguments parser class definition                   *
 *********************************************************************/

#include &lt;QStringList&gt;
#include &lt;QTextDocument&gt;

#include "rbl_arguments_parser.h"
#include "rbl_logger.h"
#include "rbl_error.h"
#include "rbl_utils.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.71">void RArgumentsParser::_init(const RArgumentsParser *pArgumentsParser)
{
    if (pArgumentsParser)
    {
        this-&gt;executable = pArgumentsParser-&gt;executable;
        this-&gt;arguments = pArgumentsParser-&gt;arguments;
        this-&gt;filesEnabled = pArgumentsParser-&gt;filesEnabled;
        this-&gt;files = pArgumentsParser-&gt;files;
        this-&gt;validOptions = pArgumentsParser-&gt;validOptions;
    }
}

RArgumentsParser::RArgumentsParser(const QStringList &amp;argumentList, const QList&lt;RArgumentOption&gt; &amp;validOptions, bool filesEnabled)
    : filesEnabled(filesEnabled)
{
    this-&gt;_init();
    foreach (const RArgumentOption &amp;option, validOptions)
    {
        this-&gt;validOptions.insert(option.getFlag(),option);
    }
    RArgumentOption helpOption(RArgumentOption::generateHelpOption());
    RArgumentOption versionOption(RArgumentOption::generateVersionOption());
    this-&gt;validOptions.insert(helpOption.getFlag(),helpOption);
    this-&gt;validOptions.insert(versionOption.getFlag(),versionOption);
    this-&gt;processArgumentList(argumentList);
}

RArgumentsParser::RArgumentsParser(const RArgumentsParser &amp;argumentsParser)
{
    this-&gt;_init(&amp;argumentsParser);
}

RArgumentsParser::~RArgumentsParser()
{
}

RArgumentsParser &amp;RArgumentsParser::operator =(const RArgumentsParser &amp;argumentsParser)
{
    this-&gt;_init(&amp;argumentsParser);
    return (*this);
}

</t>
<t tx="leo.20201108101530.72">bool RArgumentsParser::isSet(const QString &amp;option) const
{
    return (this-&gt;arguments.find(option) != this-&gt;arguments.end());
}

</t>
<t tx="leo.20201108101530.73">bool RArgumentsParser::isValid(const QString &amp;option) const
{
    return (this-&gt;validOptions.find(option) != this-&gt;validOptions.end());
}

QVariant RArgumentsParser::getValue(const QString &amp;option) const
{
    QMap&lt;QString,RArgumentOption&gt;::const_iterator iter = this-&gt;arguments.find(option);

    if (iter == this-&gt;arguments.end())
    {
        return QVariant();
    }
    else
    {
        return iter.value().getValue();
    }
}

</t>
<t tx="leo.20201108101530.74">const QStringList &amp;RArgumentsParser::getFiles() const
{
    return this-&gt;files;
}

</t>
<t tx="leo.20201108101530.75">void RArgumentsParser::printHelp(void) const
{
    RLogger::info("Usage: %s%s &lt;mandatory arguments&gt; [optional arguments]\n",
                  this-&gt;executable.toUtf8().constData(),
                  this-&gt;filesEnabled ? " [file(s)]" : "");
    RLogger::info("\n");
    RLogger::info("  Mandatory:\n");
    foreach (const RArgumentOption &amp;option, this-&gt;validOptions)
    {
        if (option.getMandatory())
        {
            RLogger::info("    %s\n",option.getHelpMessage(30).toUtf8().constData());
        }
    }
    RLogger::info("\n");
    RLogger::info("  Optional:\n");
    foreach (const RArgumentOption &amp;option, this-&gt;validOptions)
    {
        if (!option.getMandatory())
        {
            RLogger::info("    %s\n",option.getHelpMessage(30).toUtf8().constData());
        }
    }
}

</t>
<t tx="leo.20201108101530.76">void RArgumentsParser::printVersion(void) const
{
    RLogger::info("VERSION=%s\n",RVendor::version.toString().toUtf8().constData());
}

</t>
<t tx="leo.20201108101530.77">void RArgumentsParser::printHeader(const QString &amp;applicationName)
{
    RLogger::info(" ____                          ____         __ _                          \n");
    RLogger::info("|  _ \\ __ _ _ __   __ _  ___  / ___|  ___  / _| |___      ____ _ _ __ ___ \n");
    RLogger::info("| |_) / _` | \'_ \\ / _` |/ _ \\ \\___ \\ / _ \\| |_| __\\ \\ /\\ / / _` | '__/ _ \\\n");
    RLogger::info("|  _ &lt; (_| | | | | (_| |  __/  ___) | (_) |  _| |_ \\ V  V / (_| | | |  __/\n");
    RLogger::info("|_| \\_\\__,_|_| |_|\\__, |\\___| |____/ \\___/|_|  \\__| \\_/\\_/ \\__,_|_|  \\___|\n");
    RLogger::info("                  |___/                                                   \n");
    RLogger::info("\n");
    RLogger::info("%s %s\n",RVendor::shortName.toUtf8().constData(),applicationName.toUtf8().constData());
    RLogger::info("%s\n",RVendor::title.toUtf8().constData());
    RLogger::info("Version: %s\n",RVendor::version.toString().toUtf8().constData());
    RLogger::info("--------------------------------------------------------------------------\n");
    RLogger::info("\n");
}

</t>
<t tx="leo.20201108101530.78">void RArgumentsParser::printFooter(void)
{
    RLogger::info("\n");
    RLogger::info("--------------------------------------------------------------------------\n");
    RLogger::info("%s (c) %d\n",RVendor::author.toUtf8().constData(),RVendor::year);
    RLogger::info("%s\n",RVendor::email.toUtf8().constData());
    RLogger::info("%s\n",RVendor::www.toUtf8().constData());
}

</t>
<t tx="leo.20201108101530.79">void RArgumentsParser::processArgumentList(const QStringList &amp;argumentList)
{
    // Process executable.
    if (argumentList.size() &gt; 0)
    {
        this-&gt;executable = argumentList.at(0);
    }

    bool exclusiveSet = false;

    // Process arguments
    for (int i=1;i&lt;argumentList.size();i++)
    {
        RArgumentOption option;
        if (this-&gt;processArgument(argumentList[i],option))
        {
            this-&gt;arguments.insert(option.getFlag(),option);
            if (option.getExclusive())
            {
                exclusiveSet = true;
            }
        }
        else
        {
            if (this-&gt;filesEnabled &amp;&amp; !RArgumentOption::isOption(argumentList[i]))
            {
                this-&gt;files.append(argumentList[i]);
            }
            else
            {
                throw RError(R_ERROR_INVALID_INPUT,R_ERROR_REF,"Invalid command line argument \'%s\'",argumentList[i].toUtf8().constData());
            }
        }
    }

    if (!exclusiveSet)
    {
        // Check for mandatory options
        foreach (const RArgumentOption &amp;rArgument, this-&gt;validOptions)
        {
            if (rArgument.getMandatory())
            {
                if (!this-&gt;isSet(rArgument.getFlag()))
                {
                    throw RError(R_ERROR_INVALID_INPUT,
                                 R_ERROR_REF,
                                 "Missing mandatory command line argument \'%s\'",
                                 rArgument.getFlagMessage().toUtf8().constData());
                }
            }
        }
    }
}

</t>
<t tx="leo.20201108101530.8">@path ./Range/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   value_set_generator_dialog.cpp                           *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   30-th May 2014                                           *
 *                                                                   *
 *  DESCRIPTION: Value set generator dialog class definition         *
 *********************************************************************/

#include &lt;cmath&gt;

#include &lt;QGridLayout&gt;
#include &lt;QPushButton&gt;
#include &lt;QLabel&gt;

#include "value_set_generator_dialog.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101530.80">bool RArgumentsParser::processArgument(const QString &amp;argument, RArgumentOption &amp;option)
{
    QString flag;
    QString value;

    if (argument.size() &lt; 2)
    {
        return false;
    }
    if (argument[0] != '-')
    {
        return false;
    }

    if (argument.size() == 2)
    {
        flag = argument[1];
    }
    else
    {
        if (argument[1] != '-')
        {
            return false;
        }

        QStringList query = argument.split(QRegExp("(\\=)"));

        flag = query.at(0);
        flag.remove(QRegExp("^[-]*"));
        if (query.size() &gt; 1)
        {
            value = query.at(1);
        }
    }

    QMap&lt;QString,RArgumentOption&gt;::const_iterator iter = this-&gt;validOptions.find(flag);
    if (iter == this-&gt;validOptions.end())
    {
        return false;
    }

    option = iter.value();
    switch (option.getType())
    {
        case RArgumentOption::Switch:
        {
            option.setValue(QVariant(true));
            break;
        }
        case RArgumentOption::Char:
        {
            QChar c = value.isEmpty() ? QChar('\0') : value[0];
            option.setValue(QVariant(c));
            break;
        }
        case RArgumentOption::Integer:
        {
            bool isOk = false;
            option.setValue(QVariant(value.toInt(&amp;isOk)));
            if (!isOk)
            {
                RLogger::warning("Invalid number \'%s\'\n",value.toUtf8().constData());
                return false;
            }
            break;
        }
        case RArgumentOption::Real:
        {
            bool isOk = false;
            option.setValue(QVariant(value.toDouble(&amp;isOk)));
            if (!isOk)
            {
                RLogger::warning("Invalid value \'%s\'\n",value.toUtf8().constData());
                return false;
            }
            break;
        }
        case RArgumentOption::Date:
        {
            QDate date(QDate::fromString(value,"dd.MM.yyyy"));
            if (!date.isValid())
            {
                RLogger::warning("Invalid date \'%s\'\n",value.toUtf8().constData());
                return false;
            }
            option.setValue(QVariant(value));
            break;
        }
        case RArgumentOption::String:
        case RArgumentOption::Path:
        default:
        {
            option.setValue(QVariant(value));
            break;
        }
    }

    return true;
}
</t>
<t tx="leo.20201108101530.9">typedef enum _FuncType
{
    FUNC_FILL_A = 0,
    FUNC_LINEAR,
    FUNC_SIN,
    FUNC_COS,
    FUNC_N_FUNCS
} FuncType;

</t>
<t tx="leo.20201108101531.1">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_argument_option.cpp                                  *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th September 2016                                      *
 *                                                                   *
 *  DESCRIPTION: Argument option class definition                    *
 *********************************************************************/

#include "rbl_argument_option.h"
#include "rbl_utils.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.10">bool RArgumentOption::getMandatory(void) const
{
    return this-&gt;mandatory;
}

</t>
<t tx="leo.20201108101531.100">void RLogger::decreaseIndent (void)
{
    RLocker::lock();
    if (this-&gt;indentLevel &gt; 0)
    {
        this-&gt;indentLevel--;
    }
    RLocker::unlock();
} /* RLogger::decreaseIndent */


</t>
<t tx="leo.20201108101531.101">void RLogger::printToFile (time_t         pTime,
                           const QString &amp;cppString) const
{
    if (this-&gt;logFileName.isEmpty())
    {
        return;
    }

    QFile logFile(this-&gt;logFileName);

    if (!logFile.open(QIODevice::Append | QIODevice::Text))
    {
        QTextStream(stderr) &lt;&lt; "Failed to open the log file '" &lt;&lt; this-&gt;logFileName &lt;&lt; "'\n";
        return;
    }

    QTextStream out(&amp;logFile);

    if (this-&gt;printTime)
    {
        char buffer [80];
        strftime (buffer,80,"%Y/%m/%d - %H:%M:%S &gt; ",localtime (&amp;pTime));
        out &lt;&lt; buffer;
    }
    out &lt;&lt; cppString;
    if (out.status() != QTextStream::Ok)
    {
        QTextStream(stderr) &lt;&lt; "Failed to write the log message to file '" &lt;&lt; this-&gt;logFileName &lt;&lt; "'\n";
    }

    logFile.close ();
} /* RLogger::printToFile */


</t>
<t tx="leo.20201108101531.102">void RLogger::insertLabel(const QString &amp;label, QString &amp;message)
{
    for (int i=0;i&lt;message.length();i++)
    {
        if (!message.at(i).isSpace())
        {
            message.insert(i,label+": ");
            break;
        }
    }
} /* RLogger::insertLabel */


</t>
<t tx="leo.20201108101531.103">void RLogger::print (const RMessage &amp;message)
{
    RMessageType messageType;
    messageType = message.getType();
    QString fullMessage;
    bool printToStderr = false;

    if (!(messageType &amp; this-&gt;getLevel()))
    {
        // Message is out of the log level, so it will be dropped.
        return;
    }

    for (unsigned int i=0;i&lt;this-&gt;getIndentLevel();i++)
    {
        fullMessage += "  ";
    }
    fullMessage += message;
    if (this-&gt;getAddNewLine())
    {
        fullMessage += '\n';
    }

    switch (messageType)
    {
        case R_MESSAGE_ERROR:
            RLogger::insertLabel("ERROR",fullMessage);
            printToStderr = true;
            break;
        case R_MESSAGE_WARNING:
            RLogger::insertLabel("WARNING",fullMessage);
            printToStderr = true;
            break;
        case R_MESSAGE_DEBUG:
            RLogger::insertLabel("DEBUG",fullMessage);
            printToStderr = false;
            break;
        case R_MESSAGE_TRACE:
            RLogger::insertLabel("TRACE",fullMessage);
            printToStderr = false;
            break;
        case R_MESSAGE_NOTICE:
            RLogger::insertLabel("NOTICE",fullMessage);
            printToStderr = false;
            break;
        case R_MESSAGE_INFO:
        default:
            printToStderr = false;
            break;
    }

    if (printToStderr)
    {
        QTextStream(stderr) &lt;&lt; fullMessage;
        QTextStream(stderr).flush();
    }
    else
    {
        QTextStream(stdout) &lt;&lt; fullMessage;
        QTextStream(stdout).flush();

    }

    if (this-&gt;getHalted())
    {
        RLocker::lock();
        // Print to file is halted =&gt; store message
        this-&gt;messages.push_back (fullMessage);
        RLocker::unlock();
    }
    else
    {
        RLocker::lock();
        this-&gt;printToFile (message.getAtime(), fullMessage);
        if (this-&gt;logHandler)
        {
            this-&gt;logHandler(RMessage(fullMessage, messageType));
        }
        RLocker::unlock();
    }
} /* RLogger::print */


</t>
<t tx="leo.20201108101531.104">void RLogger::print (const QString &amp;cppString,
                     RMessageType   messageType)
{
    std::vector&lt;QString&gt; messages = RMessage::explode(cppString,'\n',true);
    for (unsigned int i=0;i&lt;messages.size();i++)
    {
        RMessage message(messages[i]);
        message.setType (messageType);
        this-&gt;print (message);
    }
} /* RLogger::print */


</t>
<t tx="leo.20201108101531.105">void RLogger::print (const char   *cString,
                     RMessageType  messageType)
{
    this-&gt;print (QString(cString),messageType);
} /* RLogger::print */


</t>
<t tx="leo.20201108101531.106">void RLogger::print (const char   cChar,
                     RMessageType messageType)
{
    RMessage message(1,cChar);
    message.setType (messageType);
    this-&gt;print (message);
} /* RLogger::print */


</t>
<t tx="leo.20201108101531.107">void RLogger::flush (void)
{
    std::vector&lt;RMessage&gt;::iterator iter;

    RLocker::lock();
    for (iter = this-&gt;messages.begin();
         iter != this-&gt;messages.end();
         ++iter)
    {
        this-&gt;printToFile (iter-&gt;getAtime(), *iter);
        if (this-&gt;logHandler)
        {
            this-&gt;logHandler(*iter);
        }
    }
    RLocker::unlock();
    this-&gt;purge();
} /* RLogger::flush */


</t>
<t tx="leo.20201108101531.108">void RLogger::purge (unsigned int nMessages)
{
    RLocker::lock();
    if (nMessages == 0)
    {
        this-&gt;messages.clear ();
        RLocker::unlock();
        return;
    }

    unsigned int n;
    std::vector&lt;RMessage&gt;::iterator iter = this-&gt;messages.begin();

    n = (unsigned int)this-&gt;messages.size();
    if (n &gt; nMessages)
    {
        n = nMessages;
    }

    std::advance(iter,n);

    this-&gt;messages.erase (this-&gt;messages.begin(),iter);
    RLocker::unlock();
} /* RLogger::purge */


</t>
<t tx="leo.20201108101531.109">int RLogger::trace(const char *format, ...)
{
    va_list ap;
    va_start(ap, format);
    RLogger::getInstance().print(QString::vasprintf(format, ap), R_MESSAGE_TRACE);
    va_end(ap);
    return 0;
} /* RLogger::trace */


</t>
<t tx="leo.20201108101531.11">void RArgumentOption::setMandatory(bool mandatory)
{
    this-&gt;mandatory = mandatory;
}

</t>
<t tx="leo.20201108101531.110">int RLogger::debug(const char *format, ...)
{
    va_list ap;
    va_start(ap, format);
    RLogger::getInstance().print(QString::vasprintf(format, ap), R_MESSAGE_DEBUG);
    va_end(ap);
    return 0;
} /* RLogger::debug */


</t>
<t tx="leo.20201108101531.111">int RLogger::info(const char *format, ...)
{
    va_list ap;
    va_start(ap, format);
    RLogger::getInstance().print(QString::vasprintf(format, ap), R_MESSAGE_INFO);
    va_end(ap);
    return 0;
} /* RLogger::info */


</t>
<t tx="leo.20201108101531.112">int RLogger::notice(const char *format, ...)
{
    va_list ap;
    va_start(ap, format);
    RLogger::getInstance().print(QString::vasprintf(format, ap), R_MESSAGE_NOTICE);
    va_end(ap);
    return 0;
} /* RLogger::notice */


</t>
<t tx="leo.20201108101531.113">int RLogger::warning(const char *format, ...)
{
    va_list ap;
    va_start(ap, format);
    RLogger::getInstance().print(QString::vasprintf(format, ap), R_MESSAGE_WARNING);
    va_end(ap);
    return 0;
} /* RLogger::warning */


</t>
<t tx="leo.20201108101531.114">int RLogger::error(const char *format, ...)
{
    va_list ap;
    va_start(ap, format);
    RLogger::getInstance().print(QString::vasprintf(format, ap), R_MESSAGE_ERROR);
    va_end(ap);
    return 0;
} /* RLogger::error */


</t>
<t tx="leo.20201108101531.115">void RLogger::timestamp(const QString prefix)
{
    QDateTime timeStamp = QDateTime::currentDateTime();
    RLogger::info("%s%s%s\n",
                  prefix.toUtf8().constData(),
                  prefix.size()&gt;0?" ":"",
                  timeStamp.toString("dd/MM/yyyy hh:mm:ss").toUtf8().constData());
} /* RLogger::timestamp */


</t>
<t tx="leo.20201108101531.116">void RLogger::indent (void)
{
    RLogger::getInstance().timerStack.push_front(QTime());
    RLogger::getInstance().timerStack.first().start();
    RLogger::info("{\n");
    RLogger::getInstance().increaseIndent();
} /* RLogger::indent */


</t>
<t tx="leo.20201108101531.117">void RLogger::unindent (bool printTime)
{
    RLogger::getInstance().decreaseIndent();
    int elapsed = qRound(double(RLogger::getInstance().timerStack.first().elapsed())/1000.0);
    if (printTime)
    {
        RLogger::info("} %s\n", QDateTime::fromTime_t(elapsed).toUTC().toString("hh:mm:ss").toUtf8().constData());
    }
    else
    {
        RLogger::info("}\n");
    }
    RLogger::getInstance().timerStack.pop_front();
} /* RLogger::unindent */
</t>
<t tx="leo.20201108101531.118">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_message.cpp                                          *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   22-nd December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Message class definition                            *
 *********************************************************************/

#include &lt;QStringList&gt;

#include &lt;time.h&gt;

#include "rbl_message.h"
#include "rbl_error.h"

RMessage::RMessage (RMessageType type)
{
    this-&gt;_init ();
    this-&gt;setAtimeFrozen(false);
    this-&gt;setType (type);
} /* RMessage::RMessage */


RMessage::RMessage (const RMessage &amp;message) : QString (message)
{
    this-&gt;_init (&amp;message);
    this-&gt;setAtimeFrozen(false);
    this-&gt;setType (type);
} /* RMessage::RMessage (copy) */


RMessage::RMessage (const QString &amp;cppString, RMessageType type) : QString (cppString)
{
    this-&gt;_init ();
    this-&gt;setAtimeFrozen(false);
    this-&gt;setType (type);
} /* RMessage::RMessage (copy c++ string) */


RMessage::RMessage (const char *cString, RMessageType type) : QString (cString)
{
    this-&gt;_init ();
    this-&gt;setAtimeFrozen(false);
    this-&gt;setType (type);
} /* RMessage::RMessage (copy c string) */


RMessage::RMessage (size_t n, char cChar, RMessageType type) : QString (int(n),cChar)
{
    this-&gt;_init ();
    this-&gt;setAtimeFrozen(false);
    this-&gt;setType (type);
} /* RMessage::RMessage (copy c char) */


RMessage::~RMessage ()
{
} /* RMessage::~RMessage */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.119">void RMessage::_init (const RMessage *pMessage)
{
    this-&gt;setAtimeToNow ();
    if (pMessage)
    {
        if (pMessage-&gt;getAtimeFrozen())
        {
            this-&gt;aTime = pMessage-&gt;getAtime();
        }
        this-&gt;setAtimeFrozen (pMessage-&gt;getAtimeFrozen());
        this-&gt;setType (pMessage-&gt;getType());
    }
} /* RMessage::_init */


RMessageType RMessage::getType (void) const
{
    return this-&gt;type;
} /* RMessage::get_type */


</t>
<t tx="leo.20201108101531.12">bool RArgumentOption::getExclusive(void) const
{
    return this-&gt;exclusive;
}

</t>
<t tx="leo.20201108101531.120">void RMessage::setType (RMessageType type)
{
    R_ERROR_ASSERT (R_MESSAGE_TYPE_IS_VALID (type));

    this-&gt;type = type;
} /* RMessage::set_type */


time_t RMessage::getAtime ( void ) const
{
    return this-&gt;aTime;
} /* RMessage::get_atime */

</t>
<t tx="leo.20201108101531.121">void RMessage::setAtimeToNow ( void )
{
    this-&gt;aTime = time(0);
} /* RMessage::set_atime_to_now */


RMessage &amp; RMessage::operator = (const RMessage &amp;message)
{
    this-&gt;QString::operator = (message);
    this-&gt;_init (&amp;message);
    return (*this);
} /* RMessage::operator = (message) */


RMessage &amp; RMessage::operator = (const QString &amp;cppString)
{
    this-&gt;QString::operator = (cppString);
    this-&gt;_init ();
    return (*this);
} /* RMessage::operator = (cpp string) */


RMessage &amp; RMessage::operator = (const char *cString)
{
    this-&gt;QString::operator = (cString);
    this-&gt;_init ();
    return (*this);
} /* RMessage::operator = (c string) */


RMessage &amp; RMessage::operator = (char cChar)
{
    this-&gt;QString::operator = (cChar);
    this-&gt;_init ();
    return (*this);
}

std::vector&lt;QString&gt; RMessage::explode(const QString &amp;str, char ch, bool keepCh)
{
    std::vector&lt;QString&gt; result;

    QStringList query = str.split(QRegExp(QString("(\\") + ch + ")"));

    for (int i=0;i&lt;query.size();i++)
    {
        if (i == query.size()-1 &amp;&amp; query[i].isEmpty() &amp;&amp; query.size() &gt; 1)
        {
            continue;
        }
        if (keepCh &amp;&amp; query.size() &gt; 1)
        {
            query[i].append(ch);
        }
        result.push_back(query[i]);
    }

    return result;
} /* RMessage::operator = (c char) */

</t>
<t tx="leo.20201108101531.122">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_plane.cpp                                            *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Plane class definition                              *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rbl_utils.h"
#include "rbl_plane.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.123">void RPlane::_init(const RPlane *pPlane)
{
    if (pPlane)
    {
        this-&gt;position = pPlane-&gt;position;
        this-&gt;normal = pPlane-&gt;normal;
    }
}

RPlane::RPlane()
    : position(0.0,0.0,0.0)
    , normal(1.0,0.0,0.0)
{
    this-&gt;_init();
}

RPlane::RPlane(const RR3Vector &amp;position, const RR3Vector &amp;normal)
    : position(position)
    , normal(normal)
{
    this-&gt;_init();
}

RPlane::RPlane(const RR3Vector &amp;node1, const RR3Vector &amp;node2, const RR3Vector &amp;node3)
{
    RR3Vector v1(node2[0]-node1[0],node2[1]-node1[1],node2[2]-node1[2]);
    RR3Vector v2(node3[0]-node1[0],node3[1]-node1[1],node3[2]-node1[2]);
    RR3Vector::cross(v1,v2,this-&gt;normal);
    this-&gt;position = node1;
}

RPlane::RPlane(const RPlane &amp;rPlane)
{
    this-&gt;_init(&amp;rPlane);
}

RPlane::~RPlane()
{
}

RPlane &amp;RPlane::operator =(const RPlane &amp;rPlane)
{
    this-&gt;_init(&amp;rPlane);
    return (*this);
}

</t>
<t tx="leo.20201108101531.124">const RR3Vector &amp;RPlane::getPosition(void) const
{
    return this-&gt;position;
}

</t>
<t tx="leo.20201108101531.125">void RPlane::setPosition(const RR3Vector &amp;position)
{
    this-&gt;position = position;
}

</t>
<t tx="leo.20201108101531.126">const RR3Vector &amp;RPlane::getNormal(void) const
{
    return this-&gt;normal;
}

</t>
<t tx="leo.20201108101531.127">void RPlane::setNormal(const RR3Vector &amp;normal)
{
    this-&gt;normal = normal;
}

</t>
<t tx="leo.20201108101531.128">void RPlane::findRotationMatrix(RRMatrix &amp;R) const
{
    this-&gt;normal.findRotationMatrix(R);
}

</t>
<t tx="leo.20201108101531.129">void RPlane::findPoints(RR3Vector &amp;point1, RR3Vector &amp;point2, RR3Vector &amp;point3) const
{
    point1 = this-&gt;position;

    RR3Vector g(0.0,0.0,1.0);

    if (std::abs(RR3Vector::angle(this-&gt;normal,g)) &lt; RConstants::pi/6.0)
    {
        g = RR3Vector(0.0,1.0,0.0);
    }
    if (std::abs(RR3Vector::angle(this-&gt;normal,g)) &lt; RConstants::pi/6.0)
    {
        g = RR3Vector(1.0,0.0,0.0);
    }

    RR3Vector u;
    RR3Vector::cross(this-&gt;normal,g,u);
    u.normalize();

    RR3Vector v;
    RR3Vector::cross(u,this-&gt;normal,v);
    v.normalize();

    point3[0] = point1[0] + u[0];
    point3[1] = point1[1] + u[1];
    point3[2] = point1[2] + u[2];

    point2[0] = point1[0] + v[0];
    point2[1] = point1[1] + v[1];
    point2[2] = point1[2] + v[2];
}

</t>
<t tx="leo.20201108101531.13">void RArgumentOption::setExclusive(bool exclusive)
{
    this-&gt;exclusive = exclusive;
}

QString RArgumentOption::getFlagMessage(void) const
{
    QString message;
    message += "--" + this-&gt;flag;
    switch (this-&gt;type)
    {
        case Char:
        {
            message += "=&lt;C&gt;";
            break;
        }
        case String:
        {
            message += "=&lt;STRING&gt;";
            break;
        }
        case Path:
        {
            message += "=&lt;PATH&gt;";
            break;
        }
        case Integer:
        {
            message += "=&lt;N&gt;";
            break;
        }
        case Real:
        {
            message += "=&lt;REAL NUMBER&gt;";
            break;
        }
        case Date:
        {
            message += "=&lt;DD.MM.YYYY&gt;";
            break;
        }
        default:
        {
            break;
        }
    }
    return message;
}

QString RArgumentOption::getHelpMessage(uint width) const
{
    QString message = this-&gt;getFlagMessage();
    message += " ";
    for (uint i=uint(message.length());i&lt;width;i++)
    {
        message += " ";
    }
    message += this-&gt;description;
    if (this-&gt;type != Switch &amp;&amp; !this-&gt;value.isNull())
    {
        message += " (default=" + this-&gt;value.toString() + ")";
    }
    return message;
}

RArgumentOption RArgumentOption::generateHelpOption(void)
{
    return RArgumentOption("help",Switch,QVariant(false),"Print help",false,true);
}

RArgumentOption RArgumentOption::generateVersionOption(void)
{
    return RArgumentOption("version",Switch,QVariant(RVendor::version.toString()),"Print version",false,true);
}

</t>
<t tx="leo.20201108101531.130">bool RPlane::findLineIntersection(const RR3Vector &amp;position, const RR3Vector &amp;direction, RR3Vector &amp;x, double &amp;u) const
{
    @others
}

</t>
<t tx="leo.20201108101531.131">double n = (this-&gt;position[0] - position[0]) * this-&gt;normal[0]
         + (this-&gt;position[1] - position[1]) * this-&gt;normal[1]
         + (this-&gt;position[2] - position[2]) * this-&gt;normal[2];
double d = direction[0] * this-&gt;normal[0]
         + direction[1] * this-&gt;normal[1]
         + direction[2] * this-&gt;normal[2];

if (std::abs(d) &lt; RConstants::eps)
{
    return false;
}

u = n / d;

x[0] = u * direction[0] + position[0];
x[1] = u * direction[1] + position[1];
x[2] = u * direction[2] + position[2];

return true;
</t>
<t tx="leo.20201108101531.132">bool RPlane::findSegmentIntersection(const RR3Vector &amp;node1, const RR3Vector &amp;node2, RR3Vector &amp;x) const
{
    RR3Vector direction(node2[0]-node1[0],node2[1]-node1[1],node2[2]-node1[2]);
    double u;
    if (this-&gt;findLineIntersection(node1,direction,x,u))
    {
        if (u &gt;= 0.0 &amp;&amp; u &lt;= 1.0)
        {
            return true;
        }
    }
    return false;
}

double RPlane::findPointDistance(const RR3Vector &amp;point) const
{
    double d = 0.0;

    d = this-&gt;normal[0] * (this-&gt;position[0] - point[0])
      + this-&gt;normal[1] * (this-&gt;position[1] - point[1])
      + this-&gt;normal[2] * (this-&gt;position[2] - point[2]);

    return d;
}
</t>
<t tx="leo.20201108101531.14">bool RArgumentOption::isOption(const QString &amp;argument)
{
    if (argument.size() == 2)
    {
        if (argument[0] == '-' &amp;&amp; argument[1] != '-')
        {
            return true;
        }
    }
    else if (argument.size() &gt;= 4)
    {
        if (argument[0] == '-' &amp;&amp; argument[1] == '-')
        {
            return true;
        }
    }
    return false;
}
</t>
<t tx="leo.20201108101531.15">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_book.cpp                                             *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th August 2014                                         *
 *                                                                   *
 *  DESCRIPTION: Book class definition                               *
 *********************************************************************/

#include &lt;limits.h&gt;

#include "rbl_book.h"
#include "rbl_logger.h"
#include "rbl_utils.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.16">void RBook::_init(const RBook *pBook)
{
    if (pBook)
    {
        this-&gt;book = pBook-&gt;book;
    }
}

RBook::RBook(uint size)
{
    this-&gt;_init();
    this-&gt;resize(size);
}

RBook::RBook(const RBook &amp;book)
{
    this-&gt;_init(&amp;book);
}

RBook::~RBook()
{
}

RBook &amp;RBook::operator =(const RBook &amp;book)
{
    this-&gt;_init(&amp;book);
    return (*this);
}

</t>
<t tx="leo.20201108101531.17">void RBook::resize(uint size)
{
    this-&gt;book.resize(size);
    this-&gt;initialize();
}

uint RBook::size() const
{
    return (uint)this-&gt;book.size();
}

</t>
<t tx="leo.20201108101531.18">void RBook::initialize()
{
    for (uint i=0;i&lt;this-&gt;book.size();i++)
    {
        this-&gt;book[i] = i;
    }
}

</t>
<t tx="leo.20201108101531.19">bool RBook::getValue(uint position, uint &amp;value) const
{
    value = this-&gt;book[position];
    if (value != RConstants::eod)
    {
        return true;
    }
    return false;
}

</t>
<t tx="leo.20201108101531.2">void RArgumentOption::_init(const RArgumentOption *pArgumentOption)
{
    if (pArgumentOption)
    {
        this-&gt;flag = pArgumentOption-&gt;flag;
        this-&gt;type = pArgumentOption-&gt;type;
        this-&gt;value = pArgumentOption-&gt;value;
        this-&gt;description = pArgumentOption-&gt;description;
        this-&gt;mandatory = pArgumentOption-&gt;mandatory;
        this-&gt;exclusive = pArgumentOption-&gt;exclusive;
    }
}

RArgumentOption::RArgumentOption()
    : type(None)
{
    this-&gt;_init();
}

RArgumentOption::RArgumentOption(const QString &amp;flag, RArgumentOption::Type type, const QVariant &amp;value, const QString &amp;description, bool mandatory, bool exclusive)
    : flag(flag)
    , type(type)
    , value(value)
    , description(description)
    , mandatory(mandatory)
    , exclusive(exclusive)
{
    this-&gt;_init();
}

RArgumentOption::RArgumentOption(const RArgumentOption &amp;argumentOption)
{
    this-&gt;_init(&amp;argumentOption);
}

RArgumentOption::~RArgumentOption()
{

}

RArgumentOption &amp;RArgumentOption::operator =(const RArgumentOption &amp;argumentOption)
{
    this-&gt;_init(&amp;argumentOption);
    return (*this);
}

</t>
<t tx="leo.20201108101531.20">void RBook::setValue(uint position, uint value)
{
    this-&gt;book[position] = value;
}

</t>
<t tx="leo.20201108101531.21">void RBook::enable(uint position, bool consolidate)
{
    if (this-&gt;book[position] != RConstants::eod)
    {
        return;
    }

    if (position == 0)
    {
        this-&gt;book[position] = 0;
    }
    else
    {
        for (uint i=position;i&gt;0;i--)
        {
            if (this-&gt;book[i-1] != RConstants::eod)
            {
                this-&gt;book[position] = this-&gt;book[i-1] + 1;
                break;
            }
        }
        this-&gt;book[position] = 0;
    }

    if (consolidate)
    {
        for (uint i=position+1;i&lt;this-&gt;book.size();i++)
        {
            if (this-&gt;book[i] != RConstants::eod)
            {
                this-&gt;book[i]++;
            }
        }
    }
}

</t>
<t tx="leo.20201108101531.22">void RBook::disable(uint position, bool consolidate)
{
    if (this-&gt;book[position] == RConstants::eod)
    {
        return;
    }

    this-&gt;book[position] = RConstants::eod;

    if (consolidate)
    {
        for (uint i=position+1;i&lt;this-&gt;book.size();i++)
        {
            if (this-&gt;book[i] != RConstants::eod)
            {
                this-&gt;book[i]--;
            }
        }
    }
}

uint RBook::getNEnabled() const
{
    return (uint)this-&gt;book.size() - this-&gt;getNDisabled();
}

uint RBook::getNDisabled() const
{
    uint nDisabled = 0;
    for (uint i=0;i&lt;this-&gt;book.size();i++)
    {
        if (this-&gt;book[i] == RConstants::eod)
        {
            nDisabled++;
        }
    }
    return nDisabled;
}

RUVector RBook::getEnabled() const
{
    uint nEnabled = 0;
    RUVector enabled;

    enabled.resize(this-&gt;size());

    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        if (this-&gt;book[i] != RConstants::eod)
        {
            enabled[this-&gt;book[i]] = i;
            nEnabled++;
        }
    }

    enabled.resize(nEnabled);

    return enabled;
}

</t>
<t tx="leo.20201108101531.23">void RBook::print() const
{
    RLogger::info("Node book: [%u]\n",this-&gt;size());
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        RLogger::info("%9u: %9u\n",i,this-&gt;book[i]);
    }
}
</t>
<t tx="leo.20201108101531.24">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_uvector.cpp                                          *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th November 2015                                      *
 *                                                                   *
 *  DESCRIPTION: Bool vector class definition                        *
 *********************************************************************/

#include &lt;algorithm&gt;

#include "rbl_bvector.h"
#include "rbl_error.h"
#include "rbl_logger.h"


RBVector::RBVector (uint nRows, bool value)
{
    this-&gt;resize(nRows,value);
    this-&gt;_init();
} /* RBVector::RBVector */


RBVector::RBVector (const RBVector &amp;array) : std::vector&lt;bool&gt;(array)
{
    this-&gt;_init(&amp;array);
} /* RBVector::RBVector (copy) */


RBVector::~RBVector ()
{
} /* RBVector::~RBVector */


RBVector &amp; RBVector::operator = (const RBVector &amp;array)
{
    this-&gt;std::vector&lt;bool&gt;::operator = (array);
    this-&gt;_init(&amp;array);
    return (*this);
} /* RBVector::operator = */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.25">void RBVector::_init(const RBVector *pArray)
{
    if (pArray)
    {
    }
} /* RBVector::_init */


//bool &amp; RBVector::operator [] (uint n)
//{
//    R_ERROR_ASSERT(n&lt;this-&gt;getNRows());

//    return this-&gt;at(n);
//} /* RBVector::operator [] */


//const bool &amp; RBVector::operator [] (uint n) const
//{
//    R_ERROR_ASSERT(n&lt;this-&gt;getNRows());

//    return this-&gt;at(n);
//} /* RBVector::operator [] */


</t>
<t tx="leo.20201108101531.26">void RBVector::fill(bool value)
{
    std::fill(this-&gt;begin(),this-&gt;end(),value);
} /* RBVector::fill */


</t>
<t tx="leo.20201108101531.27">void RBVector::print(bool oneLine, bool newLine) const
{
    if (!oneLine)
    {
        RLogger::info("Vector - bool: [%u]\n",this-&gt;size());
    }
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        RLogger::info("%7s",this-&gt;at(i)?"true":"false");
        if (!oneLine)
        {
            RLogger::info("\n");
        }
    }
    if (newLine)
    {
        RLogger::info("\n");
    }
} /* RBVector::print */
</t>
<t tx="leo.20201108101531.28">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_error.cpp                                            *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   11-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Error class definition                              *
 *********************************************************************/

#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;cstring&gt;
#include &lt;cstdio&gt;

#ifdef DEBUG
#  include &lt;assert.h&gt;
#endif

#include "rbl_error.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.29">const QString errorTypeMessages [] =
{
    "No error.",
    "Failed to open the file.",
    "Failed to read the file.",
    "Failed to write the file.",
    "Failed to remove the file.",
    "Failed to rename the file.",
    "Invalid file name.",
    "Invalid file format.",
    "Failed to open the directory.",
    "Failed to read the directory.",
    "Application error.",
    "Invalid input.",
    "Unknown error."
};


RError::RError(RErrorType type, const char *file, unsigned int line, const QString &amp;message)
{
    this-&gt;_init();
    this-&gt;setType(type);
    QString devInfo;
#ifdef DEBUG
    devInfo = QString(file) + "@" + QString::number(line) + ":";
#else
    // Suppress unused parameter warnings
    (void)file;
    (void)line;
#endif
    this-&gt;setMessage(this-&gt;getMessage() + " " + devInfo + message);
} /* RError::RError */


RError::RError(RErrorType type, const char *file, unsigned int line, const char *format, ...)
{
    QString buffer;

#ifdef DEBUG
    buffer = QString::asprintf("%s@%u: ",file,line);
#else
    // Suppress unused parameter warnings
    (void)file;
    (void)line;
#endif

    va_list ap;
    va_start(ap, format);
    buffer += QString::vasprintf(format,ap);
    va_end(ap);
    this-&gt;_init();
    this-&gt;setType(type);
    this-&gt;setMessage(this-&gt;getMessage() + " " + buffer);
} /* RError::RError */


RError::RError(const RError &amp;error)
{
    this-&gt;_init(&amp;error);
} /* RError::RError(copy) */


RError::~RError()
{
} /* RError::~RError */


</t>
<t tx="leo.20201108101531.3">const QString &amp;RArgumentOption::getFlag(void) const
{
    return this-&gt;flag;
}

</t>
<t tx="leo.20201108101531.30">void RError::_init(const RError *pError)
{
    if (pError)
    {
        this-&gt;type = pError-&gt;type;
        this-&gt;message = pError-&gt;message;
    }
} /* RError::_init */


RError &amp; RError::operator =(const RError &amp;error)
{
    this-&gt;_init(&amp;error);
    return (*this);
} /* RError::operator = */


RErrorType RError::getType() const
{
    return this-&gt;type;
} /* RError::getType */


</t>
<t tx="leo.20201108101531.31">void RError::setType(RErrorType type)
{
#ifdef DEBUG
    assert (R_ERROR_IS_VALID(type));
#endif
    this-&gt;type = type;
    this-&gt;setMessage(RErrorTypeGetMessage(this-&gt;type));
} /* RError::setType */


QString RError::getMessage() const
{
    return this-&gt;message;
} /* RError::getMessage */


</t>
<t tx="leo.20201108101531.32">void RError::setMessage(QString message)
{
    this-&gt;message = message;
} /* RError::setMessage */


</t>
<t tx="leo.20201108101531.33">const QString &amp; RErrorTypeGetMessage (RErrorType type)
{
#ifdef DEBUG
    assert (R_ERROR_IS_VALID(type));
#endif
    return errorTypeMessages[type];
} /* RErrorTypeGetMessage */
</t>
<t tx="leo.20201108101531.34">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_gl_light.cpp                                         *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   09-nd March 2012                                         *
 *                                                                   *
 *  DESCRIPTION: OpenGL light class definition                       *
 *********************************************************************/

#include "rbl_gl_light.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.35">void RGLLight::_init(const RGLLight *pGlLight)
{
    if (pGlLight)
    {
        this-&gt;enabled = pGlLight-&gt;enabled;
        this-&gt;lightNum = pGlLight-&gt;lightNum;
        this-&gt;ambient = pGlLight-&gt;ambient;
        this-&gt;diffuse = pGlLight-&gt;diffuse;
        this-&gt;specular = pGlLight-&gt;specular;
        this-&gt;direction = pGlLight-&gt;direction;
        this-&gt;position = pGlLight-&gt;position;
    }
}

RGLLight::RGLLight()
{
    this-&gt;setDefault();
    this-&gt;_init();
}

RGLLight::RGLLight(const RGLLight &amp;glLight)
{
    this-&gt;_init(&amp;glLight);
}

RGLLight::~RGLLight()
{
}

RGLLight &amp;RGLLight::operator =(const RGLLight &amp;glLight)
{
    this-&gt;_init(&amp;glLight);
    return (*this);
}

</t>
<t tx="leo.20201108101531.36">bool RGLLight::getEnabled(void) const
{
    return this-&gt;enabled;
}

</t>
<t tx="leo.20201108101531.37">void RGLLight::setEnabled(bool enabled)
{
    this-&gt;enabled = enabled;
}

</t>
<t tx="leo.20201108101531.38">const QColor &amp;RGLLight::getAmbient(void) const
{
    return this-&gt;ambient;
}

</t>
<t tx="leo.20201108101531.39">void RGLLight::setAmbient(const QColor &amp;ambient)
{
    this-&gt;ambient = ambient;
}

</t>
<t tx="leo.20201108101531.4">void RArgumentOption::setFlag(const QString &amp;flag)
{
    this-&gt;flag = flag;
}

RArgumentOption::Type RArgumentOption::getType(void) const
{
    return this-&gt;type;
}

</t>
<t tx="leo.20201108101531.40">const QColor &amp;RGLLight::getDiffuse(void) const
{
    return this-&gt;diffuse;
}

</t>
<t tx="leo.20201108101531.41">void RGLLight::setDiffuse(const QColor &amp;diffuse)
{
    this-&gt;diffuse = diffuse;
}

</t>
<t tx="leo.20201108101531.42">const QColor &amp;RGLLight::getSpecular(void) const
{
    return this-&gt;specular;
}

</t>
<t tx="leo.20201108101531.43">void RGLLight::setSpecular(const QColor &amp;specular)
{
    this-&gt;specular = specular;
}

</t>
<t tx="leo.20201108101531.44">const RR3Vector &amp;RGLLight::getDirection(void) const
{
    return this-&gt;direction;
}

</t>
<t tx="leo.20201108101531.45">void RGLLight::setDirection(const RR3Vector &amp;direction)
{
    this-&gt;direction = direction;
}

</t>
<t tx="leo.20201108101531.46">const RR3Vector &amp;RGLLight::getPosition(void) const
{
    return this-&gt;position;
}

</t>
<t tx="leo.20201108101531.47">void RGLLight::setPosition(const RR3Vector &amp;position)
{
    this-&gt;position = position;
}

</t>
<t tx="leo.20201108101531.48">int RGLLight::getLightNumber(void) const
{
    return this-&gt;lightNum;
}

</t>
<t tx="leo.20201108101531.49">void RGLLight::setLightNumber(int lightNum)
{
    this-&gt;lightNum = lightNum;
}

</t>
<t tx="leo.20201108101531.5">void RArgumentOption::setType(RArgumentOption::Type type)
{
    this-&gt;type = type;
}

</t>
<t tx="leo.20201108101531.50">void RGLLight::setDefault(void)
{
    this-&gt;enabled = true;
//    this-&gt;lightNum = GL_LIGHT0;
    this-&gt;lightNum = 0;
    this-&gt;ambient.fromRgbF(0.1,0.1,0.1,1.0);
//    this-&gt;diffuse.fromRgbF(0.5,0.5,0.5,1.0);
    this-&gt;diffuse.fromRgbF(1.0,1.0,1.0,1.0);
    this-&gt;specular.fromRgbF(1.0,1.0,1.0,1.0);
    this-&gt;direction[0] = -0.6666667;
    this-&gt;direction[1] = 0.6666667;
    this-&gt;direction[2] = 0.3333333;
    this-&gt;position[0] = 1.0;
    this-&gt;position[1] = 1.0;
    this-&gt;position[2] = 10.0;
}
</t>
<t tx="leo.20201108101531.51">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_imatrix.cpp                                          *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   21-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Integer matrix class definition                     *
 *********************************************************************/

#include "rbl_imatrix.h"
#include "rbl_error.h"


RIMatrix::RIMatrix ()
{
    this-&gt;_init();
} /* RIMatrix::RIMatrix */


RIMatrix::RIMatrix (unsigned int nRows,
                    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.52">                    unsigned int nColumns, int value)
{
    this-&gt;_init();
    this-&gt;resize(nRows,nColumns,value);
} /* RIMatrix::RIMatrix */


RIMatrix::RIMatrix (const RIMatrix &amp;matrix)
{
    this-&gt;_init(&amp;matrix);
} /* RIMatrix::RIMatrix (copy) */


RIMatrix::~RIMatrix ()
{
} /* RIMatrix::~RIMatrix */


RIMatrix &amp; RIMatrix::operator = (const RIMatrix &amp;matrix)
{
    this-&gt;_init(&amp;matrix);
    return (*this);
} /* RIMatrix::operator = */


</t>
<t tx="leo.20201108101531.53">void RIMatrix::_init (const RIMatrix *pMatrix)
{
    if (pMatrix)
    {
        this-&gt;resize(pMatrix-&gt;getNRows(),pMatrix-&gt;getNColumns());
        for (unsigned int i=0;i&lt;pMatrix-&gt;getNRows();i++)
        {
            for (unsigned int j=0;j&lt;pMatrix-&gt;getNColumns();j++)
            {
                this-&gt;setValue(i,j,pMatrix-&gt;getValue(i,j));
            }
        }
    }
} /* RIMatrix::_init */


</t>
<t tx="leo.20201108101531.54">unsigned int RIMatrix::getNRows (void) const
{
    return (unsigned int)this-&gt;array.size();
} /* RIMatrix::getNRows */


</t>
<t tx="leo.20201108101531.55">unsigned int RIMatrix::getNColumns (void) const
{
    if (this-&gt;getNRows() &gt; 0)
    {
        return (unsigned int)this-&gt;array[0].size();
    }
    else
    {
        return 0;
    }
} /* RIMatrix::getNColumns */


</t>
<t tx="leo.20201108101531.56">void RIMatrix::resize (unsigned int nRows, unsigned int nColumns, int value)
{
    this-&gt;array.resize(nRows);
    for (unsigned int i=0;i&lt;nRows;i++)
    {
        this-&gt;array[i].resize(nColumns,value);
    }
} /* RIMatrix::resize */


</t>
<t tx="leo.20201108101531.57">int RIMatrix::getValue(unsigned int row, unsigned int column) const
{
    R_ERROR_ASSERT(row &lt; this-&gt;getNRows());
    R_ERROR_ASSERT(column &lt; this-&gt;getNColumns());

    return this-&gt;array[row][column];
} /* RIMatrix::getValue */


</t>
<t tx="leo.20201108101531.58">void RIMatrix::setValue(unsigned int row, unsigned int column, int value)
{
    R_ERROR_ASSERT(row &lt; this-&gt;getNRows());
    R_ERROR_ASSERT(column &lt; this-&gt;getNColumns());

    this-&gt;array[row][column] = value;
} /* RIMatrix::setValue */


</t>
<t tx="leo.20201108101531.59">void RIMatrix::transpose (void)
{
    unsigned int nr = this-&gt;getNRows();
    unsigned int nc = this-&gt;getNColumns();

    if (nr == nc)
    {
        int itmp;
        for (unsigned int i=0;i&lt;nr;i++)
        {
            for (unsigned int j=0;j&lt;nc;j++)
            {
                if (i == j)
                {
                    continue;
                }
                itmp = this-&gt;getValue(j,i);
                this-&gt;setValue(j,i,this-&gt;getValue(i,j));
                this-&gt;setValue(i,j,itmp);
            }
        }
    }
    else
    {
        RIMatrix itmp(*this);

        this-&gt;resize(nc,nr);
        for (unsigned int i=0;i&lt;nr;i++)
        {
            for (unsigned int j=0;j&lt;nc;j++)
            {
                if (i == j)
                {
                    continue;
                }
                this-&gt;setValue(j,i,itmp.getValue(i,j));
            }
        }
    }
} /* RIMatrix::transpose */


</t>
<t tx="leo.20201108101531.6">const QVariant &amp;RArgumentOption::getValue(void) const
{
    return this-&gt;value;
}

</t>
<t tx="leo.20201108101531.60">const RIVector &amp; RIMatrix::operator [] (unsigned int row) const
{
    R_ERROR_ASSERT (row &lt; this-&gt;getNRows());

    return this-&gt;array[row];
} /* RIMatrix::operator [] */


RIVector &amp; RIMatrix::operator [] (unsigned int row)
{
    R_ERROR_ASSERT (row &lt; this-&gt;getNRows());

    return this-&gt;array[row];
} /* RIMatrix::operator [] */


</t>
<t tx="leo.20201108101531.61">void RIMatrix::clear (void)
{
    for (unsigned int i=0;i&lt;this-&gt;getNRows();i++)
    {
        this-&gt;array[i].clear();
    }
    this-&gt;array.clear();
} /* RIMatrix::clear */
</t>
<t tx="leo.20201108101531.62">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_ivector.cpp                                          *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   21-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Integer vector class definition                     *
 *********************************************************************/

#include &lt;algorithm&gt;

#include "rbl_ivector.h"
#include "rbl_error.h"
#include "rbl_logger.h"


RIVector::RIVector (unsigned int nRows, int value)
{
    this-&gt;resize(nRows,value);
    this-&gt;_init();
} /* RIVector::RIVector */


RIVector::RIVector (const RIVector &amp;array) : std::vector&lt;int&gt;(array)
{
    this-&gt;_init(&amp;array);
} /* RIVector::RIVector (copy) */


RIVector::~RIVector ()
{
} /* RIVector::~RIVector */


RIVector &amp; RIVector::operator = (const RIVector &amp;array)
{
    this-&gt;std::vector&lt;int&gt;::operator = (array);
    this-&gt;_init(&amp;array);
    return (*this);
} /* RIVector::operator = */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.63">void RIVector::_init(const RIVector *pArray)
{
    if (pArray)
    {
    }
} /* RIVector::_init */


</t>
<t tx="leo.20201108101531.64">int &amp; RIVector::operator [] (unsigned int n)
{
    R_ERROR_ASSERT(n&lt;this-&gt;getNRows());

    return this-&gt;at(n);
} /* RIVector::operator [] */


</t>
<t tx="leo.20201108101531.65">const int &amp; RIVector::operator [] (unsigned int n) const
{
    R_ERROR_ASSERT(n&lt;this-&gt;getNRows());

    return this-&gt;at(n);
} /* RIVector::operator [] */

</t>
<t tx="leo.20201108101531.66">void RIVector::fill(int value)
{
    std::fill(this-&gt;begin(),this-&gt;end(),value);
}

</t>
<t tx="leo.20201108101531.67">void RIVector::print(bool oneLine, bool newLine) const
{
    if (!oneLine)
    {
        RLogger::info("Vector - int: [%u]\n",this-&gt;size());
    }
    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        RLogger::info("%15d",this-&gt;at(i));
        if (!oneLine)
        {
            RLogger::info("\n");
        }
    }
    if (newLine)
    {
        RLogger::info("\n");
    }
} /* RIVector::fill */
</t>
<t tx="leo.20201108101531.68">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_limit_box.cpp                                        *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   10-th March 2015                                         *
 *                                                                   *
 *  DESCRIPTION: Limit box class definition                          *
 *********************************************************************/

#include "rbl_limit_box.h"
#include "rbl_utils.h"
#include "rbl_logger.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.69">void RLimitBox::_init(const RLimitBox *pBox)
{
    if (pBox)
    {
        this-&gt;xl = pBox-&gt;xl;
        this-&gt;xu = pBox-&gt;xu;
        this-&gt;yl = pBox-&gt;yl;
        this-&gt;yu = pBox-&gt;yu;
        this-&gt;zl = pBox-&gt;zl;
        this-&gt;zu = pBox-&gt;zu;
    }
    this-&gt;fixLimits();
}

RLimitBox::RLimitBox()
    : xl(0.0)
    , xu(0.0)
    , yl(0.0)
    , yu(0.0)
    , zl(0.0)
    , zu(0.0)
{
    this-&gt;_init();
}

RLimitBox::RLimitBox(double xl, double xu, double yl, double yu, double zl, double zu)
    : xl(xl)
    , xu(xu)
    , yl(yl)
    , yu(yu)
    , zl(zl)
    , zu(zu)
{
    this-&gt;_init();
}

RLimitBox::RLimitBox(const RLimitBox &amp;box)
{
    this-&gt;_init(&amp;box);
}

RLimitBox::~RLimitBox()
{

}

RLimitBox &amp;RLimitBox::operator =(const RLimitBox &amp;box)
{
    this-&gt;_init(&amp;box);
    return (*this);
}

</t>
<t tx="leo.20201108101531.7">void RArgumentOption::setValue(const QVariant &amp;value)
{
    this-&gt;value = value;
}

</t>
<t tx="leo.20201108101531.70">void RLimitBox::setLimits(double xl, double xu, double yl, double yu, double zl, double zu)
{
    this-&gt;xl = xl;
    this-&gt;xu = xu;
    this-&gt;yl = yl;
    this-&gt;yu = yu;
    this-&gt;zl = zl;
    this-&gt;zu = zu;
    this-&gt;fixLimits();
}

</t>
<t tx="leo.20201108101531.71">void RLimitBox::scale(double scaleFactor)
{
    double dx = (this-&gt;xu - this-&gt;xl) * (scaleFactor - 1.0) / 2.0;
    double dy = (this-&gt;yu - this-&gt;yl) * (scaleFactor - 1.0) / 2.0;
    double dz = (this-&gt;zu - this-&gt;zl) * (scaleFactor - 1.0) / 2.0;

    this-&gt;xl -= dx;
    this-&gt;xu += dx;

    this-&gt;yl -= dy;
    this-&gt;yu += dy;

    this-&gt;zl -= dz;
    this-&gt;zu += dz;
}

</t>
<t tx="leo.20201108101531.72">void RLimitBox::print(void) const
{
    RLogger::info("Limit box:\n");
    RLogger::info("  lower: %15.6e %15.6e %15.6e\n", this-&gt;xl, this-&gt;yl, this-&gt;zl);
    RLogger::info("  upper: %15.6e %15.6e %15.6e\n", this-&gt;xu, this-&gt;yu, this-&gt;zu);
}

</t>
<t tx="leo.20201108101531.73">bool RLimitBox::areIntersecting(const RLimitBox &amp;b1, const RLimitBox &amp;b2)
{
    if (b1.xl - b2.xu &gt; RConstants::eps)
    {
        return false;
    }
    if (b2.xl - b1.xu &gt; RConstants::eps)
    {
        return false;
    }

    if (b1.yl - b2.yu &gt; RConstants::eps)
    {
        return false;
    }
    if (b2.yl - b1.yu &gt; RConstants::eps)
    {
        return false;
    }

    if (b1.zl - b2.zu &gt; RConstants::eps)
    {
        return false;
    }
    if (b2.zl - b1.zu &gt; RConstants::eps)
    {
        return false;
    }

    return true;
}

</t>
<t tx="leo.20201108101531.74">void RLimitBox::fixLimits(void)
{
    if (this-&gt;xl &gt; this-&gt;xu)
    {
        std::swap(this-&gt;xl,this-&gt;xu);
    }
    if (this-&gt;yl &gt; this-&gt;yu)
    {
        std::swap(this-&gt;yl,this-&gt;yu);
    }
    if (this-&gt;zl &gt; this-&gt;zu)
    {
        std::swap(this-&gt;zl,this-&gt;zu);
    }
}
</t>
<t tx="leo.20201108101531.75">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_local_diraction.cpp                                  *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   23-rd May 2019                                           *
 *                                                                   *
 *  DESCRIPTION: Local direction class definition                    *
 *********************************************************************/

#include "rbl_local_direction.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.76">void RLocalDirection::_init(const RLocalDirection *pLocalDirection)
{
    if (pLocalDirection)
    {
        this-&gt;position = pLocalDirection-&gt;position;
        this-&gt;direction = pLocalDirection-&gt;direction;
    }
}

RLocalDirection::RLocalDirection()
    : position(0.0,0.0,0.0)
    , direction(1.0,0.0,0.0)
{

}

RLocalDirection::RLocalDirection(const RR3Vector &amp;position, const RR3Vector &amp;direction)
    : position(position)
    , direction(direction)
{
    this-&gt;_init();
}

RLocalDirection::RLocalDirection(const RLocalDirection &amp;rLocalDirection)
{
    this-&gt;_init(&amp;rLocalDirection);
}

RLocalDirection &amp;RLocalDirection::operator =(const RLocalDirection &amp;rLocalDirection)
{
    this-&gt;_init(&amp;rLocalDirection);
    return (*this);
}

</t>
<t tx="leo.20201108101531.77">const RR3Vector &amp;RLocalDirection::getPosition() const
{
    return this-&gt;position;
}

</t>
<t tx="leo.20201108101531.78">const RR3Vector &amp;RLocalDirection::getDirection() const
{
    return this-&gt;direction;
}
</t>
<t tx="leo.20201108101531.79">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_locker.cpp                                           *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th February 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Locker class definition                             *
 *********************************************************************/

#include "rbl_locker.h"


RLocker::RLocker () : lockHandler(0)
{
    this-&gt;_init();
} /* RLocker::RLocker */


RLocker::RLocker (const RLocker &amp;locker)
{
    this-&gt;_init(&amp;locker);
} /* RLocker::RLocker (copy) */


RLocker::~RLocker ()
{
} /* RLocker::~RLocker */


RLocker &amp; RLocker::operator = (const RLocker &amp;locker)
{
    this-&gt;_init(&amp;locker);
    return (*this);
} /* RLocker::operator = */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.8">const QString &amp;RArgumentOption::getDescription(void) const
{
    return this-&gt;description;
}

</t>
<t tx="leo.20201108101531.80">void RLocker::_init( const RLocker *pLocker)
{
    if (pLocker)
    {
        this-&gt;setLockHandler (pLocker-&gt;getLockHandler());
    }
} /* RLocker:_init */


RLocker &amp; RLocker::getInstance (void)
{
    static RLocker locker;
    return locker;
} /* RLocker:getInstance */


RLockHandler RLocker::getLockHandler (void) const
{
    return this-&gt;lockHandler;
} /* RLocker:getLockHandler */


</t>
<t tx="leo.20201108101531.81">void RLocker::setLockHandler (RLockHandler lockHandler)
{
    this-&gt;lockHandler = lockHandler;
} /* RLocker:setLockHandler */


</t>
<t tx="leo.20201108101531.82">void RLocker::setLock (bool lock)
{
    if (this-&gt;lockHandler)
    {
        this-&gt;lockHandler(lock);
    }
    else
    {
        if (lock)
        {
            this-&gt;mutex.lock();
        }
        else
        {
            this-&gt;mutex.unlock();
        }
    }
} /* RLocker:setLock */


</t>
<t tx="leo.20201108101531.83">void RLocker::lock(void)
{
    RLocker::getInstance().setLock(true);
} /* RLocker:lock */


</t>
<t tx="leo.20201108101531.84">void RLocker::unlock(void)
{
    RLocker::getInstance().setLock(false);
} /* RLocker:unlock */
</t>
<t tx="leo.20201108101531.85">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_logger.cpp                                           *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   22-nd December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Logger class definition                             *
 *********************************************************************/

#include &lt;QFile&gt;
#include &lt;QTextStream&gt;

#include &lt;vector&gt;
#include &lt;string&gt;

#include "rbl_logger.h"
#include "rbl_locker.h"
#include "rbl_error.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101531.86">void RLogger::_init (const RLogger *pLogger)
{
    if (pLogger)
    {
        this-&gt;setLevel (pLogger-&gt;getLevel());
        this-&gt;setHalted (pLogger-&gt;getHalted());
        this-&gt;setPrintTimeEnabled (pLogger-&gt;getPrintTimeEnabled());
        this-&gt;setAddNewLine (pLogger-&gt;getAddNewLine());
        this-&gt;setFile (pLogger-&gt;getFile());
        this-&gt;setLogHandler (pLogger-&gt;getLogHandler());
        this-&gt;setIndentLevel (pLogger-&gt;getIndentLevel());
        // Copy unprocessed messages.
    }
} /* RLogger::_init */


RLogger::RLogger (RLogLevel logLevel) : logHandler(0)
                                      , indentLevel(0)
{
    this-&gt;_init ();
    this-&gt;setLevel (logLevel);
    this-&gt;setHalted (false);
    this-&gt;setPrintTimeEnabled (true);
    this-&gt;setAddNewLine (false);
} /* RLogger::RLogger */


RLogger::RLogger (const RLogger &amp;logger)
{
    this-&gt;_init (&amp;logger);
} /* RLogger::RLogger (copy) */


RLogger::~RLogger ()
{
} /* RLogger::~RLogger */


RLogger &amp; RLogger::operator = (const RLogger &amp;logger)
{
    this-&gt;_init (&amp;logger);
    return (*this);
} /* RLogger::operator = */


RLogger &amp; RLogger::getInstance()
{
    static RLogger logger;
    return logger;
} /* rbl_logger_get_default_instance */


RLogLevel RLogger::getLevel (void) const
{
    RLogLevel tmpLevel;
    RLocker::lock();
    tmpLevel = this-&gt;logLevel;
    RLocker::unlock();
    return tmpLevel;
} /* RLogger::getLevel */


</t>
<t tx="leo.20201108101531.87">void RLogger::setLevel (RLogLevel level)
{
    R_ERROR_ASSERT(R_LOG_LEVEL_IS_VALID (level));

    RLocker::lock();
    this-&gt;logLevel = level;
    RLocker::unlock();
} /* RLogger::setLevel */


</t>
<t tx="leo.20201108101531.88">bool RLogger::getHalted (void) const
{
    bool tmpHalted;
    RLocker::lock();
    tmpHalted = this-&gt;halted;
    RLocker::unlock();
    return tmpHalted;
} /* RLogger::getHalted */


</t>
<t tx="leo.20201108101531.89">void RLogger::setHalted (bool halt)
{
    RLocker::lock();
    this-&gt;halted = halt;
    RLocker::unlock();
    if (!this-&gt;getHalted())
    {
        this-&gt;flush();
    }
} /* RLogger::setHalted */


</t>
<t tx="leo.20201108101531.9">void RArgumentOption::setDescription(const QString &amp;description)
{
    this-&gt;description = description;
}

</t>
<t tx="leo.20201108101531.90">bool RLogger::getPrintTimeEnabled (void) const
{
    bool tmpTime;
    RLocker::lock();
    tmpTime = this-&gt;printTime;
    RLocker::unlock();
    return tmpTime;
} /* RLogger::getPrintTimeEnabled */


</t>
<t tx="leo.20201108101531.91">void RLogger::setPrintTimeEnabled (bool printTime)
{
    RLocker::lock();
    this-&gt;printTime = printTime;
    RLocker::unlock();
} /* RLogger::setPrintTimeEnabled */


</t>
<t tx="leo.20201108101531.92">bool RLogger::getAddNewLine (void) const
{
    bool tmpNewLine;
    RLocker::lock();
    tmpNewLine = this-&gt;addNewLine;
    RLocker::unlock();
    return tmpNewLine;
} /* RLogger::getAddNewLine */


</t>
<t tx="leo.20201108101531.93">void RLogger::setAddNewLine (bool addNewLine)
{
    RLocker::lock();
    this-&gt;addNewLine = addNewLine;
    RLocker::unlock();
} /* RLogger::setAddNewLine */


</t>
<t tx="leo.20201108101531.94">const QString RLogger::getFile (void) const
{
    QString tmpFileName;
    RLocker::lock();
    tmpFileName = this-&gt;logFileName;
    RLocker::unlock();
    return tmpFileName;
} /* RLogger::getFile */


</t>
<t tx="leo.20201108101531.95">void RLogger::setFile (const QString &amp; logFileName)
{
    RLocker::lock();
    this-&gt;logFileName = logFileName;
    RLocker::unlock();
} /* RLogger::setFile */


RLogHandler RLogger::getLogHandler (void) const
{
    RLogHandler tmpHandler;
    RLocker::lock();
    tmpHandler = this-&gt;logHandler;
    RLocker::unlock();
    return tmpHandler;
} /* RLogger::getLogHandler */


</t>
<t tx="leo.20201108101531.96">void RLogger::setLogHandler (RLogHandler logHandler)
{
    RLocker::lock();
    this-&gt;logHandler = logHandler;
    RLocker::unlock();
} /* RLogger::setLogHandler */


</t>
<t tx="leo.20201108101531.97">unsigned int RLogger::getIndentLevel (void) const
{
    unsigned int tmpLevel;
    RLocker::lock();
    tmpLevel = this-&gt;indentLevel;
    RLocker::unlock();
    return tmpLevel;
} /* RLogger::getIndentLevel */


</t>
<t tx="leo.20201108101531.98">void RLogger::setIndentLevel (unsigned int indentLevel)
{
    RLocker::lock();
    this-&gt;indentLevel = indentLevel;
    RLocker::unlock();
} /* RLogger::setIndentLevel */


</t>
<t tx="leo.20201108101531.99">void RLogger::increaseIndent (void)
{
    RLocker::lock();
    this-&gt;indentLevel++;
    RLocker::unlock();
} /* RLogger::increaseIndent */


</t>
<t tx="leo.20201108101532.1">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_progress.cpp                                         *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Progress class definition                           *
 *********************************************************************/

#include &lt;cstdlib&gt;
#include &lt;cmath&gt;

#include "rbl_progress.h"
#include "rbl_logger.h"


RProgress::RProgress () : lastFraction(0.0)
                        , printToLog(false)
                        , progressHandler(0)
{
    this-&gt;_init();
} /* RProgress:: */


RProgress::RProgress (const RProgress &amp;progress)
{
    this-&gt;_init(&amp;progress);
} /* RProgress::RProgress (copy) */


RProgress::~RProgress ()
{
} /* RProgress::~RProgress */


RProgress &amp; RProgress::operator = (const RProgress &amp;progress)
{
    this-&gt;_init(&amp;progress);
    return (*this);
} /* RProgress::operator = */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.10">void RProgress::print (double fraction)
{
    if (this-&gt;printToLog)
    {
        bool addNewLine = RLogger::getInstance().getAddNewLine();
        RLogger::getInstance().setAddNewLine(false);
        if (this-&gt;pulseType)
        {
            uint indentLevel = RLogger::getInstance().getIndentLevel();
            RLogger::getInstance().setIndentLevel(0);
            RLogger::getInstance().print('.');
            RLogger::getInstance().setIndentLevel(indentLevel);
        }
        else
        {
            unsigned int nMarks = (unsigned int)floor(fraction * 10);
            unsigned int nLastMarks = (unsigned int)floor(this-&gt;lastFraction * 10);
            for (unsigned int i=nLastMarks;i&lt;nMarks;i++)
            {
                uint indentLevel = RLogger::getInstance().getIndentLevel();
                RLogger::getInstance().setIndentLevel(0);
                RLogger::getInstance().print("#");
                RLogger::getInstance().setIndentLevel(indentLevel);
            }
            if (nMarks-nLastMarks &gt;= 1)
            {
                this-&gt;lastFraction = fraction;
            }
        }
        RLogger::getInstance().setAddNewLine(addNewLine);
    }
    if (this-&gt;progressHandler)
    {
        this-&gt;progressHandler(fraction);
    }
} /* RProgress::print */


</t>
<t tx="leo.20201108101532.100">void RValueVector::resize (unsigned int nmemb)
{
    this-&gt;values.resize (nmemb);
} /* RValueVector::resize */


</t>
<t tx="leo.20201108101532.101">void RValueVector::add (double value)
{
    this-&gt;values.push_back (value);
} /* RValueVector::add */


</t>
<t tx="leo.20201108101532.102">void RValueVector::remove (unsigned int position)
{
    std::vector&lt;double&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;values.size());

    iter = this-&gt;values.begin();
    std::advance (iter, position);

    this-&gt;values.erase (iter);
}

</t>
<t tx="leo.20201108101532.103">void RValueVector::remove(const std::vector&lt;uint&gt; &amp;valueBook)
{
    RRVector valuesNew;
    valuesNew.reserve(this-&gt;values.size());
    for (uint i=0;i&lt;this-&gt;values.size();i++)
    {
        if (valueBook[i] != RConstants::eod)
        {
            valuesNew.push_back(this-&gt;values[i]);
        }
    }
    this-&gt;values = valuesNew;
} /* RValueVector::remove */


</t>
<t tx="leo.20201108101532.104">void RValueVector::fill(double value)
{
    std::fill(this-&gt;values.begin(),this-&gt;values.end(),value);
} /* RValueVector::fill */


RValueVector &amp; RValueVector::operator = (const RValueVector &amp;valueVector)
{
    this-&gt;_init (&amp;valueVector);
    return (*this);
} /* RValueVector::operator = */


double RValueVector::operator [] (unsigned int position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;size());

    return this-&gt;values[position];
} /* RValueVector::operator [] */


double &amp; RValueVector::operator [] (unsigned int position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;size());

    return this-&gt;values[position];
} /* RValueVector::operator [] */

</t>
<t tx="leo.20201108101532.105">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_version.cpp                                          *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   16-th August 2012                                        *
 *                                                                   *
 *  DESCRIPTION: Version class definition                            *
 *********************************************************************/

#include &lt;QStringList&gt;

#include "rbl_version.h"

const QChar RVersion::releaseTypeSeparator('_');

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.106">void RVersion::_init(const RVersion *pVersion)
{
    if (pVersion)
    {
        this-&gt;mMajor = pVersion-&gt;mMajor;
        this-&gt;mMinor = pVersion-&gt;mMinor;
        this-&gt;mRelease = pVersion-&gt;mRelease;
        this-&gt;mReleaseType = pVersion-&gt;mReleaseType;
    }
}

RVersion::RVersion() :
    mMajor(0),
    mMinor(0),
    mRelease(0)
{
    this-&gt;_init();
}

RVersion::RVersion(unsigned int major, unsigned int minor, unsigned int release, ReleaseType mReleaseType) :
    mMajor(major),
    mMinor(minor),
    mRelease(release),
    mReleaseType(mReleaseType)
{
    this-&gt;_init();
}

RVersion::RVersion(const QString &amp;versionStr, char delimiter) :
    mMajor(0),
    mMinor(0),
    mRelease(0),
    mReleaseType(Release)
{
    this-&gt;_init();

    QStringList query = versionStr.split(QChar(delimiter));

    if (query.size() &gt; 0)
    {
        this-&gt;mMajor = query[0].toUInt();
    }
    if (query.size() &gt; 1)
    {
        this-&gt;mMinor = query[1].toUInt();
    }
    if (query.size() &gt; 2)
    {
        QStringList releaseQuery = query[2].split(RVersion::releaseTypeSeparator);
        if (releaseQuery.size() == 1)
        {
            this-&gt;mReleaseType = Release;
            this-&gt;mRelease = releaseQuery[0].toUInt();
        }
        if (releaseQuery.size() &gt; 1)
        {
            this-&gt;mReleaseType = RVersion::getReleaseTypeFromString(releaseQuery[0]);
            this-&gt;mRelease = releaseQuery[1].toUInt();
        }
    }
}

RVersion::RVersion(const RVersion &amp;version)
{
    this-&gt;_init(&amp;version);
}

RVersion::~RVersion()
{
}

QString RVersion::toString(char delimiter) const
{
    QString versionStr;

    versionStr = QString::number(this-&gt;mMajor)
               + delimiter
               + QString::number(this-&gt;mMinor)
               + delimiter
               + (this-&gt;mReleaseType != RVersion::Release ? RVersion::getReleaseStringFromType(this-&gt;mReleaseType) + RVersion::releaseTypeSeparator : "")
               + QString::number(this-&gt;mRelease);
    return versionStr;
}

RVersion &amp;RVersion::operator =(const RVersion &amp;version)
{
    this-&gt;_init(&amp;version);
    return (*this);
}

</t>
<t tx="leo.20201108101532.107">bool RVersion::operator ==(const RVersion &amp;version) const
{
    if (this-&gt;mMajor == version.mMajor &amp;&amp;
        this-&gt;mMinor == version.mMinor &amp;&amp;
        this-&gt;mRelease == version.mRelease &amp;&amp;
        this-&gt;mReleaseType == version.mReleaseType)
    {
        return true;
    }
    return false;
}

</t>
<t tx="leo.20201108101532.108">bool RVersion::operator !=(const RVersion &amp;version) const
{
    return !((*this)==version);
}

</t>
<t tx="leo.20201108101532.109">bool RVersion::operator &gt;(const RVersion &amp;version) const
{
    if (this-&gt;mMajor &gt; version.mMajor)
    {
        return true;
    }
    else if (this-&gt;mMajor == version.mMajor)
    {
        if (this-&gt;mMinor &gt; version.mMinor)
        {
            return true;
        }
        else if (this-&gt;mMinor == version.mMinor)
        {
            if (this-&gt;mReleaseType &gt; version.mReleaseType)
            {
                return true;
            }
            else if (this-&gt;mReleaseType == version.mReleaseType)
            {
                if (this-&gt;mRelease &gt; version.mRelease)
                {
                    return true;
                }
            }
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101532.11">void RProgressInitialize (const QString &amp;message,
                          bool               pulseType)
{
    RProgress::getInstance().initialize(message,pulseType);
} /* RProgressInitialize */


</t>
<t tx="leo.20201108101532.110">bool RVersion::operator &lt;(const RVersion &amp;version) const
{
    if (this-&gt;mMajor &lt; version.mMajor)
    {
        return true;
    }
    else if (this-&gt;mMajor == version.mMajor)
    {
        if (this-&gt;mMinor &lt; version.mMinor)
        {
            return true;
        }
        else if (this-&gt;mMinor == version.mMinor)
        {
            if (this-&gt;mReleaseType &lt; version.mReleaseType)
            {
                return true;
            }
            else if (this-&gt;mReleaseType == version.mReleaseType)
            {
                if (this-&gt;mRelease &lt; version.mRelease)
                {
                    return true;
                }
            }
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101532.111">bool RVersion::operator &gt;=(const RVersion &amp;version) const
{
    if (this-&gt;mMajor &gt; version.mMajor)
    {
        return true;
    }
    else if (this-&gt;mMajor == version.mMajor)
    {
        if (this-&gt;mMinor &gt; version.mMinor)
        {
            return true;
        }
        else if (this-&gt;mMinor == version.mMinor)
        {
            if (this-&gt;mReleaseType &gt; version.mReleaseType)
            {
                return true;
            }
            else if (this-&gt;mReleaseType == version.mReleaseType)
            {
                if (this-&gt;mRelease &gt;= version.mRelease)
                {
                    return true;
                }
            }
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101532.112">bool RVersion::operator &lt;=(const RVersion &amp;version) const
{
    if (this-&gt;mMajor &lt; version.mMajor)
    {
        return true;
    }
    else if (this-&gt;mMajor == version.mMajor)
    {
        if (this-&gt;mMinor &lt; version.mMinor)
        {
            return true;
        }
        else if (this-&gt;mMinor == version.mMinor)
        {
            if (this-&gt;mReleaseType &lt; version.mReleaseType)
            {
                return true;
            }
            else if (this-&gt;mReleaseType == version.mReleaseType)
            {
                if (this-&gt;mRelease &lt;= version.mRelease)
                {
                    return true;
                }
            }
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101532.113">unsigned int RVersion::getMajor(void) const
{
    return this-&gt;mMajor;
}

</t>
<t tx="leo.20201108101532.114">unsigned int RVersion::getMinor(void) const
{
    return this-&gt;mMinor;
}

</t>
<t tx="leo.20201108101532.115">unsigned int RVersion::getRelease(void) const
{
    return this-&gt;mRelease;
}

RVersion::ReleaseType RVersion::getReleaseType(void) const
{
    return this-&gt;mReleaseType;
}

QString RVersion::getReleaseStringFromType(RVersion::ReleaseType releaseType)
{
    switch (releaseType)
    {
        case Alpha:
        {
            return QString("alpha");
        }
        case Beta:
        {
            return QString("beta");
        }
        case ReleaseCandidate:
        {
            return QString("rc");
        }
        case Release:
        default:
        {
            return QString("");
        }
    }
}

RVersion::ReleaseType RVersion::getReleaseTypeFromString(const QString &amp;releaseTypeString)
{
    if (releaseTypeString == "alpha")
    {
        return Alpha;
    }
    if (releaseTypeString == "beta")
    {
        return Beta;
    }
    else if (releaseTypeString == "rc")
    {
        return ReleaseCandidate;
    }
    return Release;
}
</t>
<t tx="leo.20201108101532.12">void RProgressFinalize (const QString &amp;message)
{
    RProgress::getInstance().finalize(message);
} /* RProgressFinalize */


</t>
<t tx="leo.20201108101532.13">void RProgressPrint (double fraction)
{
    RProgress::getInstance().print(fraction);
} /* RProgressPrint */


</t>
<t tx="leo.20201108101532.14">void RProgressPrint (unsigned int step,
                     unsigned int nSteps)
{
    RProgress::getInstance().print((double)step/(double)nSteps);
} /* RProgressPrint */


</t>
<t tx="leo.20201108101532.15">void RProgressPrintToLog (bool printToLog)
{
    RProgress::getInstance().setPrintToLog(printToLog);
} /* RProgressPrintToLog */
</t>
<t tx="leo.20201108101532.16">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_r3vector.cpp                                         *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th February 2013                                      *
 *                                                                   *
 *  DESCRIPTION: Real vector[3] class declaration                    *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rbl_utils.h"
#include "rbl_r3vector.h"
#include "rbl_error.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.17">void RR3Vector::_init(const RR3Vector *pR3Vector)
{
    if (pR3Vector)
    {

    }
} /* RR3Vector::_init */


RR3Vector::RR3Vector()
{
    this-&gt;resize(3);
    this-&gt;_init();
} /* RR3Vector::RR3Vector */


RR3Vector::RR3Vector(const RR3Vector &amp;r3Vector) : RRVector(r3Vector)
{
    this-&gt;_init(&amp;r3Vector);
} /* RR3Vector::RR3Vector */


RR3Vector::RR3Vector(double x, double y, double z)
{
    this-&gt;resize(3);
    this-&gt;operator [](0) = x;
    this-&gt;operator [](1) = y;
    this-&gt;operator [](2) = z;
    this-&gt;_init();
} /* RR3Vector::RR3Vector */


RR3Vector::~RR3Vector()
{
} /* RR3Vector::~RR3Vector */


RR3Vector &amp;RR3Vector::operator =(const RR3Vector &amp;r3Vector)
{
    RRVector::operator =(r3Vector);
    this-&gt;_init(&amp;r3Vector);
    return (*this);
} /* RR3Vector::operator = */

</t>
<t tx="leo.20201108101532.18">void RR3Vector::findRotationMatrix(RRMatrix &amp;R) const
{
    R.setIdentity(3);

    RR3Vector lx(*this);
    RR3Vector ly;
    RR3Vector lz;

    lx.normalize();

    ly[0] = 1.0;
    ly[1] = 0.0;
    ly[2] = 0.0;

    if (std::fabs(RR3Vector::angle(lx,ly)) &lt; RConstants::pi/10.0)
    {
        ly[0] = 0.0;
        ly[1] = 1.0;
        ly[2] = 0.0;
    }

    RR3Vector::cross(lx,ly,lz);

    if (std::fabs(lz.normalize()) &lt; RConstants::eps)
    {
        lz[0] = 0.0;
        lz[1] = 0.0;
        lz[2] = 1.0;
    }

    RR3Vector::cross(lz,lx,ly);

    ly.normalize();

    R.resize(3,3);

    R[0][0] = lx[0];
    R[0][1] = ly[0];
    R[0][2] = lz[0];

    R[1][0] = lx[1];
    R[1][1] = ly[1];
    R[1][2] = lz[1];

    R[2][0] = lx[2];
    R[2][1] = ly[2];
    R[2][2] = lz[2];
} /* RR3Vector::findRotationMatrix */


RR3Vector RR3Vector::getOpposite() const
{
    return RR3Vector(-this-&gt;at(0),-this-&gt;at(1),-this-&gt;at(2));
} /* RR3Vector::getOpposite */


RR3Vector RR3Vector::findOrthogonal() const
{
    RR3Vector n(*this);
    n.normalize();

    RR3Vector r(1.0,0.0,0.0);

    double angle = RR3Vector::angle(n,r);
    if (angle &lt; (RConstants::pi / 4.0) || angle &gt; (RConstants::pi * 3.0 / 4.0))
    {
        std::swap(r[0],r[1]);
    }

    RR3Vector o;

    RR3Vector::cross(n,r,o);

    return o;
} /* RR3Vector::findOrthogonal */


</t>
<t tx="leo.20201108101532.19">void RR3Vector::clear()
{
    this-&gt;operator [](0) = 0.0;
    this-&gt;operator [](1) = 0.0;
    this-&gt;operator [](2) = 0.0;
} /* RR3Vector::clear */


double RR3Vector::findDistance(const RR3Vector &amp;v1, const RR3Vector &amp;v2)
{
    double dx = v1[0] - v2[0];
    double dy = v1[1] - v2[1];
    double dz = v1[2] - v2[2];

    return std::sqrt(dx*dx+dy*dy+dz*dz);
} /* RR3Vector::findDistance */


</t>
<t tx="leo.20201108101532.2">void RProgress::_init (const RProgress *pProgress)
{
    if (pProgress)
    {
        this-&gt;setPrintToLog(pProgress-&gt;getPrintToLog());
        this-&gt;setProgressPrintHandler(pProgress-&gt;getProgressPrintHandler());
        this-&gt;setProgressInitializeHandler(pProgress-&gt;getProgressInitializeHandler());
        this-&gt;setProgressFinalizeHandler(pProgress-&gt;getProgressFinalizeHandler());
    }
} /* RProgress::_init (const RProgress *pProgress) */


RProgress &amp; RProgress::getInstance ()
{
    static RProgress progress;
    return progress;
} /* RProgress::getInstance */


</t>
<t tx="leo.20201108101532.20">void RR3Vector::cross(const RR3Vector &amp;v1, const RR3Vector &amp;v2, RR3Vector &amp;vp)
{
    R_ERROR_ASSERT(v1.size() == v2.size());

    vp.resize(v1.size());
    if (vp.size() == 3)
    {
        vp[0] = v1[1]*v2[2] - v1[2]*v2[1];
        vp[1] = v1[2]*v2[0] - v1[0]*v2[2];
        vp[2] = v1[0]*v2[1] - v1[1]*v2[0];
    }
} /* RR3Vector::cross */


</t>
<t tx="leo.20201108101532.21">bool RR3Vector::areParallel(const RR3Vector &amp;v1, const RR3Vector &amp;v2)
{
    R_ERROR_ASSERT(v1.size() == v2.size());

    RR3Vector vx;
    RR3Vector::cross(v1,v2,vx);

    for (uint i=0;i&lt;vx.size();i++)
    {
        if (std::fabs(vx[i]) &gt; RConstants::eps)
        {
            return false;
        }
    }
    return true;
} /* RR3Vector::findNParallelDimensions */

double RR3Vector::angle(const RR3Vector &amp;v1, const RR3Vector &amp;v2)
{
    R_ERROR_ASSERT(v1.size() == v2.size());

    double ln = v1.length() * v2.length();
    if (ln == 0.0)
    {
        return 0.0;
    }

    double dotValue = RRVector::dot(v1,v2)/ln;

    if (dotValue &gt; 1.0)
    {
        dotValue = 1.0;
    }
    if (dotValue &lt; -1.0)
    {
        dotValue = -1.0;
    }

    return acos(dotValue);
} /* RR3Vector::angle */
</t>
<t tx="leo.20201108101532.22">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_rmatrix.cpp                                          *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   21-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Real matrix class definition                        *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rbl_rmatrix.h"
#include "rbl_error.h"
#include "rbl_utils.h"
#include "rbl_logger.h"


RRMatrix::RRMatrix ()
{
    this-&gt;_init();
} /* RRMatrix::RRMatrix */


RRMatrix::RRMatrix (uint nRows,
                    uint nColumns,
                    @others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.23">                    double value)
{
    this-&gt;_init();
    this-&gt;resize(nRows,nColumns,value);
} /* RRMatrix::RRMatrix */


RRMatrix::RRMatrix (const RRMatrix &amp;matrix)
{
    this-&gt;_init(&amp;matrix);
} /* RRMatrix::RRMatrix (copy) */


RRMatrix::~RRMatrix ()
{
} /* RRMatrix::~RRMatrix */


RRMatrix &amp; RRMatrix::operator = (const RRMatrix &amp;matrix)
{
    this-&gt;_init(&amp;matrix);
    return (*this);
} /* RRMatrix::operator = */


</t>
<t tx="leo.20201108101532.24">void RRMatrix::_init (const RRMatrix *pMatrix)
{
    if (pMatrix)
    {
        this-&gt;array = pMatrix-&gt;array;
    }
} /* RRMatrix::_init */


uint RRMatrix::getNRows () const
{
    return (uint)this-&gt;array.size();
} /* RRMatrix::getNRows */


uint RRMatrix::getNColumns () const
{
    if (this-&gt;getNRows() &gt; 0)
    {
        return (uint)this-&gt;array[0].size();
    }
    else
    {
        return 0;
    }
} /* RRMatrix::getNColumns */


</t>
<t tx="leo.20201108101532.25">void RRMatrix::resize (uint nRows, uint nColumns, double value)
{
    this-&gt;array.resize(nRows);
    for (uint i=0;i&lt;nRows;i++)
    {
        this-&gt;array[i].resize(nColumns,value);
    }
} /* RRMatrix::resize */


</t>
<t tx="leo.20201108101532.26">void RRMatrix::setIdentity(uint nRows)
{
    this-&gt;resize(nRows,nRows,0);
    this-&gt;fill(0.0);
    for (uint i=0;i&lt;nRows;i++)
    {
        this-&gt;setValue(i,i,1.0);
    }
} /* RRMatrix::setIdentity */


</t>
<t tx="leo.20201108101532.27">void RRMatrix::fill(double value)
{
    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        this-&gt;operator [](i).fill(value);
    }
} /* RRMatrix::fill */


double RRMatrix::getValue(uint row, uint column) const
{
    R_ERROR_ASSERT(row &lt; this-&gt;getNRows());
    R_ERROR_ASSERT(column &lt; this-&gt;getNColumns());

    return this-&gt;array[row][column];
} /* RRMatrix::getValue */


std::vector&lt;RRVector&gt; RRMatrix::getVectors() const
{
    std::vector&lt;RRVector&gt; v;

    v.resize(this-&gt;getNRows());

    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        v[i].resize(this-&gt;getNColumns());
        for (uint j=0;j&lt;v[i].size();j++)
        {
            v[i][j] = this-&gt;getValue(i,j);
        }
    }

    return v;
} /* RRMatrix::getVectors */


</t>
<t tx="leo.20201108101532.28">void RRMatrix::setValue(uint row, uint column, double value)
{
    R_ERROR_ASSERT(row &lt; this-&gt;getNRows());
    R_ERROR_ASSERT(column &lt; this-&gt;getNColumns());

    this-&gt;array[row][column] = value;
} /* RRMatrix::setValue */


</t>
<t tx="leo.20201108101532.29">bool RRMatrix::isSquare() const
{
    return (this-&gt;getNRows() &gt; 0 &amp;&amp; this-&gt;getNRows() == this-&gt;getNColumns());
} /* RRMatrix::isSquare */


</t>
<t tx="leo.20201108101532.3">bool RProgress::getPrintToLog (void) const
{
    return this-&gt;printToLog;
} /* RProgress::getPrintToLog */


</t>
<t tx="leo.20201108101532.30">void RRMatrix::transpose ()
{
    uint nr = this-&gt;getNRows();
    uint nc = this-&gt;getNColumns();

    if (nr == nc)
    {
        double rtmp;
        for (uint i=0;i&lt;nr;i++)
        {
            for (uint j=i+1;j&lt;nc;j++)
            {
                rtmp = this-&gt;getValue(j,i);
                this-&gt;setValue(j,i,this-&gt;getValue(i,j));
                this-&gt;setValue(i,j,rtmp);
            }
        }
    }
    else
    {
        RRMatrix rtmp(*this);

        this-&gt;resize(nc,nr);
        for (uint i=0;i&lt;nr;i++)
        {
            for (uint j=0;j&lt;nc;j++)
            {
                this-&gt;setValue(j,i,rtmp.getValue(i,j));
            }
        }
    }
} /* RRMatrix::transpose */


</t>
<t tx="leo.20201108101532.31">void RRMatrix::transpose(const RRMatrix &amp;A)
{
    uint nr = A.getNRows();
    uint nc = A.getNColumns();

    this-&gt;resize(nc,nr);

    for (uint i=0;i&lt;nr;i++)
    {
        for (uint j=0;j&lt;nc;j++)
        {
            (*this)[j][i] = A[i][j];
        }
    }
} /* RRMatrix::transpose */


</t>
<t tx="leo.20201108101532.32">void RRMatrix::invert()
{
    R_ERROR_ASSERT (this-&gt;isSquare());

    uint n = this-&gt;getNRows();

    if (n == 0)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Can not invert zero sized matrix.");
    }
    else if (n == 1)
    {
        if (this-&gt;getValue(0,0) == 0.0)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Can not invert zero value matrix.");
        }
        this-&gt;setValue(0,0,1.0/this-&gt;getValue(0,0));
    }
    else if (n == 2)
    {
        double det = this-&gt;getDeterminant();
        if (det == 0.0)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Can not invert matrix. Matrix determinant = 0");
        }

        RRMatrix inv(n,n);

        inv[0][0] =    this-&gt;getValue(1,1) / det;
        inv[0][1] = -1*this-&gt;getValue(0,1) / det;
        inv[1][0] = -1*this-&gt;getValue(1,0) / det;
        inv[1][1] =    this-&gt;getValue(0,0) / det;

        this-&gt;operator =(inv);
    }
    else if (n == 3)
    {
        double det = this-&gt;getDeterminant();
        if (det == 0.0)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Can not invert matrix. Singular matrix.");
        }

        RRMatrix inv(n,n);

        inv[0][0] =    (this-&gt;getValue(1,1)*this-&gt;getValue(2,2) - this-&gt;getValue(1,2)*this-&gt;getValue(2,1)) / det;
        inv[0][1] = -1*(this-&gt;getValue(0,1)*this-&gt;getValue(2,2) - this-&gt;getValue(0,2)*this-&gt;getValue(2,1)) / det;
        inv[0][2] =    (this-&gt;getValue(0,1)*this-&gt;getValue(1,2) - this-&gt;getValue(0,2)*this-&gt;getValue(1,1)) / det;

        inv[1][0] = -1*(this-&gt;getValue(1,0)*this-&gt;getValue(2,2) - this-&gt;getValue(1,2)*this-&gt;getValue(2,0)) / det;
        inv[1][1] =    (this-&gt;getValue(0,0)*this-&gt;getValue(2,2) - this-&gt;getValue(0,2)*this-&gt;getValue(2,0)) / det;
        inv[1][2] = -1*(this-&gt;getValue(0,0)*this-&gt;getValue(1,2) - this-&gt;getValue(0,2)*this-&gt;getValue(1,0)) / det;

        inv[2][0] =    (this-&gt;getValue(1,0)*this-&gt;getValue(2,1) - this-&gt;getValue(1,1)*this-&gt;getValue(2,0)) / det;
        inv[2][1] = -1*(this-&gt;getValue(0,0)*this-&gt;getValue(2,1) - this-&gt;getValue(0,1)*this-&gt;getValue(2,0)) / det;
        inv[2][2] =    (this-&gt;getValue(0,0)*this-&gt;getValue(1,1) - this-&gt;getValue(0,1)*this-&gt;getValue(1,0)) / det;

        this-&gt;operator =(inv);
    }
    else
    {
        std::vector&lt;uint&gt; indxc(n);
        std::vector&lt;uint&gt; indxr(n);
        std::vector&lt;uint&gt; ipiv(n,0);;

        for (uint i=0;i&lt;n;i++)
        {
            double big = 0.0;
            uint  irow = 0;
            uint  icol = 0;
            for (uint j=0;j&lt;n;j++)
            {
                if (ipiv[j] != 1)
                {
                    for (uint k=0;k&lt;n;k++)
                    {
                        if (ipiv[k] == 0)
                        {
                            if (fabs((*this)[j][k]) &gt;= big) {
                                big=fabs((*this)[j][k]);
                                irow=j;
                                icol=k;
                            }
                        }
                    }
                }
            }
            ++(ipiv[icol]);
            if (irow != icol)
            {
                for (uint l=0;l&lt;n;l++)
                {
                    std::swap((*this)[irow][l],(*this)[icol][l]);
                }
            }
            indxr[i]=irow;
            indxc[i]=icol;
            if ((*this)[icol][icol] == 0.0)
            {
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Can not invert matrix. Singular matrix.");
            }
            double pivinv=1.0/(*this)[icol][icol];
            (*this)[icol][icol]=1.0;
            for (uint l=0;l&lt;n;l++)
            {
                (*this)[icol][l] *= pivinv;
            }
            for (uint ll=0;ll&lt;n;ll++)
            {
                if (ll != icol) {
                    double dum=(*this)[ll][icol];
                    (*this)[ll][icol]=0.0;
                    for (uint l=0;l&lt;n;l++)
                    {
                        (*this)[ll][l] -= (*this)[icol][l]*dum;
                    }
                }
            }
        }
        for (uint l=n;l&gt;0;l--)
        {
            if (indxr[l-1] != indxc[l-1])
            {
                for (uint k=0;k&lt;n;k++)
                {
                    std::swap((*this)[k][indxr[l-1]],(*this)[k][indxc[l-1]]);
                }
            }
        }
    }
} /* RRMatrix::invert */


</t>
<t tx="leo.20201108101532.33">void RRMatrix::decomposeToLU()
{
    uint m = this-&gt;getNRows();

    RRMatrix lu(m,m);
    RRMatrix &amp;A = (*this);

    for (uint j=0;j&lt;m;j++)
    {
        for (uint i=0;i&lt;m;i++)
        {
            if (i == 0)
            {
                lu[i][j] = A[i][j];
            }
            else if (i &lt;= j &amp;&amp; i != 0)
            {
                lu[i][j] = 0.0;
                for (uint k=0;k&lt;i;k++)
                {
                    lu[i][j] -= lu[i][k] * lu[k][j];
                }
                lu[i][j] += A[i][j];
            }
            else
            {
                double tmpValue = 0.0;

                if (j == 0)
                {
                    if (std::abs(lu[0][0]) &lt; RConstants::eps)
                    {
                        tmpValue = A[i][j] / RConstants::eps;
                    }
                    else
                    {
                        tmpValue = A[i][j] / lu[0][0];
                    }
                }
                else
                {
                    for (uint k=0;k&lt;j;k++)
                    {
                        tmpValue += lu[i][k] * lu[k][j];
                    }
                    if (std::abs(lu[j][j]) &lt; RConstants::eps)
                    {
                        tmpValue = (A[i][j] - tmpValue) / RConstants::eps;
                    }
                    else
                    {
                        tmpValue = (A[i][j] - tmpValue) / lu[j][j];
                    }
                }
                lu[i][j] = tmpValue;
            }
        }
    }
    this-&gt;operator =(lu);

//    std::vector&lt;uint&gt; idx(m);
//    std::vector&lt;double&gt; vv(m);

//    for (uint i=0;i&lt;m;i++)
//    {
//        double big = 0.0;
//        for (uint j=0;j&lt;m;j++)
//        {
//            big = std::max(big,std::abs(this-&gt;getValue(i,j)));
//        }
//        if (big == 0.0)
//        {
//            throw RError(R_ERROR_APPLICATION,"LU decomposition failed. Singular matrix.");
//        }
//        if (std::abs(big) &lt; RConstants::eps)
//        {
//            vv[i] = 1.0 / RConstants::eps;
//        }
//        else
//        {
//            vv[i] = 1.0 / big;
//        }
//    }

//    uint iMax;

//    for (uint j=0;j&lt;m;j++)
//    {
//        for (uint i=0;i&lt;j;i++)
//        {
//            double sum = this-&gt;getValue(i,j);
//            for (uint k=1;k&lt;i;k++)
//            {
//                sum -= this-&gt;getValue(i,k)*this-&gt;getValue(k,j);
//            }
//            this-&gt;setValue(i,j,sum);
//        }

//        double big = 0.0;

//        for (uint i=j;i&lt;m;i++)
//        {
//            double sum = this-&gt;getValue(i,j);
//            if (j &gt; 0)
//            {
//                for (uint k=0;k&lt;(j-1);k++)
//                {
//                    sum -= this-&gt;getValue(i,k)*this-&gt;getValue(k,j);
//                }
//            }
//            this-&gt;setValue(i,j,sum);
//            double dum = vv[i]*std::abs(sum);
//            if (dum &gt; big)
//            {
//                big = dum;
//                iMax = i;
//            }
//        }

//        if (j != iMax)
//        {
//            for (uint k=0;k&lt;m;k++)
//            {
//                double temp = this-&gt;getValue(iMax,k);
//                this-&gt;setValue(iMax,k,this-&gt;getValue(j,k));
//                this-&gt;setValue(j,k,temp);
//            }
//            vv[iMax] = vv[j];
//        }

//        idx[j] = iMax;

//        if (this-&gt;getValue(j,j) == 0.0)
//        {
//            this-&gt;setValue(j,j,1.0e-19);
//        }

//        if (j != m)
//        {
//            double dum;
//            if (std::abs(this-&gt;getValue(j,j)) &lt; RConstants::eps)
//            {
//                dum = 1.0 / RConstants::eps;
//            }
//            else
//            {
//                dum = 1.0 / this-&gt;getValue(j,j);
//            }
//            for (uint i=j+1;i&lt;m;i++)
//            {
//                this-&gt;setValue(i,j,this-&gt;getValue(i,j) * dum);
//            }
//        }
//    }

//    uint i = 0;
//    while (i &lt; m)
//    {
//        if (i != idx[i])
//        {
//            std::swap(this-&gt;array[i],this-&gt;array[idx[i]]);
//            std::swap(idx[i],idx[idx[i]]);
//        }
//        else
//        {
//            i++;
//        }
//    }
} /* RRMatrix::decomposeToLU */


double RRMatrix::getDeterminant() const
{
    R_ERROR_ASSERT (this-&gt;isSquare());

    double det = 0.0;

    uint n = this-&gt;getNRows();

    if (n == 1)
    {
        return this-&gt;getValue(0,0);
    }
    if (n == 2)
    {
        return this-&gt;getValue(0,0) * this-&gt;getValue(1,1) - this-&gt;getValue(0,1) * this-&gt;getValue(1,0);
    }

    RRMatrix tmp(n-1,n-1);

    for (uint i=0;i&lt;n;i++)
    {
        uint l = 0;
        for (uint j=0;j&lt;n;j++)
        {
            if (i != j)
            {
                for (uint k=1;k&lt;n;k++)
                {
                    tmp.setValue(l,k-1,this-&gt;getValue(j,k));
                }
                l++;
            }
        }
        int one = 1;
        if (i &amp; 1)
        {
            one = -1;
        }
        det += one * this-&gt;getValue(i,0) * tmp.getDeterminant();
    }

    return det;
} /* RRMatrix::getDeterminant */


RRVector RRMatrix::getSummedRows() const
{
    RRVector b(this-&gt;getNRows(),0.0);

    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        b[i] = this-&gt;getSummedRow(i);
    }

    return b;
} /* RRMatrix::getSummedRows */


double RRMatrix::getSummedRow(uint row) const
{
    R_ERROR_ASSERT (row &lt; this-&gt;getNRows());

    double b = 0.0;

    for (uint i=0;i&lt;this-&gt;getNColumns();i++)
    {
        b += (*this)[row][i];
    }

    return b;
} /* RRMatrix::getSummedRow */


</t>
<t tx="leo.20201108101532.34">const RRVector &amp; RRMatrix::operator [] (uint row) const
{
    R_ERROR_ASSERT (row &lt; this-&gt;getNRows());

    return this-&gt;array[row];
} /* RRMatrix::operator [] */


RRVector &amp; RRMatrix::operator [] (uint row)
{
    R_ERROR_ASSERT (row &lt; this-&gt;getNRows());

    return this-&gt;array[row];
} /* RRMatrix::operator [] */


</t>
<t tx="leo.20201108101532.35">void RRMatrix::operator *=(double scaleValue)
{
    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        this-&gt;operator [](i) *= scaleValue;
    }
} /* RRMatrix::operator *= */

</t>
<t tx="leo.20201108101532.36">bool RRMatrix::operator ==(const RRMatrix &amp;array) const
{
    if (this-&gt;getNRows() != array.getNRows())
    {
        return false;
    }

    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        if (this-&gt;operator[](i) != array.operator[](i))
        {
            return false;
        }
    }

    return true;
} /* RRMatrix::operator == */

</t>
<t tx="leo.20201108101532.37">bool RRMatrix::operator !=(const RRMatrix &amp;array) const
{
    return ! this-&gt;operator==(array);
} /* RRMatrix::operator != */


RRMatrix RRMatrix::getBlock(uint iBegin, uint iEnd, uint jBegin, uint jEnd) const
{
    R_ERROR_ASSERT (iBegin &lt;= iEnd);
    R_ERROR_ASSERT (jBegin &lt;= jEnd);
    R_ERROR_ASSERT (this-&gt;getNRows() &gt; iEnd);
    R_ERROR_ASSERT (this-&gt;getNColumns() &gt; jEnd);

    uint iSize = iEnd - iBegin + 1;
    uint jSize = jEnd - jBegin + 1;

    RRMatrix m(iSize,jSize);

    for (uint i=0;i&lt;iSize;i++)
    {
        for (uint j=0;j&lt;jSize;j++)
        {
            m[i][j] = (*this)[i+iBegin][j+jBegin];
        }
    }

    return m;
}

</t>
<t tx="leo.20201108101532.38">void RRMatrix::setBlock(const RRMatrix &amp;matrix, uint iBegin, uint jBegin)
{
    R_ERROR_ASSERT (this-&gt;getNRows() &gt; iBegin);
    R_ERROR_ASSERT (this-&gt;getNColumns() &gt; jBegin);
    R_ERROR_ASSERT (this-&gt;getNRows() &gt;= iBegin + matrix.getNRows());
    R_ERROR_ASSERT (this-&gt;getNColumns() &gt;= jBegin + matrix.getNColumns());

    for (uint i=0;i&lt;matrix.getNRows();i++)
    {
        for (uint j=0;j&lt;matrix.getNColumns();j++)
        {
            (*this)[iBegin+i][jBegin+j] = matrix[i][j];
        }
    }
} /* RRMatrix::getBlock */


QString RRMatrix::toString() const
{
    QString text;

    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        text += this-&gt;operator [](i).toString(true) + "\n";
    }

    return text;
} /* RRMatrix::toString */


</t>
<t tx="leo.20201108101532.39">void RRMatrix::print() const
{
    RLogger::info("Matrix - real: [%ux%u]\n",this-&gt;getNRows(),this-&gt;getNColumns());
    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        this-&gt;operator [](i).print(true,true);
    }
} /* RRMatrix::print */


</t>
<t tx="leo.20201108101532.4">void RProgress::setPrintToLog (bool printToLog)
{
    this-&gt;printToLog = printToLog;
} /* RProgress::setPrintToLog */


RProgressPrintHandler RProgress::getProgressPrintHandler (void) const
{
    return this-&gt;progressHandler;
} /* RProgress::getProgressHandler */


</t>
<t tx="leo.20201108101532.40">void RRMatrix::clear ()
{
    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        this-&gt;array[i].clear();
    }
    this-&gt;array.clear();
} /* RRMatrix::clear */


</t>
<t tx="leo.20201108101532.41">void RRMatrix::solveLU(const RRMatrix &amp;A, const RRVector &amp;x, RRVector &amp;y)
{
    RRMatrix LU(A);

    LU.decomposeToLU();

    uint m = LU.getNRows();

    y = x;

    // Solve L*b=x (where b=U*y)
    for (uint i=0;i&lt;m;i++)
    {
        double sum = y[i];
        for (uint j=0;j&lt;i;j++)
        {
            sum -= LU[i][j]*y[j];
        }
        y[i] = sum;
    }

    // Solve U*y=b
    for (uint i=0;i&lt;m;i++)
    {
        uint k = m-i-1;
        double sum = y[k];
        for (uint j=k+1;j&lt;m;j++)
        {
            sum -= LU[k][j]*y[j];
        }
        if (std::abs(LU[k][k]) &lt; RConstants::eps)
        {
            y[k] = sum / RConstants::eps;
        }
        else
        {
            y[k] = sum / LU[k][k];
        }
    }
} /* RRMatrix::solveLU */


double RRMatrix::norm(const RRMatrix &amp;M)
{
    RRVector v(M.getNRows());

    v.fill(0.0);

    for (uint i=0;i&lt;M.getNRows();i++)
    {
        for (uint j=0;j&lt;M.getNColumns();j++)
        {
            v[i] += M[i][j];
        }
    }

    return RRVector::norm(v);
} /* RRMatrix::norm */


double RRMatrix::norm(const RRMatrix &amp;M, const RRVector &amp;b)
{
    RRVector v(M.getNRows());

    v.fill(0.0);

    for (uint i=0;i&lt;M.getNRows();i++)
    {
        for (uint j=0;j&lt;M.getNColumns();j++)
        {
            v[i] += M[i][j]*b[j];
        }
    }

    double norm1 = RRVector::norm(v);
    double norm2 = RRVector::norm(b);

    if (norm2 &lt; RConstants::eps)
    {
        return 0.0;
    }
    return norm1 / norm2;
} /* RRMatrix::norm */


double RRMatrix::trace(const RRMatrix &amp;M)
{
    uint m = M.getNRows();
    if (m &gt; M.getNColumns())
    {
        m = M.getNColumns();
    }

    double traceValue = 0.0;
    for (uint i=0;i&lt;m;i++)
    {
        traceValue += M[i][i];
    }
    return traceValue;
} /* RRMatrix::trace */


</t>
<t tx="leo.20201108101532.42">void RRMatrix::mlt(const RRMatrix &amp;A, const RRVector &amp;x, RRVector &amp;y, bool add)
{
    R_ERROR_ASSERT (A.getNColumns() == x.getNRows());

    y.resize(A.getNRows(),0.0);
    if (!add)
    {
        y.fill(0.0);
    }

    for (uint i=0;i&lt;A.getNRows();i++)
    {
        for (uint j=0;j&lt;A.getNColumns();j++)
        {
            y[i] += A[i][j]*x[j];
        }
    }
} /* RRMatrix::mlt */


</t>
<t tx="leo.20201108101532.43">void RRMatrix::mlt(const RRMatrix &amp;A, const RRMatrix &amp;X, RRMatrix &amp;Y, bool add)
{
    R_ERROR_ASSERT (A.getNColumns() == X.getNRows());

    Y.resize(A.getNRows(),X.getNColumns(),0.0);
    if (!add)
    {
        Y.fill(0.0);
    }

    for (uint i=0;i&lt;X.getNColumns();i++)
    {
        for (uint j=0;j&lt;A.getNRows();j++)
        {
            for (uint k=0;k&lt;A.getNColumns();k++)
            {
                Y[j][i] += A[j][k]*X[k][i];
            }
        }
    }
} /* RRMatrix::mlt */


RRMatrix RRMatrix::generateRotationMatrix(double xAngle, double yAngle, double zAngle)
{
    RRMatrix R(3,3);
    RRMatrix Rx(3,3);
    RRMatrix Ry(3,3);
    RRMatrix Rz(3,3);

    double cxr = std::cos(xAngle);
    double sxr = std::sin(xAngle);
    double cyr = std::cos(yAngle);
    double syr = std::sin(yAngle);
    double czr = std::cos(zAngle);
    double szr = std::sin(zAngle);

    // Rx
    Rx[0][0] =  1.0; Rx[0][1] =  0.0; Rx[0][2] =  0.0;
    Rx[1][0] =  0.0; Rx[1][1] =  cxr; Rx[1][2] = -sxr;
    Rx[2][0] =  0.0; Rx[2][1] =  sxr; Rx[2][2] =  cxr;

    // Ry
    Ry[0][0] =  cyr; Ry[0][1] =  0.0; Ry[0][2] =  syr;
    Ry[1][0] =  0.0; Ry[1][1] =  1.0; Ry[1][2] =  0.0;
    Ry[2][0] = -syr; Ry[2][1] =  0.0; Ry[2][2] =  cyr;

    // Rz
    Rz[0][0] =  czr; Rz[0][1] = -szr; Rz[0][2] =  0.0;
    Rz[1][0] =  szr; Rz[1][1] =  czr; Rz[1][2] =  0.0;
    Rz[2][0] =  0.0; Rz[2][1] =  0.0; Rz[2][2] =  1.0;

    RRMatrix Rzy(3,3);

    RRMatrix::mlt(Rz,Ry,Rzy);
    RRMatrix::mlt(Rzy,Rx,R);

    return R;
} /* RRMatrix::generateRotationMatrix */
</t>
<t tx="leo.20201108101532.44">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_rvector.cpp                                          *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   21-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Real vector class declaration                       *
 *********************************************************************/

#include &lt;QTextStream&gt;

#include &lt;cmath&gt;

#include "rbl_logger.h"
#include "rbl_rvector.h"
#include "rbl_error.h"
#include "rbl_utils.h"


RRVector::RRVector(uint nRows, double value)
{
    this-&gt;resize(nRows,value);
    this-&gt;_init();
} /* RRVector::RRVector */


RRVector::RRVector(const RRVector &amp;array)
    : std::vector&lt;double&gt;(array)
{
    this-&gt;_init(&amp;array);
} /* RRVector::RRVector */

RRVector::RRVector(const std::vector&lt;double&gt; &amp;array)
    : std::vector&lt;double&gt;(array)
{
    this-&gt;_init();
} /* RRVector::RRVector (copy) */



RRVector::RRVector(double x, double y, double z)
{
    this-&gt;resize(3);
    this-&gt;operator [](0) = x;
    this-&gt;operator [](1) = y;
    this-&gt;operator [](2) = z;
    this-&gt;_init();
} /* RRVector::RRVector */


RRVector::~RRVector()
{
} /* RRVector::~RRVector */


RRVector &amp; RRVector::operator =(const RRVector &amp;array)
{
    this-&gt;std::vector&lt;double&gt;::operator = (array);
    this-&gt;_init(&amp;array);
    return (*this);
} /* RRVector::operator = */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.45">void RRVector::fill(double value)
{
    std::fill(this-&gt;begin(),this-&gt;end(),value);
} /* RRVector::fill */


</t>
<t tx="leo.20201108101532.46">void RRVector::append(const RRVector &amp;array)
{
    this-&gt;insert(this-&gt;end(), array.begin(), array.end());
} /* RRVector::append */


</t>
<t tx="leo.20201108101532.47">void RRVector::_init(const RRVector *pArray)
{
    if (pArray)
    {
    }
} /* RRVector::_init */


double &amp; RRVector::operator [](uint n)
{
    R_ERROR_ASSERT(n&lt;this-&gt;getNRows());

    return this-&gt;at(n);
} /* RRVector::operator [] */


</t>
<t tx="leo.20201108101532.48">const double &amp; RRVector::operator [](uint n) const
{
    R_ERROR_ASSERT(n&lt;this-&gt;getNRows());

    return this-&gt;at(n);
} /* RRVector::operator [] */


</t>
<t tx="leo.20201108101532.49">void RRVector::operator *=(double scaleValue)
{
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        this-&gt;at(i) *= scaleValue;
    }
} /* RRVector::operator *= */

</t>
<t tx="leo.20201108101532.5">void RProgress::setProgressPrintHandler (RProgressPrintHandler progressHandler)
{
    this-&gt;progressHandler = progressHandler;
} /* RProgress::setProgressHandler */


RProgressInitializeHandler RProgress::getProgressInitializeHandler (void) const
{
    return this-&gt;progressInitializeHandler;
} /* RProgress::getProgressInitializeHandler */


</t>
<t tx="leo.20201108101532.50">bool RRVector::operator ==(const RRVector &amp;array) const
{
    if (this-&gt;size() != array.size())
    {
        return false;
    }
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        if (!R_D_ARE_SAME(this-&gt;at(i),array.at(i)))
        {
            return false;
        }
    }
    return true;
} /* RRVector::operator == */

</t>
<t tx="leo.20201108101532.51">bool RRVector::operator !=(const RRVector &amp;array) const
{
    return ! this-&gt;operator==(array);
} /* RRVector::operator != */


double RRVector::length() const
{
    double len = 0.0;
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        len += std::pow(this-&gt;at(i),2);
    }
    return sqrt(len);
} /* RRVector::length */


double RRVector::normalize()
{
    double len = this-&gt;length();
    if (len != 0.0)
    {
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            (*this)[i] /= len;
        }
    }
    return len;
} /* RRVector::normalize */


</t>
<t tx="leo.20201108101532.52">void RRVector::scale(double scale)
{
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        (*this)[i] *= scale;
    }
} /* RRVector::scale */


QString RRVector::toString(bool oneLine) const
{
    QString string;
    QTextStream ss(&amp;string);

    ss.setFieldWidth(15);
    ss.setRealNumberNotation(QTextStream::ScientificNotation);
    ss.setRealNumberPrecision(6);

    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        ss &lt;&lt; this-&gt;operator [](i);
        if (!oneLine)
        {
            ss &lt;&lt; "\n";
        }
    }

    return string;
} /* RRVector::toString */


</t>
<t tx="leo.20201108101532.53">void RRVector::print(bool oneLine, bool newLine) const
{
    if (!oneLine)
    {
        RLogger::info("Vector - real: [%u]\n",this-&gt;size());
    }
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        RLogger::info("%15.6e",this-&gt;at(i));
        if (!oneLine)
        {
            RLogger::info("\n");
        }
    }
    if (newLine)
    {
        RLogger::info("\n");
    }
} /* RRVector::print */


double RRVector::dot(const RRVector &amp;v1, const RRVector &amp;v2)
{
    R_ERROR_ASSERT(v1.size() == v2.size());

    double dotProd = 0.0;
    for (uint i=0;i&lt;v1.size();i++)
    {
        dotProd += v1[i]*v2[i];
    }
    return dotProd;
} /* RRVector::dot */


</t>
<t tx="leo.20201108101532.54">void RRVector::add(const RRVector &amp;v1, const RRVector &amp;v2, RRVector &amp;x)
{
    R_ERROR_ASSERT(v1.size() == v2.size());

    x.resize(v1.size());

    for (uint i=0;i&lt;v1.size();i++)
    {
        x[i] = v1[i] + v2[i];
    }
} /* RRVector::add */


</t>
<t tx="leo.20201108101532.55">void RRVector::subtract(const RRVector &amp;v1, const RRVector &amp;v2, RRVector &amp;x)
{
    R_ERROR_ASSERT(v1.size() == v2.size());

    x.resize(v1.size());

    for (uint i=0;i&lt;v1.size();i++)
    {
        x[i] = v1[i] - v2[i];
    }
} /* RRVector::subtract */


double RRVector::norm(const RRVector &amp;v)
{
    return v.length();
} /* RRVector::norm */
</t>
<t tx="leo.20201108101532.56">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_statistics.cpp                                       *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th March 2013                                         *
 *                                                                   *
 *  DESCRIPTION: Statistics class definition                         *
 *********************************************************************/

#include &lt;cmath&gt;
#include &lt;algorithm&gt;

#include &lt;rblib.h&gt;

#include "rbl_statistics.h"
#include "rbl_logger.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.57">void RStatistics::_init(const RStatistics *pStatistics)
{
    if (pStatistics)
    {
        this-&gt;nValues = pStatistics-&gt;nValues;
        this-&gt;min = pStatistics-&gt;min;
        this-&gt;max = pStatistics-&gt;max;
        this-&gt;avg = pStatistics-&gt;avg;
        this-&gt;med = pStatistics-&gt;med;
        this-&gt;p05 = pStatistics-&gt;p05;
        this-&gt;p95 = pStatistics-&gt;p95;
        this-&gt;dsv = pStatistics-&gt;dsv;
    }
}

RStatistics::RStatistics(const RRVector &amp;values, unsigned int nDistValues, bool sortValues)
    : nValues(0)
    , min(0.0)
    , max(0.0)
    , avg(0.0)
    , med(0.0)
    , p05(0.0)
    , p95(0.0)
{
    this-&gt;_init();
    this-&gt;calculate(values,nDistValues,sortValues);
}

RStatistics::RStatistics(const RStatistics &amp;statistics)
{
    this-&gt;_init(&amp;statistics);
}

RStatistics::~RStatistics()
{
}

RStatistics &amp;RStatistics::operator =(const RStatistics &amp;statistics)
{
    this-&gt;_init(&amp;statistics);
    return (*this);
}

</t>
<t tx="leo.20201108101532.58">void RStatistics::print(void) const
{
    RLogger::info("Minimum:       % 14g\n",this-&gt;getMin());
    RLogger::info("Maximum:       % 14g\n",this-&gt;getMax());
    RLogger::info("Average:       % 14g\n",this-&gt;getAvg());
    RLogger::info("Median:        % 14g\n",this-&gt;getMed());
    RLogger::info("Percentile 05: % 14g\n",this-&gt;getP05());
    RLogger::info("Percentile 95: % 14g\n",this-&gt;getP95());
}

</t>
<t tx="leo.20201108101532.59">void RStatistics::calculate(const RRVector &amp;values, unsigned int nDistValues, bool sortValues)
{
    this-&gt;nValues = (unsigned int)values.size();
    this-&gt;min = RStatistics::findMinimumValue(values);
    this-&gt;max = RStatistics::findMaximumValue(values);
    this-&gt;avg = RStatistics::findAverageValue(values);
    this-&gt;dsv = RStatistics::findDistributedValues(values,nDistValues);

    if (sortValues)
    {
        RRVector sortedValues(values);
        std::sort(sortedValues.begin(),sortedValues.end());
        this-&gt;med = RStatistics::findMedianValue(sortedValues);
        this-&gt;p05 = RStatistics::findPercentileValue(sortedValues,5.0);
        this-&gt;p95 = RStatistics::findPercentileValue(sortedValues,95.0);
    }
    else
    {
        this-&gt;med = RStatistics::findMedianValue(values);
        this-&gt;p05 = RStatistics::findPercentileValue(values,5.0);
        this-&gt;p95 = RStatistics::findPercentileValue(values,95.0);
    }
}

double RStatistics::findMinimumValue(const RRVector &amp;values)
{
    double value = 0.0;
    bool firstValue = true;
    for (unsigned int i=0;i&lt;values.size();i++)
    {
        if (firstValue)
        {
            value = values[i];
            firstValue = false;
        }
        else
        {
            value = std::min(value,values[i]);
        }
    }
    return value;
}

double RStatistics::findMaximumValue(const RRVector &amp;values)
{
    double value = 0.0;
    bool firstValue = true;
    for (unsigned int i=0;i&lt;values.size();i++)
    {
        if (firstValue)
        {
            value = values[i];
            firstValue = false;
        }
        else
        {
            value = std::max(value,values[i]);
        }
    }
    return value;
}

double RStatistics::findMinimumAbsoluteValue(const RRVector &amp;values)
{
    double value = 0.0;
    bool firstValue = true;
    for (unsigned int i=0;i&lt;values.size();i++)
    {
        if (firstValue)
        {
            value = std::fabs(values[i]);
            firstValue = false;
        }
        else
        {
            value = std::min(value,std::fabs(values[i]));
        }
    }
    return value;
}

double RStatistics::findMaximumAbsoluteValue(const RRVector &amp;values)
{
    double value = 0.0;
    bool firstValue = true;
    for (unsigned int i=0;i&lt;values.size();i++)
    {
        if (firstValue)
        {
            value = std::fabs(values[i]);
            firstValue = false;
        }
        else
        {
            value = std::max(value,std::fabs(values[i]));
        }
    }
    return value;
}

double RStatistics::findAverageValue(const RRVector &amp;values)
{
    double value = 0.0;
    for (unsigned int i=0;i&lt;values.size();i++)
    {
        value += values[i];
    }
    if (values.size() &gt; 0)
    {
        value /= values.size();
    }
    return value;
}

double RStatistics::findMedianValue(const RRVector &amp;values)
{
    double value = 0.0;
    unsigned int nv = (unsigned int)values.size();
    unsigned int pos = 0;

    if (nv % 2 != 0) {
        pos = nv / 2;
        value = values[pos];
    }
    else {
        value = 0.0;
        pos = (int) floor((double)nv / 2.0);
        value += values[pos];
        pos = (int) ceil((double)nv / 2.0);
        value += values[pos];
        value /= 2.0;
    }

    return value;
}

double RStatistics::findPercentileValue(const RRVector &amp;values, double percentile)
{
    RRVector vs(values);
    double n, p, vp, vd;
    unsigned int k;
    unsigned int N;

    if (percentile &lt; 0.0)
    {
        p = 0.0;
    }
    else if (percentile &gt; 100.0)
    {
        p = 100.0;
    }
    else {
        p = percentile;
    }

    N = (unsigned int)vs.size();

    n = (p/100.0)*(N-1.0)+1.0;

    if (n &lt;= 1.0)
    {
        return vs[0];
    }
    if (n &gt;= N)
    {
        return vs[N-1];
    }

    k = (unsigned int)floor(n);
    vd = vs[k] - vs[k-1];
    vd -= floor(vd);
    vp = vs[k-1] + vd;

    return vp;
}

RRMatrix RStatistics::findDistributedValues(const RRVector &amp;values, unsigned int nDistValues)
{
    RRMatrix dist(2,nDistValues);

    double llim,  ulim;
    double sllim, sulim;
    double step;
    int nvals;

    llim = RStatistics::findMinimumValue(values);
    ulim = RStatistics::findMaximumValue(values);
    step = ulim - llim;
    if (nDistValues &gt; 1)
    {
        step /= (double)(nDistValues-1);
    }

    dist.fill(0.0);

    nvals = (unsigned int)values.size();

    for (unsigned int i=0;i&lt;nDistValues;i++) {
        sllim = step*i + llim;
        sulim = sllim + step;

        dist[0][i] = sllim;

        if (i == nDistValues-1) {
            sulim = ulim + 1.0;
        }
        for (int j=0;j&lt;nvals;j++) {
            if (sllim &lt;= values[j] &amp;&amp; values[j] &lt; sulim) {
                dist[1][i]++;
            }
        }
    }

    return dist;
}

double RStatistics::findMinimumMagnitude(const std::vector&lt;RR3Vector&gt; &amp;values)
{
    double minMag = 0.0;
    for (unsigned int i=0;i&lt;values.size();i++)
    {
        if (i==0)
        {
            minMag = RR3Vector::norm(values[i]);
        }
        else
        {
            minMag = std::min(minMag,RR3Vector::norm(values[i]));
        }
    }
    return minMag;
}

double RStatistics::findMaximumMagnitude(const std::vector&lt;RR3Vector&gt; &amp;values)
{
    double maxMag = 0.0;
    for (unsigned int i=0;i&lt;values.size();i++)
    {
        if (i==0)
        {
            maxMag = RR3Vector::norm(values[i]);
        }
        else
        {
            maxMag = std::max(maxMag,RR3Vector::norm(values[i]));
        }
    }
    return maxMag;
}
</t>
<t tx="leo.20201108101532.6">void RProgress::setProgressInitializeHandler (RProgressInitializeHandler progressInitializeHandler)
{
    this-&gt;progressInitializeHandler = progressInitializeHandler;
} /* RProgress::setProgressInitializeHandler */


RProgressFinalizeHandler RProgress::getProgressFinalizeHandler (void) const
{
    return this-&gt;progressFinalizeHandler;
} /* RProgress::getProgressFinalizeHandler */


</t>
<t tx="leo.20201108101532.60">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_stop_watch.cpp                                       *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   30-th December 2015                                      *
 *                                                                   *
 *  DESCRIPTION: Stop-watch definition                               *
 *********************************************************************/

#include &lt;QDateTime&gt;
#include &lt;cmath&gt;

#include "rbl_stop_watch.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.61">void RStopWatch::_init(const RStopWatch *pStopWatch)
{
    if (pStopWatch)
    {
        this-&gt;startTime = pStopWatch-&gt;startTime;
        this-&gt;pauseTime = pStopWatch-&gt;pauseTime;
    }
}

RStopWatch::RStopWatch()
{
    this-&gt;_init();
}

RStopWatch::RStopWatch(const RStopWatch &amp;stopWatch)
{
    this-&gt;_init(&amp;stopWatch);
}

RStopWatch::~RStopWatch()
{

}

RStopWatch &amp;RStopWatch::operator =(const RStopWatch &amp;stopWatch)
{
    this-&gt;_init(&amp;stopWatch);
    return (*this);
}

</t>
<t tx="leo.20201108101532.62">void RStopWatch::reset(void)
{
    this-&gt;startTime = QDateTime::currentMSecsSinceEpoch();
    this-&gt;pauseTime = this-&gt;startTime;
}

</t>
<t tx="leo.20201108101532.63">void RStopWatch::pause(void)
{
    this-&gt;pauseTime = QDateTime::currentMSecsSinceEpoch();
}

</t>
<t tx="leo.20201108101532.64">void RStopWatch::resume(void)
{
    this-&gt;startTime += QDateTime::currentMSecsSinceEpoch() - this-&gt;pauseTime;
}

qint64 RStopWatch::getMiliSeconds(void) const
{
    return QDateTime::currentMSecsSinceEpoch() - this-&gt;startTime;
}

</t>
<t tx="leo.20201108101532.65">void RStopWatch::addElapsedTime(qint64 elapsedTime)
{
    this-&gt;startTime -= elapsedTime;
}

</t>
<t tx="leo.20201108101532.66">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_utils.cpp                                            *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th September 2012                                     *
 *                                                                   *
 *  DESCRIPTION: Utility functions                                   *
 *********************************************************************/

#include "rbl_utils.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.67">static float storeFloat(float value)
{
    return value;
}

</t>
<t tx="leo.20201108101532.68">static double storeDouble(double value)
{
    return value;
}


</t>
<t tx="leo.20201108101532.69">float RConstants::findMachineFloatEpsilon(void)
{
    float x = 1.0f;
    while (storeFloat(1.0f + x/2.0f) != 1.0f)
    {
        x /= 2.0f;
    }
    return x;
}

double RConstants::findMachineDoubleEpsilon(void)
{
    double x = 1.0;
    while (storeDouble(1.0 + x/2.0) != 1.0)
    {
        x /= 2.0;
    }
    return x;
}
</t>
<t tx="leo.20201108101532.7">void RProgress::setProgressFinalizeHandler (RProgressFinalizeHandler progressFinalizeHandler)
{
    this-&gt;progressFinalizeHandler = progressFinalizeHandler;
} /* RProgress::setProgressFinalizeHandler */


</t>
<t tx="leo.20201108101532.70">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_uvector.cpp                                          *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th January 2014                                        *
 *                                                                   *
 *  DESCRIPTION: Unsigned integer vector class definition            *
 *********************************************************************/

#include &lt;algorithm&gt;

#include "rbl_uvector.h"
#include "rbl_error.h"
#include "rbl_logger.h"


RUVector::RUVector (unsigned int nRows, unsigned int value)
{
    this-&gt;resize(nRows,value);
    this-&gt;_init();
} /* RUVector::RUVector */


RUVector::RUVector (const RUVector &amp;array) : std::vector&lt;unsigned int&gt;(array)
{
    this-&gt;_init(&amp;array);
} /* RUVector::RUVector (copy) */


RUVector::~RUVector ()
{
} /* RUVector::~RUVector */


RUVector &amp; RUVector::operator = (const RUVector &amp;array)
{
    this-&gt;std::vector&lt;unsigned int&gt;::operator = (array);
    this-&gt;_init(&amp;array);
    return (*this);
} /* RUVector::operator = */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.71">void RUVector::_init(const RUVector *pArray)
{
    if (pArray)
    {
    }
} /* RUVector::_init */


</t>
<t tx="leo.20201108101532.72">unsigned int &amp; RUVector::operator [] (unsigned int n)
{
    R_ERROR_ASSERT(n&lt;this-&gt;getNRows());

    return this-&gt;at(n);
} /* RUVector::operator [] */


</t>
<t tx="leo.20201108101532.73">const unsigned int &amp; RUVector::operator [] (unsigned int n) const
{
    R_ERROR_ASSERT(n&lt;this-&gt;getNRows());

    return this-&gt;at(n);
} /* RUVector::operator [] */

</t>
<t tx="leo.20201108101532.74">void RUVector::fill(unsigned int value)
{
    std::fill(this-&gt;begin(),this-&gt;end(),value);
}

</t>
<t tx="leo.20201108101532.75">void RUVector::print(bool oneLine, bool newLine) const
{
    if (!oneLine)
    {
        RLogger::info("Vector - unsigned int: [%u]\n",this-&gt;size());
    }
    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        RLogger::info("%15u",this-&gt;at(i));
        if (!oneLine)
        {
            RLogger::info("\n");
        }
    }
    if (newLine)
    {
        RLogger::info("\n");
    }
} /* RUVector::fill */
</t>
<t tx="leo.20201108101532.76">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_value.cpp                                            *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   10-th February 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Value class definition                              *
 *********************************************************************/

#include "rbl_value.h"


@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.77">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_value_table.cpp                                      *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Value table class definition                        *
 *********************************************************************/

#include &lt;string&gt;
#include &lt;map&gt;

#include "rbl_value_table.h"
#include "rbl_error.h"
#include "rbl_utils.h"


RValueTable::RValueTable ()
{
    this-&gt;_init ();
} /* RValueTable::RValueTable */


RValueTable::RValueTable (const RValueTable &amp;valueTable)
{
    this-&gt;_init (&amp;valueTable);
} /* RValueTable::RValueTable (copy) */


RValueTable::~RValueTable ()
{
} /* RValueTable::~RValueTable */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.78">void RValueTable::_init (const RValueTable *pValueTable)
{
    if (pValueTable)
    {
        this-&gt;setKeyName (pValueTable-&gt;getKeyName());
        this-&gt;setKeyUnits (pValueTable-&gt;getKeyUnits());
        this-&gt;setValueName (pValueTable-&gt;getValueName());
        this-&gt;setValueUnits (pValueTable-&gt;getValueUnits());
        this-&gt;clear();
        for (unsigned int i=0;i&lt;pValueTable-&gt;size();i++)
        {
            this-&gt;add (pValueTable-&gt;getKey(i),
                       pValueTable-&gt;getValue(i));
        }
    }
} /* RValueTable::_init */


</t>
<t tx="leo.20201108101532.79">const QString &amp;RValueTable::getKeyName(void) const
{
    return this-&gt;keyName;
} /* RValueTable::get_key_name */


</t>
<t tx="leo.20201108101532.8">void RProgress::initialize (const QString &amp;message,
                            bool           pulseType)
{
    this-&gt;pulseType = pulseType;
    this-&gt;lastFraction = 0.0;
    this-&gt;print(0.0);
    if (this-&gt;printToLog)
    {
        bool addNewLine = RLogger::getInstance().getAddNewLine();
        RLogger::getInstance().setAddNewLine(false);
        RLogger::getInstance().print(message + " ");
        RLogger::getInstance().setAddNewLine(addNewLine);
    }
    if (this-&gt;progressInitializeHandler)
    {
        this-&gt;progressInitializeHandler(message,this-&gt;pulseType);
    }
} /* RProgress::initialize */


</t>
<t tx="leo.20201108101532.80">void RValueTable::setKeyName (const QString &amp;name)
{
    this-&gt;keyName = name;
} /* RValueTable::set_key_name */


</t>
<t tx="leo.20201108101532.81">const QString &amp;RValueTable::getKeyUnits(void) const
{
    return this-&gt;keyUnits;
} /* RValueTable::get_key_units */


</t>
<t tx="leo.20201108101532.82">void RValueTable::setKeyUnits (const QString &amp;units)
{
    this-&gt;keyUnits = units;
} /* RValueTable::set_key_units */


</t>
<t tx="leo.20201108101532.83">const QString &amp; RValueTable::getValueName (void) const
{
    return this-&gt;valueName;
} /* RValueTable::get_value_name */


</t>
<t tx="leo.20201108101532.84">void RValueTable::setValueName (const QString &amp;name)
{
    this-&gt;valueName = name;
} /* RValueTable::set_value_name */


</t>
<t tx="leo.20201108101532.85">const QString &amp;RValueTable::getValueUnits(void) const
{
    return this-&gt;valueUnits;
} /* RValueTable::get_value_units */


</t>
<t tx="leo.20201108101532.86">void RValueTable::setValueUnits (const QString &amp;units)
{
    this-&gt;valueUnits = units;
} /* RValueTable::set_value_units */


</t>
<t tx="leo.20201108101532.87">unsigned int RValueTable::size (void) const
{
    return (unsigned int)this-&gt;table.size();
} /* RValueTable::size */


</t>
<t tx="leo.20201108101532.88">void RValueTable::add (double key,
                       double value)
{
    this-&gt;table[key] = value;
} /* RValueTable::add */


</t>
<t tx="leo.20201108101532.89">void RValueTable::remove (double key)
{
    R_ERROR_ASSERT (this-&gt;table.find (key) != this-&gt;table.end());

    this-&gt;table.erase (key);
} /* RValueTable::remove */


</t>
<t tx="leo.20201108101532.9">void RProgress::finalize (const QString &amp;message)
{
    this-&gt;print(1.0);
    if (this-&gt;printToLog)
    {
        bool addNewLine = RLogger::getInstance().getAddNewLine();
        RLogger::getInstance().setAddNewLine(false);
        RLogger::getInstance().print(" " + message + "\n");
        RLogger::getInstance().setAddNewLine(addNewLine);
    }
    if (this-&gt;progressFinalizeHandler)
    {
        this-&gt;progressFinalizeHandler(message);
    }
} /* RProgress::finalize */


</t>
<t tx="leo.20201108101532.90">void RValueTable::remove (unsigned int position)
{
    std::map&lt;double,double&gt;::iterator iter = this-&gt;table.begin();
    R_ERROR_ASSERT (position &lt; this-&gt;size());

    std::advance (iter, position);
    this-&gt;table.erase (iter);
} /* RValueTable::remove */


double RValueTable::get (double key) const
{
    double value = 0.0;
    double ratio = 0.0;
    double dKey = 0.0;
    double k1, k2;
    double v1, v2;
    std::map&lt;double,double&gt;::const_iterator iter;

    iter = this-&gt;table.lower_bound (key);
    k2 = iter-&gt;first;
    v2 = iter-&gt;second;

    if (iter == this-&gt;table.begin())
    {
        k1 = k2;
        v1 = v2;
    }
    else
    {
        bool isLast = false;
        if (iter == this-&gt;table.end())
        {
           isLast = true; 
        }
        std::advance (iter, -1);
        k1 = iter-&gt;first;
        v1 = iter-&gt;second;
        if (isLast)
        {
            k2 = k1;
            v2 = v1;
        }
    }

    dKey = k2 - k1;
    if (dKey == 0.0)
    {
        ratio = 0.0;
    }
    else
    {
        ratio = (key  - k1) / dKey;
    }
    value = ratio * (v2 - v1) + v1;

    return value;
} /* RValueTable::get */


double RValueTable::getKey (unsigned int position) const
{
    R_ERROR_ASSERT(position &lt; this-&gt;table.size());
    std::map&lt;double,double&gt;::const_iterator iter = this-&gt;table.begin();
    std::advance (iter, position);
    return iter-&gt;first;
} /* RValueTable::get_key */


double RValueTable::getValue (unsigned int position) const
{
    R_ERROR_ASSERT(position &lt; this-&gt;table.size());
    std::map&lt;double,double&gt;::const_iterator iter = this-&gt;table.begin();
    std::advance (iter, position);
    return iter-&gt;second;
} /* RValueTable::get_key */


RValueTable &amp; RValueTable::operator = (const RValueTable &amp;valueTable)
{
    this-&gt;_init (&amp;valueTable);
    return (*this);
} /* RValueTable::operator = */


</t>
<t tx="leo.20201108101532.91">bool RValueTable::operator ==(const RValueTable &amp;valueTable) const
{
    if (this-&gt;table.size() != valueTable.size())
    {
        return false;
    }
    if (this-&gt;keyName != valueTable.keyName)
    {
        return false;
    }
    if (this-&gt;keyUnits != valueTable.keyUnits)
    {
        return false;
    }
    if (this-&gt;valueName != valueTable.valueName)
    {
        return false;
    }
    if (this-&gt;valueUnits != valueTable.valueUnits)
    {
        return false;
    }
    for (unsigned int i=0;i&lt;this-&gt;table.size();i++)
    {
        if (std::abs((this-&gt;getKey(i) - valueTable.getKey(i)) / this-&gt;getKey(i)) &gt; RConstants::eps)
        {
            return false;
        }
        if (std::abs((this-&gt;getValue(i) - valueTable.getValue(i)) / this-&gt;getValue(i)) &gt; RConstants::eps)
        {
            return false;
        }
    }
    return true;
} /* RValueTable::operator == */


</t>
<t tx="leo.20201108101532.92">bool RValueTable::operator !=(const RValueTable &amp;valueTable) const
{
    return !(this-&gt;operator ==(valueTable));
} /* RValueTable::operator != */
</t>
<t tx="leo.20201108101532.93">@path ./RangeBase/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_value_vector.cpp                                     *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Value vector class definition                       *
 *********************************************************************/

#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

#include "rbl_value_vector.h"
#include "rbl_error.h"
#include "rbl_utils.h"

RValueVector::RValueVector ()
{
    this-&gt;_init ();
} /* RValueVector::RValueVector */


RValueVector::RValueVector (const RValueVector &amp;valueVector)
{
    this-&gt;_init (&amp;valueVector);
} /* RValueVector::RValueVector (copy) */


RValueVector::~RValueVector ()
{
} /* RValueVector::~RValueVector */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101532.94">void RValueVector::_init (const RValueVector *valueVector)
{
    if (valueVector)
    {
        this-&gt;setName (valueVector-&gt;getName());
        this-&gt;setUnits (valueVector-&gt;getUnits());
        this-&gt;resize (valueVector-&gt;size());
        for (unsigned int i=0;i&lt;this-&gt;size();i++)
        {
            (*this)[i] = (*valueVector)[i];
        }
    }
} /* RValueVector::_init */


</t>
<t tx="leo.20201108101532.95">const QString &amp;RValueVector::getName(void) const
{
    return this-&gt;name;
} /* RValueVector::get_name */


</t>
<t tx="leo.20201108101532.96">void RValueVector::setName (const QString &amp;name)
{
    this-&gt;name = name;
} /* RValueVector::set_name */


</t>
<t tx="leo.20201108101532.97">const QString &amp;RValueVector::getUnits(void) const
{
    return this-&gt;units;
} /* RValueVector::get_units */


</t>
<t tx="leo.20201108101532.98">void RValueVector::setUnits (const QString &amp;units)
{
    this-&gt;units = units;
} /* RValueVector::set_units */


</t>
<t tx="leo.20201108101532.99">unsigned int RValueVector::size (void) const
{
    return (unsigned int)this-&gt;values.size();
} /* RValueVector::size */


</t>
<t tx="leo.20201108101533.1"></t>
<t tx="leo.20201108101533.10">bool RBoundaryCondition::getHasLocalDirection() const
{
    return this-&gt;hasLocalDirection;
} /* RBoundaryCondition::getHasLocalDirection */

</t>
<t tx="leo.20201108101533.100">bool RElement::nodeIsOnEdge(uint nodePosition, uint edgePosition) const
{
    switch (this-&gt;type)
    {
        case R_ELEMENT_TRUSS1:
        {
            return ((nodePosition == 0 &amp;&amp; edgePosition == 0)
                    ||
                    (nodePosition == 1 &amp;&amp; edgePosition == 1));
        }
        case R_ELEMENT_TRI1:
        {
            return (((nodePosition == 0 || nodePosition == 1) &amp;&amp; edgePosition == 0)
                    ||
                    ((nodePosition == 1 || nodePosition == 2) &amp;&amp; edgePosition == 1)
                    ||
                    ((nodePosition == 2 || nodePosition == 0) &amp;&amp; edgePosition == 2));
        }
        case R_ELEMENT_QUAD1:
        {
            return (((nodePosition == 0 || nodePosition == 1) &amp;&amp; edgePosition == 0)
                    ||
                    ((nodePosition == 1 || nodePosition == 2) &amp;&amp; edgePosition == 1)
                    ||
                    ((nodePosition == 2 || nodePosition == 3) &amp;&amp; edgePosition == 2)
                    ||
                    ((nodePosition == 3 || nodePosition == 0) &amp;&amp; edgePosition == 3));
        }
        case R_ELEMENT_TETRA1:
        {
            return (((nodePosition == 1 || nodePosition == 3 || nodePosition == 2) &amp;&amp; edgePosition == 0)
                    ||
                    ((nodePosition == 0 || nodePosition == 2 || nodePosition == 3) &amp;&amp; edgePosition == 1)
                    ||
                    ((nodePosition == 0 || nodePosition == 3 || nodePosition == 1) &amp;&amp; edgePosition == 2)
                    ||
                    ((nodePosition == 0 || nodePosition == 1 || nodePosition == 2) &amp;&amp; edgePosition == 3));
        }
        default:
        {
            return false;
        }
    }
} /* RElement::nodeIsOnEdge */


</t>
<t tx="leo.20201108101533.101">bool RElement::mergeNodes(uint nodeId1, uint nodeId2, bool allowDowngrade)
{
    bool nodeMerged = false;

    for (int i=int(this-&gt;size())-1;i&gt;=0;i--)
    {
        if (this-&gt;getNodeId(uint(i)) == nodeId2)
        {
            this-&gt;setNodeId(uint(i),nodeId1);
            nodeMerged = true;
        }
    }
    if (!allowDowngrade || !nodeMerged)
    {
        return false;
    }

    std::vector&lt;uint&gt; nids;
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        if (std::find(nids.begin(),nids.end(),this-&gt;getNodeId(i)) == nids.end())
        {
            nids.push_back(this-&gt;getNodeId(i));
        }
    }

    if (nids.size() == this-&gt;size())
    {
        return false;
    }

    switch (this-&gt;type)
    {
        case R_ELEMENT_BEAM1:
        case R_ELEMENT_TRUSS1:
        {
            this-&gt;setType(R_ELEMENT_POINT);
            this-&gt;nodeIDs.resize(1);
            this-&gt;setNodeId(0,nids[0]);
            return true;
        }
        case R_ELEMENT_TRI1:
        {
            this-&gt;setType(R_ELEMENT_TRUSS1);
            this-&gt;nodeIDs.resize(2);
            this-&gt;setNodeId(0,nids[0]);
            this-&gt;setNodeId(1,nids[1]);
            return true;
        }
        case R_ELEMENT_QUAD1:
        {
            this-&gt;setType(R_ELEMENT_TRI1);
            this-&gt;nodeIDs.resize(3);
            this-&gt;setNodeId(0,nids[0]);
            this-&gt;setNodeId(1,nids[1]);
            this-&gt;setNodeId(2,nids[2]);
            return true;
        }
        case R_ELEMENT_TETRA1:
        {
            this-&gt;setType(R_ELEMENT_TRI1);
            this-&gt;nodeIDs.resize(3);
            this-&gt;setNodeId(0,nids[0]);
            this-&gt;setNodeId(1,nids[1]);
            this-&gt;setNodeId(2,nids[2]);
            return true;
        }
        default:
        {
            return false;
        }
    }
} /* RElement::mergeNodes */


</t>
<t tx="leo.20201108101533.102">void RElement::breakWithNodes(const std::vector&lt;RNode&gt; &amp;nodes, const std::vector&lt;uint&gt; breakNodeIDs, std::vector&lt;RElement&gt; &amp;newElements)
{
    if (R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getType()))
    {
        RRMatrix R;
        RRVector t;
        RRMatrix rotatedNodes;
        try
        {
            rotatedNodes = this-&gt;findTransformationMatrix(nodes,R,t);
            R.invert();
        }
        catch (const RError &amp;rError)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to find rotation matrix. %s",rError.getMessage().toUtf8().constData());
        }

        std::vector&lt;RNode&gt; tNodes;
        std::vector&lt;uint&gt; nodeBook;
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            double x = rotatedNodes[i][0];
            double y = rotatedNodes[i][1];
            tNodes.push_back(RNode(x,y,0.0));
            nodeBook.push_back(this-&gt;getNodeId(i));
        }

        for (uint i=0;i&lt;breakNodeIDs.size();i++)
        {
            tNodes.push_back(nodes[breakNodeIDs[i]]);
            RNode &amp;rNode = tNodes.at(tNodes.size()-1);
            rNode.transform(R);
            rNode.setZ(0.0);
            nodeBook.push_back(breakNodeIDs[i]);
        }

        std::vector&lt;RElement&gt; elements = RTriangulateNodes(tNodes,true,RConstants::eps);

        bool firstAssigned = false;
        for (uint i=0;i&lt;elements.size();i++)
        {
            if (!firstAssigned)
            {
                this-&gt;operator =(elements[i]);
                for (uint j=0;j&lt;this-&gt;size();j++)
                {
                    this-&gt;setNodeId(j,nodeBook[this-&gt;getNodeId(j)]);
                }
                firstAssigned = true;
            }
            else
            {
                newElements.push_back(elements[i]);
                RElement &amp;rElement = newElements.at(newElements.size()-1);
                for (uint j=0;j&lt;rElement.size();j++)
                {
                    rElement.setNodeId(j,nodeBook[rElement.getNodeId(j)]);
                }
            }
        }
    }
    else
    {
        std::vector&lt;RElement&gt; tmpElements;
        tmpElements.push_back(*this);

        for (uint i=0;i&lt;breakNodeIDs.size();i++)
        {
            for (uint j=0;j&lt;tmpElements.size();j++)
            {
                tmpElements[j].breakWithNode(nodes,breakNodeIDs[i],tmpElements);
            }
        }

        if (tmpElements.size() &gt; 0)
        {
            (*this) = tmpElements[0];
            tmpElements.erase(tmpElements.begin());
        }
        for (uint i=0;i&lt;tmpElements.size();i++)
        {
            newElements.push_back(tmpElements[i]);
        }
    }
} /* RElement::breakWithPoints */


</t>
<t tx="leo.20201108101533.103">void RElement::breakWithNode(const std::vector&lt;RNode&gt; &amp;nodes, uint breakNodeID, std::vector&lt;RElement&gt; &amp;newElements)
{
    const RNode &amp;node = nodes[breakNodeID];
    std::vector&lt;RElement&gt; tmpElements;

//    double tolerance = RConstants::eps;
//    double tolerance = 0.0;
    double tolerance = RConstants::findMachineDoubleEpsilon();

    switch (this-&gt;getType())
    {
        case R_ELEMENT_BEAM1:
        case R_ELEMENT_TRUSS1:
        {
            uint n1 = this-&gt;getNodeId(0);
            uint n2 = this-&gt;getNodeId(1);
            RSegment s(nodes[n1],nodes[n2]);
            if (s.isPointInside(node.toVector(),false))
            {
                RElement e1(R_ELEMENT_TRUSS1);
                e1.setNodeId(0,breakNodeID);
                e1.setNodeId(1,n2);
                tmpElements.push_back(e1);
                RElement e2(R_ELEMENT_TRUSS1);
                e2.setNodeId(0,n1);
                e2.setNodeId(1,breakNodeID);
                tmpElements.push_back(e2);
            }
            break;
        }
        case R_ELEMENT_TRI1:
        {
            uint n1 = this-&gt;getNodeId(0);
            uint n2 = this-&gt;getNodeId(1);
            uint n3 = this-&gt;getNodeId(2);
            RTriangle t(nodes[n1],nodes[n2],nodes[n3]);
            if (t.isPointInside(node.toVector(),false))
            {
                if (RTriangle::findArea(nodes[n1],nodes[n2],node) &gt; tolerance)
                {
                    RElement e(R_ELEMENT_TRI1);
                    e.setNodeId(0,n1);
                    e.setNodeId(1,n2);
                    e.setNodeId(2,breakNodeID);
                    tmpElements.push_back(e);
                }
                if (RTriangle::findArea(nodes[n2],nodes[n3],node) &gt; tolerance)
                {
                    RElement e(R_ELEMENT_TRI1);
                    e.setNodeId(0,n2);
                    e.setNodeId(1,n3);
                    e.setNodeId(2,breakNodeID);
                    tmpElements.push_back(e);
                }
                if (RTriangle::findArea(nodes[n3],nodes[n1],node) &gt; tolerance)
                {
                    RElement e(R_ELEMENT_TRI1);
                    e.setNodeId(0,n3);
                    e.setNodeId(1,n1);
                    e.setNodeId(2,breakNodeID);
                    tmpElements.push_back(e);
                }
            }
            break;
        }
        case R_ELEMENT_QUAD1:
        {
            uint n1 = this-&gt;getNodeId(0);
            uint n2 = this-&gt;getNodeId(1);
            uint n3 = this-&gt;getNodeId(2);
            uint n4 = this-&gt;getNodeId(3);
            RTriangle t1(nodes[n1],nodes[n2],nodes[n3]);
            RTriangle t2(nodes[n1],nodes[n3],nodes[n4]);
            if (t1.isPointInside(node.toVector(),false) || t2.isPointInside(node.toVector(),false))
            {
                if (RTriangle::findArea(nodes[n1],nodes[n2],node) &gt; tolerance)
                {
                    RElement e(R_ELEMENT_TRI1);
                    e.setNodeId(0,n1);
                    e.setNodeId(1,n2);
                    e.setNodeId(2,breakNodeID);
                    tmpElements.push_back(e);
                }
                if (RTriangle::findArea(nodes[n2],nodes[n3],node) &gt; tolerance)
                {
                    RElement e(R_ELEMENT_TRI1);
                    e.setNodeId(0,n2);
                    e.setNodeId(1,n3);
                    e.setNodeId(2,breakNodeID);
                    tmpElements.push_back(e);
                }
                if (RTriangle::findArea(nodes[n3],nodes[n4],node) &gt; tolerance)
                {
                    RElement e(R_ELEMENT_TRI1);
                    e.setNodeId(0,n3);
                    e.setNodeId(1,n4);
                    e.setNodeId(2,breakNodeID);
                    tmpElements.push_back(e);
                }
                if (RTriangle::findArea(nodes[n4],nodes[n1],node) &gt; tolerance)
                {
                    RElement e(R_ELEMENT_TRI1);
                    e.setNodeId(0,n4);
                    e.setNodeId(1,n1);
                    e.setNodeId(2,breakNodeID);
                    tmpElements.push_back(e);
                }
            }
            break;
        }
        default:
        {
            // Unsupported element.
            break;
        }
    }

    if (tmpElements.size() &gt; 0)
    {
        (*this) = tmpElements[0];
        tmpElements.erase(tmpElements.begin());
    }
    for (uint i=0;i&lt;tmpElements.size();i++)
    {
        newElements.push_back(tmpElements[i]);
    }
} /* RElement::breakWithNode */


</t>
<t tx="leo.20201108101533.104">void RElement::findLimitBox(const std::vector&lt;RNode&gt; &amp;nodes, RLimitBox &amp;limitBox) const
{
    double xmin = 0.0, xmax = 0.0;
    double ymin = 0.0, ymax = 0.0;
    double zmin = 0.0, zmax = 0.0;

    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        const RNode &amp;rNode = nodes[this-&gt;getNodeId(i)];
        if (i == 0)
        {
            xmin = xmax = rNode.getX();
            ymin = ymax = rNode.getY();
            zmin = zmax = rNode.getZ();
        }
        else
        {
            xmin = std::min(xmin,rNode.getX());
            xmax = std::max(xmax,rNode.getX());

            ymin = std::min(ymin,rNode.getY());
            ymax = std::max(ymax,rNode.getY());

            zmin = std::min(zmin,rNode.getZ());
            zmax = std::max(zmax,rNode.getZ());
        }
    }

    limitBox.setLimits(xmin,xmax,ymin,ymax,zmin,zmax);
} /* RElement::findLimitBox */

</t>
<t tx="leo.20201108101533.105">void RElement::findScalarNodeValues(uint elementID, const RVariable &amp;rVariable, std::vector&lt;double&gt; &amp;values) const
{
    values.resize(this-&gt;size());

    double minValue = rVariable.getVariableData().getMinDisplayValue();
    double maxValue = rVariable.getVariableData().getMaxDisplayValue();

    if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            values[i] = rVariable.getValue(this-&gt;getNodeId(i));
        }
    }
    else if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            values[i] = rVariable.getValue(elementID);
        }
    }

    for (uint i=0;i&lt;values.size();i++)
    {
        values[i] = (values[i] - minValue) / (maxValue - minValue);

        values[i] = std::min(values[i],0.99);
        values[i] = std::max(values[i],0.01);
    }
} /* RElement::findScalarNodeValues */

</t>
<t tx="leo.20201108101533.106">void RElement::findDisplacementNodeValues(uint elementID, const RVariable &amp;rVariable, std::vector&lt;RR3Vector&gt; &amp;values) const
{
    values.resize(this-&gt;size());

    if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            values[i][0] = rVariable.getValue(0,this-&gt;getNodeId(i));
            values[i][1] = rVariable.getValue(1,this-&gt;getNodeId(i));
            values[i][2] = rVariable.getValue(2,this-&gt;getNodeId(i));
        }
    }
    else if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            values[i][0] = rVariable.getValue(0,elementID);
            values[i][1] = rVariable.getValue(1,elementID);
            values[i][2] = rVariable.getValue(2,elementID);
        }
    }

    double scale = rVariable.getVariableData().getScale();

    for (uint i=0;i&lt;values.size();i++)
    {
        values[i] *= scale;
    }
} /* RElement::findDisplacementNodeValues */

</t>
<t tx="leo.20201108101533.107">void RElement::print(const std::vector&lt;RNode&gt; &amp;nodes) const
{
    RLogger::info("Name: %s\n",RElement::getName(this-&gt;getType()).toUtf8().constData());
    RLogger::info("Nodes:\n");
    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        RLogger::info("  % 9u:",this-&gt;getNodeId(i));
        nodes[this-&gt;getNodeId(i)].print();
    }
} /* RElement::print */

</t>
<t tx="leo.20201108101533.108">void RElement::print(void) const
{
    RLogger::info("Name: %s\n",RElement::getName(this-&gt;getType()).toUtf8().constData());
    RLogger::info("Nodes:");
    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        RLogger::info(" % 9u",this-&gt;getNodeId(i));
    }
    RLogger::info("\n");
} /* RElement::print */


RElementType RElement::getTypeFromId(const QString &amp;elementId)
{
    for (uint type=uint(R_ELEMENT_NONE);type&lt;uint(R_ELEMENT_N_TYPES);type++)
    {
        if (elementDesc[type].id == elementId)
        {
            return RElementType(type);
        }
    }

    return R_ELEMENT_NONE;
} /* RElement::getTypeFromId */


QString RElement::getId(RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));

    return elementDesc[type].id;
} /* RElement::getId */


</t>
<t tx="leo.20201108101533.109">const QString &amp;RElement::getName(RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));

    return elementDesc[type].name;
} /* RElement::getName */


</t>
<t tx="leo.20201108101533.11">const RR3Vector &amp;RBoundaryCondition::getLocalDirection() const
{
    return this-&gt;direction;
} /* RBoundaryCondition::getLocalDirection */


</t>
<t tx="leo.20201108101533.110">unsigned int RElement::getNNodes(RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));

    return elementDesc[type].nNodes;
} /* RElement::getNNodes */


</t>
<t tx="leo.20201108101533.111">unsigned int RElement::getNNeighbors(RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));

    return elementDesc[type].nNeighbors;
} /* RElement::getNNeighbors */


std::vector&lt;RElementShapeFunction&gt; RElement::generateShapeFunctionValues(RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));

    std::vector&lt;RElementShapeFunction&gt; shapeFunctions;
    RRVector N;
    RRMatrix dN;
    double ksi, eta, zeta;

    switch (type)
    {
        case R_ELEMENT_POINT:
            break;
        case R_ELEMENT_TRUSS1:
            N.resize(2);
            dN.resize(2,1);
            // Derivated shape function
            dN[0][0] = -0.5;
            dN[1][0] =  0.5;
            // 1-st point
            ksi = -1.0/std::sqrt(3.0);
            N[0] = (1.0 - ksi)/2.0;
            N[1] = (1.0 + ksi)/2.0;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0));
            // 2-nd point
            ksi = 1.0/std::sqrt(3.0);
            N[0] = (1.0 - ksi)/2.0;
            N[1] = (1.0 + ksi)/2.0;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0));
            break;
        case R_ELEMENT_TRUSS2:
            break;
        case R_ELEMENT_BEAM1:
            break;
        case R_ELEMENT_BEAM2:
            break;
        case R_ELEMENT_TRI1:
            N.resize(3);
            dN.resize(3,2);
            // Derivated shape function
            dN[0][0] = -1.0;
            dN[1][0] =  1.0;
            dN[2][0] =  0.0;
            dN[0][1] = -1.0;
            dN[1][1] =  0.0;
            dN[2][1] =  1.0;
            // 1-st point
            ksi = 1.0/6.0;
            eta = 1.0/6.0;
            N[0] = 1.0 - ksi - eta;
            N[1] = ksi;
            N[2] = eta;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0/6.0));
            // 2-nd point
            ksi = 2.0/3.0;
            eta = 1.0/6.0;
            N[0] = 1.0 - ksi - eta;
            N[1] = ksi;
            N[2] = eta;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0/6.0));
            // 3-rd point
            ksi = 1.0/6.0;
            eta = 2.0/3.0;
            N[0] = 1.0 - ksi - eta;
            N[1] = ksi;
            N[2] = eta;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0/6.0));
            break;
        case R_ELEMENT_TRI2:
            break;
        case R_ELEMENT_QUAD1:
            N.resize(4);
            dN.resize(4,2);
            // 1-st point
            ksi = -1.0/std::sqrt(3.0);
            eta = -1.0/std::sqrt(3.0);
            N[0] = (1.0-ksi)*(1.0-eta)/4.0;
            N[1] = (1.0+ksi)*(1.0-eta)/4.0;
            N[2] = (1.0+ksi)*(1.0+eta)/4.0;
            N[3] = (1.0-ksi)*(1.0+eta)/4.0;
            dN[0][0] = (-1)*(1.0-eta)/4.0;
            dN[1][0] =      (1.0-eta)/4.0;
            dN[2][0] =      (1.0+eta)/4.0;
            dN[3][0] = (-1)*(1.0+eta)/4.0;
            dN[0][1] = (-1)*(1.0-ksi)/4.0;
            dN[1][1] = (-1)*(1.0+ksi)/4.0;
            dN[2][1] =      (1.0+ksi)/4.0;
            dN[3][1] =      (1.0-ksi)/4.0;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0));
            // 2-nd point
            ksi =  1.0/std::sqrt(3.0);
            eta = -1.0/std::sqrt(3.0);
            N[0] = (1.0-ksi)*(1.0-eta)/4.0;
            N[1] = (1.0+ksi)*(1.0-eta)/4.0;
            N[2] = (1.0+ksi)*(1.0+eta)/4.0;
            N[3] = (1.0-ksi)*(1.0+eta)/4.0;
            dN[0][0] = (-1)*(1.0-eta)/4.0;
            dN[1][0] =      (1.0-eta)/4.0;
            dN[2][0] =      (1.0+eta)/4.0;
            dN[3][0] = (-1)*(1.0+eta)/4.0;
            dN[0][1] = (-1)*(1.0-ksi)/4.0;
            dN[1][1] = (-1)*(1.0+ksi)/4.0;
            dN[2][1] =      (1.0+ksi)/4.0;
            dN[3][1] =      (1.0-ksi)/4.0;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0));
            // 3-rd point
            ksi = 1.0/std::sqrt(3.0);
            eta = 1.0/std::sqrt(3.0);
            N[0] = (1.0-ksi)*(1.0-eta)/4.0;
            N[1] = (1.0+ksi)*(1.0-eta)/4.0;
            N[2] = (1.0+ksi)*(1.0+eta)/4.0;
            N[3] = (1.0-ksi)*(1.0+eta)/4.0;
            dN[0][0] = (-1)*(1.0-eta)/4.0;
            dN[1][0] =      (1.0-eta)/4.0;
            dN[2][0] =      (1.0+eta)/4.0;
            dN[3][0] = (-1)*(1.0+eta)/4.0;
            dN[0][1] = (-1)*(1.0-ksi)/4.0;
            dN[1][1] = (-1)*(1.0+ksi)/4.0;
            dN[2][1] =      (1.0+ksi)/4.0;
            dN[3][1] =      (1.0-ksi)/4.0;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0));
            // 4-th point
            ksi = -1.0/std::sqrt(3.0);
            eta =  1.0/std::sqrt(3.0);
            N[0] = (1.0-ksi)*(1.0-eta)/4.0;
            N[1] = (1.0+ksi)*(1.0-eta)/4.0;
            N[2] = (1.0+ksi)*(1.0+eta)/4.0;
            N[3] = (1.0-ksi)*(1.0+eta)/4.0;
            dN[0][0] = (-1)*(1.0-eta)/4.0;
            dN[1][0] =      (1.0-eta)/4.0;
            dN[2][0] =      (1.0+eta)/4.0;
            dN[3][0] = (-1)*(1.0+eta)/4.0;
            dN[0][1] = (-1)*(1.0-ksi)/4.0;
            dN[1][1] = (-1)*(1.0+ksi)/4.0;
            dN[2][1] =      (1.0+ksi)/4.0;
            dN[3][1] =      (1.0-ksi)/4.0;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0));
            break;
        case R_ELEMENT_QUAD2:
            break;
        case R_ELEMENT_TETRA1:
            N.resize(4);
            dN.resize(4,3);
            // Derivated shape function
            dN[0][0] = -1.0;
            dN[1][0] =  1.0;
            dN[2][0] =  0.0;
            dN[3][0] =  0.0;
            dN[0][1] = -1.0;
            dN[1][1] =  0.0;
            dN[2][1] =  1.0;
            dN[3][1] =  0.0;
            dN[0][2] = -1.0;
            dN[1][2] =  0.0;
            dN[2][2] =  0.0;
            dN[3][2] =  1.0;
            // 1-st point
            ksi = 0.1381966;
            eta = 0.1381966;
            zeta = 0.1381966;
            N[0] = 1.0 - ksi - eta - zeta;
            N[1] = ksi;
            N[2] = eta;
            N[3] = zeta;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0/24.0));
            // 2-st point
            ksi = 0.5854102;
            eta = 0.1381966;
            zeta = 0.1381966;
            N[0] = 1.0 - ksi - eta - zeta;
            N[1] = ksi;
            N[2] = eta;
            N[3] = zeta;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0/24.0));
            // 3-st point
            ksi = 0.1381966;
            eta = 0.5854102;
            zeta = 0.1381966;
            N[0] = 1.0 - ksi - eta - zeta;
            N[1] = ksi;
            N[2] = eta;
            N[3] = zeta;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0/24.0));
            // 4-st point
            ksi = 0.1381966;
            eta = 0.1381966;
            zeta = 0.5854102;
            N[0] = 1.0 - ksi - eta - zeta;
            N[1] = ksi;
            N[2] = eta;
            N[3] = zeta;
            shapeFunctions.push_back(RElementShapeFunction(N,dN,1.0/24.0));
            break;
        case R_ELEMENT_WEDGE1:
            break;
        case R_ELEMENT_HEXA1:
            break;
        case R_ELEMENT_NONE:
        default:
            break;
    }

    return shapeFunctions;
} /* RElement::generateShapeFunctionValues */


RRMatrix RElement::generateMassMatrix(RElementType type)
{
    RRMatrix M;

    std::vector&lt;RElementShapeFunction&gt; shapeFunctions = RElement::generateShapeFunctionValues(type);
    unsigned int nn = RElement::getNNodes(type);
    M.resize(nn,nn);
    for (unsigned int i=0;i&lt;shapeFunctions.size();i++)
    {
        const RRVector &amp;N = shapeFunctions[i].getN();
        double w = shapeFunctions[i].getW();

        for (unsigned int k=0;k&lt;nn;k++)
        {
            for (unsigned int l=0;l&lt;nn;l++)
            {
                M[k][l] += N[k]*N[l]*w;
            }
        }
    }

    return M;
} /* RElement::generateMassMatrix */


RRVector RElement::generateMassVector(RElementType type)
{
    RRVector m;

    std::vector&lt;RElementShapeFunction&gt; shapeFunctions = RElement::generateShapeFunctionValues(type);
    unsigned int nn = RElement::getNNodes(type);
    m.resize(nn);
    for (unsigned int i=0;i&lt;shapeFunctions.size();i++)
    {
        const RRVector &amp;N = shapeFunctions[i].getN();
        double w = shapeFunctions[i].getW();

        for (unsigned int k=0;k&lt;nn;k++)
        {
            m[k] += N[k]*w;
        }
    }

    return m;
} /* RElement::generateMassVector */

double RElement::generateTotalWeightFactor(RElementType type)
{
    double wt = 0.0;

    std::vector&lt;RElementShapeFunction&gt; shapeFunctions = RElement::generateShapeFunctionValues(type);
    for (unsigned int i=0;i&lt;shapeFunctions.size();i++)
    {
        wt += shapeFunctions[i].getW();
    }

    return wt;
} /* RElement::generateTotalWeightFactor */


</t>
<t tx="leo.20201108101533.112">unsigned int RElement::getNIntegrationPoints(RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));
    return static_cast&lt;unsigned int&gt;(elementDesc[type].shapeFunctions.size());
} /* RElement::getNIntegrationPoints */


</t>
<t tx="leo.20201108101533.113">const RElementShapeFunction &amp;RElement::getShapeFunction(RElementType type, unsigned int point)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));
    R_ERROR_ASSERT (point &lt; RElement::getNIntegrationPoints(type));
    return elementDesc[type].shapeFunctions[point];
} /* RElement::getShapeFunction */


</t>
<t tx="leo.20201108101533.114">const RRMatrix &amp;RElement::getMassMatrix(RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));
    return elementDesc[type].M;
} /* RElement::getMassMatrix */


</t>
<t tx="leo.20201108101533.115">const RRVector &amp;RElement::getMassVector(RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));
    return elementDesc[type].m;
} /* RElement::getMassVector */


double RElement::getTotalWeightFactor(RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));
    return elementDesc[type].wt;
} /* RElement::getMassVector */


</t>
<t tx="leo.20201108101533.116">bool RElement::hasConstantDerivative(RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID(type));
    return elementDesc[type].constantDerivative;
} /* RElement::getMassVector */


</t>
<t tx="leo.20201108101533.117">bool RElement::findIntersectionPoints(const RElement &amp;e1, const RElement &amp;e2, const std::vector&lt;RNode&gt; &amp;nodes, std::set&lt;RR3Vector&gt; &amp;x)
{
    std::vector&lt;RNode&gt; p1;
    std::vector&lt;RNode&gt; p2;
    std::vector&lt;RSegment&gt; s1;
    std::vector&lt;RSegment&gt; s2;
    std::vector&lt;RTriangle&gt; t1;
    std::vector&lt;RTriangle&gt; t2;

    double nodeScale = 1.0;

    double xmin = 0.0, xmax = 0.0;
    double ymin = 0.0, ymax = 0.0;
    double zmin = 0.0, zmax = 0.0;

    for (uint i=0;i&lt;e1.size();i++)
    {
        if (i==0)
        {
            xmin = xmax = nodes[e1.getNodeId(i)].getX();
            ymin = ymax = nodes[e1.getNodeId(i)].getY();
            zmin = zmax = nodes[e1.getNodeId(i)].getZ();
        }
        else
        {
            xmin = std::min(nodes[e1.getNodeId(i)].getX(),xmin);
            ymin = std::min(nodes[e1.getNodeId(i)].getY(),ymin);
            zmin = std::min(nodes[e1.getNodeId(i)].getZ(),zmin);

            xmax = std::max(nodes[e1.getNodeId(i)].getX(),xmax);
            ymax = std::max(nodes[e1.getNodeId(i)].getY(),ymax);
            zmax = std::max(nodes[e1.getNodeId(i)].getZ(),zmax);
        }
    }

    for (uint i=0;i&lt;e2.size();i++)
    {
        xmin = std::min(nodes[e2.getNodeId(i)].getX(),xmin);
        ymin = std::min(nodes[e2.getNodeId(i)].getY(),ymin);
        zmin = std::min(nodes[e2.getNodeId(i)].getZ(),zmin);

        xmax = std::max(nodes[e2.getNodeId(i)].getX(),xmax);
        ymax = std::max(nodes[e2.getNodeId(i)].getY(),ymax);
        zmax = std::max(nodes[e2.getNodeId(i)].getZ(),zmax);
    }


    nodeScale = std::sqrt(std::pow(xmax - xmin,2) + std::pow(ymax - ymin,2) + std::pow(zmax - zmin,2));
    if (nodeScale &lt;= RConstants::eps)
    {
        nodeScale = 1.0;
    }
    else
    {
        nodeScale = 1.0/nodeScale;
    }

    if (R_ELEMENT_TYPE_IS_POINT(e1.getType()))
    {
        p1.push_back(nodes[e1.getNodeId(0)]);
        p1.at(0).scale(nodeScale);
    }
    if (R_ELEMENT_TYPE_IS_POINT(e2.getType()))
    {
        p2.push_back(nodes[e2.getNodeId(0)]);
        p2.at(0).scale(nodeScale);
    }
    if (R_ELEMENT_TYPE_IS_LINE(e1.getType()))
    {
        s1 = e1.segmentize(nodes);
        for (uint i=0;i&lt;s1.size();i++)
        {
            s1.at(i).getNode1().scale(nodeScale);
            s1.at(i).getNode2().scale(nodeScale);
        }
    }
    if (R_ELEMENT_TYPE_IS_LINE(e2.getType()))
    {
        s2 = e2.segmentize(nodes);
        for (uint i=0;i&lt;s2.size();i++)
        {
            s2.at(i).getNode1().scale(nodeScale);
            s2.at(i).getNode2().scale(nodeScale);
        }
    }
    if (R_ELEMENT_TYPE_IS_SURFACE(e1.getType()))
    {
        t1 = e1.triangulate(nodes);
        for (uint i=0;i&lt;t1.size();i++)
        {
            t1.at(i).getNode1().scale(nodeScale);
            t1.at(i).getNode2().scale(nodeScale);
            t1.at(i).getNode3().scale(nodeScale);
        }
    }
    if (R_ELEMENT_TYPE_IS_SURFACE(e2.getType()))
    {
        t2 = e2.triangulate(nodes);
        for (uint i=0;i&lt;t2.size();i++)
        {
            t2.at(i).getNode1().scale(nodeScale);
            t2.at(i).getNode2().scale(nodeScale);
            t2.at(i).getNode3().scale(nodeScale);
        }
    }

    bool intersectionFound = false;

    std::set&lt;RR3Vector&gt; xTmp;

    // Segment-point intersection
    for (uint i=0;i&lt;s1.size();i++)
    {
        for (uint j=0;j&lt;p2.size();j++)
        {
            if (s1[i].findPointIntersection(p2[j],xTmp))
            {
                intersectionFound = true;
            }
        }
    }
    for (uint i=0;i&lt;s2.size();i++)
    {
        for (uint j=0;j&lt;p1.size();j++)
        {
            if (s2[i].findPointIntersection(p1[j],xTmp))
            {
                intersectionFound = true;
            }
        }
    }

    // Segment-segment intersection
    for (uint i=0;i&lt;s1.size();i++)
    {
        for (uint j=0;j&lt;s2.size();j++)
        {
            if (s1[i].findSegmentIntersection(s2[j],xTmp))
            {
                intersectionFound = true;
            }
        }
    }

    // Triangle-point intersection
    for (uint i=0;i&lt;t1.size();i++)
    {
        for (uint j=0;j&lt;p2.size();j++)
        {
            if (t1[i].findPointIntersection(p2[j],xTmp))
            {
                intersectionFound = true;
            }
        }
    }
    for (uint i=0;i&lt;t2.size();i++)
    {
        for (uint j=0;j&lt;p1.size();j++)
        {
            if (t2[i].findPointIntersection(p1[j],xTmp))
            {
                intersectionFound = true;
            }
        }
    }

    // Triangle-segment intersection
    for (uint i=0;i&lt;t1.size();i++)
    {
        for (uint j=0;j&lt;s2.size();j++)
        {
            if (t1[i].findSegmentIntersection(s2[j],xTmp))
            {
                intersectionFound = true;
            }
        }
    }
    for (uint i=0;i&lt;t2.size();i++)
    {
        for (uint j=0;j&lt;s1.size();j++)
        {
            if (t2[i].findSegmentIntersection(s1[j],xTmp))
            {
                intersectionFound = true;
            }
        }
    }

    // Triangle-triangle intersection
    for (uint i=0;i&lt;t1.size();i++)
    {
        for (uint j=0;j&lt;t2.size();j++)
        {
            if (t1[i].findTriangleIntersection(t2[j],xTmp))
            {
                intersectionFound = true;
            }
        }
    }

    for (auto f : xTmp)
    {
        f.scale(1.0/nodeScale);
        x.insert(f);
    }

    return intersectionFound;
} /* RElement::findIntersectionPoints */


</t>
<t tx="leo.20201108101533.118">bool RElement::isInsideBoundingBox(const std::vector&lt;RNode&gt; &amp;nodes, const RNode &amp;node) const
{
    double minX = 0.0, minY = 0.0, minZ = 0.0;
    double maxX = 0.0, maxY = 0.0, maxZ = 0.0;
    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        const RNode &amp;eNode = nodes[this-&gt;getNodeId(i)];
        if (i == 0)
        {
            minX = maxX = eNode.getX();
            minY = maxY = eNode.getY();
            minZ = maxZ = eNode.getZ();
        }
        else
        {
            minX = std::min(minX,eNode.getX());
            minY = std::min(minY,eNode.getY());
            minZ = std::min(minZ,eNode.getZ());

            maxX = std::max(maxX,eNode.getX());
            maxY = std::max(maxY,eNode.getY());
            maxZ = std::max(maxZ,eNode.getZ());
        }
    }
    return (node.getX() &gt;= minX &amp;&amp; node.getX() &lt;= maxX
            &amp;&amp;
            node.getY() &gt;= minY &amp;&amp; node.getY() &lt;= maxY
            &amp;&amp;
            node.getZ() &gt;= minZ &amp;&amp; node.getZ() &lt;= maxZ);
} /* RElement::isInsideBoundingBox */


</t>
<t tx="leo.20201108101533.119">bool RElement::testPlaneIntersect(const RPlane &amp;plane,
                                  const std::vector &lt;RNode&gt; &amp;nodes) const
{
    double distance = 0.0;
    bool hasNegative = false;
    bool hasPositive = false;

    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        distance = plane.findPointDistance(nodes[this-&gt;getNodeId(i)].toVector());
        if (std::abs(distance) &lt; RConstants::eps)
        {
            return true;
        }
        if (distance &lt; 0.0)
        {
            hasNegative = true;
        }
        else
        {
            hasPositive = true;
        }

        if (hasNegative &amp;&amp; hasPositive)
        {
            return true;
        }
    }

    return false;
} /* RElement::testPlaneIntersect */

</t>
<t tx="leo.20201108101533.12">void RBoundaryCondition::setLocalDirection(const RR3Vector &amp;direction)
{
    this-&gt;direction = direction;
} /* RBoundaryCondition::setLocalRotations */


RBoundaryCondition &amp; RBoundaryCondition::operator =
                                 (const RBoundaryCondition &amp;condition)
{
    this-&gt;RCondition::operator = (condition);
    this-&gt;_init (&amp;condition);
    return (*this);
} /* RBoundaryCondition::operator = */


RBoundaryConditionType RBoundaryCondition::getTypeFromId(const QString &amp;bcId)
{
    for (uint type=uint(R_BOUNDARY_CONDITION_NONE);type&lt;uint(R_BOUNDARY_CONDITION_N_TYPES);type++)
    {
        if (boundaryConditionDesc[type].id == bcId)
        {
            return RBoundaryConditionType(type);
        }
    }

    return R_BOUNDARY_CONDITION_NONE;
} /* RBoundaryCondition::getTypeFromId */


QString RBoundaryCondition::getId(RBoundaryConditionType type)
{
    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));
    return boundaryConditionDesc[type].id;
} /* RBoundaryCondition::getId */


</t>
<t tx="leo.20201108101533.120">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_element_group.cpp                                    *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th December 2011                                       *
 *                                                                   *
 *  DESCRIPTION: ElementGroup class definition                       *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "rml_element.h"
#include "rml_element_group.h"


RElementGroup::RElementGroup ()
{
    this-&gt;_init ();
    this-&gt;setDefaultEnvironmentConditions();
} /* RElementGroup::RElementGroup */


RElementGroup::RElementGroup (const RElementGroup &amp;elementGroup) :
    REntityGroup(elementGroup)
{
    this-&gt;_init (&amp;elementGroup);
} /* RElementGroup::RElementGroup */


RElementGroup::~RElementGroup ()
{
} /* RElementGroup::~RElementGroup */


RElementGroup &amp; RElementGroup::operator = (const RElementGroup &amp;elementGroup)
{
    this-&gt;REntityGroup::operator = (elementGroup);
    this-&gt;_init (&amp;elementGroup);
    return (*this);
} /* RElementGroup::operator = */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101533.121">void RElementGroup::_init (const RElementGroup *pElementGroup)
{
    if (pElementGroup)
    {
        this-&gt;elementIDs = pElementGroup-&gt;elementIDs;
        this-&gt;bConditions = pElementGroup-&gt;bConditions;
        this-&gt;eConditions = pElementGroup-&gt;eConditions;
        this-&gt;iConditions = pElementGroup-&gt;iConditions;
        this-&gt;material = pElementGroup-&gt;material;
        this-&gt;data = pElementGroup-&gt;data;
    }
} /* RElementGroup::_init */


</t>
<t tx="leo.20201108101533.122">void RElementGroup::add (unsigned int elementID)
{
    this-&gt;elementIDs.push_back (elementID);
} /* RElementGroup::add */


</t>
<t tx="leo.20201108101533.123">unsigned int RElementGroup::get (unsigned int position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;elementIDs.size());
    return this-&gt;elementIDs[position];
} /* RElementGroup::get */


</t>
<t tx="leo.20201108101533.124">void RElementGroup::remove (unsigned int position)
{
    std::vector&lt;unsigned int&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;elementIDs.size());

    iter = this-&gt;elementIDs.begin();
    std::advance (iter, position);

    this-&gt;elementIDs.erase (iter);
} /* RElementGroup::remove */


</t>
<t tx="leo.20201108101533.125">void RElementGroup::set (unsigned int position,
                         unsigned int elementID)
{
    R_ERROR_ASSERT (position &lt; this-&gt;elementIDs.size());
    this-&gt;elementIDs[position] = elementID;
} /* RElementGroup::set */


</t>
<t tx="leo.20201108101533.126">bool RElementGroup::findPosition (unsigned int  elementID,
                                  unsigned int *position) const
{
    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        if (elementID == this-&gt;get(i))
        {
            (*position) = i;
            return true;
        }
    }

    return false;
} /* RElementGroup::find_position */


</t>
<t tx="leo.20201108101533.127">unsigned int RElementGroup::size (void) const
{
    return (unsigned int)this-&gt;elementIDs.size();
} /* RElementGroup::size */


</t>
<t tx="leo.20201108101533.128">void RElementGroup::resize (unsigned int nmemb)
{
    this-&gt;elementIDs.resize(nmemb);
} /* RElementGroup::size */


</t>
<t tx="leo.20201108101533.129">void RElementGroup::addBoundaryCondition
                                (const RBoundaryCondition &amp;bCondition)
{
    this-&gt;bConditions[bCondition.getType()] = bCondition;
} /* RElementGroup::addBoundaryCondition */


</t>
<t tx="leo.20201108101533.13">const QString &amp;RBoundaryCondition::getName(RBoundaryConditionType type)
{
    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));
    return boundaryConditionDesc[type].name;
} /* RBoundaryCondition::getName */


</t>
<t tx="leo.20201108101533.130">bool RElementGroup::hasBoundaryCondition(RBoundaryConditionType type) const
{
    return (this-&gt;bConditions.find(type) != this-&gt;bConditions.end());
} /* RElementGroup:: */


</t>
<t tx="leo.20201108101533.131">const RBoundaryCondition &amp; RElementGroup::getBoundaryCondition
                                   (RBoundaryConditionType type) const
{
    std::map&lt;RBoundaryConditionType,RBoundaryCondition&gt;::const_iterator iter;

    iter = this-&gt;bConditions.find(type);

    R_ERROR_ASSERT (iter != this-&gt;bConditions.end());

    return iter-&gt;second;
} /* RElementGroup::getBoundaryCondition */


RBoundaryCondition &amp;RElementGroup::getBoundaryCondition(RBoundaryConditionType type)
{
    std::map&lt;RBoundaryConditionType,RBoundaryCondition&gt;::iterator iter;

    iter = this-&gt;bConditions.find(type);

    R_ERROR_ASSERT (iter != this-&gt;bConditions.end());

    return iter-&gt;second;
} /* RElementGroup::getBoundaryCondition */


</t>
<t tx="leo.20201108101533.132">const RBoundaryCondition &amp; RElementGroup::getBoundaryCondition
                                         (unsigned int position) const
{
    std::map&lt;RBoundaryConditionType,RBoundaryCondition&gt;::const_iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNBoundaryConditions());

    iter = this-&gt;bConditions.begin();
    std::advance (iter, position);

    return iter-&gt;second;
} /* RElementGroup::getBoundaryCondition */


RBoundaryCondition &amp;RElementGroup::getBoundaryCondition(unsigned int position)
{
    std::map&lt;RBoundaryConditionType,RBoundaryCondition&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNBoundaryConditions());

    iter = this-&gt;bConditions.begin();
    std::advance (iter, position);

    return iter-&gt;second;
} /* RElementGroup::getBoundaryCondition */


</t>
<t tx="leo.20201108101533.133">void RElementGroup::removeBoundaryCondition
                                         (RBoundaryConditionType type)
{
    std::map&lt;RBoundaryConditionType,RBoundaryCondition&gt;::iterator iter;

    iter = this-&gt;bConditions.find(type);

    R_ERROR_ASSERT (iter != this-&gt;bConditions.end());

    this-&gt;bConditions.erase (iter);
} /* RElementGroup::removeBoundaryCondition */


</t>
<t tx="leo.20201108101533.134">void RElementGroup::removeBoundaryCondition (unsigned int position)
{
    std::map&lt;RBoundaryConditionType,RBoundaryCondition&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNBoundaryConditions());

    iter = this-&gt;bConditions.begin();
    std::advance (iter, position);

    this-&gt;bConditions.erase(iter);
} /* RElementGroup::removeBoundaryCondition */


</t>
<t tx="leo.20201108101533.135">void RElementGroup::removeAllBoundaryConditions(void)
{
    this-&gt;bConditions.clear();
} /* RElementGroup::removeAllBoundaryConditions */

</t>
<t tx="leo.20201108101533.136">void RElementGroup::addEnvironmentCondition
                                (const REnvironmentCondition &amp;eCondition)
{
    this-&gt;eConditions[eCondition.getType()] = eCondition;
} /* RElementGroup::addEnvironmentCondition */


</t>
<t tx="leo.20201108101533.137">bool RElementGroup::hasEnvironmentCondition(REnvironmentConditionType type) const
{
    return (this-&gt;eConditions.find(type) != this-&gt;eConditions.end());
} /* RElementGroup::hasEnvironmentCondition */


</t>
<t tx="leo.20201108101533.138">const REnvironmentCondition &amp; RElementGroup::getEnvironmentCondition
                                   (REnvironmentConditionType type) const
{
    std::map&lt;REnvironmentConditionType,REnvironmentCondition&gt;::const_iterator iter;

    iter = this-&gt;eConditions.find(type);

    R_ERROR_ASSERT (iter != this-&gt;eConditions.end());

    return iter-&gt;second;
} /* RElementGroup::getEnvironmentCondition */


REnvironmentCondition &amp;RElementGroup::getEnvironmentCondition(REnvironmentConditionType type)
{
    std::map&lt;REnvironmentConditionType,REnvironmentCondition&gt;::iterator iter;

    iter = this-&gt;eConditions.find(type);

    R_ERROR_ASSERT (iter != this-&gt;eConditions.end());

    return iter-&gt;second;
} /* RElementGroup::getEnvironmentCondition */


</t>
<t tx="leo.20201108101533.139">const REnvironmentCondition &amp; RElementGroup::getEnvironmentCondition
                                         (unsigned int position) const
{
    std::map&lt;REnvironmentConditionType,REnvironmentCondition&gt;::const_iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNEnvironmentConditions());

    iter = this-&gt;eConditions.begin();
    std::advance (iter, position);

    return iter-&gt;second;
} /* RElementGroup::getEnvironmentCondition */


REnvironmentCondition &amp;RElementGroup::getEnvironmentCondition(unsigned int position)
{
    std::map&lt;REnvironmentConditionType,REnvironmentCondition&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNEnvironmentConditions());

    iter = this-&gt;eConditions.begin();
    std::advance (iter, position);

    return iter-&gt;second;
} /* RElementGroup::getEnvironmentCondition */


</t>
<t tx="leo.20201108101533.14">bool RBoundaryCondition::getOptional (RBoundaryConditionType type)
{
    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));
    return boundaryConditionDesc[type].optional;
} /* RBoundaryCondition::getOptional */


</t>
<t tx="leo.20201108101533.140">void RElementGroup::removeEnvironmentCondition
                                         (REnvironmentConditionType type)
{
    std::map&lt;REnvironmentConditionType,REnvironmentCondition&gt;::iterator iter;

    iter = this-&gt;eConditions.find(type);

    R_ERROR_ASSERT (iter != this-&gt;eConditions.end());

    this-&gt;eConditions.erase (iter);
} /* RElementGroup::removeEnvironmentCondition */


</t>
<t tx="leo.20201108101533.141">void RElementGroup::removeEnvironmentCondition (unsigned int position)
{
    std::map&lt;REnvironmentConditionType,REnvironmentCondition&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNEnvironmentConditions());

    iter = this-&gt;eConditions.begin();
    std::advance (iter, position);

    this-&gt;eConditions.erase(iter);
} /* RElementGroup::removeEnvironmentCondition */


</t>
<t tx="leo.20201108101533.142">void RElementGroup::removeAllEnvironmentConditions(void)
{
    this-&gt;eConditions.clear();
    this-&gt;setDefaultEnvironmentConditions();
} /* RElementGroup::removeAllEnvironmentConditions */


</t>
<t tx="leo.20201108101533.143">void RElementGroup::addInitialCondition
                                (const RInitialCondition &amp;iCondition)
{
    this-&gt;iConditions[iCondition.getType()] = iCondition;
} /* RElementGroup::addInitialCondition */


</t>
<t tx="leo.20201108101533.144">bool RElementGroup::hasInitialCondition(RInitialConditionType type) const
{
    return (this-&gt;iConditions.find(type) != this-&gt;iConditions.end());
} /* RElementGroup::hasInitialCondition */


</t>
<t tx="leo.20201108101533.145">const RInitialCondition &amp; RElementGroup::getInitialCondition
                                   (RInitialConditionType type) const
{
    std::map&lt;RInitialConditionType,RInitialCondition&gt;::const_iterator iter;

    iter = this-&gt;iConditions.find(type);

    R_ERROR_ASSERT (iter != this-&gt;iConditions.end());

    return iter-&gt;second;
} /* RElementGroup::getInitialCondition */


RInitialCondition &amp;RElementGroup::getInitialCondition(RInitialConditionType type)
{
    std::map&lt;RInitialConditionType,RInitialCondition&gt;::iterator iter;

    iter = this-&gt;iConditions.find(type);

    R_ERROR_ASSERT (iter != this-&gt;iConditions.end());

    return iter-&gt;second;
} /* RElementGroup::getInitialCondition */


</t>
<t tx="leo.20201108101533.146">const RInitialCondition &amp; RElementGroup::getInitialCondition
                                         (unsigned int position) const
{
    std::map&lt;RInitialConditionType,RInitialCondition&gt;::const_iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNInitialConditions());

    iter = this-&gt;iConditions.begin();
    std::advance (iter, position);

    return iter-&gt;second;
} /* RElementGroup::getInitialCondition */


RInitialCondition &amp;RElementGroup::getInitialCondition(unsigned int position)
{
    std::map&lt;RInitialConditionType,RInitialCondition&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNInitialConditions());

    iter = this-&gt;iConditions.begin();
    std::advance (iter, position);

    return iter-&gt;second;
} /* RElementGroup::getInitialCondition */


</t>
<t tx="leo.20201108101533.147">void RElementGroup::removeInitialCondition
                                         (RInitialConditionType type)
{
    std::map&lt;RInitialConditionType,RInitialCondition&gt;::iterator iter;

    iter = this-&gt;iConditions.find(type);

    R_ERROR_ASSERT (iter != this-&gt;iConditions.end());

    this-&gt;iConditions.erase (iter);
} /* RElementGroup::removeInitialCondition */


</t>
<t tx="leo.20201108101533.148">void RElementGroup::removeInitialCondition (unsigned int position)
{
    std::map&lt;RInitialConditionType,RInitialCondition&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNInitialConditions());

    iter = this-&gt;iConditions.begin();
    std::advance (iter, position);

    this-&gt;iConditions.erase(iter);
} /* RElementGroup::removeInitialCondition */


</t>
<t tx="leo.20201108101533.149">void RElementGroup::removeAllInitialConditions(void)
{
    this-&gt;iConditions.clear();
} /* RElementGroup::removeAllInitialConditions */


REntityGroupType RElementGroup::getGroupType (RElementType elementType)
{
    if (R_ELEMENT_TYPE_IS_POINT (elementType))
    {
        return R_ENTITY_GROUP_POINT;
    }

    if (R_ELEMENT_TYPE_IS_LINE (elementType))
    {
        return R_ENTITY_GROUP_LINE;
    }

    if (R_ELEMENT_TYPE_IS_SURFACE (elementType))
    {
        return R_ENTITY_GROUP_SURFACE;
    }

    if (R_ELEMENT_TYPE_IS_VOLUME (elementType))
    {
        return R_ENTITY_GROUP_VOLUME;
    }

    return R_ENTITY_GROUP_NONE;
} /* RElementGroup::getGroupType */


</t>
<t tx="leo.20201108101533.15">bool RBoundaryCondition::getExplicit (RBoundaryConditionType type)
{
    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));
    return boundaryConditionDesc[type].isExplicit;
} /* RBoundaryCondition::getExplicit */


</t>
<t tx="leo.20201108101533.150">void RElementGroup::setDefaultEnvironmentConditions(void)
{
    this-&gt;eConditions[R_ENVIRONMENT_CONDITION_G_ACCELERATION] = REnvironmentCondition(R_ENVIRONMENT_CONDITION_G_ACCELERATION);
    this-&gt;eConditions[R_ENVIRONMENT_CONDITION_TEMPERATURE] = REnvironmentCondition(R_ENVIRONMENT_CONDITION_TEMPERATURE);
} /* RElementGroup::setDefaultEnvironmentConditions */
</t>
<t tx="leo.20201108101533.151">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_element_shape_derivation.cpp                         *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   16-th December 2015                                      *
 *                                                                   *
 *  DESCRIPTION: Element shape derivation class definition           *
 *********************************************************************/

#include "rml_element_shape_derivation.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101533.152">void RElementShapeDerivation::_init(const RElementShapeDerivation *pElementShapeDerivation)
{
    if (pElementShapeDerivation)
    {
        this-&gt;B = pElementShapeDerivation-&gt;B;
        this-&gt;detJ = pElementShapeDerivation-&gt;detJ;
    }
}

RElementShapeDerivation::RElementShapeDerivation(const RElement &amp;rElement, const std::vector&lt;RNode&gt; &amp;nodes, RProblemType problemType)
{
    this-&gt;_init();

    switch (problemType)
    {
        case R_PROBLEM_FLUID:
        {
            this-&gt;generateFluid(rElement,nodes);
            break;
        }
        default:
        {
            break;
        }
    }
}

RElementShapeDerivation::RElementShapeDerivation(const RElementShapeDerivation &amp;elementShapeDerivation)
{
    this-&gt;_init(&amp;elementShapeDerivation);
}

RElementShapeDerivation::~RElementShapeDerivation()
{

}

RElementShapeDerivation &amp;RElementShapeDerivation::operator =(const RElementShapeDerivation &amp;elementShapeDerivation)
{
    this-&gt;_init(&amp;elementShapeDerivation);
    return (*this);
}

</t>
<t tx="leo.20201108101533.153">const RRMatrix &amp;RElementShapeDerivation::getDerivative(uint integrationPoint) const
{
    return this-&gt;B[integrationPoint];
}

double RElementShapeDerivation::getJacobian(uint integrationPoint) const
{
    return this-&gt;detJ[integrationPoint];
}

</t>
<t tx="leo.20201108101533.154">void RElementShapeDerivation::generateFluid(const RElement &amp;rElement, const std::vector&lt;RNode&gt; &amp;nodes)
{
    uint nen = rElement.size();
    uint nInp = RElement::getNIntegrationPoints(rElement.getType());

    this-&gt;detJ.resize(nInp);
    this-&gt;B.resize(nInp);

    for (uint intPoint=0;intPoint&lt;nInp;intPoint++)
    {
        const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(rElement.getType(),intPoint);
        const RRMatrix &amp;dN = shapeFunc.getDN();
        RRMatrix J, Rt;

        this-&gt;detJ[intPoint] = rElement.findJacobian(nodes,intPoint,J,Rt);

        if (R_ELEMENT_TYPE_IS_VOLUME(rElement.getType()))
        {
            this-&gt;B[intPoint].resize(nen,3,0.0);

            for (uint m=0;m&lt;dN.getNRows();m++)
            {
                this-&gt;B[intPoint][m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]);
                this-&gt;B[intPoint][m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]);
                this-&gt;B[intPoint][m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]);
            }
        }
    }
}
</t>
<t tx="leo.20201108101533.16">bool RBoundaryCondition::getApplyOnPoint (RBoundaryConditionType type)
{
    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));
    return boundaryConditionDesc[type].applyOnPoint;
} /* RBoundaryCondition::getApplyOnPoint */


</t>
<t tx="leo.20201108101533.17">bool RBoundaryCondition::getApplyOnLine (RBoundaryConditionType type)
{
    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));
    return boundaryConditionDesc[type].applyOnLine;
} /* RBoundaryCondition::getApplyOnLine */


</t>
<t tx="leo.20201108101533.18">bool RBoundaryCondition::getApplyOnSurface (RBoundaryConditionType type)
{
    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));
    return boundaryConditionDesc[type].applyOnSurface;
} /* RBoundaryCondition::getApplyOnSurface */


</t>
<t tx="leo.20201108101533.19">bool RBoundaryCondition::getApplyOnVolume (RBoundaryConditionType type)
{
    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));
    return boundaryConditionDesc[type].applyOnVolume;
} /* RBoundaryCondition::getApplyOnVolume */


</t>
<t tx="leo.20201108101533.20">bool RBoundaryCondition::getHasLocalDirection (RBoundaryConditionType type)
{
    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));
    return boundaryConditionDesc[type].hasLocalDirections;
} /* RBoundaryCondition::getHasLocalDirection */


RProblemTypeMask RBoundaryCondition::getProblemTypeMask (RBoundaryConditionType type)
{
    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));
    return boundaryConditionDesc[type].problemTypeMask;
} /* RBoundaryCondition::getProblemTypeMask */


std::vector&lt;RBoundaryConditionType&gt; RBoundaryCondition::getTypes (RProblemTypeMask problemTypeMask,
                                                                  RBoundaryConditionType bcType)
{
    R_ERROR_ASSERT (R_PROBLEM_TYPE_MASK_IS_VALID (problemTypeMask));

    std::vector&lt;RProblemType&gt; prbTypes = RProblem::getTypes(problemTypeMask);

    std::vector&lt;bool&gt; bcBook;
    bcBook.resize(R_BOUNDARY_CONDITION_N_TYPES,false);

    for (unsigned int i=0;i&lt;prbTypes.size();i++)
    {
        if (bcType != R_BOUNDARY_CONDITION_ALL)
        {
            if (!(RBoundaryCondition::getProblemTypeMask(bcType) &amp; prbTypes[i]))
            {
                continue;
            }
        }
        for (unsigned int j=0;j&lt;bcBook.size();j++)
        {
            if (bcBook[j])
            {
                continue;
            }
            if (RBoundaryCondition::getProblemTypeMask(RBoundaryConditionType(j)) &amp; prbTypes[i])
            {
                bcBook[j] = true;
            }
        }
    }

    std::vector&lt;RBoundaryConditionType&gt; bcTypes;
    for (unsigned int i=0;i&lt;bcBook.size();i++)
    {
        if (bcBook[i])
        {
            bcTypes.push_back(RBoundaryConditionType(i));
        }
    }
    return bcTypes;
} /* RBoundaryCondition::getTypes */


std::vector&lt;RBoundaryConditionType&gt; RBoundaryCondition::getConflictTypes(RProblemTypeMask problemTypeMask,
                                                                         RBoundaryConditionType bcType)
{
    std::vector&lt;RBoundaryConditionType&gt; bcTypes;

    bcTypes = RBoundaryCondition::getTypes(problemTypeMask,bcType);
    for (unsigned int i=0;i&lt;bcTypes.size();i++)
    {
        if (bcTypes[i] == bcType)
        {
            bcTypes.erase(bcTypes.begin() + i);
        }
    }

    return bcTypes;
} /* RBoundaryCondition::getConflictTypes */


</t>
<t tx="leo.20201108101533.21">bool RBoundaryCondition::getHasExplicit(RProblemType problemType)
{
    std::vector&lt;RBoundaryConditionType&gt; types = RBoundaryCondition::getTypes(problemType);
    for (unsigned int i=0;i&lt;types.size();i++)
    {
        if (RBoundaryCondition::getExplicit(types[i]))
        {
            return true;
        }
    }
    return false;
} /* RBoundaryCondition::getNeedsExplicit */


std::vector&lt;RVariableType&gt; RBoundaryCondition::getDefaultComponents
                                         (RBoundaryConditionType type)
{
    std::vector&lt;RVariableType&gt; componentTypes;

    R_ERROR_ASSERT (R_BOUNDARY_CONDITION_TYPE_IS_VALID (type));

    switch (type)
    {
        case R_BOUNDARY_CONDITION_NONE:
            break;
        case R_BOUNDARY_CONDITION_ABSORBING_BOUNDARY:
            break;
        case R_BOUNDARY_CONDITION_CHARGE_DENSITY:
            componentTypes.push_back (R_VARIABLE_CHARGE_DENSITY);
            break;
        case R_BOUNDARY_CONDITION_CONVECTION_FORCED:
            componentTypes.push_back (R_VARIABLE_DENSITY);
            componentTypes.push_back (R_VARIABLE_DYNAMIC_VISCOSITY);
            componentTypes.push_back (R_VARIABLE_HEAT_CAPACITY);
            componentTypes.push_back (R_VARIABLE_HYDRAULIC_DIAMETER);
            componentTypes.push_back (R_VARIABLE_THERMAL_CONDUCTIVITY);
            componentTypes.push_back (R_VARIABLE_VELOCITY);
            break;
        case R_BOUNDARY_CONDITION_CONVECTION_NATURAL:
            componentTypes.push_back (R_VARIABLE_DENSITY);
            componentTypes.push_back (R_VARIABLE_DYNAMIC_VISCOSITY);
            componentTypes.push_back (R_VARIABLE_FLUID_TEMPERATURE);
            componentTypes.push_back (R_VARIABLE_HEAT_CAPACITY);
            componentTypes.push_back (R_VARIABLE_HYDRAULIC_DIAMETER);
            componentTypes.push_back (R_VARIABLE_THERMAL_CONDUCTIVITY);
            componentTypes.push_back (R_VARIABLE_THERMAL_EXPANSION_COEFFICIENT);
            break;
        case R_BOUNDARY_CONDITION_CONVECTION_SIMPLE:
            componentTypes.push_back (R_VARIABLE_CONVECTION_COEFFICIENT);
            componentTypes.push_back (R_VARIABLE_FLUID_TEMPERATURE);
            break;
        case R_BOUNDARY_CONDITION_DISPLACEMENT:
            componentTypes.push_back (R_VARIABLE_DISPLACEMENT_X);
            componentTypes.push_back (R_VARIABLE_DISPLACEMENT_Y);
            componentTypes.push_back (R_VARIABLE_DISPLACEMENT_Z);
            break;
        case R_BOUNDARY_CONDITION_DISPLACEMENT_NORMAL:
            componentTypes.push_back (R_VARIABLE_DISPLACEMENT);
            break;
        case R_BOUNDARY_CONDITION_DISPLACEMENT_ROLLER:
            componentTypes.push_back (R_VARIABLE_DISPLACEMENT);
            break;
        case R_BOUNDARY_CONDITION_ELECTRIC_POTENTIAL:
            componentTypes.push_back (R_VARIABLE_ELECTRIC_POTENTIAL);
            break;
        case R_BOUNDARY_CONDITION_FORCE:
            componentTypes.push_back (R_VARIABLE_FORCE_X);
            componentTypes.push_back (R_VARIABLE_FORCE_Y);
            componentTypes.push_back (R_VARIABLE_FORCE_Z);
            break;
        case R_BOUNDARY_CONDITION_FORCE_UNIT_AREA:
            componentTypes.push_back (R_VARIABLE_FORCE_UNIT_AREA_X);
            componentTypes.push_back (R_VARIABLE_FORCE_UNIT_AREA_Y);
            componentTypes.push_back (R_VARIABLE_FORCE_UNIT_AREA_Z);
            break;
        case R_BOUNDARY_CONDITION_HEAT:
            componentTypes.push_back (R_VARIABLE_HEAT);
            break;
        case R_BOUNDARY_CONDITION_HEAT_RATE_AREA:
            componentTypes.push_back (R_VARIABLE_HEAT_RATE_AREA);
            break;
        case R_BOUNDARY_CONDITION_HEAT_RATE_VOLUME:
            componentTypes.push_back (R_VARIABLE_HEAT_RATE_VOLUME);
            break;
        case R_BOUNDARY_CONDITION_PRESSURE_EXPLICIT:
            componentTypes.push_back (R_VARIABLE_PRESSURE);
            break;
        case R_BOUNDARY_CONDITION_INFLOW_VELOCITY:
            componentTypes.push_back (R_VARIABLE_VELOCITY);
            break;
        case R_BOUNDARY_CONDITION_INFLOW_VOLURATE:
            componentTypes.push_back (R_VARIABLE_VOLUME_FLOW_RATE);
            break;
        case R_BOUNDARY_CONDITION_PARTICLE_CONCENTRATION:
            componentTypes.push_back (R_VARIABLE_PARTICLE_CONCENTRATION);
            break;
        case R_BOUNDARY_CONDITION_PRESSURE_IMPLICIT:
            componentTypes.push_back (R_VARIABLE_PRESSURE);
            break;
        case R_BOUNDARY_CONDITION_PARTICLE_RATE:
            componentTypes.push_back (R_VARIABLE_PARTICLE_RATE);
            break;
        case R_BOUNDARY_CONDITION_PRESSURE:
            componentTypes.push_back (R_VARIABLE_PRESSURE);
            break;
        case R_BOUNDARY_CONDITION_RADIATION:
            componentTypes.push_back (R_VARIABLE_RADIATION_EMITTER);
            componentTypes.push_back (R_VARIABLE_RADIATION_RECEIVER);
            componentTypes.push_back (R_VARIABLE_PATCH_AREA);
            componentTypes.push_back (R_VARIABLE_PATCH_SIZE);
            componentTypes.push_back (R_VARIABLE_SEPARATION_ANGLE);
            break;
        case R_BOUNDARY_CONDITION_TEMPERATURE:
            componentTypes.push_back (R_VARIABLE_TEMPERATURE);
            break;
        case R_BOUNDARY_CONDITION_VELOCITY_NORMAL:
            componentTypes.push_back (R_VARIABLE_VELOCITY);
            break;
        case R_BOUNDARY_CONDITION_VELOCITY_POTENTIAL:
            componentTypes.push_back (R_VARIABLE_POTENTIAL);
            break;
        case R_BOUNDARY_CONDITION_WALL:
            break;
        case R_BOUNDARY_CONDITION_WAVE_DISPLACEMENT:
            componentTypes.push_back (R_VARIABLE_WAVE_DISPLACEMENT);
            break;
        case R_BOUNDARY_CONDITION_WEIGHT:
            componentTypes.push_back (R_VARIABLE_WEIGHT);
            break;
        case R_BOUNDARY_CONDITION_CUSTOM:
            break;
        default:
            break;
    }

    return componentTypes;
} /* RBoundaryCondition::getDefaultComponents */


</t>
<t tx="leo.20201108101533.22">void operator ++(RBoundaryConditionType &amp;type, int increment)
{
    type = (RBoundaryConditionType)((int)type+increment+1);
} /* operator ++ */
</t>
<t tx="leo.20201108101533.23">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_condition.cpp                                        *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Condition class definition                          *
 *********************************************************************/

#include "rml_condition.h"

RCondition::RCondition ()
{
    this-&gt;_init ();
} /* RCondition::RCondition */


RCondition::RCondition (const RCondition &amp;condition)
{
    this-&gt;_init (&amp;condition);
} /* RCondition::RCondition (copy) */


RCondition::~RCondition ()
{
} /* RCondition::~RCondition */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101533.24">void RCondition::_init (const RCondition *pCondition)
{
    if (pCondition)
    {
        this-&gt;name = pCondition-&gt;name;
        this-&gt;components = pCondition-&gt;components;
        this-&gt;applyOnPoint = pCondition-&gt;applyOnPoint;
        this-&gt;applyOnLine = pCondition-&gt;applyOnLine;
        this-&gt;applyOnSurface = pCondition-&gt;applyOnSurface;
        this-&gt;applyOnVolume = pCondition-&gt;applyOnVolume;
        this-&gt;problemTypeMask = pCondition-&gt;problemTypeMask;
    }
} /* RCondition::_init */


</t>
<t tx="leo.20201108101533.25">const QString &amp;RCondition::getName(void) const
{
    return this-&gt;name;
} /* RCondition::get_name */


</t>
<t tx="leo.20201108101533.26">void RCondition::setName (const QString &amp;name)
{
    this-&gt;name = name;
} /* RCondition::set_name */


</t>
<t tx="leo.20201108101533.27">bool RCondition::getApplyOnPoint ( void ) const
{
    return this-&gt;applyOnPoint;
} /* RCondition::get_apply_on_point */


</t>
<t tx="leo.20201108101533.28">void RCondition::setApplyOnPoint ( bool apply )
{
    this-&gt;applyOnPoint = apply;
} /* RCondition::set_apply_on_point */


</t>
<t tx="leo.20201108101533.29">bool RCondition::getApplyOnLine ( void ) const
{
    return this-&gt;applyOnLine;
} /* RCondition::get_apply_on_line */


</t>
<t tx="leo.20201108101533.3"></t>
<t tx="leo.20201108101533.30">void RCondition::setApplyOnLine ( bool apply )
{
    this-&gt;applyOnLine = apply;
} /* RCondition::set_apply_on_line */


</t>
<t tx="leo.20201108101533.31">bool RCondition::getApplyOnSurface ( void ) const
{
    return this-&gt;applyOnSurface;
} /* RCondition::get_apply_on_surface */


</t>
<t tx="leo.20201108101533.32">void RCondition::setApplyOnSurface ( bool apply )
{
    this-&gt;applyOnSurface = apply;
} /* RCondition::set_apply_on_surface */


</t>
<t tx="leo.20201108101533.33">bool RCondition::getApplyOnVolume ( void ) const
{
    return this-&gt;applyOnVolume;
} /* RCondition::get_apply_on_volume */


</t>
<t tx="leo.20201108101533.34">void RCondition::setApplyOnVolume ( bool apply )
{
    this-&gt;applyOnVolume = apply;
} /* RCondition::set_apply_on_volume */


RProblemTypeMask RCondition::getProblemTypeMask (void) const
{
    return this-&gt;problemTypeMask;
} /* RCondition::get_problem_type_mask */


</t>
<t tx="leo.20201108101533.35">void RCondition::setProblemTypeMask (RProblemTypeMask typeMask)
{
    R_ERROR_ASSERT (R_PROBLEM_TYPE_MASK_IS_VALID (typeMask));
    this-&gt;problemTypeMask = typeMask;
} /* RCondition::set_problem_type_mask */


</t>
<t tx="leo.20201108101533.36">bool RCondition::checkProblemTypeMask (RProblemType type) const
{
    R_ERROR_ASSERT (R_PROBLEM_TYPE_IS_VALID (type));
    return (type &amp; this-&gt;getProblemTypeMask()) ? true : false;
} /* RCondition::check_problem_type_mask */


</t>
<t tx="leo.20201108101533.37">unsigned int RCondition::size (void) const
{
    return (unsigned int)this-&gt;components.size();
} /* RCondition::size */


</t>
<t tx="leo.20201108101533.38">bool RCondition::addComponent (const RConditionComponent &amp;component)
{
    unsigned int position = 0;

    position = this-&gt;findComponentPosition (component.getType());

    if (position == RConstants::eod)
    {
        this-&gt;components.push_back(component);
        return true;
    }
    else
    {
        this-&gt;components[position] = component;
        return false;
    }
} /* RCondition::add */


</t>
<t tx="leo.20201108101533.39">const RConditionComponent &amp; RCondition::getComponent (unsigned int position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;size());
    return this-&gt;components[position];
} /* RCondition::get */


RConditionComponent &amp; RCondition::getComponent (unsigned int position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;size());
    return this-&gt;components[position];
} /* RCondition::get */


</t>
<t tx="leo.20201108101533.4">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_boundary_condition.cpp                               *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Boundary condition class definition                 *
 *********************************************************************/

#include "rml_boundary_condition.h"
#include "rml_problem.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101533.40">void RCondition::removeComponent (unsigned int position)
{
    std::vector&lt;RConditionComponent&gt;::iterator iter;

    iter = this-&gt;components.begin();
    std::advance (iter, position);

    this-&gt;components.erase (iter);
} /* RCondition::remove */


</t>
<t tx="leo.20201108101533.41">unsigned int RCondition::findComponentPosition (RVariableType type) const
{
    std::vector&lt;RConditionComponent&gt;::const_iterator iter;
    unsigned int i = 0;

    for (iter = this-&gt;components.begin();
         iter != this-&gt;components.end();
         ++iter)
    {
        if (iter-&gt;getType() == type)
        {
           return i;
        }
        i++;
    }

    return RConstants::eod;
} /* RCondition::find_position */


RCondition &amp; RCondition::operator = (const RCondition &amp;condition)
{
    this-&gt;_init (&amp;condition);
    return (*this);
} /* RCondition::operator = */
</t>
<t tx="leo.20201108101533.42">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_condition_component.cpp                              *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Condition component class definition                *
 *********************************************************************/

#include "rml_condition_component.h"
#include "rml_variable.h"

RConditionComponent::RConditionComponent (RVariableType type) : keyType(R_VARIABLE_TIME)
{
    this-&gt;setType (type);
    this-&gt;_init ();
} /* RConditionComponent::RConditionComponent */


RConditionComponent::RConditionComponent
                       (const RConditionComponent &amp;conditionComponent)
                                    : RValueTable (conditionComponent)
{
    this-&gt;_init (&amp;conditionComponent);
} /* RConditionComponent::RConditionComponent (copy) */


RConditionComponent::~RConditionComponent ()
{
} /* RConditionComponent::~RConditionComponent */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101533.43">void RConditionComponent::_init
                      (const RConditionComponent *pConditionComponent)
{
    this-&gt;keyType = R_VARIABLE_TIME;
    this-&gt;RValueTable::setKeyName (RVariable::getName (this-&gt;getKeyType()));
    this-&gt;RValueTable::setKeyUnits (RVariable::getUnits (this-&gt;getKeyType()));
    if (pConditionComponent)
    {
        this-&gt;keyType = pConditionComponent-&gt;keyType;
        this-&gt;type = pConditionComponent-&gt;type;
        this-&gt;enabled = pConditionComponent-&gt;enabled;
    }
} /* RConditionComponent::_init */


RVariableType RConditionComponent::getKeyType (void) const
{
    return this-&gt;keyType;
} /* RConditionComponent::get_key_type */


RVariableType RConditionComponent::getType (void) const
{
    return this-&gt;type;
} /* RConditionComponent::get_type */


</t>
<t tx="leo.20201108101533.44">void RConditionComponent::setType (RVariableType type, bool clearContent)
{
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID(type));

    this-&gt;type = type;
    this-&gt;RValueTable::setValueName (RVariable::getName (type));
    this-&gt;RValueTable::setValueUnits (RVariable::getUnits (type));
    if (clearContent)
    {
        this-&gt;clear ();
        this-&gt;add (RVariable::getInitValue (this-&gt;getKeyType()),
                   RVariable::getInitValue (this-&gt;type));
    }
} /* RConditionComponent::setType */


</t>
<t tx="leo.20201108101533.45">const QString &amp;RConditionComponent::getName(void) const
{
    return this-&gt;getValueName ();
} /* RConditionComponent::get_name */


</t>
<t tx="leo.20201108101533.46">void RConditionComponent::setName (const QString &amp;name)
{
    this-&gt;RValueTable::setValueName (name);
} /* RConditionComponent::set_name */


</t>
<t tx="leo.20201108101533.47">const QString &amp;RConditionComponent::getUnits(void) const
{
    return this-&gt;getValueUnits ();
} /* RConditionComponent::get_units */


</t>
<t tx="leo.20201108101533.48">void RConditionComponent::setUnits (const QString &amp;units)
{
    this-&gt;RValueTable::setValueUnits (units);
} /* RConditionComponent::set_units */


RConditionComponent &amp; RConditionComponent::operator =
                       (const RConditionComponent &amp;conditionComponent)
{
    this-&gt;RValueTable::operator = (conditionComponent);
    this-&gt;_init (&amp;conditionComponent);
    return (*this);
} /* RConditionComponent::operator = */
</t>
<t tx="leo.20201108101533.49">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_cut.cpp                                              *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Cut class definition                                *
 *********************************************************************/

#include "rml_cut.h"

const QString RCut::defaultName("Cut");

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101533.5">typedef struct _RBoundaryConditionDesc
{
    QString          id;
    QString          name;
    bool             optional;
    bool             isExplicit;
    bool             applyOnPoint;
    bool             applyOnLine;
    bool             applyOnSurface;
    bool             applyOnVolume;
    bool             hasLocalDirections;
    RProblemTypeMask problemTypeMask;
} RBoundaryConditionDesc;

</t>
<t tx="leo.20201108101533.50">void RCut::_init(const RCut *pCut)
{
    if (pCut)
    {
        this-&gt;plane = pCut-&gt;plane;
        this-&gt;elementGroupIDs = pCut-&gt;elementGroupIDs;
    }
}

RCut::RCut()
{
    this-&gt;name = RCut::defaultName;
    this-&gt;_init();
}

RCut::RCut(const RCut &amp;cut)
    : RInterpolatedEntity(cut)
{
    this-&gt;_init(&amp;cut);
}

RCut::~RCut()
{
}

RCut &amp;RCut::operator =(const RCut &amp;cut)
{
    this-&gt;RInterpolatedEntity::operator = (cut);
    this-&gt;_init(&amp;cut);
    return (*this);
}

</t>
<t tx="leo.20201108101533.51">const RPlane &amp;RCut::getPlane(void) const
{
    return this-&gt;plane;
}

RPlane &amp;RCut::getPlane(void)
{
    return this-&gt;plane;
}

</t>
<t tx="leo.20201108101533.52">void RCut::setPlane(const RPlane &amp;plane)
{
    this-&gt;plane = plane;
}

</t>
<t tx="leo.20201108101533.53">const std::vector&lt;uint&gt; &amp;RCut::getElementGroupIDs(void) const
{
    return this-&gt;elementGroupIDs;
}

std::vector&lt;uint&gt; &amp;RCut::getElementGroupIDs(void)
{
    return this-&gt;elementGroupIDs;
}

</t>
<t tx="leo.20201108101533.54">bool RCut::addElementGroupID(uint elementGroupID)
{
    if (std::find(this-&gt;elementGroupIDs.begin(),this-&gt;elementGroupIDs.end(),elementGroupID) != this-&gt;elementGroupIDs.end())
    {
        return false;
    }

    this-&gt;elementGroupIDs.push_back(elementGroupID);

    std::sort(this-&gt;elementGroupIDs.begin(),this-&gt;elementGroupIDs.end());

    return true;
}

</t>
<t tx="leo.20201108101533.55">bool RCut::removeElementGroupID(uint elementGroupID, bool decrement)
{
    bool removed = false;
    std::vector&lt;uint&gt;::iterator iter = std::find(this-&gt;elementGroupIDs.begin(),this-&gt;elementGroupIDs.end(),elementGroupID);
    if (iter != this-&gt;elementGroupIDs.end())
    {
        this-&gt;elementGroupIDs.erase(iter);
        removed = true;
    }
    if (decrement)
    {
        for (uint i=0;i&lt;this-&gt;elementGroupIDs.size();i++)
        {
            if (this-&gt;elementGroupIDs[i] &gt; elementGroupID)
            {
                this-&gt;elementGroupIDs[i]--;
            }
        }
    }
    return removed;
}

</t>
<t tx="leo.20201108101533.56">void RCut::clearElementGroupIDs(void)
{
    this-&gt;elementGroupIDs.clear();
}
</t>
<t tx="leo.20201108101533.57">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_eigen_value_solver_conf.cpp                          *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   1-st July 2015                                           *
 *                                                                   *
 *  DESCRIPTION: Eigen value solver class definition                 *
 *********************************************************************/


#include "rml_eigen_value_solver_conf.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101533.58">typedef struct _REigenValueSolverDesc
{
    QString name;
} REigenValueSolverDesc;

</t>
<t tx="leo.20201108101533.59">static REigenValueSolverDesc eigenValueSolverDesc [] =
{
    { "None" },
    { "Lanczos" },
    { "Arnoldi" },
    { "Rayleigh" }
};


</t>
<t tx="leo.20201108101533.6">const RBoundaryConditionDesc boundaryConditionDesc [] =
{
    /* ID, Name, optional, explicit, point, line, surface, volume, has local direction */
    { "bc-none", "None", false, false, false, false, false, false, false, R_PROBLEM_NONE },
    { "bc-absorbing_boundary", "Absorbing boundary", false, false, true, true, true, true, false, R_PROBLEM_ACOUSTICS | R_PROBLEM_WAVE},
    { "bc-charge_density", "Charge density", false, false, true, true, true, true, false, R_PROBLEM_ELECTROSTATICS },
    { "bc-forced_convection", "Forced convection", false, false, false, false, true, false, false, R_PROBLEM_HEAT },
    { "bc-natural_convection", "Natural convection", false, false, false, false, true, false, false, R_PROBLEM_HEAT },
    { "bc-simple_convection", "Simple convection", false, false, false, false, true, false, false, R_PROBLEM_HEAT },
    { "bc-displacement", "Displacement", true, true, true, true, true, true, false, R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "bc-normal_displacement", "Normal displacement", false, true, false, false, true, false, true, R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "bc-roller_displacement", "Roller displacement", false, true, true, true, true, false, true, R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "bc-electric_potential", "Electric potential", false, true, true, true, true, true, false, R_PROBLEM_ELECTROSTATICS },
    { "bc-force", "Force", false, false, true, true, true, false, false, R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "bc-force_ua", "Force (unit area)", false, false, false, false, true, false, false, R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "bc-heat", "Heat", false, false, true, true, true, true, false, R_PROBLEM_HEAT | R_PROBLEM_FLUID_HEAT },
    { "bc-heat_rate_ua", "Heat rate (unit area)", false, false, false, false, true, false, false, R_PROBLEM_HEAT | R_PROBLEM_FLUID_HEAT },
    { "bc-heat_rate_uv", "Heat rate (unit volume)", false, false, false, false, false, true, false, R_PROBLEM_HEAT | R_PROBLEM_FLUID_HEAT },
    { "bc-velocity_outflow", "Velocity (inflow)", false, true, false, false, true, false, false, R_PROBLEM_FLUID | R_PROBLEM_POTENTIAL },
    { "bc-volumetric_flow_rate", "Volumetric flow rate (inflow)", false, true, false, false, true, false, false, R_PROBLEM_FLUID | R_PROBLEM_POTENTIAL },
    { "bc-particle_concentration", "Particle concentration", false, true, true, true, true, false, false, R_PROBLEM_FLUID_PARTICLE },
    { "bc-particle_rate", "Particle rate", false, false, true, true, true, true, false, R_PROBLEM_FLUID_PARTICLE },
    { "bc-pressure", "Pressure", false, false, false, false, true, false, false, R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "bc-pressure_explicit", "Pressure (explicit)", false, true, false, false, true, false, false, R_PROBLEM_FLUID | R_PROBLEM_POTENTIAL },
    { "bc-pressure_implicit", "Pressure (implicit)", false, false, false, false, true, false, false, R_PROBLEM_FLUID | R_PROBLEM_POTENTIAL },
    { "bc-radiation_boundary", "Radiation boundary", false, false, false, false, true, false, false, R_PROBLEM_RADIATIVE_HEAT },
    { "bc-temperature", "Temperature", false, true, true, true, true, true, false, R_PROBLEM_HEAT | R_PROBLEM_FLUID_HEAT },
    { "bc-velocity", "Velocity", false, false, false, false, true, false, false, R_PROBLEM_ACOUSTICS },
    { "bc-velocity_potential", "Velocity potential", false, true, true, true, true, false, false, R_PROBLEM_ACOUSTICS },
    { "bc-wall", "Wall", false, true, true, true, true, false, false, R_PROBLEM_FLUID },
    { "bc-wall_frictionless", "Wall (frictionless)", false, true, true, true, true, false, false, R_PROBLEM_FLUID },
    { "bc-wave_displacement", "Wave displacement", false, true, true, true, true, true, false, R_PROBLEM_WAVE },
    { "bc-weight", "Weight", false, false, true, true, true, false, false, R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "bc-custom", "Custom", false, false, false, false, false, false, false, R_PROBLEM_NONE }
};


RBoundaryCondition::RBoundaryCondition (RBoundaryConditionType type)
    : direction(0.0,0.0,1.0)
{
    this-&gt;setType(type);
    this-&gt;_init();
} /* RBoundaryCondition::RBoundaryCondition */


RBoundaryCondition::RBoundaryCondition
                                 (const RBoundaryCondition &amp;condition)
                                              : RCondition (condition)
{
    this-&gt;_init (&amp;condition);
} /* RBoundaryCondition::RBoundaryCondition (copy) */


RBoundaryCondition::~RBoundaryCondition ()
{
} /* RBoundaryCondition::~RBoundaryCondition */


</t>
<t tx="leo.20201108101533.60">void REigenValueSolverConf::_init(const REigenValueSolverConf *pEigenValueSolverConf)
{
    if (pEigenValueSolverConf)
    {
        this-&gt;method = pEigenValueSolverConf-&gt;method;
        this-&gt;nIterations = pEigenValueSolverConf-&gt;nIterations;
        this-&gt;nEigenValues = pEigenValueSolverConf-&gt;nEigenValues;
        this-&gt;solverCvgValue = pEigenValueSolverConf-&gt;solverCvgValue;
        this-&gt;outputFrequency = pEigenValueSolverConf-&gt;outputFrequency;
    }
}

REigenValueSolverConf::REigenValueSolverConf(REigenValueSolverConf::Method method)
    : method(method)
{
    this-&gt;_init();
}

REigenValueSolverConf::REigenValueSolverConf(const REigenValueSolverConf &amp;eigenValueSolverConf)
{
    this-&gt;_init(&amp;eigenValueSolverConf);
}

REigenValueSolverConf::~REigenValueSolverConf()
{

}

REigenValueSolverConf &amp;REigenValueSolverConf::operator =(const REigenValueSolverConf &amp;eigenValueSolverConf)
{
    this-&gt;_init(&amp;eigenValueSolverConf);
    return (*this);
}

REigenValueSolverConf::Method REigenValueSolverConf::getMethod(void) const
{
    return this-&gt;method;
}

</t>
<t tx="leo.20201108101533.61">void REigenValueSolverConf::setMethod(REigenValueSolverConf::Method method)
{
    this-&gt;method = method;
}

</t>
<t tx="leo.20201108101533.62">unsigned int REigenValueSolverConf::getNIterations(void) const
{
    return this-&gt;nIterations;
}

</t>
<t tx="leo.20201108101533.63">void REigenValueSolverConf::setNIterations(unsigned int nIterations)
{
    this-&gt;nIterations = nIterations;
}

</t>
<t tx="leo.20201108101533.64">unsigned int REigenValueSolverConf::getNEigenValues(void) const
{
    return this-&gt;nEigenValues;
}

</t>
<t tx="leo.20201108101533.65">void REigenValueSolverConf::setNEigenValues(unsigned int nEigenValues)
{
    this-&gt;nEigenValues = nEigenValues;
}

double REigenValueSolverConf::getSolverCvgValue(void) const
{
    return this-&gt;solverCvgValue;
}

</t>
<t tx="leo.20201108101533.66">void REigenValueSolverConf::setSolverCvgValue(double solverCvgValue)
{
    this-&gt;solverCvgValue = solverCvgValue;
}

</t>
<t tx="leo.20201108101533.67">unsigned int REigenValueSolverConf::getOutputFrequency(void) const
{
    return this-&gt;outputFrequency;
}

</t>
<t tx="leo.20201108101533.68">void REigenValueSolverConf::setOutputFrequency(unsigned int outputFrequency)
{
    this-&gt;outputFrequency = outputFrequency;
}

</t>
<t tx="leo.20201108101533.69">const QString &amp;REigenValueSolverConf::getOutputFileName(void) const
{
    return this-&gt;outputFileName;
}

</t>
<t tx="leo.20201108101533.7">void RBoundaryCondition::_init (const RBoundaryCondition *pCondition)
{
    if (pCondition)
    {
        this-&gt;type = pCondition-&gt;type;
        this-&gt;optional = pCondition-&gt;optional;
        this-&gt;isExplicit = pCondition-&gt;isExplicit;
        this-&gt;hasLocalDirection = pCondition-&gt;hasLocalDirection;
        this-&gt;direction = pCondition-&gt;direction;
    }
} /* RBoundaryCondition::_init */


RBoundaryConditionType RBoundaryCondition::getType(void) const
{
    return this-&gt;type;
} /* RBoundaryCondition::get_type */


</t>
<t tx="leo.20201108101533.70">void REigenValueSolverConf::setOutputFileName(const QString &amp;outputFileName)
{
    this-&gt;outputFileName = outputFileName;
}

</t>
<t tx="leo.20201108101533.71">const QString &amp;REigenValueSolverConf::getName(REigenValueSolverConf::Method method)
{
    return eigenValueSolverDesc[method].name;
}
</t>
<t tx="leo.20201108101533.72">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_element.cpp                                          *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th December 2011                                       *
 *                                                                   *
 *  DESCRIPTION: Element class definition                            *
 *********************************************************************/

#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;cmath&gt;

#include "rml_element.h"
#include "rml_element_shape_function.h"
#include "rml_interpolated_element.h"
#include "rml_triangle.h"
#include "rml_tetrahedron.h"
#include "rml_triangulate.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101533.73">typedef struct _RElementDesc
{
    QString                            id;
    QString                            name;
    unsigned int                       nNodes;
    unsigned int                       nNeighbors;
    std::vector&lt;RElementShapeFunction&gt; shapeFunctions;
    RRMatrix                           M;
    RRVector                           m;
    double                             wt;
    bool                               constantDerivative;
} RElementDesc;

</t>
<t tx="leo.20201108101533.74">static const RElementDesc elementDesc [] =
{
    {
        "elem-none",
        "None",
        0,
        0,
        RElement::generateShapeFunctionValues(R_ELEMENT_NONE),
        RElement::generateMassMatrix(R_ELEMENT_NONE),
        RElement::generateMassVector(R_ELEMENT_NONE),
        RElement::generateTotalWeightFactor(R_ELEMENT_NONE),
        false
    },
    {
        "elem-point",
        "Point",
        1,
        0,
        RElement::generateShapeFunctionValues(R_ELEMENT_POINT),
        RElement::generateMassMatrix(R_ELEMENT_POINT),
        RElement::generateMassVector(R_ELEMENT_POINT),
        RElement::generateTotalWeightFactor(R_ELEMENT_POINT),
        false
    },
    {
        "elem-truss1",
        "Truss1",
        2,
        2,
        RElement::generateShapeFunctionValues(R_ELEMENT_TRUSS1),
        RElement::generateMassMatrix(R_ELEMENT_TRUSS1),
        RElement::generateMassVector(R_ELEMENT_TRUSS1),
        RElement::generateTotalWeightFactor(R_ELEMENT_TRUSS1),
        true
    },
    {
        "elem-truss2",
        "Truss2",
        3,
        2,
        RElement::generateShapeFunctionValues(R_ELEMENT_TRUSS2),
        RElement::generateMassMatrix(R_ELEMENT_TRUSS2),
        RElement::generateMassVector(R_ELEMENT_TRUSS2),
        RElement::generateTotalWeightFactor(R_ELEMENT_TRUSS2),
        false
    },
    {
        "elem-beam1",
        "Beam1",
        2,
        2,
        RElement::generateShapeFunctionValues(R_ELEMENT_BEAM1),
        RElement::generateMassMatrix(R_ELEMENT_BEAM1),
        RElement::generateMassVector(R_ELEMENT_BEAM1),
        RElement::generateTotalWeightFactor(R_ELEMENT_BEAM1),
        false
    },
    {
        "elem-beam2",
        "Beam2",
        3,
        2,
        RElement::generateShapeFunctionValues(R_ELEMENT_BEAM2),
        RElement::generateMassMatrix(R_ELEMENT_BEAM2),
        RElement::generateMassVector(R_ELEMENT_BEAM2),
        RElement::generateTotalWeightFactor(R_ELEMENT_BEAM2),
        false
    },
    {
        "elem-triangle1",
        "Triangle1",
        3,
        3,
        RElement::generateShapeFunctionValues(R_ELEMENT_TRI1),
        RElement::generateMassMatrix(R_ELEMENT_TRI1),
        RElement::generateMassVector(R_ELEMENT_TRI1),
        RElement::generateTotalWeightFactor(R_ELEMENT_TRI1),
        true
    },
    {
        "elem-triangle2",
        "Triangle2",
        6,
        3,
        RElement::generateShapeFunctionValues(R_ELEMENT_TRI2),
        RElement::generateMassMatrix(R_ELEMENT_TRI2),
        RElement::generateMassVector(R_ELEMENT_TRI2),
        RElement::generateTotalWeightFactor(R_ELEMENT_TRI2),
        false
    },
    {
        "elem-1uadrilateral1",
        "Quadrilateral1",
        4,
        4,
        RElement::generateShapeFunctionValues(R_ELEMENT_QUAD1),
        RElement::generateMassMatrix(R_ELEMENT_QUAD1),
        RElement::generateMassVector(R_ELEMENT_QUAD1),
        RElement::generateTotalWeightFactor(R_ELEMENT_QUAD1),
        false
    },
    {
        "elem-quadrilateral2",
        "Quadrilateral2",
        9,
        4,
        RElement::generateShapeFunctionValues(R_ELEMENT_QUAD2),
        RElement::generateMassMatrix(R_ELEMENT_QUAD2),
        RElement::generateMassVector(R_ELEMENT_QUAD2),
        RElement::generateTotalWeightFactor(R_ELEMENT_QUAD2),
        false
    },
    {
        "elem-tetrahedron1",
        "Tetrahedron1",
        4,
        4,
        RElement::generateShapeFunctionValues(R_ELEMENT_TETRA1),
        RElement::generateMassMatrix(R_ELEMENT_TETRA1),
        RElement::generateMassVector(R_ELEMENT_TETRA1),
        RElement::generateTotalWeightFactor(R_ELEMENT_TETRA1),
        true
    },
    {
        "elem-wedge1",
        "Wedge1",
        6,
        5,
        RElement::generateShapeFunctionValues(R_ELEMENT_WEDGE1),
        RElement::generateMassMatrix(R_ELEMENT_WEDGE1),
        RElement::generateMassVector(R_ELEMENT_WEDGE1),
        RElement::generateTotalWeightFactor(R_ELEMENT_WEDGE1),
        false
    },
    {
        "elem-hexahedron1",
        "Hexahedron1",
        8,
        6,
        RElement::generateShapeFunctionValues(R_ELEMENT_HEXA1),
        RElement::generateMassMatrix(R_ELEMENT_HEXA1),
        RElement::generateMassVector(R_ELEMENT_HEXA1),
        RElement::generateTotalWeightFactor(R_ELEMENT_HEXA1),
        false
    }
};


RElement::RElement (RElementType type)
{
    this-&gt;setType (type);
    this-&gt;_init ();
} /* RElement::RElement */


RElement::RElement (const RElement &amp;element)
{
    this-&gt;_init (&amp;element);
} /* RElement::RElement */


RElement::~RElement ()
{
} /* RElement::~RElement */


</t>
<t tx="leo.20201108101533.75">void RElement::_init (const RElement *element)
{
    if (element)
    {
        this-&gt;setType (element-&gt;getType());
        for (unsigned int i=0;i&lt;this-&gt;size ();i++)
        {
            this-&gt;setNodeId (i, element-&gt;getNodeId(i));
        }
    }
} /* RElement::_init */


RElement &amp; RElement::operator = (const RElement &amp;element)
{
    this-&gt;_init (&amp;element);
    return (*this);
} /* RElement::operator = */


</t>
<t tx="leo.20201108101533.76">bool RElement::operator ==(const RElement &amp;element) const
{
    if (this-&gt;type != element.type)
    {
        return false;
    }
    for (uint i=0;i&lt;this-&gt;nodeIDs.size();i++)
    {
        bool nodeFound = false;
        for (uint j=0;j&lt;element.nodeIDs.size();j++)
        {
            if (this-&gt;nodeIDs[i] == element.nodeIDs[j])
            {
                nodeFound = true;
                break;
            }
        }
        if (!nodeFound)
        {
            return false;
        }
    }
    return true;
} /* RElement::operator == */

</t>
<t tx="leo.20201108101533.77">bool RElement::operator &lt;(const RElement &amp;element) const
{
    if (this-&gt;type &lt; element.type)
    {
        return true;
    }
    else if (this-&gt;type &gt; element.type)
    {
        return false;
    }

    std::vector&lt;uint&gt; n1Nodes(this-&gt;nodeIDs);
    std::vector&lt;uint&gt; n2Nodes(element.nodeIDs);

    std::sort(n1Nodes.begin(),n1Nodes.end());
    std::sort(n2Nodes.begin(),n2Nodes.end());

    for (uint i=0;i&lt;n1Nodes.size();i++)
    {
        if (n1Nodes[i] &lt; n2Nodes[i])
        {
            return true;
        }
        else if (n1Nodes[i] &gt; n2Nodes[i])
        {
            return false;
        }
    }

    return false;
} /* RElement::operator &lt; */


RElementType RElement::getType (void) const
{
    return this-&gt;type;
} /* RElement::getType */


</t>
<t tx="leo.20201108101533.78">void RElement::setType (RElementType type)
{
    R_ERROR_ASSERT (R_ELEMENT_TYPE_IS_VALID (type));

    this-&gt;type = type;
    this-&gt;nodeIDs.resize (RElement::getNNodes(type));
} /* RElement::setType */


</t>
<t tx="leo.20201108101533.79">unsigned int RElement::size (void) const
{
    return static_cast&lt;unsigned int&gt;(this-&gt;nodeIDs.size());
} /* RElement::size */


</t>
<t tx="leo.20201108101533.8">void RBoundaryCondition::setType(RBoundaryConditionType type)
{
    std::vector&lt;RVariableType&gt; componentTypes;
    RConditionComponent component;

    this-&gt;setTypeSafe(type);
    this-&gt;clear();

    componentTypes = RBoundaryCondition::getDefaultComponents(type);

    for (unsigned int i=0;i&lt;componentTypes.size();i++)
    {
        component.setType(componentTypes[i]);
        this-&gt;addComponent(component);
    }
} /* RBoundaryCondition::set_type */


</t>
<t tx="leo.20201108101533.80">unsigned int RElement::getNodeId (unsigned int position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;nodeIDs.size());

    return this-&gt;nodeIDs[position];
} /* RElement::getNodeId */


</t>
<t tx="leo.20201108101533.81">void RElement::setNodeId (unsigned int position,
                            unsigned int nodeID)
{
    R_ERROR_ASSERT (position &lt; this-&gt;nodeIDs.size());
    this-&gt;nodeIDs[position] = nodeID;
} /* RElement::setNodeId */


</t>
<t tx="leo.20201108101533.82">void RElement::swapNodeIds(unsigned int position1, unsigned int position2)
{
    R_ERROR_ASSERT (position1 &lt; this-&gt;nodeIDs.size());
    R_ERROR_ASSERT (position2 &lt; this-&gt;nodeIDs.size());
    std::swap(this-&gt;nodeIDs[position1],this-&gt;nodeIDs[position2]);
} /* RElement::swapNodeIds */


</t>
<t tx="leo.20201108101533.83">bool RElement::hasNodeId (unsigned int nodeID) const
{
    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        if (nodeID == this-&gt;getNodeId(i))
        {
           return true;
        }
    }
    return false;
} /* RElement::hasNodeId */


</t>
<t tx="leo.20201108101533.84">bool RElement::hasDuplicateNodes(void) const
{
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        for (uint j=i+1;j&lt;this-&gt;size();j++)
        {
            if (this-&gt;getNodeId(i) == this-&gt;getNodeId(j))
            {
                return true;
            }
        }
    }

    return false;
} /* RElement::hasDuplicateNodes */


</t>
<t tx="leo.20201108101533.85">bool RElement::swapNormal(void)
{
    if (!R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getType()))
    {
        return false;
    }

    if (this-&gt;getType() == R_ELEMENT_TRI1 ||
        this-&gt;getType() == R_ELEMENT_TRI2)
    {
        std::swap(this-&gt;nodeIDs[0],this-&gt;nodeIDs[1]);
    }
    else if (this-&gt;getType() == R_ELEMENT_QUAD1 ||
             this-&gt;getType() == R_ELEMENT_QUAD2)
    {
        std::swap(this-&gt;nodeIDs[1],this-&gt;nodeIDs[3]);
    }

    return true;
} /* RElement::swapNormal */


</t>
<t tx="leo.20201108101533.86">bool RElement::findNormal(const std::vector&lt;RNode&gt; &amp;nodes, double &amp;nx, double &amp;ny, double &amp;nz) const
{
    if (!R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getType()))
    {
        return false;
    }

    if (this-&gt;getType() == R_ELEMENT_TRI1 ||
        this-&gt;getType() == R_ELEMENT_TRI2)
    {
        RTriangle triangle(nodes[this-&gt;getNodeId(0)],
                           nodes[this-&gt;getNodeId(1)],
                           nodes[this-&gt;getNodeId(2)]);
        nx = triangle.getNormal()[0];
        ny = triangle.getNormal()[1];
        nz = triangle.getNormal()[2];
    }
    if (this-&gt;getType() == R_ELEMENT_QUAD1 ||
        this-&gt;getType() == R_ELEMENT_QUAD2)
    {
        RTriangle triangle1(nodes[this-&gt;getNodeId(0)],
                            nodes[this-&gt;getNodeId(1)],
                            nodes[this-&gt;getNodeId(2)]);
        RTriangle triangle2(nodes[this-&gt;getNodeId(2)],
                            nodes[this-&gt;getNodeId(3)],
                            nodes[this-&gt;getNodeId(0)]);
        nx = (triangle1.getNormal()[0] + triangle2.getNormal()[0])/2.0;
        ny = (triangle1.getNormal()[1] + triangle2.getNormal()[1])/2.0;
        nz = (triangle1.getNormal()[2] + triangle2.getNormal()[2])/2.0;
    }

    return true;
} /* RElement::findNormal */


</t>
<t tx="leo.20201108101533.87">void RElement::findCenter(const std::vector&lt;RNode&gt; &amp;nodes, double &amp;cx, double &amp;cy, double &amp;cz) const
{
    cx = cy = cz = 0.0;

    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        cx += nodes[this-&gt;getNodeId(i)].getX();
        cy += nodes[this-&gt;getNodeId(i)].getY();
        cz += nodes[this-&gt;getNodeId(i)].getZ();
    }

    if (this-&gt;size() &gt; 0)
    {
        cx /= double(this-&gt;size());
        cy /= double(this-&gt;size());
        cz /= double(this-&gt;size());
    }
} /* RElement::findCenter */


</t>
<t tx="leo.20201108101533.88">bool RElement::findShortestEdge(const std::vector&lt;RNode&gt; &amp;nodes, double &amp;length, uint &amp;node1, uint &amp;node2) const
{
    if (!R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getType()))
    {
        return false;
    }

    switch (this-&gt;getType())
    {
        case R_ELEMENT_TRI1:
        case R_ELEMENT_TRI2:
        {
            const RNode &amp;n1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;n2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;n3 = nodes[this-&gt;getNodeId(2)];

            double l1 = n1.getDistance(n2);
            double l2 = n2.getDistance(n3);
            double l3 = n3.getDistance(n1);

            length = l1;
            node1 = 0;
            node2 = 1;

            if (l2 &lt; length)
            {
                length = l2;
                node1 = 1;
                node2 = 2;
            }
            if (l3 &lt; length)
            {
                length = l3;
                node1 = 2;
                node2 = 0;
            }

            break;
        }
        case R_ELEMENT_QUAD1:
        case R_ELEMENT_QUAD2:
        {
            const RNode &amp;n1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;n2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;n3 = nodes[this-&gt;getNodeId(2)];
            const RNode &amp;n4 = nodes[this-&gt;getNodeId(3)];

            double l1 = n1.getDistance(n2);
            double l2 = n2.getDistance(n3);
            double l3 = n3.getDistance(n4);
            double l4 = n4.getDistance(n1);

            length = l1;
            node1 = 0;
            node2 = 1;

            if (l2 &lt; length)
            {
                length = l2;
                node1 = 1;
                node2 = 2;
            }
            if (l3 &lt; length)
            {
                length = l3;
                node1 = 2;
                node2 = 3;
            }
            if (l4 &lt; length)
            {
                length = l4;
                node1 = 3;
                node2 = 0;
            }

            break;
        }
        default:
        {
            return false;
        }
    }

    return true;
} /* RElement::findShortestEdge */


</t>
<t tx="leo.20201108101533.89">bool RElement::findLength(const std::vector&lt;RNode&gt; &amp;nodes, double &amp;length) const
{
    if (!R_ELEMENT_TYPE_IS_LINE(this-&gt;getType()))
    {
        return false;
    }

    length = nodes[this-&gt;getNodeId(0)].getDistance(nodes[this-&gt;getNodeId(1)]);

    return true;
} /* RElement::findLength */


</t>
<t tx="leo.20201108101533.9">void RBoundaryCondition::setTypeSafe(RBoundaryConditionType type)
{
    this-&gt;type = type;
    this-&gt;name = RBoundaryCondition::getName(type);
    this-&gt;optional = RBoundaryCondition::getOptional(type);
    this-&gt;isExplicit = RBoundaryCondition::getExplicit(type);
    this-&gt;applyOnPoint = RBoundaryCondition::getApplyOnPoint(type);
    this-&gt;applyOnLine = RBoundaryCondition::getApplyOnLine(type);
    this-&gt;applyOnSurface = RBoundaryCondition::getApplyOnSurface(type);
    this-&gt;applyOnVolume = RBoundaryCondition::getApplyOnVolume(type);
    this-&gt;hasLocalDirection = RBoundaryCondition::getHasLocalDirection(type);
    this-&gt;problemTypeMask = RBoundaryCondition::getProblemTypeMask(type);
} /* RBoundaryCondition::set_type_safe */


</t>
<t tx="leo.20201108101533.90">bool RElement::findArea(const std::vector&lt;RNode&gt; &amp;nodes, double &amp;area) const
{
    if (!R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getType()))
    {
        return false;
    }

    if (this-&gt;getType() == R_ELEMENT_TRI1 ||
        this-&gt;getType() == R_ELEMENT_TRI2)
    {
        RTriangle triangle(nodes[this-&gt;getNodeId(0)],
                           nodes[this-&gt;getNodeId(1)],
                           nodes[this-&gt;getNodeId(2)]);
        area = triangle.findArea();
    }
    if (this-&gt;getType() == R_ELEMENT_QUAD1 ||
        this-&gt;getType() == R_ELEMENT_QUAD2)
    {
        RTriangle triangle1(nodes[this-&gt;getNodeId(0)],
                            nodes[this-&gt;getNodeId(1)],
                            nodes[this-&gt;getNodeId(2)]);
        RTriangle triangle2(nodes[this-&gt;getNodeId(2)],
                            nodes[this-&gt;getNodeId(3)],
                            nodes[this-&gt;getNodeId(0)]);
        area = triangle1.findArea() + triangle2.findArea();
    }

    return true;
} /* RElement::findArea */


</t>
<t tx="leo.20201108101533.91">bool RElement::findVolume(const std::vector&lt;RNode&gt; &amp;nodes, double &amp;volume) const
{
    if (!R_ELEMENT_TYPE_IS_VOLUME(this-&gt;getType()))
    {
        return false;
    }

    if (this-&gt;getType() == R_ELEMENT_TETRA1)
    {
        const RNode &amp;n1 = nodes[this-&gt;getNodeId(0)];
        const RNode &amp;n2 = nodes[this-&gt;getNodeId(1)];
        const RNode &amp;n3 = nodes[this-&gt;getNodeId(2)];
        const RNode &amp;n4 = nodes[this-&gt;getNodeId(3)];
        volume = RTetrahedron::findVolume(n1,n2,n3,n4);
    }

    return true;
} /* RElement::findVolume */


double RElement::findSize(const std::vector&lt;RNode&gt; &amp;nodes) const
{
    double elementSize = 0.0;

    if (R_ELEMENT_TYPE_IS_POINT(this-&gt;type))
    {
        elementSize = 0.0;
    }
    else if (R_ELEMENT_TYPE_IS_LINE(this-&gt;type))
    {
        double length = 0.0;
        if (this-&gt;findLength(nodes,length))
        {
            elementSize = length;
        }
    }
    else if (R_ELEMENT_TYPE_IS_SURFACE(this-&gt;type))
    {
        double area = 0.0;
        if (this-&gt;findArea(nodes,area))
        {
            if (this-&gt;type == R_ELEMENT_TRI1 || this-&gt;type == R_ELEMENT_TRI2)
            {
                elementSize = std::sqrt(2.0*area / RConstants::pi);
            }
            else if (this-&gt;type == R_ELEMENT_QUAD1 || this-&gt;type == R_ELEMENT_QUAD2)
            {
                elementSize = std::sqrt(area);
            }
        }
    }
    else if (R_ELEMENT_TYPE_IS_VOLUME(this-&gt;type))
    {
        double volume = 0.0;
        if (this-&gt;findVolume(nodes,volume))
        {
            if (this-&gt;type == R_ELEMENT_TETRA1)
            {
                elementSize = std::pow(6.0 * volume / RConstants::pi, 1.0/3.0);
            }
            else if (this-&gt;type == R_ELEMENT_HEXA1)
            {
                elementSize = std::pow(volume, 1.0/3.0);
            }
        }
    }
    return elementSize;
} /* RElement::findSize */

</t>
<t tx="leo.20201108101533.92">bool RElement::findPickDistance(const std::vector&lt;RNode&gt; &amp;nodes,
                                const RR3Vector &amp;position,
                                const RR3Vector &amp;direction,
                                double tolerance,
                                double &amp;distance) const
{
    if (R_ELEMENT_TYPE_IS_POINT(this-&gt;type))
    {
        const RNode &amp;node = nodes[this-&gt;getNodeId(0)];
        RSegment s(RNode(position),RNode(position[0]+direction[0],position[1]+direction[1],position[2]+direction[2]));
        double u = s.findPointDistance(node.toVector());
        if (u &lt;= tolerance)
        {
            double lp = node.getDistance(RNode(position));
            distance = std::sqrt(lp*lp-u*u);
            return true;
        }
    }
    else if (R_ELEMENT_TYPE_IS_LINE(this-&gt;type))
    {
        std::vector&lt;RSegment&gt; segments = this-&gt;segmentize(nodes);
        double d;
        bool found = false;
        for (uint i=0;i&lt;segments.size();i++)
        {
            d = segments[i].findSegmentDistance(position,direction);
            if (d &lt;= tolerance)
            {
                if (!found || d &lt; distance)
                {
                    distance = d;
                    found = true;
                }
            }
        }
        return found;
    }
    else if (R_ELEMENT_TYPE_IS_SURFACE(this-&gt;type))
    {
        std::vector&lt;RTriangle&gt; triangles = this-&gt;triangulate(nodes);
        for (uint i=0;i&lt;triangles.size();i++)
        {
            RR3Vector x;
            if (triangles[i].findLineIntersection(position,direction,x,distance))
            {
                return true;
            }
        }
    }
    else if (R_ELEMENT_TYPE_IS_VOLUME(this-&gt;type))
    {
        std::vector&lt;RElement&gt; edges = this-&gt;generateEdgeElements();

        double u;
        bool found = false;
        for (uint i=0;i&lt;edges.size();i++)
        {
            if (edges[i].findPickDistance(nodes,position,direction,tolerance,u))
            {
                if (!found || distance &gt; u)
                {
                    found = true;
                    distance = u;
                }
            }
        }
        return found;
    }
    return false;
} /* RElement::findPickDistance */


RInterpolatedElement RElement::createInterpolatedElement(const RPlane &amp;plane, const std::vector&lt;RNode&gt; &amp;nodes, unsigned int elementID) const
{
    RInterpolatedElement iElement;

    switch (this-&gt;getType())
    {
        case R_ELEMENT_TRUSS1:
        {
            const RNode &amp;node1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;node2 = nodes[this-&gt;getNodeId(1)];

            RR3Vector x;

            if (this-&gt;testPlaneIntersect(plane,nodes))
            {
                if (plane.findSegmentIntersection(node1.toVector(),node2.toVector(),x))
                {
                    iElement.push_back(RInterpolatedNode(elementID,x[0],x[1],x[2]));
                }
            }
            break;
        }
        case R_ELEMENT_TRI1:
        {
            const RNode &amp;node1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;node2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;node3 = nodes[this-&gt;getNodeId(2)];

            RR3Vector x;

            if (this-&gt;testPlaneIntersect(plane,nodes))
            {
                if (plane.findSegmentIntersection(node1.toVector(),node2.toVector(),x))
                {
                    iElement.push_back(RInterpolatedNode(elementID,x[0],x[1],x[2]));
                }

                if (plane.findSegmentIntersection(node2.toVector(),node3.toVector(),x))
                {
                    iElement.push_back(RInterpolatedNode(elementID,x[0],x[1],x[2]));
                }

                if (plane.findSegmentIntersection(node3.toVector(),node1.toVector(),x))
                {
                    iElement.push_back(RInterpolatedNode(elementID,x[0],x[1],x[2]));
                }
            }
            break;
        }
        case R_ELEMENT_TETRA1:
        {
            const RNode &amp;node1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;node2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;node3 = nodes[this-&gt;getNodeId(2)];
            const RNode &amp;node4 = nodes[this-&gt;getNodeId(3)];

            RR3Vector x;

            if (this-&gt;testPlaneIntersect(plane,nodes))
            {
                if (plane.findSegmentIntersection(node1.toVector(),node2.toVector(),x))
                {
                    iElement.push_back(RInterpolatedNode(elementID,x[0],x[1],x[2]));
                }

                if (plane.findSegmentIntersection(node1.toVector(),node3.toVector(),x))
                {
                    iElement.push_back(RInterpolatedNode(elementID,x[0],x[1],x[2]));
                }

                if (plane.findSegmentIntersection(node1.toVector(),node4.toVector(),x))
                {
                    iElement.push_back(RInterpolatedNode(elementID,x[0],x[1],x[2]));
                }

                if (plane.findSegmentIntersection(node2.toVector(),node3.toVector(),x))
                {
                    iElement.push_back(RInterpolatedNode(elementID,x[0],x[1],x[2]));
                }

                if (plane.findSegmentIntersection(node3.toVector(),node4.toVector(),x))
                {
                    iElement.push_back(RInterpolatedNode(elementID,x[0],x[1],x[2]));
                }

                if (plane.findSegmentIntersection(node4.toVector(),node2.toVector(),x))
                {
                    iElement.push_back(RInterpolatedNode(elementID,x[0],x[1],x[2]));
                }
            }
            iElement.sortNodes();
            break;
        }
        default:
        {
            break;
        }
    }

    return iElement;
} /* RElement::createInterpolatedElement */


RInterpolatedElement RElement::createInterpolatedElement(double value, const std::vector&lt;double&gt; &amp;nodeValues, const std::vector&lt;RNode&gt; &amp;nodes, unsigned int elementID) const
{
    RInterpolatedElement iElement;

    bool isBigger = false;
    bool isSmaller = false;
    for (unsigned int i=0;i&lt;nodeValues.size();i++)
    {
        if (value &lt;= nodeValues[i])
        {
            isSmaller = true;
        }
        if (value &gt;= nodeValues[i])
        {
            isBigger = true;
        }
    }
    if (!isSmaller || !isBigger)
    {
        return iElement;
    }

    switch (this-&gt;getType())
    {
        case R_ELEMENT_TRUSS1:
        {
            const RNode &amp;node1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;node2 = nodes[this-&gt;getNodeId(1)];

            double dist = nodeValues[1] - nodeValues[0];
            double ratio = (dist != 0.0) ? (value - nodeValues[0]) / dist : 0.0;
            if (ratio &gt;= 0.0 &amp;&amp; ratio &lt;= 1.0)
            {
                iElement.push_back(RInterpolatedNode(elementID,
                                                     ratio * (node2.getX() - node1.getX()) + node1.getX(),
                                                     ratio * (node2.getY() - node1.getY()) + node1.getY(),
                                                     ratio * (node2.getZ() - node1.getZ()) + node1.getZ()));
            }
            break;
        }
        case R_ELEMENT_TRI1:
        {
            const RNode &amp;node1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;node2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;node3 = nodes[this-&gt;getNodeId(2)];

            double dist = 0.0;
            double ratio = 0.0;

            dist = nodeValues[1] - nodeValues[0];
            ratio = (dist != 0.0) ? (value - nodeValues[0]) / dist : 0.0;
            if (ratio &gt; 0.0 &amp;&amp; ratio &lt;= 1.0)
            {
                iElement.push_back(RInterpolatedNode(elementID,
                                                     ratio * (node2.getX() - node1.getX()) + node1.getX(),
                                                     ratio * (node2.getY() - node1.getY()) + node1.getY(),
                                                     ratio * (node2.getZ() - node1.getZ()) + node1.getZ()));
            }

            dist = nodeValues[2] - nodeValues[1];
            ratio = (dist != 0.0) ? (value - nodeValues[1]) / dist : 0.0;
            if (ratio &gt; 0.0 &amp;&amp; ratio &lt;= 1.0)
            {
                iElement.push_back(RInterpolatedNode(elementID,
                                                     ratio * (node3.getX() - node2.getX()) + node2.getX(),
                                                     ratio * (node3.getY() - node2.getY()) + node2.getY(),
                                                     ratio * (node3.getZ() - node2.getZ()) + node2.getZ()));
            }

            dist = nodeValues[0] - nodeValues[2];
            ratio = (dist != 0.0) ? (value - nodeValues[2]) / dist : 0.0;
            if (ratio &gt; 0.0 &amp;&amp; ratio &lt;= 1.0)
            {
                iElement.push_back(RInterpolatedNode(elementID,
                                                     ratio * (node1.getX() - node3.getX()) + node3.getX(),
                                                     ratio * (node1.getY() - node3.getY()) + node3.getY(),
                                                     ratio * (node1.getZ() - node3.getZ()) + node3.getZ()));
            }
            break;
        }
        case R_ELEMENT_TETRA1:
        {
            const RNode &amp;node1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;node2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;node3 = nodes[this-&gt;getNodeId(2)];
            const RNode &amp;node4 = nodes[this-&gt;getNodeId(3)];

            double dist = 0.0;
            double ratio = 0.0;

            // 1 - 2
            dist = nodeValues[1] - nodeValues[0];
            ratio = (dist != 0.0) ? (value - nodeValues[0]) / dist : 0.0;
            if (ratio &gt; 0.0 &amp;&amp; ratio &lt;= 1.0)
            {
                iElement.push_back(RInterpolatedNode(elementID,
                                                     ratio * (node2.getX() - node1.getX()) + node1.getX(),
                                                     ratio * (node2.getY() - node1.getY()) + node1.getY(),
                                                     ratio * (node2.getZ() - node1.getZ()) + node1.getZ()));
            }

            // 1 - 3
            dist = nodeValues[2] - nodeValues[0];
            ratio = (dist != 0.0) ? (value - nodeValues[0]) / dist : 0.0;
            if (ratio &gt; 0.0 &amp;&amp; ratio &lt;= 1.0)
            {
                iElement.push_back(RInterpolatedNode(elementID,
                                                     ratio * (node3.getX() - node1.getX()) + node1.getX(),
                                                     ratio * (node3.getY() - node1.getY()) + node1.getY(),
                                                     ratio * (node3.getZ() - node1.getZ()) + node1.getZ()));
            }

            // 1 - 4
            dist = nodeValues[3] - nodeValues[0];
            ratio = (dist != 0.0) ? (value - nodeValues[0]) / dist : 0.0;
            if (ratio &gt; 0.0 &amp;&amp; ratio &lt;= 1.0)
            {
                iElement.push_back(RInterpolatedNode(elementID,
                                                     ratio * (node4.getX() - node1.getX()) + node1.getX(),
                                                     ratio * (node4.getY() - node1.getY()) + node1.getY(),
                                                     ratio * (node4.getZ() - node1.getZ()) + node1.getZ()));
            }

            // 2 - 3
            dist = nodeValues[2] - nodeValues[1];
            ratio = (dist != 0.0) ? (value - nodeValues[1]) / dist : 0.0;
            if (ratio &gt; 0.0 &amp;&amp; ratio &lt;= 1.0)
            {
                iElement.push_back(RInterpolatedNode(elementID,
                                                     ratio * (node3.getX() - node2.getX()) + node2.getX(),
                                                     ratio * (node3.getY() - node2.getY()) + node2.getY(),
                                                     ratio * (node3.getZ() - node2.getZ()) + node2.getZ()));
            }

            // 2 - 4
            ratio = (dist != 0.0) ? (value - nodeValues[1]) / dist : 0.0;
            if (ratio &gt; 0.0 &amp;&amp; ratio &lt;= 1.0)
            {
                iElement.push_back(RInterpolatedNode(elementID,
                                                     ratio * (node4.getX() - node2.getX()) + node2.getX(),
                                                     ratio * (node4.getY() - node2.getY()) + node2.getY(),
                                                     ratio * (node4.getZ() - node2.getZ()) + node2.getZ()));
            }

            // 3 - 4
            dist = nodeValues[3] - nodeValues[2];
            ratio = (dist != 0.0) ? (value - nodeValues[2]) / dist : 0.0;
            if (ratio &gt; 0.0 &amp;&amp; ratio &lt;= 1.0)
            {
                iElement.push_back(RInterpolatedNode(elementID,
                                                     ratio * (node4.getX() - node3.getX()) + node3.getX(),
                                                     ratio * (node4.getY() - node3.getY()) + node3.getY(),
                                                     ratio * (node4.getZ() - node3.getZ()) + node3.getZ()));
            }

            iElement.sortNodes();
            break;
        }
        default:
        {
            break;
        }
    }

    return iElement;
} /* RElement::createInterpolatedElement */


</t>
<t tx="leo.20201108101533.93">bool RElement::isInside(const std::vector&lt;RNode&gt; &amp;nodes, const RNode &amp;node) const
{
    RRVector volumes;
    return this-&gt;isInside(nodes,node,volumes);
} /* RElement::isInside */


</t>
<t tx="leo.20201108101533.94">bool RElement::isInside(const std::vector&lt;RNode&gt; &amp;nodes, const RNode &amp;node, RRVector &amp;volumes) const
{
    switch (this-&gt;getType())
    {
        case R_ELEMENT_POINT:
        {
            volumes.resize(0);
            return (std::abs(nodes[this-&gt;getNodeId(0)].getDistance(node)) &lt; RConstants::eps);
        }
        case R_ELEMENT_TRUSS1:
        {
            if (!this-&gt;isInsideBoundingBox(nodes,node))
            {
                return false;
            }
            const RNode &amp;n1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;n2 = nodes[this-&gt;getNodeId(1)];
            volumes.resize(2);
            volumes[0] = n1.getDistance(node);
            volumes[1] = n2.getDistance(node);
            double bt = volumes[0] + volumes[1];

            return (std::abs(n1.getDistance(n2) - bt) &lt; RConstants::eps);
        }
        case R_ELEMENT_TRI1:
        {
            if (!this-&gt;isInsideBoundingBox(nodes,node))
            {
                return false;
            }
            const RNode &amp;n1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;n2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;n3 = nodes[this-&gt;getNodeId(2)];

            volumes.resize(3);
            volumes[0] = RTriangle::findArea(node,n2,n3);
            volumes[1] = RTriangle::findArea(node,n3,n1);
            volumes[2] = RTriangle::findArea(node,n1,n2);
            double bt = volumes[0] + volumes[1] + volumes[2];

            double area = 0.0;

            if (!this-&gt;findArea(nodes,area))
            {
                return false;
            }

            return (std::abs(area - bt) &lt; RConstants::eps);
        }
        case R_ELEMENT_TETRA1:
        {
            if (!this-&gt;isInsideBoundingBox(nodes,node))
            {
                return false;
            }
            double volume = 0.0;

            if (!this-&gt;findVolume(nodes,volume))
            {
                return false;
            }

            const RNode &amp;n1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;n2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;n3 = nodes[this-&gt;getNodeId(2)];
            const RNode &amp;n4 = nodes[this-&gt;getNodeId(3)];

            double b1 = RTetrahedron::findVolume(node,n2,n4,n3);
            if (!R_SIGNS_EQUAL(b1,volume) &amp;&amp; b1 != 0.0)
            {
                return false;
            }
            double b2 = RTetrahedron::findVolume(node,n1,n3,n4);
            if (!R_SIGNS_EQUAL(b2,volume) &amp;&amp; b2 != 0.0)
            {
                return false;
            }
            double b3 = RTetrahedron::findVolume(node,n1,n4,n2);
            if (!R_SIGNS_EQUAL(b3,volume) &amp;&amp; b3 != 0.0)
            {
                return false;
            }
            double b4 = RTetrahedron::findVolume(node,n1,n2,n3);
            if (!R_SIGNS_EQUAL(b4,volume) &amp;&amp; b4 != 0.0)
            {
                return false;
            }
            volumes.resize(4);
            volumes[0] = b1;
            volumes[1] = b2;
            volumes[2] = b3;
            volumes[3] = b4;
            double bt = b1 + b2 + b3 + b4;

            return (std::abs(volume - bt) &lt; RConstants::eps);
        }
        default:
        {
            break;
        }
    }

    return false;
} /* RElement::isInside */


double RElement::interpolate(const std::vector&lt;RNode&gt; &amp;nodes, const RNode &amp;interpolatedNode, const RRVector &amp;nodeValues) const
{
    RRVector volumes;
    return this-&gt;interpolate(nodes,interpolatedNode,nodeValues,volumes);
} /* RElement::interpolate */


double RElement::interpolate(const std::vector&lt;RNode&gt; &amp;nodes,
</t>
<t tx="leo.20201108101533.95">                             const RNode &amp;interpolatedNode,
                             const RRVector &amp;nodeValues,
                             const RRVector &amp;volumes) const
{
    RRVector ratios;

    switch (this-&gt;getType())
    {
        case R_ELEMENT_POINT:
        {
            ratios.resize(1,1.0);
            break;
        }
        case R_ELEMENT_TRUSS1:
        {
            ratios.resize(2,1.0);
            const RNode &amp;n1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;n2 = nodes[this-&gt;getNodeId(1)];
            double b1 = volumes.size() == 2 ? volumes[0] : n1.getDistance(interpolatedNode);
            double b2 = volumes.size() == 2 ? volumes[1] : n2.getDistance(interpolatedNode);
            double bt = b1 + b2;
            if (bt != 0.0)
            {
                ratios[0] = b1/bt;
                ratios[1] = b2/bt;
            }
            break;
        }
        case R_ELEMENT_TRI1:
        {
            ratios.resize(3,1.0);
            const RNode &amp;n1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;n2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;n3 = nodes[this-&gt;getNodeId(2)];

//            double b1 = RTriangle::findArea(interpolatedNode,n2,n3);
//            double b2 = RTriangle::findArea(interpolatedNode,n3,n1);
//            double b3 = RTriangle::findArea(interpolatedNode,n1,n2);

            double b1 = volumes.size() == 3 ? volumes[0] : RTriangle::findArea(interpolatedNode,n2,n3);
            double b2 = volumes.size() == 3 ? volumes[1] : RTriangle::findArea(interpolatedNode,n3,n1);
            double b3 = volumes.size() == 3 ? volumes[2] : RTriangle::findArea(interpolatedNode,n1,n2);
            double bt = b1 + b2 + b3;
            if (bt != 0.0)
            {
                ratios[0] = b1/bt;
                ratios[1] = b2/bt;
                ratios[2] = b3/bt;
            }
            break;
        }
        case R_ELEMENT_TETRA1:
        {
            ratios.resize(4,1.0);
            const RNode &amp;n1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;n2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;n3 = nodes[this-&gt;getNodeId(2)];
            const RNode &amp;n4 = nodes[this-&gt;getNodeId(3)];

            double b1 = volumes.size() == 4 ? volumes[0] : RTetrahedron::findVolume(interpolatedNode,n2,n4,n3);
            double b2 = volumes.size() == 4 ? volumes[1] : RTetrahedron::findVolume(interpolatedNode,n1,n3,n4);
            double b3 = volumes.size() == 4 ? volumes[2] : RTetrahedron::findVolume(interpolatedNode,n1,n4,n2);
            double b4 = volumes.size() == 4 ? volumes[3] : RTetrahedron::findVolume(interpolatedNode,n1,n2,n3);
            double bt = b1 + b2 + b3 + b4;
            if (bt != 0.0)
            {
                ratios[0] = b1/bt;
                ratios[1] = b2/bt;
                ratios[2] = b3/bt;
                ratios[3] = b4/bt;
            }
            break;
        }
        default:
        {
            break;
        }
    }

    double value = 0.0;

    for (unsigned int i=0;i&lt;ratios.size();i++)
    {
        value += ratios[i] * nodeValues[i];
    }

    return value;
} /* RElement::interpolate */


RRMatrix RElement::findTransformationMatrix(const std::vector&lt;RNode&gt; &amp;nodes, RRMatrix &amp;R, RRVector &amp;t) const
{
    RRMatrix lNodes;
    R.setIdentity(3);
    t.resize(3);
    t.fill(0.0);

    unsigned int nn = this-&gt;size();

    if (R_ELEMENT_TYPE_IS_POINT(this-&gt;getType()) || R_ELEMENT_TYPE_IS_VOLUME(this-&gt;getType()))
    {
        lNodes.resize(nn,3);

        for (unsigned int i=0;i&lt;nn;i++)
        {
            lNodes[i][0] = nodes[this-&gt;getNodeId(i)].getX();
            lNodes[i][1] = nodes[this-&gt;getNodeId(i)].getY();
            lNodes[i][2] = nodes[this-&gt;getNodeId(i)].getZ();
        }
    }
    else if (R_ELEMENT_TYPE_IS_LINE(this-&gt;getType()))
    {
        t[0] = nodes[this-&gt;getNodeId(0)].getX();
        t[1] = nodes[this-&gt;getNodeId(0)].getY();
        t[2] = nodes[this-&gt;getNodeId(0)].getZ();

        lNodes.resize(nn,1);

        RSegment segment(nodes[this-&gt;getNodeId(0)],
                         nodes[this-&gt;getNodeId(1)]);
        segment.findRotationMatrix(R);

        RRMatrix Ri(R);
        Ri.invert();

        for (unsigned int i=0;i&lt;nn;i++)
        {
            double x = nodes[this-&gt;getNodeId(i)].getX();
            double y = nodes[this-&gt;getNodeId(i)].getY();
            double z = nodes[this-&gt;getNodeId(i)].getZ();
            x -= t[0];
            y -= t[1];
            z -= t[2];
            lNodes[i][0] = Ri[0][0]*x + Ri[0][1]*y + Ri[0][2]*z;
        }
    }
    else if (R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getType()))
    {
        lNodes.resize(nn,2);

        RTriangle triangle(nodes[this-&gt;getNodeId(0)],
                           nodes[this-&gt;getNodeId(1)],
                           nodes[this-&gt;getNodeId(2)]);
        triangle.findRotationMatrix(R);

        RRMatrix Ri(R);
        Ri.invert();

        for (unsigned int i=0;i&lt;nn;i++)
        {
            double x = nodes[this-&gt;getNodeId(i)].getX();
            double y = nodes[this-&gt;getNodeId(i)].getY();
            double z = nodes[this-&gt;getNodeId(i)].getZ();
            x -= t[0];
            y -= t[1];
            z -= t[2];
            lNodes[i][0] = Ri[0][0]*x + Ri[0][1]*y + Ri[0][2]*z;
            lNodes[i][1] = Ri[1][0]*x + Ri[1][1]*y + Ri[1][2]*z;
        }
    }
    else
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Element type (%d) has no group type.",this-&gt;getType());
    }


    return lNodes;
} /* RElement::findRotationMatrix */


double RElement::findJacobian(const std::vector&lt;RNode&gt; &amp;nodes, unsigned int iPoint, RRMatrix &amp;J, RRMatrix &amp;Rt) const
{
    RRMatrix lNodes;
    RRMatrix R;
    RRVector t;

    const RElementShapeFunction &amp;shapeFunction = RElement::getShapeFunction(this-&gt;getType(),iPoint);
    const RRMatrix &amp;dN = shapeFunction.getDN();

    J.resize(dN.getNColumns(),dN.getNColumns());
    J.fill(0.0);
    lNodes.resize(dN.getNRows(),dN.getNColumns());

    lNodes = this-&gt;findTransformationMatrix(nodes,R,t);

    for (unsigned int i=0;i&lt;dN.getNColumns();i++)
    {
        for (unsigned int j=0;j&lt;dN.getNColumns();j++)
        {
            for (unsigned int k=0;k&lt;dN.getNRows();k++)
            {
                J[i][j] += dN[k][i]*lNodes[k][j];
            }
        }
    }
    double detJ = J.getDeterminant();
    if (J.getNRows() == 1 &amp;&amp; J.getNColumns() == 1)
    {
        if (std::abs(J[0][0]) &gt; RConstants::eps)
        {
            J[0][0] = 1.0 / J[0][0];
        }
    }
    else
    {
        J.invert();
    }

    if (R_ELEMENT_TYPE_IS_LINE(this-&gt;getType()))
    {
        Rt.resize(this-&gt;size()*3,this-&gt;size()*1);

        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            for (uint j=0;j&lt;this-&gt;size();j++)
            {
                Rt[3*i+0][j] = R[0][0];
                Rt[3*i+1][j] = R[1][0];
                Rt[3*i+2][j] = R[2][0];
            }
        }
    }
    else if (R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getType()))
    {
        Rt.resize(this-&gt;size()*3,this-&gt;size()*2);

        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            for (uint j=0;j&lt;this-&gt;size();j++)
            {
                Rt[3*i+0][2*j+0] = R[0][0];
                Rt[3*i+1][2*j+0] = R[1][0];
                Rt[3*i+2][2*j+0] = R[2][0];

                Rt[3*i+0][2*j+1] = R[0][1];
                Rt[3*i+1][2*j+1] = R[1][1];
                Rt[3*i+2][2*j+1] = R[2][1];
            }
        }
    }
    else if (R_ELEMENT_TYPE_IS_VOLUME(this-&gt;getType()) || R_ELEMENT_TYPE_IS_POINT(this-&gt;getType()))
    {
        Rt.setIdentity(this-&gt;size()*3);
    }

    return detJ;
} /* RElement::findJacobian */


</t>
<t tx="leo.20201108101533.96">unsigned int RElement::findIntersectedSide(const std::vector&lt;RNode&gt; &amp;nodes,
                                           const RR3Vector &amp;position,
                                           const RR3Vector &amp;direction,
                                           RR3Vector &amp;intersection) const
{
    switch (this-&gt;getType())
    {
        case R_ELEMENT_TETRA1:
        {
            const RNode &amp;n1 = nodes[this-&gt;getNodeId(0)];
            const RNode &amp;n2 = nodes[this-&gt;getNodeId(1)];
            const RNode &amp;n3 = nodes[this-&gt;getNodeId(2)];
            const RNode &amp;n4 = nodes[this-&gt;getNodeId(3)];

            double u = 0.0;

            RTriangle t1(n2,n3,n4);
            if (t1.findLineIntersection(position,direction,intersection,u))
            {
                if (u &gt; RConstants::eps)
                {
                    return 0;
                }
            }

            RTriangle t2(n1,n3,n4);
            if (t2.findLineIntersection(position,direction,intersection,u))
            {
                if (u &gt; RConstants::eps)
                {
                    return 1;
                }
            }

            RTriangle t3(n1,n2,n4);
            if (t3.findLineIntersection(position,direction,intersection,u))
            {
                if (u &gt; RConstants::eps)
                {
                    return 2;
                }
            }

            RTriangle t4(n1,n2,n3);
            if (t4.findLineIntersection(position,direction,intersection,u))
            {
                if (u &gt; RConstants::eps)
                {
                    return 3;
                }
            }

            break;
        }
        default:
        {
            RLogger::warning("Unsupported element type.\n");
            break;
        }
    }

    return RConstants::eod;
} /* RElement::findIntersectedSide */

std::vector&lt;RSegment&gt; RElement::segmentize(const std::vector&lt;RNode&gt; &amp;nodes) const
{
    std::vector&lt;RSegment&gt; segments;

    switch (this-&gt;type)
    {
        case R_ELEMENT_BEAM1:
        case R_ELEMENT_TRUSS1:
            segments.push_back(RSegment(nodes[this-&gt;nodeIDs[0]],nodes[this-&gt;nodeIDs[1]]));
            break;
        case R_ELEMENT_BEAM2:
        case R_ELEMENT_TRUSS2:
            segments.push_back(RSegment(nodes[this-&gt;nodeIDs[0]],nodes[this-&gt;nodeIDs[2]]));
            segments.push_back(RSegment(nodes[this-&gt;nodeIDs[2]],nodes[this-&gt;nodeIDs[1]]));
            break;
        default:
            break;
    }

    return segments;
} /* RElement::segmentize */

std::vector&lt;RTriangle&gt; RElement::triangulate(const std::vector&lt;RNode&gt; &amp;nodes) const
{
    std::vector&lt;RTriangle&gt; triangles;

    switch (this-&gt;type)
    {
        case R_ELEMENT_TRI1:
        case R_ELEMENT_TRI2:
        {
            RTriangle t1(RTriangle(nodes[this-&gt;nodeIDs[0]],nodes[this-&gt;nodeIDs[1]],nodes[this-&gt;nodeIDs[2]]));
            t1.setNodeIDs(this-&gt;nodeIDs[0],this-&gt;nodeIDs[1],this-&gt;nodeIDs[2]);
            triangles.push_back(t1);
            break;
        }
        case R_ELEMENT_QUAD1:
        case R_ELEMENT_QUAD2:
        {
            RTriangle t1(RTriangle(nodes[this-&gt;nodeIDs[0]],nodes[this-&gt;nodeIDs[1]],nodes[this-&gt;nodeIDs[2]]));
            RTriangle t2(RTriangle(nodes[this-&gt;nodeIDs[0]],nodes[this-&gt;nodeIDs[2]],nodes[this-&gt;nodeIDs[3]]));
            t1.setNodeIDs(this-&gt;nodeIDs[0],this-&gt;nodeIDs[1],this-&gt;nodeIDs[2]);
            t2.setNodeIDs(this-&gt;nodeIDs[0],this-&gt;nodeIDs[2],this-&gt;nodeIDs[3]);
            triangles.reserve(2);
            triangles.push_back(t1);
            triangles.push_back(t2);
            break;
        }
        default:
        {
            break;
        }
    }

    return triangles;
} /* RElement::triangulate */


uint RElement::getNEdgeElements(void) const
{
    switch (this-&gt;type)
    {
        case R_ELEMENT_TRUSS1:
        {
            return 2;
        }
        case R_ELEMENT_TRI1:
        {
            return 3;
        }
        case R_ELEMENT_QUAD1:
        {
            return 4;
        }
        case R_ELEMENT_TETRA1:
        {
            return 4;
        }
        default:
        {
            return 0;
        }
    }
} /* RElement::getNEdgeElements */


std::vector&lt;RElement&gt; RElement::generateEdgeElements(void) const
{
    std::vector&lt;RElement&gt; edgeElements;

    switch (this-&gt;type)
    {
        case R_ELEMENT_TRUSS1:
        {
            RElement e1(R_ELEMENT_POINT);
            e1.setNodeId(0,this-&gt;getNodeId(0));
            edgeElements.push_back(e1);

            RElement e2(R_ELEMENT_POINT);
            e2.setNodeId(0,this-&gt;getNodeId(1));
            edgeElements.push_back(e2);

            break;
        }
        case R_ELEMENT_TRI1:
        {
            RElement e1(R_ELEMENT_TRUSS1);
            e1.setNodeId(0,this-&gt;getNodeId(0));
            e1.setNodeId(1,this-&gt;getNodeId(1));
            edgeElements.push_back(e1);

            RElement e2(R_ELEMENT_TRUSS1);
            e2.setNodeId(0,this-&gt;getNodeId(1));
            e2.setNodeId(1,this-&gt;getNodeId(2));
            edgeElements.push_back(e2);

            RElement e3(R_ELEMENT_TRUSS1);
            e3.setNodeId(0,this-&gt;getNodeId(2));
            e3.setNodeId(1,this-&gt;getNodeId(0));
            edgeElements.push_back(e3);

            break;
        }
        case R_ELEMENT_QUAD1:
        {
            RElement e1(R_ELEMENT_TRUSS1);
            e1.setNodeId(0,this-&gt;getNodeId(0));
            e1.setNodeId(1,this-&gt;getNodeId(1));
            edgeElements.push_back(e1);

            RElement e2(R_ELEMENT_TRUSS1);
            e2.setNodeId(0,this-&gt;getNodeId(1));
            e2.setNodeId(1,this-&gt;getNodeId(2));
            edgeElements.push_back(e2);

            RElement e3(R_ELEMENT_TRUSS1);
            e3.setNodeId(0,this-&gt;getNodeId(2));
            e3.setNodeId(1,this-&gt;getNodeId(3));
            edgeElements.push_back(e3);

            RElement e4(R_ELEMENT_TRUSS1);
            e4.setNodeId(0,this-&gt;getNodeId(3));
            e4.setNodeId(1,this-&gt;getNodeId(0));
            edgeElements.push_back(e4);

            break;
        }
        case R_ELEMENT_TETRA1:
        {
            RElement e1(R_ELEMENT_TRI1);
            e1.setNodeId(0,this-&gt;getNodeId(1));
            e1.setNodeId(1,this-&gt;getNodeId(3));
            e1.setNodeId(2,this-&gt;getNodeId(2));
            edgeElements.push_back(e1);

            RElement e2(R_ELEMENT_TRI1);
            e2.setNodeId(0,this-&gt;getNodeId(0));
            e2.setNodeId(1,this-&gt;getNodeId(2));
            e2.setNodeId(2,this-&gt;getNodeId(3));
            edgeElements.push_back(e2);

            RElement e3(R_ELEMENT_TRI1);
            e3.setNodeId(0,this-&gt;getNodeId(0));
            e3.setNodeId(1,this-&gt;getNodeId(3));
            e3.setNodeId(2,this-&gt;getNodeId(1));
            edgeElements.push_back(e3);

            RElement e4(R_ELEMENT_TRI1);
            e4.setNodeId(0,this-&gt;getNodeId(0));
            e4.setNodeId(1,this-&gt;getNodeId(1));
            e4.setNodeId(2,this-&gt;getNodeId(2));
            edgeElements.push_back(e4);

            break;
        }
        default:
        {
            break;
        }
    }

    return edgeElements;
} /* RElement::generateEdgeElements */


</t>
<t tx="leo.20201108101533.97">bool RElement::isNeighbor(const RElement &amp;rElement) const
{
    if (!R_ELEMENT_GROUP_TYPE_EQUALS(this-&gt;getType(),rElement.getType()))
    {
        return RConstants::eod;
    }

    uint nNodesPerSide = 0;

    if (R_ELEMENT_TYPE_IS_LINE(this-&gt;getType()))
    {
        nNodesPerSide = 1;
    }
    else if (R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getType()))
    {
        nNodesPerSide = 2;
    }
    else if (R_ELEMENT_TYPE_IS_VOLUME(this-&gt;getType()))
    {
        if (this-&gt;getType() == R_ELEMENT_TETRA1)
        {
            nNodesPerSide = 3;
        }
        if (this-&gt;getType() == R_ELEMENT_HEXA1)
        {
            nNodesPerSide = 4;
        }
    }
    if (nNodesPerSide == 0)
    {
        return false;
    }

    uint nFound = 0;
    for (uint i=0;i&lt;rElement.size();i++)
    {
        if (this-&gt;hasNodeId(rElement.getNodeId(i)))
        {
            nFound++;
        }
    }
    if (nFound == nNodesPerSide)
    {
        return true;
    }
    return false;
} /* RElement::isNeighbor */


</t>
<t tx="leo.20201108101533.98">unsigned int RElement::findEdgePositionForNeighborElement(const RElement &amp;rElement) const
{
    if (!R_ELEMENT_GROUP_TYPE_EQUALS(this-&gt;getType(),rElement.getType()))
    {
        return RConstants::eod;
    }
    std::vector&lt;RElement&gt; edgeElements = this-&gt;generateEdgeElements();
    for (uint i=0;i&lt;edgeElements.size();i++)
    {
        uint nNodesFound = 0;
        for (uint j=0;j&lt;edgeElements[i].size();j++)
        {
            for (uint k=0;k&lt;rElement.size();k++)
            {
                if (edgeElements[i].getNodeId(j) == rElement.getNodeId(k))
                {
                    nNodesFound++;
                    break;
                }
            }
        }
        if (nNodesFound == edgeElements[i].size())
        {
            return i;
        }
    }
    return RConstants::eod;
} /* RElement::findEdgePositionForNeighborElement */


</t>
<t tx="leo.20201108101533.99">bool RElement::isNeighborNormalSync(const RElement &amp;rElement) const
{
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        uint n11 = this-&gt;getNodeId(i);
        uint n12 = (i+1&lt;this-&gt;size()) ? this-&gt;getNodeId(i+1) : this-&gt;getNodeId(0);
        for (uint j=0;j&lt;rElement.size();j++)
        {
            uint n21 = rElement.getNodeId(j);
            uint n22 = (j+1&lt;rElement.size()) ? rElement.getNodeId(j+1) : rElement.getNodeId(0);

            if (n11 == n22 &amp;&amp; n12 == n21)
            {
                return true;
            }
            else if (n11 == n21 &amp;&amp; n12 == n22)
            {
                return false;
            }
        }
    }
    return true;
} /* RElement::isNeighborNormalSync */


</t>
<t tx="leo.20201108101534.1">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_element_shape_function.cpp                           *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th December 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Element shape function class definition             *
 *********************************************************************/

#include "rml_element_shape_function.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101534.10">void REntityGroup::setName(const QString &amp;name)
{
    this-&gt;name = name;
} /* REntityGroup::setName */

std::vector&lt;REntityGroupType&gt; REntityGroup::getAllTypes(void)
{
    std::vector&lt;REntityGroupType&gt; types(R_ENTITY_GROUP_N_TYPES);
    types[0] = R_ENTITY_GROUP_POINT;
    types[1] = R_ENTITY_GROUP_LINE;
    types[2] = R_ENTITY_GROUP_SURFACE;
    types[3] = R_ENTITY_GROUP_VOLUME;
    types[4] = R_ENTITY_GROUP_VECTOR_FIELD;
    types[5] = R_ENTITY_GROUP_STREAM_LINE;
    types[6] = R_ENTITY_GROUP_CUT;
    types[7] = R_ENTITY_GROUP_ISO;
    types[9] = R_ENTITY_GROUP_SCALAR_FIELD;
    return types;
} /* REntityGroup::getAllTypes */

std::vector&lt;REntityGroupType&gt; REntityGroup::getMaskTypes(REntityGroupTypeMask elementGroupTypeMask)
{
    std::vector&lt;REntityGroupType&gt; types;
    if (elementGroupTypeMask &amp; R_ENTITY_GROUP_POINT) types.push_back(R_ENTITY_GROUP_POINT);
    if (elementGroupTypeMask &amp; R_ENTITY_GROUP_LINE) types.push_back(R_ENTITY_GROUP_LINE);
    if (elementGroupTypeMask &amp; R_ENTITY_GROUP_SURFACE) types.push_back(R_ENTITY_GROUP_SURFACE);
    if (elementGroupTypeMask &amp; R_ENTITY_GROUP_VOLUME) types.push_back(R_ENTITY_GROUP_VOLUME);
    if (elementGroupTypeMask &amp; R_ENTITY_GROUP_VECTOR_FIELD) types.push_back(R_ENTITY_GROUP_VECTOR_FIELD);
    if (elementGroupTypeMask &amp; R_ENTITY_GROUP_STREAM_LINE) types.push_back(R_ENTITY_GROUP_STREAM_LINE);
    if (elementGroupTypeMask &amp; R_ENTITY_GROUP_CUT) types.push_back(R_ENTITY_GROUP_CUT);
    if (elementGroupTypeMask &amp; R_ENTITY_GROUP_ISO) types.push_back(R_ENTITY_GROUP_ISO);
    if (elementGroupTypeMask &amp; R_ENTITY_GROUP_SCALAR_FIELD) types.push_back(R_ENTITY_GROUP_SCALAR_FIELD);
    return types;
} /* REntityGroup::getMaskTypes */


</t>
<t tx="leo.20201108101534.100">void RFileIO::writeAscii(RSaveFile &amp;outFile, const char *sValue, bool addNewLine)
{
    RFileIO::writeAscii(outFile,QString(sValue),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.101">void RFileIO::writeAscii(RSaveFile &amp;outFile, const std::string &amp;sValue, bool addNewLine)
{
    RFileIO::writeAscii(outFile,QString(sValue.c_str()),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.102">void RFileIO::writeBinary(RSaveFile &amp;outFile, const char *sValue)
{
    RFileIO::writeBinary(outFile,QString(sValue));
} /* RFileIO::writeBinary */


</t>
<t tx="leo.20201108101534.103">void RFileIO::writeBinary(RSaveFile &amp;outFile, const std::string &amp;sValue)
{
    RFileIO::writeBinary(outFile,QString(sValue.c_str()));
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RIVector                                                         *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.104">void RFileIO::readAscii(RFile &amp;inFile, RIVector &amp;iVector, bool readSize)
{
    unsigned int nr = 0;

    if (readSize)
    {
        RFileIO::readAscii(inFile,nr);
        iVector.resize(nr);
    }
    else
    {
        nr = iVector.getNRows();
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::readAscii(inFile,iVector[i]);
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.105">void RFileIO::readBinary(RFile &amp;inFile, RIVector &amp;iVector, bool readSize)
{
    unsigned int nr = 0;

    if (readSize)
    {
        RFileIO::readBinary(inFile,nr);
        iVector.resize(nr);
    }
    else
    {
        nr = iVector.getNRows();
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::readBinary(inFile,iVector[i]);
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.106">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RIVector &amp;iVector, bool writeSize, bool addNewLine)
{
    unsigned int nr = iVector.getNRows();
    if (writeSize)
    {
        if (addNewLine)
        {
            RFileIO::writeAscii(outFile,nr,true);
        }
        else
        {
            RFileIO::writeAscii(outFile,nr,false);
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeAscii(outFile,iVector[i], false);
        if (i+1 &lt; nr)
        {
            RFileIO::writeAscii(outFile,' ', false);
        }
    }
    if (addNewLine)
    {
        RFileIO::writeNewLineAscii(outFile);
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.107">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RIVector &amp;iVector, bool writeSize)
{
    unsigned int nr = iVector.getNRows();
    if (writeSize)
    {
        RFileIO::writeBinary(outFile,nr);
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeBinary(outFile,iVector[i]);
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RUVector                                                         *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.108">void RFileIO::readAscii(RFile &amp;inFile, RUVector &amp;uVector, bool readSize)
{
    unsigned int nr = 0;

    if (readSize)
    {
        RFileIO::readAscii(inFile,nr);
        uVector.resize(nr);
    }
    else
    {
        nr = uVector.getNRows();
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::readAscii(inFile,uVector[i]);
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.109">void RFileIO::readBinary(RFile &amp;inFile, RUVector &amp;uVector, bool readSize)
{
    unsigned int nr = 0;

    if (readSize)
    {
        RFileIO::readBinary(inFile,nr);
        uVector.resize(nr);
    }
    else
    {
        nr = uVector.getNRows();
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::readBinary(inFile,uVector[i]);
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.11">const QString REntityGroup::getTypeName(REntityGroupType elementGroupType)
{
    switch (elementGroupType)
    {
        case R_ENTITY_GROUP_POINT:
            return "point";
        case R_ENTITY_GROUP_LINE:
            return "line";
        case R_ENTITY_GROUP_SURFACE:
            return "surface";
        case R_ENTITY_GROUP_VOLUME:
            return "volume";
        case R_ENTITY_GROUP_VECTOR_FIELD:
            return "vector field";
        case R_ENTITY_GROUP_STREAM_LINE:
            return "stream line";
        case R_ENTITY_GROUP_CUT:
            return "cut";
        case R_ENTITY_GROUP_ISO:
            return "iso";
        case R_ENTITY_GROUP_SCALAR_FIELD:
            return "scalar";
        case R_ENTITY_GROUP_NONE:
        default:
            return "none";
    }
} /* REntityGroup::getTypeName */


</t>
<t tx="leo.20201108101534.110">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RUVector &amp;uVector, bool writeSize, bool addNewLine)
{
    unsigned int nr = uVector.getNRows();
    if (writeSize)
    {
        if (addNewLine)
        {
            RFileIO::writeAscii(outFile,nr,true);
        }
        else
        {
            RFileIO::writeAscii(outFile,nr,false);
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeAscii(outFile,uVector[i], false);
        if (i+1 &lt; nr)
        {
            RFileIO::writeAscii(outFile,' ', false);
        }
    }
    if (addNewLine)
    {
        RFileIO::writeNewLineAscii(outFile);
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.111">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RUVector &amp;uVector, bool writeSize)
{
    unsigned int nr = uVector.getNRows();
    if (writeSize)
    {
        RFileIO::writeBinary(outFile,nr);
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeBinary(outFile,uVector[i]);
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RRVector                                                         *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.112">void RFileIO::readAscii(RFile &amp;inFile, RRVector &amp;rVector, bool readSize)
{
    unsigned int nr = 0;

    if (readSize)
    {
        RFileIO::readAscii(inFile,nr);
        rVector.resize(nr);
    }
    else
    {
        nr = rVector.getNRows();
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::readAscii(inFile,rVector[i]);
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.113">void RFileIO::readBinary(RFile &amp;inFile, RRVector &amp;rVector, bool readSize)
{
    unsigned int nr = 0;

    if (readSize)
    {
        RFileIO::readBinary(inFile,nr);
        rVector.resize(nr);
    }
    else
    {
        nr = rVector.getNRows();
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::readBinary(inFile,rVector[i]);
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.114">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RRVector &amp;rVector, bool writeSize, bool addNewLine)
{
    unsigned int nr = rVector.getNRows();
    if (writeSize)
    {
        RFileIO::writeAscii(outFile,nr,addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeAscii(outFile,rVector[i], false);
        if (i+1 &lt; nr)
        {
            RFileIO::writeAscii(outFile,' ', false);
        }
    }
    if (addNewLine)
    {
        RFileIO::writeNewLineAscii(outFile);
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.115">void RFileIO::writeAscii(RFile &amp;outFile, const RRVector &amp;rVector, bool writeSize, bool addNewLine)
{
    unsigned int nr = rVector.getNRows();
    if (writeSize)
    {
        RFileIO::writeAscii(outFile,nr,addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeAscii(outFile,rVector[i], false);
        if (i+1 &lt; nr)
        {
            RFileIO::writeAscii(outFile,' ', false);
        }
    }
    if (addNewLine)
    {
        RFileIO::writeNewLineAscii(outFile);
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.116">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RRVector &amp;rVector, bool writeSize)
{
    unsigned int nr = rVector.getNRows();
    if (writeSize)
    {
        RFileIO::writeBinary(outFile,nr);
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeBinary(outFile,rVector[i]);
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RR3Vector                                                         *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.117">void RFileIO::readAscii(RFile &amp;inFile, RR3Vector &amp;rVector)
{
    RFileIO::readAscii(inFile,rVector[0]);
    RFileIO::readAscii(inFile,rVector[1]);
    RFileIO::readAscii(inFile,rVector[2]);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.118">void RFileIO::readBinary(RFile &amp;inFile, RR3Vector &amp;rVector)
{
    RFileIO::readBinary(inFile,rVector[0]);
    RFileIO::readBinary(inFile,rVector[1]);
    RFileIO::readBinary(inFile,rVector[2]);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.119">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RR3Vector &amp;rVector, bool addNewLine)
{
    RFileIO::writeAscii(outFile,rVector[0],addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile," ",false);
    }
    RFileIO::writeAscii(outFile,rVector[1],addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile," ",false);
    }
    RFileIO::writeAscii(outFile,rVector[2],addNewLine);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.12">bool REntityGroup::typeIsElementGroup(REntityGroupType elementGroupType)
{
    switch (elementGroupType)
    {
        case R_ENTITY_GROUP_POINT:
        case R_ENTITY_GROUP_LINE:
        case R_ENTITY_GROUP_SURFACE:
        case R_ENTITY_GROUP_VOLUME:
            return true;
        default:
            return false;
    }
} /* REntityGroup::typeIsElementGroup */


</t>
<t tx="leo.20201108101534.120">void RFileIO::writeAscii(RFile &amp;outFile, const RR3Vector &amp;rVector, bool addNewLine)
{
    RFileIO::writeAscii(outFile,rVector[0],addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile," ",false);
    }
    RFileIO::writeAscii(outFile,rVector[1],addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile," ",false);
    }
    RFileIO::writeAscii(outFile,rVector[2],addNewLine);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.121">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RR3Vector &amp;rVector)
{
    RFileIO::writeBinary(outFile,rVector[0]);
    RFileIO::writeBinary(outFile,rVector[1]);
    RFileIO::writeBinary(outFile,rVector[2]);
} /* RFileIO::readAscii */


/*********************************************************************
 *  RIMatrix                                                         *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.122">void RFileIO::readAscii(RFile &amp;inFile, RIMatrix &amp;iMatrix, bool readSize)
{
    unsigned int nr = 0;

    if (readSize)
    {
        unsigned int nc = 0;
        RFileIO::readAscii(inFile,nr);
        RFileIO::readAscii(inFile,nc);
        iMatrix.resize(nr,nc);
    }
    else
    {
        nr = iMatrix.getNRows();
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::readAscii(inFile,iMatrix[i],false);
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.123">void RFileIO::readBinary(RFile &amp;inFile, RIMatrix &amp;iMatrix, bool readSize)
{
    unsigned int nr = 0;

    if (readSize)
    {
        unsigned int nc = 0;
        RFileIO::readBinary(inFile,nr);
        RFileIO::readBinary(inFile,nc);
        iMatrix.resize(nr,nc);
    }
    else
    {
        nr = iMatrix.getNRows();
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::readBinary(inFile,iMatrix[i]);
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.124">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RIMatrix &amp;iMatrix, bool writeSize, bool addNewLine)
{
    unsigned int nr = iMatrix.getNRows();
    if (writeSize)
    {
        unsigned int nc = iMatrix.getNColumns();
        RFileIO::writeAscii(outFile,nr,false);
        RFileIO::writeAscii(outFile,' ',false);
        if (addNewLine)
        {
            RFileIO::writeAscii(outFile,nc,true);
        }
        else
        {
            RFileIO::writeAscii(outFile,nc,false);
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeAscii(outFile,iMatrix[i],writeSize,addNewLine);
        if (i+1 &lt; nr &amp;&amp; !addNewLine)
        {
            RFileIO::writeAscii(outFile,' ');
        }
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.125">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RIMatrix &amp;iMatrix, bool writeSize)
{
    unsigned int nr = iMatrix.getNRows();
    if (writeSize)
    {
        RFileIO::writeBinary(outFile,nr);
        RFileIO::writeBinary(outFile,iMatrix.getNColumns());
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeBinary(outFile,iMatrix[i],writeSize);
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RRMatrix                                                         *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.126">void RFileIO::readAscii(RFile &amp;inFile, RRMatrix &amp;rMatrix, bool readSize)
{

    unsigned int nr = 0;

    if (readSize)
    {
        unsigned int nc = 0;
        RFileIO::readAscii(inFile,nr);
        RFileIO::readAscii(inFile,nc);
        rMatrix.resize(nr,nc);
    }
    else
    {
        nr = rMatrix.getNRows();
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        try {
        RFileIO::readAscii(inFile,rMatrix[i],false);
        } catch (const RError &amp;error)
        {
            RLogger::warning("i = %u\n",i);
            throw error;
        }
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.127">void RFileIO::readBinary(RFile &amp;inFile, RRMatrix &amp;rMatrix, bool readSize)
{
    unsigned int nr = 0;

    if (readSize)
    {
        unsigned int nc = 0;
        RFileIO::readBinary(inFile,nr);
        RFileIO::readBinary(inFile,nc);
        rMatrix.resize(nr,nc);
    }
    else
    {
        nr = rMatrix.getNRows();
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::readBinary(inFile,rMatrix[i],false);
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.128">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RRMatrix &amp;rMatrix, bool writeSize, bool addNewLine)
{
    unsigned int nr = rMatrix.getNRows();
    if (writeSize)
    {
        unsigned int nc = rMatrix.getNColumns();
        RFileIO::writeAscii(outFile,nr,false);
        RFileIO::writeAscii(outFile,' ',false);
        if (addNewLine)
        {
            RFileIO::writeAscii(outFile,nc,true);
        }
        else
        {
            RFileIO::writeAscii(outFile,nc,false);
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeAscii(outFile,rMatrix[i],false,addNewLine);
        if (i+1 &lt; nr &amp;&amp; !addNewLine)
        {
            RFileIO::writeAscii(outFile,' ');
        }
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.129">void RFileIO::writeBinary(RSaveFile  &amp;outFile, const RRMatrix &amp;rMatrix, bool writeSize)
{
    unsigned int nr = rMatrix.getNRows();
    if (writeSize)
    {
        RFileIO::writeBinary(outFile,nr);
        RFileIO::writeBinary(outFile,rMatrix.getNColumns());
    }
    for (unsigned int i=0;i&lt;nr;i++)
    {
        RFileIO::writeBinary(outFile,rMatrix[i],false);
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RVersion                                                         *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.13">bool REntityGroup::typeIsInterpolatedElementGroup(REntityGroupType elementGroupType)
{
    switch (elementGroupType)
    {
        case R_ENTITY_GROUP_CUT:
        case R_ENTITY_GROUP_ISO:
            return true;
        default:
            return false;
    }
} /* REntityGroup::typeIsInterpolatedElementGroup */
</t>
<t tx="leo.20201108101534.130">void RFileIO::readAscii(RFile &amp;inFile, RVersion &amp;version)
{
    QString versionStr;
    RFileIO::readAscii(inFile,versionStr);
    version = RVersion(versionStr);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.131">void RFileIO::readBinary(RFile &amp;inFile, RVersion &amp;version)
{
    unsigned int major = 0;
    unsigned int minor = 0;
    unsigned int release = 0;
    unsigned int releaseType = RVersion::Release;
    RFileIO::readBinary(inFile,major);
    RFileIO::readBinary(inFile,minor);
    RFileIO::readBinary(inFile,release);
    RFileIO::readBinary(inFile,releaseType);
    version = RVersion(major,minor,release,RVersion::ReleaseType(releaseType));
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.132">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RVersion &amp;version, bool addNewLine)
{
    RFileIO::writeAscii(outFile,version.toString(),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.133">void RFileIO::writeBinary(RSaveFile  &amp;outFile, const RVersion &amp;version)
{
    RFileIO::writeBinary(outFile,version.getMajor());
    RFileIO::writeBinary(outFile,version.getMinor());
    RFileIO::writeBinary(outFile,version.getRelease());
    RFileIO::writeBinary(outFile,(unsigned int)(version.getReleaseType()));
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RValueVector                                                     *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.134">void RFileIO::readAscii(RFile &amp;inFile, RValueVector &amp;valueVector)
{
    unsigned int n;
    QString name;
    QString units;

    RFileIO::readAscii(inFile,name);
    RFileIO::readAscii(inFile,units);
    RFileIO::readAscii(inFile,n);

    valueVector.setName(name);
    valueVector.setUnits(units);
    valueVector.resize(n);

    for (unsigned int i=0;i&lt;n;i++)
    {
        RFileIO::readAscii(inFile,valueVector[i]);
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.135">void RFileIO::readBinary(RFile &amp;inFile, RValueVector &amp;valueVector)
{
    unsigned int n;
    QString name;
    QString units;

    RFileIO::readBinary(inFile,name);
    RFileIO::readBinary(inFile,units);
    RFileIO::readBinary(inFile,n);

    valueVector.setName(name);
    valueVector.setUnits(units);
    valueVector.resize(n);

    for (unsigned int i=0;i&lt;n;i++)
    {
        RFileIO::readBinary(inFile,valueVector[i]);
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.136">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RValueVector &amp;valueVector, bool addNewLine)
{
    unsigned int n = valueVector.size();

    RFileIO::writeAscii(outFile,"\"" + valueVector.getName() + "\"",addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile, "\"" + valueVector.getUnits() + "\"",addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,n,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }

    for (unsigned int i=0;i&lt;n;i++)
    {
        RFileIO::writeAscii(outFile,valueVector[i],addNewLine);
        if (!addNewLine &amp;&amp; i+1&lt;n)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.137">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RValueVector &amp;valueVector)
{
    unsigned int n = valueVector.size();

    RFileIO::writeBinary(outFile,valueVector.getName());
    RFileIO::writeBinary(outFile,valueVector.getUnits());
    RFileIO::writeBinary(outFile,n);

    for (unsigned int i=0;i&lt;n;i++)
    {
        RFileIO::writeBinary(outFile,valueVector[i]);
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RPlane                                                           *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.138">void RFileIO::readAscii(RFile &amp;inFile, RPlane &amp;plane)
{
    RR3Vector position;
    RR3Vector normal;

    RFileIO::readAscii(inFile,position);
    RFileIO::readAscii(inFile,normal);

    plane.setPosition(position);
    plane.setNormal(normal);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.139">void RFileIO::readBinary(RFile &amp;inFile, RPlane &amp;plane)
{
    RR3Vector position;
    RR3Vector normal;

    RFileIO::readBinary(inFile,position);
    RFileIO::readBinary(inFile,normal);

    plane.setPosition(position);
    plane.setNormal(normal);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.14">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_entity_group_data.cpp                                *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Entity group data class declaration                 *
 *********************************************************************/

#include &lt;cstdlib&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

#include "rml_entity_group_data.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101534.140">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RPlane &amp;plane, bool addNewLine)
{
    RFileIO::writeAscii(outFile,plane.getPosition(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,plane.getNormal(),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.141">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RPlane &amp;plane)
{
    RFileIO::writeBinary(outFile,plane.getPosition());
    RFileIO::writeBinary(outFile,plane.getNormal());
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RValueTable                                                      *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.142">void RFileIO::readAscii(RFile &amp;inFile, RValueTable &amp;valueTable)
{
    unsigned int n;
    QString keyName;
    QString keyUnits;
    QString valueName;
    QString valueUnits;
    double key;
    double value;

    RFileIO::readAscii(inFile,keyName);
    RFileIO::readAscii(inFile,keyUnits);
    RFileIO::readAscii(inFile,valueName);
    RFileIO::readAscii(inFile,valueUnits);
    RFileIO::readAscii(inFile,n);

    valueTable.clear();

    valueTable.setKeyName(keyName);
    valueTable.setKeyName(keyUnits);
    valueTable.setValueName(valueName);
    valueTable.setValueUnits(valueUnits);

    for (unsigned int i=0;i&lt;n;i++)
    {
        RFileIO::readAscii(inFile,key);
        RFileIO::readAscii(inFile,value);
        valueTable.add(key,value);
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.143">void RFileIO::readBinary(RFile &amp;inFile, RValueTable &amp;valueTable)
{
    unsigned int n;
    QString keyName;
    QString keyUnits;
    QString valueName;
    QString valueUnits;
    double key;
    double value;

    RFileIO::readBinary(inFile,keyName);
    RFileIO::readBinary(inFile,keyUnits);
    RFileIO::readBinary(inFile,valueName);
    RFileIO::readBinary(inFile,valueUnits);
    RFileIO::readBinary(inFile,n);

    valueTable.clear();

    valueTable.setKeyName(keyName);
    valueTable.setKeyUnits(keyUnits);
    valueTable.setValueName(valueName);
    valueTable.setValueUnits(valueUnits);

    for (unsigned int i=0;i&lt;n;i++)
    {
        RFileIO::readBinary(inFile,key);
        RFileIO::readBinary(inFile,value);
        valueTable.add(key,value);
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.144">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RValueTable &amp;valueTable, bool addNewLine)
{
    unsigned int n = valueTable.size();

    RFileIO::writeAscii(outFile,"\"" + valueTable.getKeyName() + "\"",addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,"\"" + valueTable.getKeyUnits() + "\"",addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,"\"" + valueTable.getValueName() + "\"",addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,"\"" + valueTable.getValueUnits() + "\"",addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,n,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }

    for (unsigned int i=0;i&lt;n;i++)
    {
        RFileIO::writeAscii(outFile,valueTable.getKey(i),addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
        RFileIO::writeAscii(outFile,valueTable.getValue(i),addNewLine);
        if (!addNewLine &amp;&amp; i+1 &lt; n)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.145">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RValueTable &amp;valueTable)
{
    unsigned int n = valueTable.size();

    RFileIO::writeBinary(outFile,valueTable.getKeyName());
    RFileIO::writeBinary(outFile,valueTable.getKeyUnits());
    RFileIO::writeBinary(outFile,valueTable.getValueName());
    RFileIO::writeBinary(outFile,valueTable.getValueUnits());
    RFileIO::writeBinary(outFile,n);

    for (unsigned int i=0;i&lt;n;i++)
    {
        RFileIO::writeBinary(outFile,valueTable.getKey(i));
        RFileIO::writeBinary(outFile,valueTable.getValue(i));
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  QColor                                                           *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.146">void RFileIO::readAscii(RFile &amp;inFile, QColor &amp;color)
{
    int r,g,b,a;
    RFileIO::readAscii(inFile,r);
    RFileIO::readAscii(inFile,g);
    RFileIO::readAscii(inFile,b);
    RFileIO::readAscii(inFile,a);
    color = QColor(r,g,b,a);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.147">void RFileIO::readBinary(RFile &amp;inFile, QColor &amp;color)
{
    int r,g,b,a;
    RFileIO::readBinary(inFile,r);
    RFileIO::readBinary(inFile,g);
    RFileIO::readBinary(inFile,b);
    RFileIO::readBinary(inFile,a);
    color = QColor(r,g,b,a);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.148">void RFileIO::writeAscii(RSaveFile &amp;outFile, const QColor &amp;color, bool addNewLine)
{
    RFileIO::writeAscii(outFile,color.red(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,color.green(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,color.blue(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,color.alpha(),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.149">void RFileIO::writeBinary(RSaveFile &amp;outFile, const QColor &amp;color)
{
    RFileIO::writeBinary(outFile,color.red());
    RFileIO::writeBinary(outFile,color.green());
    RFileIO::writeBinary(outFile,color.blue());
    RFileIO::writeBinary(outFile,color.alpha());
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RLight                                                           *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.15">typedef struct _REntityGroupVariableDisplayDesc
{
    QString name;
} REntityGroupVariableDisplayDesc;

</t>
<t tx="leo.20201108101534.150">void RFileIO::readAscii(RFile &amp;inFile, RGLLight &amp;light)
{
    RFileIO::readAscii(inFile,light.enabled);
    RFileIO::readAscii(inFile,light.lightNum);
    RFileIO::readAscii(inFile,light.ambient);
    RFileIO::readAscii(inFile,light.diffuse);
    RFileIO::readAscii(inFile,light.specular);
    RFileIO::readAscii(inFile,light.direction);
    RFileIO::readAscii(inFile,light.position);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.151">void RFileIO::readBinary(RFile &amp;inFile, RGLLight &amp;light)
{
    RFileIO::readBinary(inFile,light.enabled);
    RFileIO::readBinary(inFile,light.lightNum);
    RFileIO::readBinary(inFile,light.ambient);
    RFileIO::readBinary(inFile,light.diffuse);
    RFileIO::readBinary(inFile,light.specular);
    RFileIO::readBinary(inFile,light.direction);
    RFileIO::readBinary(inFile,light.position);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.152">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RGLLight &amp;light, bool addNewLine)
{
    RFileIO::writeAscii(outFile,light.enabled,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,light.lightNum,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,light.ambient,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,light.diffuse,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,light.specular,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,light.direction,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,light.position,addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.153">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RGLLight &amp;light)
{
    RFileIO::writeBinary(outFile,light.enabled);
    RFileIO::writeBinary(outFile,light.lightNum);
    RFileIO::writeBinary(outFile,light.ambient);
    RFileIO::writeBinary(outFile,light.diffuse);
    RFileIO::writeBinary(outFile,light.specular);
    RFileIO::writeBinary(outFile,light.direction);
    RFileIO::writeBinary(outFile,light.position);
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RGLDisplayProperties                                             *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.154">void RFileIO::readAscii(RFile &amp;inFile, RGLDisplayProperties &amp;displayProperties)
{
    unsigned int nLights;
    RFileIO::readAscii(inFile,displayProperties.drawGlobalAxis);
    RFileIO::readAscii(inFile,displayProperties.drawLocalAxis);
    RFileIO::readAscii(inFile,displayProperties.showModelEdges);
    RFileIO::readAscii(inFile,displayProperties.showModelDimensions);
    RFileIO::readAscii(inFile,displayProperties.showErrors);
    RFileIO::readAscii(inFile,displayProperties.bgColor);
    RFileIO::readAscii(inFile,displayProperties.bgGradient);
    RFileIO::readAscii(inFile,nLights);
    displayProperties.setNLights(nLights);
    for (unsigned int i=0;i&lt;nLights;i++)
    {
        RFileIO::readAscii(inFile,displayProperties.lights[i]);
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.155">void RFileIO::readBinary(RFile &amp;inFile, RGLDisplayProperties &amp;displayProperties)
{
    unsigned int nLights;
    RFileIO::readBinary(inFile,displayProperties.drawGlobalAxis);
    RFileIO::readBinary(inFile,displayProperties.drawLocalAxis);
    RFileIO::readBinary(inFile,displayProperties.showModelEdges);
    RFileIO::readBinary(inFile,displayProperties.showModelDimensions);
    RFileIO::readBinary(inFile,displayProperties.showErrors);
    RFileIO::readBinary(inFile,displayProperties.bgColor);
    RFileIO::readBinary(inFile,displayProperties.bgGradient);
    RFileIO::readBinary(inFile,nLights);
    displayProperties.setNLights(nLights);
    for (unsigned int i=0;i&lt;displayProperties.getNLights();i++)
    {
        RFileIO::readBinary(inFile,displayProperties.lights[i]);
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.156">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RGLDisplayProperties &amp;displayProperties, bool addNewLine)
{
    RFileIO::writeAscii(outFile,displayProperties.drawGlobalAxis,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,displayProperties.drawLocalAxis,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,displayProperties.showModelEdges,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,displayProperties.showModelDimensions,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,displayProperties.showErrors,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,displayProperties.bgColor,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,displayProperties.bgGradient,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,displayProperties.getNLights(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;displayProperties.getNLights();i++)
    {
        RFileIO::writeAscii(outFile,displayProperties.lights[i]);
        if (!addNewLine &amp;&amp; i+1 &lt; displayProperties.getNLights())
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.157">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RGLDisplayProperties &amp;displayProperties)
{
    RFileIO::writeBinary(outFile,displayProperties.drawGlobalAxis);
    RFileIO::writeBinary(outFile,displayProperties.drawLocalAxis);
    RFileIO::writeBinary(outFile,displayProperties.showModelEdges);
    RFileIO::writeBinary(outFile,displayProperties.showModelDimensions);
    RFileIO::writeBinary(outFile,displayProperties.showErrors);
    RFileIO::writeBinary(outFile,displayProperties.bgColor);
    RFileIO::writeBinary(outFile,displayProperties.bgGradient);
    RFileIO::writeBinary(outFile,displayProperties.getNLights());
    for (unsigned int i=0;i&lt;displayProperties.getNLights();i++)
    {
        RFileIO::writeBinary(outFile,displayProperties.lights[i]);
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RModelData                                                       *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.158">void RFileIO::readAscii(RFile &amp;inFile, RModelData &amp;modelData)
{
    RFileIO::readAscii(inFile,modelData.selected);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.159">void RFileIO::readBinary(RFile &amp;inFile, RModelData &amp;modelData)
{
    RFileIO::readBinary(inFile,modelData.selected);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.16">const REntityGroupVariableDisplayDesc elementGroupVariableDisplayDesc [] =
{
    { "None" },
    { "Scalar" },
    { "Displacement" }
};

REntityGroupData::REntityGroupData() :
    selected(false),
    visible(false),
    drawWire(false),
    drawEdges(false),
    drawNodes(false),
    drawElementNumbers(false),
    drawNodeNumbers(false),
    drawArrowHeads(false),
    drawEqualArrowLength(false),
    drawArrowFrom(true),
    colorByPatch(false),
    colorByViewFactor(false)
{
    int r = int(floor(255*double(rand())/double(RAND_MAX)));
    int g = int(floor(255*double(rand())/double(RAND_MAX)));
    int b = int(floor(255*double(rand())/double(RAND_MAX)));
    this-&gt;setColor(r,g,b);
    this-&gt;_init();
}

REntityGroupData::REntityGroupData(const REntityGroupData &amp;elementGroupData)
{
    this-&gt;_init(&amp;elementGroupData);
}

REntityGroupData::~REntityGroupData()
{
}

REntityGroupData &amp; REntityGroupData::operator =(const REntityGroupData &amp;elementGroupData)
{
    this-&gt;_init(&amp;elementGroupData);
    return (*this);
}

</t>
<t tx="leo.20201108101534.160">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RModelData &amp;modelData, bool addNewLine)
{
    RFileIO::writeAscii(outFile,modelData.selected,addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.161">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RModelData &amp;modelData)
{
    RFileIO::writeBinary(outFile,modelData.selected);
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RVariableType                                                    *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.162">void RFileIO::readAscii(RFile &amp;inFile, RVariableType &amp;variableType)
{
    QString variableId;
    RFileIO::readAscii(inFile,variableId);
    variableType = RVariable::getTypeFromId(variableId);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.163">void RFileIO::readBinary(RFile &amp;inFile, RVariableType &amp;variableType)
{
    QString variableId;
    RFileIO::readBinary(inFile,variableId);
    variableType = RVariable::getTypeFromId(variableId);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.164">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RVariableType &amp;variableType, bool addNewLine)
{
    RFileIO::writeAscii(outFile,RVariable::getId(variableType),addNewLine);
} /* RFileIO::writeAscii */

</t>
<t tx="leo.20201108101534.165">void RFileIO::writeAscii(RFile &amp;outFile, const RVariableType &amp;variableType, bool addNewLine)
{
    RFileIO::writeAscii(outFile,RVariable::getId(variableType),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.166">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RVariableType &amp;variableType)
{
    RFileIO::writeBinary(outFile,RVariable::getId(variableType));
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RVariableApplyType                                               *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.167">void RFileIO::readAscii(RFile &amp;inFile, RVariableApplyType &amp;variableApplyType)
{
    int iValue;
    inFile.getTextStream() &gt;&gt; iValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read RVariableApplyType value.");
    }
    variableApplyType = RVariableApplyType(iValue);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.168">void RFileIO::readBinary(RFile &amp;inFile, RVariableApplyType &amp;variableApplyType)
{
    inFile.read((char*)&amp;variableApplyType,sizeof(RVariableApplyType));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read RVariableApplyType value.");
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.169">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RVariableApplyType &amp;variableApplyType, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; int(variableApplyType);
    }
    else
    {
        outFile.getTextStream() &lt;&lt; int(variableApplyType) &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RVariableApplyType value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.17">void REntityGroupData::_init(const REntityGroupData *pElementGroupData)
{
    if (pElementGroupData)
    {
        this-&gt;selected = pElementGroupData-&gt;selected;
        this-&gt;visible = pElementGroupData-&gt;visible;
        this-&gt;rgba[0] = pElementGroupData-&gt;rgba[0];
        this-&gt;rgba[1] = pElementGroupData-&gt;rgba[1];
        this-&gt;rgba[2] = pElementGroupData-&gt;rgba[2];
        this-&gt;rgba[3] = pElementGroupData-&gt;rgba[3];
        this-&gt;drawWire = pElementGroupData-&gt;drawWire;
        this-&gt;drawEdges = pElementGroupData-&gt;drawEdges;
        this-&gt;drawNodes = pElementGroupData-&gt;drawNodes;
        this-&gt;drawElementNumbers = pElementGroupData-&gt;drawElementNumbers;
        this-&gt;drawNodeNumbers = pElementGroupData-&gt;drawNodeNumbers;
        this-&gt;drawArrowHeads = pElementGroupData-&gt;drawArrowHeads;
        this-&gt;drawEqualArrowLength = pElementGroupData-&gt;drawEqualArrowLength;
        this-&gt;drawArrowFrom = pElementGroupData-&gt;drawArrowFrom;
        this-&gt;colorByPatch = pElementGroupData-&gt;colorByPatch;
        this-&gt;colorByViewFactor = pElementGroupData-&gt;colorByViewFactor;
        this-&gt;variableData = pElementGroupData-&gt;variableData;
    }
}

</t>
<t tx="leo.20201108101534.170">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RVariableApplyType &amp;variableApplyType)
{
    outFile.write((char*)&amp;variableApplyType,sizeof(RVariableApplyType));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RVariableApplyType value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RVariableData                                                    *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.171">void RFileIO::readAscii(RFile &amp;inFile, RVariableData &amp;variableData)
{
    RFileIO::readAscii(inFile,variableData.minDisplayValue);
    RFileIO::readAscii(inFile,variableData.maxDisplayValue);
    RFileIO::readAscii(inFile,variableData.displayValueRange);
    RFileIO::readAscii(inFile,variableData.valueRangeName);
    RFileIO::readAscii(inFile,variableData.scale);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.172">void RFileIO::readBinary(RFile &amp;inFile, RVariableData &amp;variableData)
{
    RFileIO::readBinary(inFile,variableData.minDisplayValue);
    RFileIO::readBinary(inFile,variableData.maxDisplayValue);
    RFileIO::readBinary(inFile,variableData.displayValueRange);
    RFileIO::readBinary(inFile,variableData.valueRangeName);
    RFileIO::readBinary(inFile,variableData.scale);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.173">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RVariableData &amp;variableData, bool addNewLine)
{
    RFileIO::writeAscii(outFile,variableData.minDisplayValue,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,variableData.maxDisplayValue,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,variableData.displayValueRange,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,variableData.valueRangeName,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,variableData.scale,addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.174">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RVariableData &amp;variableData)
{
    RFileIO::writeBinary(outFile,variableData.minDisplayValue);
    RFileIO::writeBinary(outFile,variableData.maxDisplayValue);
    RFileIO::writeBinary(outFile,variableData.displayValueRange);
    RFileIO::writeBinary(outFile,variableData.valueRangeName);
    RFileIO::writeBinary(outFile,variableData.scale);
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RVariable                                                        *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.175">void RFileIO::readAscii(RFile &amp;inFile, RVariable &amp;variable)
{
    RFileIO::readAscii(inFile,variable.type);
    RFileIO::readAscii(inFile,variable.applyType);
    RFileIO::readAscii(inFile,variable.name);
    RFileIO::readAscii(inFile,variable.units);
    unsigned int nValues = 0;
    RFileIO::readAscii(inFile,nValues);
    variable.values.resize(nValues);
    for (unsigned int i=0;i&lt;variable.values.size();i++)
    {
        RFileIO::readAscii(inFile,variable.values[i]);
    }
    RFileIO::readAscii(inFile,variable.variableData);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.176">void RFileIO::readBinary(RFile &amp;inFile, RVariable &amp;variable)
{
    RFileIO::readBinary(inFile,variable.type);
    RFileIO::readBinary(inFile,variable.applyType);
    RFileIO::readBinary(inFile,variable.name);
    RFileIO::readBinary(inFile,variable.units);
    unsigned int nValues = 0;
    RFileIO::readBinary(inFile,nValues);
    variable.values.resize(nValues);
    for (unsigned int i=0;i&lt;variable.values.size();i++)
    {
        RFileIO::readBinary(inFile,variable.values[i]);
    }
    RFileIO::readBinary(inFile,variable.variableData);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.177">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RVariable &amp;variable, bool addNewLine)
{
    RFileIO::writeAscii(outFile,variable.type,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,variable.applyType,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,variable.name,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,variable.units,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,(unsigned int)variable.values.size(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;variable.values.size();i++)
    {
        RFileIO::writeAscii(outFile,variable.values[i],addNewLine);
        if (!addNewLine &amp;&amp; i+1 &lt; variable.values.size())
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    RFileIO::writeAscii(outFile,variable.variableData,addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.178">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RVariable &amp;variable)
{
    RFileIO::writeBinary(outFile,variable.type);
    RFileIO::writeBinary(outFile,variable.applyType);
    RFileIO::writeBinary(outFile,variable.name);
    RFileIO::writeBinary(outFile,variable.units);
    RFileIO::writeBinary(outFile,(unsigned int)variable.values.size());
    for (unsigned int i=0;i&lt;variable.values.size();i++)
    {
        RFileIO::writeBinary(outFile,variable.values[i]);
    }
    RFileIO::writeBinary(outFile,variable.variableData);
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RBoundaryConditionType                                           *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.179">void RFileIO::readAscii(RFile &amp;inFile, RBoundaryConditionType &amp;bcType)
{
    QString propertyId;
    RFileIO::readAscii(inFile,propertyId);
    bcType = RBoundaryCondition::getTypeFromId(propertyId);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.18">bool REntityGroupData::getSelected(void) const
{
    return this-&gt;selected;
}

</t>
<t tx="leo.20201108101534.180">void RFileIO::readBinary(RFile &amp;inFile, RBoundaryConditionType &amp;bcType)
{
    QString propertyId;
    RFileIO::readBinary(inFile,propertyId);
    bcType = RBoundaryCondition::getTypeFromId(propertyId);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.181">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RBoundaryConditionType &amp;bcType, bool addNewLine)
{
    RFileIO::writeAscii(outFile,RBoundaryCondition::getId(bcType),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.182">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RBoundaryConditionType &amp;bcType)
{
    RFileIO::writeBinary(outFile,RBoundaryCondition::getId(bcType));
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RInitialConditionType                                            *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.183">void RFileIO::readAscii(RFile &amp;inFile, RInitialConditionType &amp;icType)
{
    QString propertyId;
    RFileIO::readAscii(inFile,propertyId);
    icType = RInitialCondition::getTypeFromId(propertyId);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.184">void RFileIO::readBinary(RFile &amp;inFile, RInitialConditionType &amp;icType)
{
    QString propertyId;
    RFileIO::readBinary(inFile,propertyId);
    icType = RInitialCondition::getTypeFromId(propertyId);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.185">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RInitialConditionType &amp;icType, bool addNewLine)
{
    RFileIO::writeAscii(outFile,RInitialCondition::getId(icType),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.186">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RInitialConditionType &amp;icType)
{
    RFileIO::writeBinary(outFile,RInitialCondition::getId(icType));
} /* RFileIO::writeBinary */


/*********************************************************************
 *  REnvironmentConditionType                                        *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.187">void RFileIO::readAscii(RFile &amp;inFile, REnvironmentConditionType &amp;ecType)
{
    QString propertyId;
    RFileIO::readAscii(inFile,propertyId);
    ecType = REnvironmentCondition::getTypeFromId(propertyId);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.188">void RFileIO::readBinary(RFile &amp;inFile, REnvironmentConditionType &amp;ecType)
{
    QString propertyId;
    RFileIO::readBinary(inFile,propertyId);
    ecType = REnvironmentCondition::getTypeFromId(propertyId);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.189">void RFileIO::writeAscii(RSaveFile &amp;outFile, const REnvironmentConditionType &amp;ecType, bool addNewLine)
{
    RFileIO::writeAscii(outFile,REnvironmentCondition::getId(ecType),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.19">void REntityGroupData::setSelected(bool selected)
{
    this-&gt;selected = selected;
}

</t>
<t tx="leo.20201108101534.190">void RFileIO::writeBinary(RSaveFile &amp;outFile, const REnvironmentConditionType &amp;ecType)
{
    RFileIO::writeBinary(outFile,REnvironmentCondition::getId(ecType));
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RConditionComponent                                              *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.191">void RFileIO::readAscii(RFile &amp;inFile, RConditionComponent &amp;conditionComponent)
{
    RFileIO::readAscii(inFile,static_cast&lt;RValueTable&amp;&gt;(conditionComponent));
    RFileIO::readAscii(inFile,conditionComponent.keyType);
    RFileIO::readAscii(inFile,conditionComponent.type);
    RFileIO::readAscii(inFile,conditionComponent.enabled);
}

</t>
<t tx="leo.20201108101534.192">void RFileIO::readBinary(RFile &amp;inFile, RConditionComponent &amp;conditionComponent)
{
    RFileIO::readBinary(inFile,static_cast&lt;RValueTable&amp;&gt;(conditionComponent));
    RFileIO::readBinary(inFile,conditionComponent.keyType);
    RFileIO::readBinary(inFile,conditionComponent.type);
    RFileIO::readBinary(inFile,conditionComponent.enabled);
}

</t>
<t tx="leo.20201108101534.193">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RConditionComponent &amp;conditionComponent, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const RValueTable&amp;&gt;(conditionComponent),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,conditionComponent.keyType,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,conditionComponent.type,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,conditionComponent.enabled,addNewLine);
}

</t>
<t tx="leo.20201108101534.194">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RConditionComponent &amp;conditionComponent)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const RValueTable&amp;&gt;(conditionComponent));
    RFileIO::writeBinary(outFile,conditionComponent.keyType);
    RFileIO::writeBinary(outFile,conditionComponent.type);
    RFileIO::writeBinary(outFile,conditionComponent.enabled);
}


/*********************************************************************
 *  RCondition                                                       *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.195">void RFileIO::readAscii(RFile &amp;inFile, RCondition &amp;condition)
{
    RFileIO::readAscii(inFile,condition.name);
    unsigned int nComponents;
    RFileIO::readAscii(inFile,nComponents);
    condition.components.resize(nComponents);
    for (unsigned int i=0;i&lt;nComponents;i++)
    {
        RFileIO::readAscii(inFile,condition.components[i]);
    }
    RFileIO::readAscii(inFile,condition.applyOnPoint);
    RFileIO::readAscii(inFile,condition.applyOnLine);
    RFileIO::readAscii(inFile,condition.applyOnSurface);
    RFileIO::readAscii(inFile,condition.applyOnVolume);
    RFileIO::readAscii(inFile,condition.problemTypeMask);
}


</t>
<t tx="leo.20201108101534.196">void RFileIO::readBinary(RFile &amp;inFile, RCondition &amp;condition)
{
    RFileIO::readBinary(inFile,condition.name);
    unsigned int nComponents;
    RFileIO::readBinary(inFile,nComponents);
    condition.components.resize(nComponents);
    for (unsigned int i=0;i&lt;nComponents;i++)
    {
        RFileIO::readBinary(inFile,condition.components[i]);
    }
    RFileIO::readBinary(inFile,condition.applyOnPoint);
    RFileIO::readBinary(inFile,condition.applyOnLine);
    RFileIO::readBinary(inFile,condition.applyOnSurface);
    RFileIO::readBinary(inFile,condition.applyOnVolume);
    RFileIO::readBinary(inFile,condition.problemTypeMask);
}


</t>
<t tx="leo.20201108101534.197">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RCondition &amp;condition, bool addNewLine)
{
    RFileIO::writeAscii(outFile,"\"" + condition.name + "\"",addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,condition.size(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;condition.components.size();i++)
    {
        RFileIO::writeAscii(outFile,condition.components[i],addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    RFileIO::writeAscii(outFile,condition.applyOnPoint,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,condition.applyOnLine,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,condition.applyOnSurface,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,condition.applyOnVolume,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,condition.problemTypeMask,addNewLine);
}


</t>
<t tx="leo.20201108101534.198">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RCondition &amp;condition)
{
    RFileIO::writeBinary(outFile,condition.name);
    RFileIO::writeBinary(outFile,condition.size());
    for (unsigned int i=0;i&lt;condition.components.size();i++)
    {
        RFileIO::writeBinary(outFile,condition.components[i]);
    }
    RFileIO::writeBinary(outFile,condition.applyOnPoint);
    RFileIO::writeBinary(outFile,condition.applyOnLine);
    RFileIO::writeBinary(outFile,condition.applyOnSurface);
    RFileIO::writeBinary(outFile,condition.applyOnVolume);
    RFileIO::writeBinary(outFile,condition.problemTypeMask);
}


/*********************************************************************
 *  RBoundaryCondition                                               *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.199">void RFileIO::readAscii(RFile &amp;inFile, RBoundaryCondition &amp;boundaryCondition)
{
    RFileIO::readAscii(inFile,static_cast&lt;RCondition&amp;&gt;(boundaryCondition));
    RFileIO::readAscii(inFile,boundaryCondition.type);
    RFileIO::readAscii(inFile,boundaryCondition.optional);
    RFileIO::readAscii(inFile,boundaryCondition.isExplicit);
    RFileIO::readAscii(inFile,boundaryCondition.hasLocalDirection);
    RFileIO::readAscii(inFile,boundaryCondition.direction[0]);
    RFileIO::readAscii(inFile,boundaryCondition.direction[1]);
    RFileIO::readAscii(inFile,boundaryCondition.direction[2]);
}


</t>
<t tx="leo.20201108101534.2">void RElementShapeFunction::_init(const RElementShapeFunction *pElementShapeFunction)
{
    if (pElementShapeFunction)
    {
        this-&gt;N = pElementShapeFunction-&gt;N;
        this-&gt;dN = pElementShapeFunction-&gt;dN;
        this-&gt;w = pElementShapeFunction-&gt;w;
    }
}

RElementShapeFunction::RElementShapeFunction(const RRVector &amp;N, const RRMatrix &amp;dN, double w)
    : N(N)
    , dN(dN)
    , w(w)
{
    R_ERROR_ASSERT(N.size() == dN.getNRows());
    this-&gt;_init();
}

RElementShapeFunction::RElementShapeFunction(const RElementShapeFunction &amp;elementShapeFunction)
{
    this-&gt;_init(&amp;elementShapeFunction);
}

RElementShapeFunction::~RElementShapeFunction()
{
}

RElementShapeFunction &amp;RElementShapeFunction::operator =(const RElementShapeFunction &amp;elementShapeFunction)
{
    this-&gt;_init(&amp;elementShapeFunction);
    return (*this);
}

</t>
<t tx="leo.20201108101534.20">bool REntityGroupData::getVisible(void) const
{
    return this-&gt;visible;
}

</t>
<t tx="leo.20201108101534.200">void RFileIO::readBinary(RFile &amp;inFile, RBoundaryCondition &amp;boundaryCondition)
{
    RFileIO::readBinary(inFile,static_cast&lt;RCondition&amp;&gt;(boundaryCondition));
    RFileIO::readBinary(inFile,boundaryCondition.type);
    RFileIO::readBinary(inFile,boundaryCondition.optional);
    RFileIO::readBinary(inFile,boundaryCondition.isExplicit);
    RFileIO::readBinary(inFile,boundaryCondition.hasLocalDirection);
    RFileIO::readBinary(inFile,boundaryCondition.direction[0]);
    RFileIO::readBinary(inFile,boundaryCondition.direction[1]);
    RFileIO::readBinary(inFile,boundaryCondition.direction[2]);
}


</t>
<t tx="leo.20201108101534.201">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RBoundaryCondition &amp;boundaryCondition, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const RCondition&amp;&gt;(boundaryCondition),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,boundaryCondition.type,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,boundaryCondition.optional,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,boundaryCondition.isExplicit,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,boundaryCondition.hasLocalDirection,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,boundaryCondition.direction[0],addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,boundaryCondition.direction[1],addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,boundaryCondition.direction[2],addNewLine);
}


</t>
<t tx="leo.20201108101534.202">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RBoundaryCondition &amp;boundaryCondition)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const RCondition&amp;&gt;(boundaryCondition));
    RFileIO::writeBinary(outFile,boundaryCondition.type);
    RFileIO::writeBinary(outFile,boundaryCondition.optional);
    RFileIO::writeBinary(outFile,boundaryCondition.isExplicit);
    RFileIO::writeBinary(outFile,boundaryCondition.hasLocalDirection);
    RFileIO::writeBinary(outFile,boundaryCondition.direction[0]);
    RFileIO::writeBinary(outFile,boundaryCondition.direction[1]);
    RFileIO::writeBinary(outFile,boundaryCondition.direction[2]);
}


/*********************************************************************
 *  RInitialCondition                                                *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.203">void RFileIO::readAscii(RFile &amp;inFile, RInitialCondition &amp;initialCondition)
{
    RFileIO::readAscii(inFile,static_cast&lt;RCondition&amp;&gt;(initialCondition));
    RFileIO::readAscii(inFile,initialCondition.type);
}


</t>
<t tx="leo.20201108101534.204">void RFileIO::readBinary(RFile &amp;inFile, RInitialCondition &amp;initialCondition)
{
    RFileIO::readBinary(inFile,static_cast&lt;RCondition&amp;&gt;(initialCondition));
    RFileIO::readBinary(inFile,initialCondition.type);
}


</t>
<t tx="leo.20201108101534.205">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RInitialCondition &amp;initialCondition, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const RCondition&amp;&gt;(initialCondition),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,initialCondition.type,addNewLine);
}


</t>
<t tx="leo.20201108101534.206">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RInitialCondition &amp;initialCondition)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const RCondition&amp;&gt;(initialCondition));
    RFileIO::writeBinary(outFile,initialCondition.type);
}


/*********************************************************************
 *  REnvironmentCondition                                            *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.207">void RFileIO::readAscii(RFile &amp;inFile, REnvironmentCondition &amp;environmentCondition)
{
    RFileIO::readAscii(inFile,static_cast&lt;RCondition&amp;&gt;(environmentCondition));
    RFileIO::readAscii(inFile,environmentCondition.type);
}


</t>
<t tx="leo.20201108101534.208">void RFileIO::readBinary(RFile &amp;inFile, REnvironmentCondition &amp;environmentCondition)
{
    RFileIO::readBinary(inFile,static_cast&lt;RCondition&amp;&gt;(environmentCondition));
    RFileIO::readBinary(inFile,environmentCondition.type);
}


</t>
<t tx="leo.20201108101534.209">void RFileIO::writeAscii(RSaveFile &amp;outFile, const REnvironmentCondition &amp;environmentCondition, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const RCondition&amp;&gt;(environmentCondition),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,environmentCondition.type,addNewLine);
}


</t>
<t tx="leo.20201108101534.21">void REntityGroupData::setVisible(bool visible)
{
    this-&gt;visible = visible;
}

</t>
<t tx="leo.20201108101534.210">void RFileIO::writeBinary(RSaveFile &amp;outFile, const REnvironmentCondition &amp;environmentCondition)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const RCondition&amp;&gt;(environmentCondition));
    RFileIO::writeBinary(outFile,environmentCondition.type);
}


/*********************************************************************
 *  RMaterialPropertyType                                            *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.211">void RFileIO::readAscii(RFile &amp;inFile, RMaterialPropertyType &amp;mpType)
{
    QString propertyId;
    RFileIO::readAscii(inFile,propertyId);
    mpType = RMaterialProperty::getTypeFromId(propertyId);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.212">void RFileIO::readBinary(RFile &amp;inFile, RMaterialPropertyType &amp;mpType)
{
    QString propertyId;
    RFileIO::readBinary(inFile,propertyId);
    mpType = RMaterialProperty::getTypeFromId(propertyId);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.213">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RMaterialPropertyType &amp;mpType, bool addNewLine)
{
    RFileIO::writeAscii(outFile,RMaterialProperty::getId(mpType),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.214">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RMaterialPropertyType &amp;mpType)
{
    RFileIO::writeBinary(outFile,RMaterialProperty::getId(mpType));

} /* RFileIO::writeBinary */


/*********************************************************************
 *  RMaterialState                                                   *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.215">void RFileIO::readAscii(RFile &amp;inFile, RMaterialState &amp;state)
{
    int iValue;
    inFile.getTextStream() &gt;&gt; iValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read RMaterialState value.");
    }
    state = RMaterialState(iValue);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.216">void RFileIO::readBinary(RFile &amp;inFile, RMaterialState &amp;state)
{
    inFile.read((char*)&amp;state,sizeof(RMaterialState));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read RMaterialState value.");
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.217">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RMaterialState &amp;state, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; int(state);
    }
    else
    {
        outFile.getTextStream() &lt;&lt; int(state) &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RMaterialState value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.218">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RMaterialState &amp;state)
{
    outFile.write((char*)&amp;state,sizeof(RMaterialState));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RMaterialState value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RMaterialProperty                                                *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.219">void RFileIO::readAscii(RFile &amp;inFile, RMaterialProperty &amp;materialProperty)
{
    RFileIO::readAscii(inFile,static_cast&lt;RValueTable&amp;&gt;(materialProperty));
    RFileIO::readAscii(inFile,materialProperty.keyType);
    RFileIO::readAscii(inFile,materialProperty.type);
    // HACK - always based on temperature
    materialProperty.keyType = R_VARIABLE_TEMPERATURE;
}

</t>
<t tx="leo.20201108101534.22">void REntityGroupData::getColor(int &amp;r, int &amp;g, int &amp;b, int &amp;a) const
{
    r = this-&gt;rgba[0];
    g = this-&gt;rgba[1];
    b = this-&gt;rgba[2];
    a = this-&gt;rgba[3];
}

</t>
<t tx="leo.20201108101534.220">void RFileIO::readBinary(RFile &amp;inFile, RMaterialProperty &amp;materialProperty)
{
    RFileIO::readBinary(inFile,static_cast&lt;RValueTable&amp;&gt;(materialProperty));
    RFileIO::readBinary(inFile,materialProperty.keyType);
    RFileIO::readBinary(inFile,materialProperty.type);
    // HACK - always based on temperature
    materialProperty.keyType = R_VARIABLE_TEMPERATURE;
}

</t>
<t tx="leo.20201108101534.221">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RMaterialProperty &amp;materialProperty, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const RValueTable&amp;&gt;(materialProperty),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,materialProperty.keyType,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,materialProperty.type,addNewLine);
}

</t>
<t tx="leo.20201108101534.222">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RMaterialProperty &amp;materialProperty)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const RValueTable&amp;&gt;(materialProperty));
    RFileIO::writeBinary(outFile,materialProperty.keyType);
    RFileIO::writeBinary(outFile,materialProperty.type);
}


/*********************************************************************
 *  RMaterial                                                        *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.223">void RFileIO::readAscii(RFile &amp;inFile, RMaterial &amp;material)
{
    RFileIO::readAscii(inFile,material.id);
    RFileIO::readAscii(inFile,material.name);
    RFileIO::readAscii(inFile,material.state);
    unsigned int nPorperties;
    RFileIO::readAscii(inFile,nPorperties);
    material.properties.resize(nPorperties);
    for (unsigned int i=0;i&lt;nPorperties;i++)
    {
        RFileIO::readAscii(inFile,material.properties[i]);
    }
}


</t>
<t tx="leo.20201108101534.224">void RFileIO::readBinary(RFile &amp;inFile, RMaterial &amp;material)
{
    RFileIO::readBinary(inFile,material.id);
    RFileIO::readBinary(inFile,material.name);
    RFileIO::readBinary(inFile,material.state);
    unsigned int nPorperties;
    RFileIO::readBinary(inFile,nPorperties);
    material.properties.resize(nPorperties);
    for (unsigned int i=0;i&lt;nPorperties;i++)
    {
        RFileIO::readBinary(inFile,material.properties[i]);
    }
}


</t>
<t tx="leo.20201108101534.225">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RMaterial &amp;material, bool addNewLine)
{
    RFileIO::writeAscii(outFile,material.id,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,"\"" + material.name + "\"",addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,material.state,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,material.size(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;material.properties.size();i++)
    {
        RFileIO::writeAscii(outFile,material.properties[i],addNewLine);
        if (!addNewLine &amp;&amp; i+1 &lt; material.properties.size())
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
}


</t>
<t tx="leo.20201108101534.226">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RMaterial &amp;material)
{
    RFileIO::writeBinary(outFile,material.id);
    RFileIO::writeBinary(outFile,material.name);
    RFileIO::writeBinary(outFile,material.state);
    RFileIO::writeBinary(outFile,material.size());
    for (unsigned int i=0;i&lt;material.properties.size();i++)
    {
        RFileIO::writeBinary(outFile,material.properties[i]);
    }
}


/*********************************************************************
 *  RNode                                                            *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.227">void RFileIO::readAscii(RFile &amp;inFile, RNode &amp;node)
{
    RFileIO::readAscii(inFile,node.x);
    RFileIO::readAscii(inFile,node.y);
    RFileIO::readAscii(inFile,node.z);
}


</t>
<t tx="leo.20201108101534.228">void RFileIO::readBinary(RFile &amp;inFile, RNode &amp;node)
{
    RFileIO::readBinary(inFile,node.x);
    RFileIO::readBinary(inFile,node.y);
    RFileIO::readBinary(inFile,node.z);
}


</t>
<t tx="leo.20201108101534.229">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RNode &amp;node, bool addNewLine)
{
    RFileIO::writeAscii(outFile,node.x,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,node.y,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,node.z,addNewLine);
}


</t>
<t tx="leo.20201108101534.23">void REntityGroupData::setColor(int r, int g, int b, int a)
{
    this-&gt;rgba[0] = std::max(std::min(r,255),0);
    this-&gt;rgba[1] = std::max(std::min(g,255),0);
    this-&gt;rgba[2] = std::max(std::min(b,255),0);
    this-&gt;rgba[3] = std::max(std::min(a,255),0);
}

</t>
<t tx="leo.20201108101534.230">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RNode &amp;node)
{
    RFileIO::writeBinary(outFile,node.x);
    RFileIO::writeBinary(outFile,node.y);
    RFileIO::writeBinary(outFile,node.z);
}


/*********************************************************************
 *  RElementType                                                     *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.231">void RFileIO::readAscii(RFile &amp;inFile, RElementType &amp;elementType)
{
    QString propertyId;
    RFileIO::readAscii(inFile,propertyId);
    elementType = RElement::getTypeFromId(propertyId);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.232">void RFileIO::readBinary(RFile &amp;inFile, RElementType &amp;elementType)
{
    QString propertyId;
    RFileIO::readBinary(inFile,propertyId);
    elementType = RElement::getTypeFromId(propertyId);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.233">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RElementType &amp;elementType, bool addNewLine)
{
    RFileIO::writeAscii(outFile,RElement::getId(elementType),addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.234">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RElementType &amp;elementType)
{
    RFileIO::writeBinary(outFile,RElement::getId(elementType));
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RElement                                                         *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.235">void RFileIO::readAscii(RFile &amp;inFile, RElement &amp;element)
{
    RFileIO::readAscii(inFile,element.type);
    unsigned int nNodeIDs;
    RFileIO::readAscii(inFile,nNodeIDs);
    element.nodeIDs.resize(nNodeIDs);
    for (unsigned int i=0;i&lt;nNodeIDs;i++)
    {
        RFileIO::readAscii(inFile,element.nodeIDs[i]);
    }
}


</t>
<t tx="leo.20201108101534.236">void RFileIO::readBinary(RFile &amp;inFile, RElement &amp;element)
{
    RFileIO::readBinary(inFile,element.type);
    unsigned int nNodeIDs;
    RFileIO::readBinary(inFile,nNodeIDs);
    element.nodeIDs.resize(nNodeIDs);
    for (unsigned int i=0;i&lt;nNodeIDs;i++)
    {
        RFileIO::readBinary(inFile,element.nodeIDs[i]);
    }
}


</t>
<t tx="leo.20201108101534.237">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RElement &amp;element, bool addNewLine)
{
    RFileIO::writeAscii(outFile,element.type,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,element.size(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;element.nodeIDs.size();i++)
    {
        RFileIO::writeAscii(outFile,element.nodeIDs[i],addNewLine);
        if (!addNewLine &amp;&amp; i+1 &lt; element.nodeIDs.size())
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
}


</t>
<t tx="leo.20201108101534.238">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RElement &amp;element)
{
    RFileIO::writeBinary(outFile,element.type);
    RFileIO::writeBinary(outFile,element.size());
    for (unsigned int i=0;i&lt;element.nodeIDs.size();i++)
    {
        RFileIO::writeBinary(outFile,element.nodeIDs[i]);
    }
}


/*********************************************************************
 *  RElementGroupVariableDisplayType                                 *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.239">void RFileIO::readAscii(RFile &amp;inFile, REntityGroupVariableDisplayType &amp;elementGroupVariableDisplayType)
{
    int iValue;
    inFile.getTextStream() &gt;&gt; iValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read RElementGroupVariableDisplayType value.");
    }
    elementGroupVariableDisplayType = REntityGroupVariableDisplayType(iValue);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.24">bool REntityGroupData::getDrawWire(void) const
{
    return this-&gt;drawWire;
}

</t>
<t tx="leo.20201108101534.240">void RFileIO::readBinary(RFile &amp;inFile, REntityGroupVariableDisplayType &amp;elementGroupVariableDisplayType)
{
    inFile.read((char*)&amp;elementGroupVariableDisplayType,sizeof(REntityGroupVariableDisplayType));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read RElementGroupVariableDisplayType value.");
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.241">void RFileIO::writeAscii(RSaveFile &amp;outFile, const REntityGroupVariableDisplayType &amp;elementGroupVariableDisplayType, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; int(elementGroupVariableDisplayType);
    }
    else
    {
        outFile.getTextStream() &lt;&lt; int(elementGroupVariableDisplayType) &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RElementGroupVariableDisplayType value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.242">void RFileIO::writeBinary(RSaveFile &amp;outFile, const REntityGroupVariableDisplayType &amp;elementGroupVariableDisplayType)
{
    outFile.write((char*)&amp;elementGroupVariableDisplayType,sizeof(REntityGroupVariableDisplayType));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RElementGroupVariableDisplayType value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RElementGroupData                                                *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.243">void RFileIO::readAscii(RFile &amp;inFile, REntityGroupData &amp;elementGroupData)
{
    RFileIO::readAscii(inFile,elementGroupData.selected);
    RFileIO::readAscii(inFile,elementGroupData.visible);
    RFileIO::readAscii(inFile,elementGroupData.rgba[0]);
    RFileIO::readAscii(inFile,elementGroupData.rgba[1]);
    RFileIO::readAscii(inFile,elementGroupData.rgba[2]);
    RFileIO::readAscii(inFile,elementGroupData.rgba[3]);
    RFileIO::readAscii(inFile,elementGroupData.drawWire);
    RFileIO::readAscii(inFile,elementGroupData.drawEdges);
    RFileIO::readAscii(inFile,elementGroupData.drawNodes);
    RFileIO::readAscii(inFile,elementGroupData.drawElementNumbers);
    RFileIO::readAscii(inFile,elementGroupData.drawNodeNumbers);
    RFileIO::readAscii(inFile,elementGroupData.drawArrowHeads);
    RFileIO::readAscii(inFile,elementGroupData.drawEqualArrowLength);
    RFileIO::readAscii(inFile,elementGroupData.drawArrowFrom);
    RFileIO::readAscii(inFile,elementGroupData.colorByPatch);
    RFileIO::readAscii(inFile,elementGroupData.colorByViewFactor);
    elementGroupData.variableData.clear();
    unsigned int nVariableData = 0;
    RFileIO::readAscii(inFile,nVariableData);
    for (unsigned int i=0;i&lt;nVariableData;i++)
    {
        RVariableType variableType;
        REntityGroupVariableDisplayType variableDisplayType;
        RFileIO::readAscii(inFile,variableType);
        RFileIO::readAscii(inFile,variableDisplayType);
        elementGroupData.variableData[variableType] = variableDisplayType;
    }
}


</t>
<t tx="leo.20201108101534.244">void RFileIO::readBinary(RFile &amp;inFile, REntityGroupData &amp;elementGroupData)
{
    RFileIO::readBinary(inFile,elementGroupData.selected);
    RFileIO::readBinary(inFile,elementGroupData.visible);
    RFileIO::readBinary(inFile,elementGroupData.rgba[0]);
    RFileIO::readBinary(inFile,elementGroupData.rgba[1]);
    RFileIO::readBinary(inFile,elementGroupData.rgba[2]);
    RFileIO::readBinary(inFile,elementGroupData.rgba[3]);
    RFileIO::readBinary(inFile,elementGroupData.drawWire);
    RFileIO::readBinary(inFile,elementGroupData.drawEdges);
    RFileIO::readBinary(inFile,elementGroupData.drawNodes);
    RFileIO::readBinary(inFile,elementGroupData.drawElementNumbers);
    RFileIO::readBinary(inFile,elementGroupData.drawNodeNumbers);
    RFileIO::readBinary(inFile,elementGroupData.drawArrowHeads);
    RFileIO::readBinary(inFile,elementGroupData.drawEqualArrowLength);
    RFileIO::readBinary(inFile,elementGroupData.drawArrowFrom);
    RFileIO::readBinary(inFile,elementGroupData.colorByPatch);
    RFileIO::readBinary(inFile,elementGroupData.colorByViewFactor);
    elementGroupData.variableData.clear();
    unsigned int nVariableData = 0;
    RFileIO::readBinary(inFile,nVariableData);
    for (unsigned int i=0;i&lt;nVariableData;i++)
    {
        RVariableType variableType;
        REntityGroupVariableDisplayType variableDisplayType;
        RFileIO::readBinary(inFile,variableType);
        RFileIO::readBinary(inFile,variableDisplayType);
        elementGroupData.variableData[variableType] = variableDisplayType;
    }
}


</t>
<t tx="leo.20201108101534.245">void RFileIO::writeAscii(RSaveFile &amp;outFile, const REntityGroupData &amp;elementGroupData, bool addNewLine)
{
    RFileIO::writeAscii(outFile,elementGroupData.selected,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.visible,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.rgba[0],addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.rgba[1],addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.rgba[2],addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.rgba[3],addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.drawWire,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.drawEdges,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.drawNodes,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.drawElementNumbers,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.drawNodeNumbers,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.drawArrowHeads,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.drawEqualArrowLength,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.drawArrowFrom,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.colorByPatch,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroupData.colorByViewFactor,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,(unsigned int)elementGroupData.variableData.size(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    typedef std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt;::const_iterator it_type;
    for (it_type iterator = elementGroupData.variableData.begin(); iterator != elementGroupData.variableData.end(); iterator++) {
        RFileIO::writeAscii(outFile,RVariableType(iterator-&gt;first),addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
        RFileIO::writeAscii(outFile,REntityGroupVariableDisplayTypeMask(iterator-&gt;second),addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
}


</t>
<t tx="leo.20201108101534.246">void RFileIO::writeBinary(RSaveFile &amp;outFile, const REntityGroupData &amp;elementGroupData)
{
    RFileIO::writeBinary(outFile,elementGroupData.selected);
    RFileIO::writeBinary(outFile,elementGroupData.visible);
    RFileIO::writeBinary(outFile,elementGroupData.rgba[0]);
    RFileIO::writeBinary(outFile,elementGroupData.rgba[1]);
    RFileIO::writeBinary(outFile,elementGroupData.rgba[2]);
    RFileIO::writeBinary(outFile,elementGroupData.rgba[3]);
    RFileIO::writeBinary(outFile,elementGroupData.drawWire);
    RFileIO::writeBinary(outFile,elementGroupData.drawEdges);
    RFileIO::writeBinary(outFile,elementGroupData.drawNodes);
    RFileIO::writeBinary(outFile,elementGroupData.drawElementNumbers);
    RFileIO::writeBinary(outFile,elementGroupData.drawNodeNumbers);
    RFileIO::writeBinary(outFile,elementGroupData.drawArrowHeads);
    RFileIO::writeBinary(outFile,elementGroupData.drawEqualArrowLength);
    RFileIO::writeBinary(outFile,elementGroupData.drawArrowFrom);
    RFileIO::writeBinary(outFile,elementGroupData.colorByPatch);
    RFileIO::writeBinary(outFile,elementGroupData.colorByViewFactor);
    RFileIO::writeBinary(outFile,(unsigned int)elementGroupData.variableData.size());
    typedef std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt;::const_iterator it_type;
    for (it_type iterator = elementGroupData.variableData.begin(); iterator != elementGroupData.variableData.end(); iterator++) {
        RFileIO::writeBinary(outFile,RVariableType(iterator-&gt;first));
        RFileIO::writeBinary(outFile,REntityGroupVariableDisplayTypeMask(iterator-&gt;second));
    }
}


/*********************************************************************
 *  REntityGroup                                                     *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.247">void RFileIO::readAscii(RFile &amp;inFile, REntityGroup &amp;entityGroup)
{
    RFileIO::readAscii(inFile,entityGroup.name);
    RFileIO::readAscii(inFile,entityGroup.data);
}

</t>
<t tx="leo.20201108101534.248">void RFileIO::readBinary(RFile &amp;inFile, REntityGroup &amp;entityGroup)
{
    RFileIO::readBinary(inFile,entityGroup.name);
    RFileIO::readBinary(inFile,entityGroup.data);
}

</t>
<t tx="leo.20201108101534.249">void RFileIO::writeAscii(RSaveFile &amp;outFile, const REntityGroup &amp;entityGroup, bool addNewLine)
{
    RFileIO::writeAscii(outFile,"\"" + entityGroup.name + "\"",addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,entityGroup.data,addNewLine);
}

</t>
<t tx="leo.20201108101534.25">void REntityGroupData::setDrawWire(bool drawWire)
{
    this-&gt;drawWire = drawWire;
}

</t>
<t tx="leo.20201108101534.250">void RFileIO::writeBinary(RSaveFile &amp;outFile, const REntityGroup &amp;entityGroup)
{
    RFileIO::writeBinary(outFile,entityGroup.name);
    RFileIO::writeBinary(outFile,entityGroup.data);
}


/*********************************************************************
 *  RElementGroup                                                    *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.251">void RFileIO::readAscii(RFile &amp;inFile, RElementGroup &amp;elementGroup)
{
    RFileIO::readAscii(inFile,static_cast&lt;REntityGroup&amp;&gt;(elementGroup));
    unsigned int nElementIDs = 0;
    RFileIO::readAscii(inFile,nElementIDs);
    elementGroup.elementIDs.resize(nElementIDs);
    for (unsigned int i=0;i&lt;nElementIDs;i++)
    {
        RFileIO::readAscii(inFile,elementGroup.elementIDs[i]);
    }
    unsigned int nBConditions = 0;
    RFileIO::readAscii(inFile,nBConditions);
    RBoundaryCondition bCondition;
    for (unsigned int i=0;i&lt;nBConditions;i++)
    {
        RFileIO::readAscii(inFile,bCondition);
        elementGroup.addBoundaryCondition(bCondition);
    }
    unsigned int nEConditions = 0;
    RFileIO::readAscii(inFile,nEConditions);
    REnvironmentCondition eCondition;
    for (unsigned int i=0;i&lt;nEConditions;i++)
    {
        RFileIO::readAscii(inFile,eCondition);
        elementGroup.addEnvironmentCondition(eCondition);
    }
    unsigned int nIConditions = 0;
    RFileIO::readAscii(inFile,nIConditions);
    RInitialCondition iCondition;
    for (unsigned int i=0;i&lt;nIConditions;i++)
    {
        RFileIO::readAscii(inFile,iCondition);
        elementGroup.addInitialCondition(iCondition);
    }
    RFileIO::readAscii(inFile,elementGroup.material);
}


</t>
<t tx="leo.20201108101534.252">void RFileIO::readBinary(RFile &amp;inFile, RElementGroup &amp;elementGroup)
{
    RFileIO::readBinary(inFile,static_cast&lt;REntityGroup&amp;&gt;(elementGroup));
    unsigned int nElementIDs = 0;
    RFileIO::readBinary(inFile,nElementIDs);
    elementGroup.elementIDs.resize(nElementIDs);
    for (unsigned int i=0;i&lt;nElementIDs;i++)
    {
        RFileIO::readBinary(inFile,elementGroup.elementIDs[i]);
    }
    unsigned int nBConditions = 0;
    RFileIO::readBinary(inFile,nBConditions);
    RBoundaryCondition bCondition;
    for (unsigned int i=0;i&lt;nBConditions;i++)
    {
        RFileIO::readBinary(inFile,bCondition);
        elementGroup.addBoundaryCondition(bCondition);
    }
    unsigned int nEConditions = 0;
    RFileIO::readBinary(inFile,nEConditions);
    REnvironmentCondition eCondition;
    for (unsigned int i=0;i&lt;nEConditions;i++)
    {
        RFileIO::readBinary(inFile,eCondition);
        elementGroup.addEnvironmentCondition(eCondition);
    }
    unsigned int nIConditions = 0;
    RFileIO::readBinary(inFile,nIConditions);
    RInitialCondition iCondition;
    for (unsigned int i=0;i&lt;nIConditions;i++)
    {
        RFileIO::readBinary(inFile,iCondition);
        elementGroup.addInitialCondition(iCondition);
    }
    RFileIO::readBinary(inFile,elementGroup.material);
}


</t>
<t tx="leo.20201108101534.253">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RElementGroup &amp;elementGroup, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const REntityGroup&amp;&gt;(elementGroup),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,elementGroup.size(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;elementGroup.elementIDs.size();i++)
    {
        RFileIO::writeAscii(outFile,elementGroup.elementIDs[i],addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    RFileIO::writeAscii(outFile,elementGroup.getNBoundaryConditions(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;elementGroup.bConditions.size();i++)
    {
        RFileIO::writeAscii(outFile,elementGroup.getBoundaryCondition(i),addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    RFileIO::writeAscii(outFile,elementGroup.getNEnvironmentConditions(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;elementGroup.eConditions.size();i++)
    {
        RFileIO::writeAscii(outFile,elementGroup.getEnvironmentCondition(i),addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    RFileIO::writeAscii(outFile,elementGroup.getNInitialConditions(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;elementGroup.iConditions.size();i++)
    {
        RFileIO::writeAscii(outFile,elementGroup.getInitialCondition(i),addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    RFileIO::writeAscii(outFile,elementGroup.material,addNewLine);
}


</t>
<t tx="leo.20201108101534.254">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RElementGroup &amp;elementGroup)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const REntityGroup&amp;&gt;(elementGroup));
    RFileIO::writeBinary(outFile,elementGroup.size());
    for (unsigned int i=0;i&lt;elementGroup.elementIDs.size();i++)
    {
        RFileIO::writeBinary(outFile,elementGroup.elementIDs[i]);
    }
    RFileIO::writeBinary(outFile,elementGroup.getNBoundaryConditions());
    for (unsigned int i=0;i&lt;elementGroup.bConditions.size();i++)
    {
        RFileIO::writeBinary(outFile,elementGroup.getBoundaryCondition(i));
    }
    RFileIO::writeBinary(outFile,elementGroup.getNEnvironmentConditions());
    for (unsigned int i=0;i&lt;elementGroup.eConditions.size();i++)
    {
        RFileIO::writeBinary(outFile,elementGroup.getEnvironmentCondition(i));
    }
    RFileIO::writeBinary(outFile,elementGroup.getNInitialConditions());
    for (unsigned int i=0;i&lt;elementGroup.iConditions.size();i++)
    {
        RFileIO::writeBinary(outFile,elementGroup.getInitialCondition(i));
    }
    RFileIO::writeBinary(outFile,elementGroup.material);
}


/*********************************************************************
 *  RPoint                                                           *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.255">void RFileIO::readAscii(RFile &amp;inFile, RPoint &amp;point)
{
    RFileIO::readAscii(inFile,static_cast&lt;RElementGroup&amp;&gt;(point));
    RFileIO::readAscii(inFile,point.volume);
}

</t>
<t tx="leo.20201108101534.256">void RFileIO::readBinary(RFile &amp;inFile, RPoint &amp;point)
{
    RFileIO::readBinary(inFile,static_cast&lt;RElementGroup&amp;&gt;(point));
    RFileIO::readBinary(inFile,point.volume);
}

</t>
<t tx="leo.20201108101534.257">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RPoint &amp;point, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const RElementGroup&amp;&gt;(point),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,point.volume,addNewLine);
}

</t>
<t tx="leo.20201108101534.258">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RPoint &amp;point)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const RElementGroup&amp;&gt;(point));
    RFileIO::writeBinary(outFile,point.volume);
}


/*********************************************************************
 *  RLine                                                            *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.259">void RFileIO::readAscii(RFile &amp;inFile, RLine &amp;line)
{
    RFileIO::readAscii(inFile,static_cast&lt;RElementGroup&amp;&gt;(line));
    RFileIO::readAscii(inFile,line.crossArea);
}

</t>
<t tx="leo.20201108101534.26">bool REntityGroupData::getDrawEdges(void) const
{
    return this-&gt;drawEdges;
}

</t>
<t tx="leo.20201108101534.260">void RFileIO::readBinary(RFile &amp;inFile, RLine &amp;line)
{
    RFileIO::readBinary(inFile,static_cast&lt;RElementGroup&amp;&gt;(line));
    RFileIO::readBinary(inFile,line.crossArea);
}

</t>
<t tx="leo.20201108101534.261">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RLine &amp;line, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const RElementGroup&amp;&gt;(line),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,line.crossArea,addNewLine);
}

</t>
<t tx="leo.20201108101534.262">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RLine &amp;line)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const RElementGroup&amp;&gt;(line));
    RFileIO::writeBinary(outFile,line.crossArea);
}


/*********************************************************************
 *  RSurface                                                         *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.263">void RFileIO::readAscii(RFile &amp;inFile, RSurface &amp;surface)
{
    RFileIO::readAscii(inFile,static_cast&lt;RElementGroup&amp;&gt;(surface));
    RFileIO::readAscii(inFile,surface.thickness);
}

</t>
<t tx="leo.20201108101534.264">void RFileIO::readBinary(RFile &amp;inFile, RSurface &amp;surface)
{
    RFileIO::readBinary(inFile,static_cast&lt;RElementGroup&amp;&gt;(surface));
    RFileIO::readBinary(inFile,surface.thickness);
}

</t>
<t tx="leo.20201108101534.265">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RSurface &amp;surface, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const RElementGroup&amp;&gt;(surface),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,surface.thickness,addNewLine);
}

</t>
<t tx="leo.20201108101534.266">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RSurface &amp;surface)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const RElementGroup&amp;&gt;(surface));
    RFileIO::writeBinary(outFile,surface.thickness);
}


/*********************************************************************
 *  RVolume                                                          *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.267">void RFileIO::readAscii(RFile &amp;inFile, RVolume &amp;volume)
{
    RFileIO::readAscii(inFile,static_cast&lt;RElementGroup&amp;&gt;(volume));
}

</t>
<t tx="leo.20201108101534.268">void RFileIO::readBinary(RFile &amp;inFile, RVolume &amp;volume)
{
    RFileIO::readBinary(inFile,static_cast&lt;RElementGroup&amp;&gt;(volume));
}

</t>
<t tx="leo.20201108101534.269">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RVolume &amp;volume, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const RElementGroup&amp;&gt;(volume),addNewLine);
}

</t>
<t tx="leo.20201108101534.27">void REntityGroupData::setDrawEdges(bool drawEdges)
{
    this-&gt;drawEdges = drawEdges;
}

</t>
<t tx="leo.20201108101534.270">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RVolume &amp;volume)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const RElementGroup&amp;&gt;(volume));
}


/*********************************************************************
 *  RVectorField                                                     *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.271">void RFileIO::readAscii(RFile &amp;inFile, RVectorField &amp;vectorField)
{
    RFileIO::readAscii(inFile,static_cast&lt;REntityGroup&amp;&gt;(vectorField));
    RFileIO::readAscii(inFile,vectorField.variableType);
    if (inFile.getVersion() &gt; RVersion(0,3,3))
    {
        RFileIO::readAscii(inFile,vectorField.type3d);
    }
    unsigned int nElementGroupIDs;
    RFileIO::readAscii(inFile,nElementGroupIDs);
    vectorField.elementGroupIDs.resize(nElementGroupIDs);
    for (unsigned int i=0;i&lt;nElementGroupIDs;i++)
    {
        RFileIO::readAscii(inFile,vectorField.elementGroupIDs[i]);
    }
}


</t>
<t tx="leo.20201108101534.272">void RFileIO::readBinary(RFile &amp;inFile, RVectorField &amp;vectorField)
{
    RFileIO::readBinary(inFile,static_cast&lt;REntityGroup&amp;&gt;(vectorField));
    RFileIO::readBinary(inFile,vectorField.variableType);
    if (inFile.getVersion() &gt; RVersion(0,3,3))
    {
        RFileIO::readBinary(inFile,vectorField.type3d);
    }
    unsigned int nElementGroupIDs;
    RFileIO::readBinary(inFile,nElementGroupIDs);
    vectorField.elementGroupIDs.resize(nElementGroupIDs);
    for (unsigned int i=0;i&lt;nElementGroupIDs;i++)
    {
        RFileIO::readBinary(inFile,vectorField.elementGroupIDs[i]);
    }
}


</t>
<t tx="leo.20201108101534.273">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RVectorField &amp;vectorField, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const REntityGroup&amp;&gt;(vectorField),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,vectorField.variableType,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,vectorField.type3d,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,(unsigned int)vectorField.elementGroupIDs.size(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;vectorField.elementGroupIDs.size();i++)
    {
        RFileIO::writeAscii(outFile,vectorField.elementGroupIDs[i],addNewLine);
        if (!addNewLine &amp;&amp; i &lt; vectorField.elementGroupIDs.size()-1)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
}


</t>
<t tx="leo.20201108101534.274">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RVectorField &amp;vectorField)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const REntityGroup&amp;&gt;(vectorField));
    RFileIO::writeBinary(outFile,vectorField.variableType);
    RFileIO::writeBinary(outFile,vectorField.type3d);
    RFileIO::writeBinary(outFile,(unsigned int)vectorField.elementGroupIDs.size());
    for (unsigned int i=0;i&lt;vectorField.elementGroupIDs.size();i++)
    {
        RFileIO::writeBinary(outFile,vectorField.elementGroupIDs[i]);
    }
}


/*********************************************************************
 *  RScalarField                                                   *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.275">void RFileIO::readAscii(RFile &amp;inFile, RScalarField &amp;scalarField)
{
    RFileIO::readAscii(inFile,static_cast&lt;RVectorField&amp;&gt;(scalarField));
}

</t>
<t tx="leo.20201108101534.276">void RFileIO::readBinary(RFile &amp;inFile, RScalarField &amp;scalarField)
{
    RFileIO::readBinary(inFile,static_cast&lt;RVectorField&amp;&gt;(scalarField));
}

</t>
<t tx="leo.20201108101534.277">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RScalarField &amp;scalarField, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const RVectorField&amp;&gt;(scalarField),addNewLine);
}

</t>
<t tx="leo.20201108101534.278">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RScalarField &amp;scalarField)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const RVectorField&amp;&gt;(scalarField));
}


/*********************************************************************
 *  RStreamLine                                                      *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.279">void RFileIO::readAscii(RFile &amp;inFile, RStreamLine &amp;streamLine)
{
    RFileIO::readAscii(inFile,static_cast&lt;REntityGroup&amp;&gt;(streamLine));
    RFileIO::readAscii(inFile,streamLine.variableType);
    RFileIO::readAscii(inFile,streamLine.position);
}


</t>
<t tx="leo.20201108101534.28">bool REntityGroupData::getDrawNodes(void) const
{
    return this-&gt;drawNodes;
}

</t>
<t tx="leo.20201108101534.280">void RFileIO::readBinary(RFile &amp;inFile, RStreamLine &amp;streamLine)
{
    RFileIO::readBinary(inFile,static_cast&lt;REntityGroup&amp;&gt;(streamLine));
    RFileIO::readBinary(inFile,streamLine.variableType);
    RFileIO::readBinary(inFile,streamLine.position);
}


</t>
<t tx="leo.20201108101534.281">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RStreamLine &amp;streamLine, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const REntityGroup&amp;&gt;(streamLine),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,streamLine.variableType,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,streamLine.position,addNewLine);
}


</t>
<t tx="leo.20201108101534.282">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RStreamLine &amp;streamLine)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const REntityGroup&amp;&gt;(streamLine));
    RFileIO::writeBinary(outFile,streamLine.variableType);
    RFileIO::writeBinary(outFile,streamLine.position);
}


/*********************************************************************
 *  RCut                                                             *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.283">void RFileIO::readAscii(RFile &amp;inFile, RCut &amp;cut)
{
    RFileIO::readAscii(inFile,static_cast&lt;REntityGroup&amp;&gt;(cut));
    RFileIO::readAscii(inFile,cut.plane);
    unsigned int nElementGroupIDs;
    RFileIO::readAscii(inFile,nElementGroupIDs);
    cut.elementGroupIDs.resize(nElementGroupIDs);
    for (unsigned int i=0;i&lt;nElementGroupIDs;i++)
    {
        RFileIO::readAscii(inFile,cut.elementGroupIDs[i]);
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.284">void RFileIO::readBinary(RFile &amp;inFile, RCut &amp;cut)
{
    RFileIO::readBinary(inFile,static_cast&lt;REntityGroup&amp;&gt;(cut));
    RFileIO::readBinary(inFile,cut.plane);
    unsigned int nElementGroupIDs;
    RFileIO::readBinary(inFile,nElementGroupIDs);
    cut.elementGroupIDs.resize(nElementGroupIDs);
    for (unsigned int i=0;i&lt;nElementGroupIDs;i++)
    {
        RFileIO::readBinary(inFile,cut.elementGroupIDs[i]);
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.285">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RCut &amp;cut, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const REntityGroup&amp;&gt;(cut),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,cut.plane,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,(unsigned int)cut.elementGroupIDs.size(),addNewLine);
    for (unsigned int i=0;i&lt;cut.elementGroupIDs.size();i++)
    {
        RFileIO::writeAscii(outFile,cut.elementGroupIDs[i],addNewLine);
        if (!addNewLine &amp;&amp; i &lt; cut.elementGroupIDs.size()-1)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.286">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RCut &amp;cut)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const REntityGroup&amp;&gt;(cut));
    RFileIO::writeBinary(outFile,cut.plane);
    RFileIO::writeBinary(outFile,(unsigned int)cut.elementGroupIDs.size());
    for (unsigned int i=0;i&lt;cut.elementGroupIDs.size();i++)
    {
        RFileIO::writeBinary(outFile,cut.elementGroupIDs[i]);
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RIso                                                             *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.287">void RFileIO::readAscii(RFile &amp;inFile, RIso &amp;iso)
{
    RFileIO::readAscii(inFile,static_cast&lt;REntityGroup&amp;&gt;(iso));
    RFileIO::readAscii(inFile,iso.variableType);
    RFileIO::readAscii(inFile,iso.variableValue);
    unsigned int nElementGroupIDs;
    RFileIO::readAscii(inFile,nElementGroupIDs);
    iso.elementGroupIDs.resize(nElementGroupIDs);
    for (unsigned int i=0;i&lt;nElementGroupIDs;i++)
    {
        RFileIO::readAscii(inFile,iso.elementGroupIDs[i]);
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.288">void RFileIO::readBinary(RFile &amp;inFile, RIso &amp;iso)
{
    RFileIO::readBinary(inFile,static_cast&lt;REntityGroup&amp;&gt;(iso));
    RFileIO::readBinary(inFile,iso.variableType);
    RFileIO::readBinary(inFile,iso.variableValue);
    unsigned int nElementGroupIDs;
    RFileIO::readBinary(inFile,nElementGroupIDs);
    iso.elementGroupIDs.resize(nElementGroupIDs);
    for (unsigned int i=0;i&lt;nElementGroupIDs;i++)
    {
        RFileIO::readBinary(inFile,iso.elementGroupIDs[i]);
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.289">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RIso &amp;iso, bool addNewLine)
{
    RFileIO::writeAscii(outFile,static_cast&lt;const REntityGroup&amp;&gt;(iso),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,iso.variableType,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,iso.variableValue,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,(unsigned int)iso.elementGroupIDs.size(),addNewLine);
    for (unsigned int i=0;i&lt;iso.elementGroupIDs.size();i++)
    {
        RFileIO::writeAscii(outFile,iso.elementGroupIDs[i],addNewLine);
        if (!addNewLine &amp;&amp; i &lt; iso.elementGroupIDs.size()-1)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.29">void REntityGroupData::setDrawNodes(bool drawNodes)
{
    this-&gt;drawNodes = drawNodes;
}

</t>
<t tx="leo.20201108101534.290">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RIso &amp;iso)
{
    RFileIO::writeBinary(outFile,static_cast&lt;const REntityGroup&amp;&gt;(iso));
    RFileIO::writeBinary(outFile,iso.variableType);
    RFileIO::writeBinary(outFile,iso.variableValue);
    RFileIO::writeBinary(outFile,(unsigned int)iso.elementGroupIDs.size());
    for (unsigned int i=0;i&lt;iso.elementGroupIDs.size();i++)
    {
        RFileIO::writeBinary(outFile,iso.elementGroupIDs[i]);
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RFileType                                                        *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.291">void RFileIO::readAscii(RFile &amp;inFile, RFileType &amp;fileType)
{
    int iValue;
    inFile.getTextStream() &gt;&gt; iValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read RFileType value.");
    }
    fileType = RFileType(iValue);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.292">void RFileIO::readBinary(RFile &amp;inFile, RFileType &amp;fileType)
{
    int iValue;
    RFileIO::readBinary(inFile,iValue);
    fileType = RFileType(iValue);
//    inFile.read((char*)&amp;fileType,sizeof(RFileType));
//    if (inFile.error() != RFile::NoError)
//    {
//        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read RFileType value.");
//    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.293">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RFileType &amp;fileType, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; int(fileType);
    }
    else
    {
        outFile.getTextStream() &lt;&lt; int(fileType) &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RFileType value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.294">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RFileType &amp;fileType)
{
    RFileIO::writeBinary(outFile,int(fileType));
//    outFile.write((char*)&amp;fileType,sizeof(RFileType));
//    if (outFile.error() != RFile::NoError)
//    {
//        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RFileType value.");
//    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RFileHeader                                                      *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.295">void RFileIO::readAscii(RFile &amp;inFile, RFileHeader &amp;fileHeader)
{
    RFileIO::readAscii(inFile,fileHeader.version);
    RFileIO::readAscii(inFile,fileHeader.type);
    RFileIO::readAscii(inFile,fileHeader.information);
}

</t>
<t tx="leo.20201108101534.296">void RFileIO::readBinary(RFile &amp;inFile, RFileHeader &amp;fileHeader)
{
    RFileIO::readBinary(inFile,fileHeader.version);
    RFileIO::readBinary(inFile,fileHeader.type);
    RFileIO::readBinary(inFile,fileHeader.information);
}

</t>
<t tx="leo.20201108101534.297">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RFileHeader &amp;fileHeader, bool addNewLine)
{
    RFileIO::writeAscii(outFile,fileHeader.version,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,fileHeader.type,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,fileHeader.information,addNewLine);
}

</t>
<t tx="leo.20201108101534.298">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RFileHeader &amp;fileHeader)
{
    RFileIO::writeBinary(outFile,fileHeader.version);
    RFileIO::writeBinary(outFile,fileHeader.type);
    RFileIO::writeBinary(outFile,fileHeader.information);
}


/*********************************************************************
 *  RTimeMarchApproximation                                          *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.299">void RFileIO::readAscii(RFile &amp;inFile, RTimeMarchApproximation &amp;timeMarchApproximation)
{
    int iValue;
    inFile.getTextStream() &gt;&gt; iValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read RTimeMarchApproximation value.");
    }
    timeMarchApproximation = RTimeMarchApproximation(iValue);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.3">unsigned int RElementShapeFunction::getNNodes(void) const
{
    return this-&gt;N.getNRows();
}

</t>
<t tx="leo.20201108101534.30">bool REntityGroupData::getDrawElementNumbers(void) const
{
    return this-&gt;drawElementNumbers;
}

</t>
<t tx="leo.20201108101534.300">void RFileIO::readBinary(RFile &amp;inFile, RTimeMarchApproximation &amp;timeMarchApproximation)
{
    inFile.read((char*)&amp;timeMarchApproximation,sizeof(RTimeMarchApproximation));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read RTimeMarchApproximation value.");
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.301">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RTimeMarchApproximation &amp;timeMarchApproximation, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; int(timeMarchApproximation);
    }
    else
    {
        outFile.getTextStream() &lt;&lt; int(timeMarchApproximation) &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RTimeMarchApproximation value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.302">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RTimeMarchApproximation &amp;timeMarchApproximation)
{
    outFile.write((char*)&amp;timeMarchApproximation,sizeof(RTimeMarchApproximation));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RTimeMarchApproximation value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RModalMethod                                                     *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.303">void RFileIO::readAscii(RFile &amp;inFile, RModalMethod &amp;method)
{
    int iValue;
    inFile.getTextStream() &gt;&gt; iValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read RModalMethod value.");
    }
    method = RModalMethod(iValue);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.304">void RFileIO::readBinary(RFile &amp;inFile, RModalMethod &amp;method)
{
    inFile.read((char*)&amp;method,sizeof(RModalMethod));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read RModalMethod value.");
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.305">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RModalMethod &amp;method, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; int(method);
    }
    else
    {
        outFile.getTextStream() &lt;&lt; int(method) &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RModalMethod value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.306">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RModalMethod &amp;method)
{
    outFile.write((char*)&amp;method,sizeof(RModalMethod));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RModalMethod value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RTimeSolver                                                      *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.307">void RFileIO::readAscii(RFile &amp;inFile, RTimeSolver &amp;timeSolver)
{
    RFileIO::readAscii(inFile,timeSolver.enabled);
    RFileIO::readAscii(inFile,timeSolver.timeMarchApproximation);
    unsigned int nTimes = 0;
    RFileIO::readAscii(inFile,nTimes);
    timeSolver.times.resize(nTimes);
    for (unsigned int i=0;i&lt;timeSolver.times.size();i++)
    {
        RFileIO::readAscii(inFile,timeSolver.times[i]);
    }
    RFileIO::readAscii(inFile,timeSolver.inputNTimeSteps);
    RFileIO::readAscii(inFile,timeSolver.inputStartTime);
    RFileIO::readAscii(inFile,timeSolver.inputTimeStepSize);
    RFileIO::readAscii(inFile,timeSolver.currentTimeStep);
    RFileIO::readAscii(inFile,timeSolver.computedTime);
    RFileIO::readAscii(inFile,timeSolver.outputFrequency);
}

</t>
<t tx="leo.20201108101534.308">void RFileIO::readBinary(RFile &amp;inFile, RTimeSolver &amp;timeSolver)
{
    RFileIO::readBinary(inFile,timeSolver.enabled);
    RFileIO::readBinary(inFile,timeSolver.timeMarchApproximation);
    unsigned int nTimes = 0;
    RFileIO::readBinary(inFile,nTimes);
    timeSolver.times.resize(nTimes);
    for (unsigned int i=0;i&lt;timeSolver.times.size();i++)
    {
        RFileIO::readBinary(inFile,timeSolver.times[i]);
    }
    RFileIO::readBinary(inFile,timeSolver.inputNTimeSteps);
    RFileIO::readBinary(inFile,timeSolver.inputStartTime);
    RFileIO::readBinary(inFile,timeSolver.inputTimeStepSize);
    RFileIO::readBinary(inFile,timeSolver.currentTimeStep);
    RFileIO::readBinary(inFile,timeSolver.computedTime);
    RFileIO::readBinary(inFile,timeSolver.outputFrequency);
}

</t>
<t tx="leo.20201108101534.309">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RTimeSolver &amp;timeSolver, bool addNewLine)
{
    RFileIO::writeAscii(outFile,timeSolver.enabled,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,timeSolver.timeMarchApproximation,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,(unsigned int)timeSolver.times.size(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;timeSolver.times.size();i++)
    {
        RFileIO::writeAscii(outFile,timeSolver.times[i],addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    RFileIO::writeAscii(outFile,timeSolver.inputNTimeSteps,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,timeSolver.inputStartTime,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,timeSolver.inputTimeStepSize,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,timeSolver.currentTimeStep,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,timeSolver.computedTime,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,timeSolver.outputFrequency,addNewLine);
}

</t>
<t tx="leo.20201108101534.31">void REntityGroupData::setDrawElementNumbers(bool drawElementNumbers)
{
    this-&gt;drawElementNumbers = drawElementNumbers;
}

</t>
<t tx="leo.20201108101534.310">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RTimeSolver &amp;timeSolver)
{
    RFileIO::writeBinary(outFile,timeSolver.enabled);
    RFileIO::writeBinary(outFile,timeSolver.timeMarchApproximation);
    RFileIO::writeBinary(outFile,(unsigned int)timeSolver.times.size());
    for (unsigned int i=0;i&lt;timeSolver.times.size();i++)
    {
        RFileIO::writeBinary(outFile,timeSolver.times[i]);
    }
    RFileIO::writeBinary(outFile,timeSolver.inputNTimeSteps);
    RFileIO::writeBinary(outFile,timeSolver.inputStartTime);
    RFileIO::writeBinary(outFile,timeSolver.inputTimeStepSize);
    RFileIO::writeBinary(outFile,timeSolver.currentTimeStep);
    RFileIO::writeBinary(outFile,timeSolver.computedTime);
    RFileIO::writeBinary(outFile,timeSolver.outputFrequency);
}


/*********************************************************************
 *  RMatrixSolverConf                                                *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.311">void RFileIO::readAscii(RFile &amp;inFile, RMatrixSolverConf &amp;matrixSolver)
{
    RFileIO::readAscii(inFile,matrixSolver.type);
    RFileIO::readAscii(inFile,matrixSolver.nInnerIterations);
    RFileIO::readAscii(inFile,matrixSolver.nOuterIterations);
    RFileIO::readAscii(inFile,matrixSolver.solverCvgValue);
    RFileIO::readAscii(inFile,matrixSolver.outputFrequency);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.312">void RFileIO::readBinary(RFile &amp;inFile, RMatrixSolverConf &amp;matrixSolver)
{
    RFileIO::readBinary(inFile,matrixSolver.type);
    RFileIO::readBinary(inFile,matrixSolver.nInnerIterations);
    RFileIO::readBinary(inFile,matrixSolver.nOuterIterations);
    RFileIO::readBinary(inFile,matrixSolver.solverCvgValue);
    RFileIO::readBinary(inFile,matrixSolver.outputFrequency);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.313">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RMatrixSolverConf &amp;matrixSolver, bool addNewLine)
{
    RFileIO::writeAscii(outFile,matrixSolver.type,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,matrixSolver.nInnerIterations,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,matrixSolver.nOuterIterations,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,matrixSolver.solverCvgValue,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,matrixSolver.outputFrequency,addNewLine);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.314">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RMatrixSolverConf &amp;matrixSolver)
{
    RFileIO::writeBinary(outFile,matrixSolver.type);
    RFileIO::writeBinary(outFile,matrixSolver.nInnerIterations);
    RFileIO::writeBinary(outFile,matrixSolver.nOuterIterations);
    RFileIO::writeBinary(outFile,matrixSolver.solverCvgValue);
    RFileIO::writeBinary(outFile,matrixSolver.outputFrequency);
} /* RFileIO::writeBinary */


/*********************************************************************
 *  RMonitoringPoint                                                 *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.315">void RFileIO::readAscii(RFile &amp;inFile, RMonitoringPoint &amp;monitoringPoint)
{
    RFileIO::readAscii(inFile,monitoringPoint.variableType);
    RFileIO::readAscii(inFile,monitoringPoint.position);
}


</t>
<t tx="leo.20201108101534.316">void RFileIO::readBinary(RFile &amp;inFile, RMonitoringPoint &amp;monitoringPoint)
{
    RFileIO::readBinary(inFile,monitoringPoint.variableType);
    RFileIO::readBinary(inFile,monitoringPoint.position);
}


</t>
<t tx="leo.20201108101534.317">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RMonitoringPoint &amp;monitoringPoint, bool addNewLine)
{
    RFileIO::writeAscii(outFile,monitoringPoint.variableType,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,monitoringPoint.position,false,addNewLine);
}


</t>
<t tx="leo.20201108101534.318">void RFileIO::writeAscii(RFile &amp;outFile, const RMonitoringPoint &amp;monitoringPoint, bool addNewLine)
{
    RFileIO::writeAscii(outFile,monitoringPoint.variableType,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,monitoringPoint.position,false,addNewLine);
}


</t>
<t tx="leo.20201108101534.319">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RMonitoringPoint &amp;monitoringPoint)
{
    RFileIO::writeBinary(outFile,monitoringPoint.variableType);
    RFileIO::writeBinary(outFile,monitoringPoint.position);
}


/*********************************************************************
 *  RMonitoringPointManager                                          *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.32">bool REntityGroupData::getDrawNodeNumbers(void) const
{
    return this-&gt;drawNodeNumbers;
}

</t>
<t tx="leo.20201108101534.320">void RFileIO::readAscii(RFile &amp;inFile, RMonitoringPointManager &amp;monitoringPointManager)
{
    unsigned int nMonitoringPoints;
    RFileIO::readAscii(inFile,nMonitoringPoints);
    monitoringPointManager.resize(nMonitoringPoints);
    for (unsigned int i=0;i&lt;nMonitoringPoints;i++)
    {
        RFileIO::readAscii(inFile,monitoringPointManager[i]);
    }
}


</t>
<t tx="leo.20201108101534.321">void RFileIO::readBinary(RFile &amp;inFile, RMonitoringPointManager &amp;monitoringPointManager)
{
    unsigned int nMonitoringPoints;
    RFileIO::readBinary(inFile,nMonitoringPoints);
    monitoringPointManager.resize(nMonitoringPoints);
    for (unsigned int i=0;i&lt;nMonitoringPoints;i++)
    {
        RFileIO::readBinary(inFile,monitoringPointManager[i]);
    }
}


</t>
<t tx="leo.20201108101534.322">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RMonitoringPointManager &amp;monitoringPointManager, bool addNewLine)
{
    RFileIO::writeAscii(outFile,(unsigned int)monitoringPointManager.size(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (unsigned int i=0;i&lt;monitoringPointManager.size();i++)
    {
        RFileIO::writeAscii(outFile,monitoringPointManager[i],addNewLine);
        if (i &lt; monitoringPointManager.size()-1 &amp;&amp; !addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
}


</t>
<t tx="leo.20201108101534.323">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RMonitoringPointManager &amp;monitoringPointManager)
{
    RFileIO::writeBinary(outFile,(unsigned int)monitoringPointManager.size());
    for (unsigned int i=0;i&lt;monitoringPointManager.size();i++)
    {
        RFileIO::writeBinary(outFile,monitoringPointManager[i]);
    }
}


/*********************************************************************
 *  RProblemType                                                     *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.324">void RFileIO::readAscii(RFile &amp;inFile, RProblemType &amp;problemType)
{
    QString id;
    RFileIO::readAscii(inFile,id);
    problemType = RProblem::getTypeFromId(id);
}

</t>
<t tx="leo.20201108101534.325">void RFileIO::readBinary(RFile &amp;inFile, RProblemType &amp;problemType)
{
    QString id;
    RFileIO::readBinary(inFile,id);
    problemType = RProblem::getTypeFromId(id);
}

</t>
<t tx="leo.20201108101534.326">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RProblemType &amp;problemType, bool addNewLine)
{
    RFileIO::writeAscii(outFile,RProblem::getId(problemType),addNewLine);
}

</t>
<t tx="leo.20201108101534.327">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RProblemType &amp;problemType)
{
    RFileIO::writeBinary(outFile,RProblem::getId(problemType));
}


/*********************************************************************
 *  RProblemTaskItem                                                 *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.328">void RFileIO::readAscii(RFile &amp;inFile, RProblemTaskItem &amp;problemTaskItem)
{
    RFileIO::readAscii(inFile,problemTaskItem.problemType);
    RFileIO::readAscii(inFile,problemTaskItem.nIterations);
    uint nChildren = 0;
    RFileIO::readAscii(inFile,nChildren);
    for (uint i=0;i&lt;nChildren;i++)
    {
        RProblemTaskItem child;
        RFileIO::readAscii(inFile,child);
        problemTaskItem.addChild(child);
    }
}

</t>
<t tx="leo.20201108101534.329">void RFileIO::readBinary(RFile &amp;inFile, RProblemTaskItem &amp;problemTaskItem)
{
    RFileIO::readBinary(inFile,problemTaskItem.problemType);
    RFileIO::readBinary(inFile,problemTaskItem.nIterations);
    uint nChildren = 0;
    RFileIO::readBinary(inFile,nChildren);
    for (uint i=0;i&lt;nChildren;i++)
    {
        RProblemTaskItem child;
        RFileIO::readBinary(inFile,child);
        problemTaskItem.addChild(child);
    }
}

</t>
<t tx="leo.20201108101534.33">void REntityGroupData::setDrawNodeNumbers(bool drawNodeNumbers)
{
    this-&gt;drawNodeNumbers = drawNodeNumbers;
}

</t>
<t tx="leo.20201108101534.330">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RProblemTaskItem &amp;problemTaskItem, bool addNewLine)
{
    RFileIO::writeAscii(outFile,problemTaskItem.problemType,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,problemTaskItem.nIterations,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,uint(problemTaskItem.children.size()),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    for (uint i=0;i&lt;problemTaskItem.children.size();i++)
    {
        RFileIO::writeAscii(outFile,problemTaskItem.children[i],addNewLine);
        if (i &lt; problemTaskItem.children.size()-1 &amp;&amp; !addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
}

</t>
<t tx="leo.20201108101534.331">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RProblemTaskItem &amp;problemTaskItem)
{
    RFileIO::writeBinary(outFile,problemTaskItem.problemType);
    RFileIO::writeBinary(outFile,problemTaskItem.nIterations);
    RFileIO::writeBinary(outFile,uint(problemTaskItem.children.size()));
    for (uint i=0;i&lt;problemTaskItem.children.size();i++)
    {
        RFileIO::writeBinary(outFile,problemTaskItem.children[i]);
    }
}


/*********************************************************************
 *  RProblemSetup                                                    *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.332">void RFileIO::readAscii(RFile &amp;inFile, RProblemSetup &amp;problemSetup)
{
    RFileIO::readAscii(inFile,problemSetup.restart);
    RFileIO::readAscii(inFile,problemSetup.radiationSetup);
    RFileIO::readAscii(inFile,problemSetup.modalSetup);
    if (inFile.getVersion() &gt; RVersion(0,3,4))
    {
        RFileIO::readAscii(inFile,problemSetup.meshSetup);
    }
}

</t>
<t tx="leo.20201108101534.333">void RFileIO::readBinary(RFile &amp;inFile, RProblemSetup &amp;problemSetup)
{
    RFileIO::readBinary(inFile,problemSetup.restart);
    RFileIO::readBinary(inFile,problemSetup.radiationSetup);
    RFileIO::readBinary(inFile,problemSetup.modalSetup);
    if (inFile.getVersion() &gt; RVersion(0,3,4))
    {
        RFileIO::readBinary(inFile,problemSetup.meshSetup);
    }
}

</t>
<t tx="leo.20201108101534.334">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RProblemSetup &amp;problemSetup, bool addNewLine)
{
    RFileIO::writeAscii(outFile,problemSetup.restart,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,problemSetup.radiationSetup,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,problemSetup.modalSetup,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,problemSetup.meshSetup,addNewLine);
}

</t>
<t tx="leo.20201108101534.335">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RProblemSetup &amp;problemSetup)
{
    RFileIO::writeBinary(outFile,problemSetup.restart);
    RFileIO::writeBinary(outFile,problemSetup.radiationSetup);
    RFileIO::writeBinary(outFile,problemSetup.modalSetup);
    RFileIO::writeBinary(outFile,problemSetup.meshSetup);
}


/*********************************************************************
 *  RRadiationResolution                                             *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.336">void RFileIO::readAscii(RFile &amp;inFile, RRadiationResolution &amp;radiationResolution)
{
    int iValue;
    inFile.getTextStream() &gt;&gt; iValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read RRadiationResolution value.");
    }
    radiationResolution = RRadiationResolution(iValue);
}

</t>
<t tx="leo.20201108101534.337">void RFileIO::readBinary(RFile &amp;inFile, RRadiationResolution &amp;radiationResolution)
{
    inFile.read((char*)&amp;radiationResolution,sizeof(RRadiationResolution));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read RRadiationResolution value.");
    }
}

</t>
<t tx="leo.20201108101534.338">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RRadiationResolution &amp;radiationResolution, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; int(radiationResolution);
    }
    else
    {
        outFile.getTextStream() &lt;&lt; int(radiationResolution) &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RRadiationResolution value.");
    }
}

</t>
<t tx="leo.20201108101534.339">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RRadiationResolution &amp;radiationResolution)
{
    outFile.write((char*)&amp;radiationResolution,sizeof(RRadiationResolution));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write RRadiationResolution value.");
    }
}


/*********************************************************************
 *  RRadiationSetup                                                  *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.34">bool REntityGroupData::getDrawArrowHeads(void) const
{
    return this-&gt;drawArrowHeads;
}

</t>
<t tx="leo.20201108101534.340">void RFileIO::readAscii(RFile &amp;inFile, RRadiationSetup &amp;radiationSetup)
{
    RFileIO::readAscii(inFile,radiationSetup.resolution);
    RFileIO::readAscii(inFile,radiationSetup.viewFactorMatrixFile);
}

</t>
<t tx="leo.20201108101534.341">void RFileIO::readBinary(RFile &amp;inFile, RRadiationSetup &amp;radiationSetup)
{
    RFileIO::readBinary(inFile,radiationSetup.resolution);
    RFileIO::readBinary(inFile,radiationSetup.viewFactorMatrixFile);
}

</t>
<t tx="leo.20201108101534.342">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RRadiationSetup &amp;radiationSetup, bool addNewLine)
{
    RFileIO::writeAscii(outFile,radiationSetup.resolution,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,radiationSetup.viewFactorMatrixFile,addNewLine);
}

</t>
<t tx="leo.20201108101534.343">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RRadiationSetup &amp;radiationSetup)
{
    RFileIO::writeBinary(outFile,radiationSetup.resolution);
    RFileIO::writeBinary(outFile,radiationSetup.viewFactorMatrixFile);
}


/*********************************************************************
 *  RModalSetup                                                      *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.344">void RFileIO::readAscii(RFile &amp;inFile, RModalSetup &amp;modalSetup)
{
    RFileIO::readAscii(inFile,modalSetup.method);
    RFileIO::readAscii(inFile,modalSetup.nIterations);
    RFileIO::readAscii(inFile,modalSetup.nModesToExtract);
    RFileIO::readAscii(inFile,modalSetup.convergenceValue);
    RFileIO::readAscii(inFile,modalSetup.mode);
    RFileIO::readAscii(inFile,modalSetup.frequency);
}

</t>
<t tx="leo.20201108101534.345">void RFileIO::readBinary(RFile &amp;inFile, RModalSetup &amp;modalSetup)
{
    RFileIO::readBinary(inFile,modalSetup.method);
    RFileIO::readBinary(inFile,modalSetup.nIterations);
    RFileIO::readBinary(inFile,modalSetup.nModesToExtract);
    RFileIO::readBinary(inFile,modalSetup.convergenceValue);
    RFileIO::readBinary(inFile,modalSetup.mode);
    RFileIO::readBinary(inFile,modalSetup.frequency);
}

</t>
<t tx="leo.20201108101534.346">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RModalSetup &amp;modalSetup, bool addNewLine)
{
    RFileIO::writeAscii(outFile,modalSetup.method,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,modalSetup.nIterations,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,modalSetup.nModesToExtract,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,modalSetup.convergenceValue,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,modalSetup.mode,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,modalSetup.frequency,addNewLine);
}

</t>
<t tx="leo.20201108101534.347">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RModalSetup &amp;modalSetup)
{
    RFileIO::writeBinary(outFile,modalSetup.method);
    RFileIO::writeBinary(outFile,modalSetup.nIterations);
    RFileIO::writeBinary(outFile,modalSetup.nModesToExtract);
    RFileIO::writeBinary(outFile,modalSetup.convergenceValue);
    RFileIO::writeBinary(outFile,modalSetup.mode);
    RFileIO::writeBinary(outFile,modalSetup.frequency);
}


/*********************************************************************
 *  RMeshSetup                                                       *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.348">void RFileIO::readAscii(RFile &amp;inFile, RMeshSetup &amp;meshSetup)
{
    meshSetup.variables.clear();

    uint nVariables = 0;
    RFileIO::readAscii(inFile,nVariables);
    for (uint i=0;i&lt;nVariables;i++)
    {
        RVariableType variableType;
        RFileIO::readAscii(inFile,variableType);
        meshSetup.variables.insert(variableType);
    }
    RFileIO::readAscii(inFile,meshSetup.minEdgeLength);
    RFileIO::readAscii(inFile,meshSetup.maxEdgeLength);
}

</t>
<t tx="leo.20201108101534.349">void RFileIO::readBinary(RFile &amp;inFile, RMeshSetup &amp;meshSetup)
{
    meshSetup.variables.clear();

    int nVariables = 0;
    RFileIO::readBinary(inFile,nVariables);
    for (int i=0;i&lt;nVariables;i++)
    {
        RVariableType variableType;
        RFileIO::readBinary(inFile,variableType);
        meshSetup.variables.insert(variableType);
    }
    RFileIO::readBinary(inFile,meshSetup.minEdgeLength);
    RFileIO::readBinary(inFile,meshSetup.maxEdgeLength);
}

</t>
<t tx="leo.20201108101534.35">void REntityGroupData::setDrawArrowHeads(bool drawArrowHeads)
{
    this-&gt;drawArrowHeads = drawArrowHeads;
}

</t>
<t tx="leo.20201108101534.350">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RMeshSetup &amp;meshSetup, bool addNewLine)
{
    RFileIO::writeAscii(outFile,meshSetup.variables.size(),addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    foreach (RVariableType variableType, meshSetup.variables)
    {
        RFileIO::writeAscii(outFile,variableType,addNewLine);
        if (!addNewLine)
        {
            RFileIO::writeAscii(outFile,' ',false);
        }
    }
    RFileIO::writeAscii(outFile,meshSetup.minEdgeLength,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,meshSetup.maxEdgeLength,addNewLine);
}

</t>
<t tx="leo.20201108101534.351">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RMeshSetup &amp;meshSetup)
{
    RFileIO::writeBinary(outFile,meshSetup.variables.size());
    foreach (RVariableType variableType, meshSetup.variables)
    {
        RFileIO::writeBinary(outFile,variableType);
    }
    RFileIO::writeBinary(outFile,meshSetup.minEdgeLength);
    RFileIO::writeBinary(outFile,meshSetup.maxEdgeLength);
}


/*********************************************************************
 *  RBook                                                            *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.352">void RFileIO::readAscii(RFile &amp;inFile, RBook &amp;book)
{
    RFileIO::readAscii(inFile,book.book,true);
}

</t>
<t tx="leo.20201108101534.353">void RFileIO::readBinary(RFile &amp;inFile, RBook &amp;book)
{
    RFileIO::readBinary(inFile,book.book,true);
}

</t>
<t tx="leo.20201108101534.354">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RBook &amp;book, bool addNewLine)
{
    RFileIO::writeAscii(outFile,book.book,true,addNewLine);
}

</t>
<t tx="leo.20201108101534.355">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RBook &amp;book)
{
    RFileIO::writeBinary(outFile,book.book,true);
}


/*********************************************************************
 *  RPatch                                                           *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.356">void RFileIO::readAscii(RFile &amp;inFile, RPatch &amp;patch)
{
    RFileIO::readAscii(inFile,patch.surfaceID);
    RFileIO::readAscii(inFile,patch.elementIDs,true);
}

</t>
<t tx="leo.20201108101534.357">void RFileIO::readBinary(RFile &amp;inFile, RPatch &amp;patch)
{
    RFileIO::readBinary(inFile,patch.surfaceID);
    RFileIO::readBinary(inFile,patch.elementIDs,true);
}

</t>
<t tx="leo.20201108101534.358">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RPatch &amp;patch, bool addNewLine)
{
    RFileIO::writeAscii(outFile,patch.surfaceID,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,patch.elementIDs,true,addNewLine);
}

</t>
<t tx="leo.20201108101534.359">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RPatch &amp;patch)
{
    RFileIO::writeBinary(outFile,patch.surfaceID);
    RFileIO::writeBinary(outFile,patch.elementIDs,true);
}


/*********************************************************************
 *  RPatchBook                                                       *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.36">bool REntityGroupData::getDrawEqualArrowLength(void) const
{
    return this-&gt;drawEqualArrowLength;
}

</t>
<t tx="leo.20201108101534.360">void RFileIO::readAscii(RFile &amp;inFile, RPatchBook &amp;patchBook)
{
    RFileIO::readAscii(inFile,patchBook.patches);
    uint nElements = 0;
    RFileIO::readAscii(inFile,nElements);
    for (uint i=0;i&lt;nElements;i++)
    {
        uint key = 0;
        uint value = 0;
        RFileIO::readAscii(inFile,key);
        RFileIO::readAscii(inFile,value);
        patchBook.elementPatchMap[key] = value;
    }
}

</t>
<t tx="leo.20201108101534.361">void RFileIO::readBinary(RFile &amp;inFile, RPatchBook &amp;patchBook)
{
    RFileIO::readBinary(inFile,patchBook.patches);
    uint nElements = 0;
    RFileIO::readBinary(inFile,nElements);
    for (uint i=0;i&lt;nElements;i++)
    {
        uint key = 0;
        uint value = 0;
        RFileIO::readBinary(inFile,key);
        RFileIO::readBinary(inFile,value);
        patchBook.elementPatchMap[key] = value;
    }
}

</t>
<t tx="leo.20201108101534.362">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RPatchBook &amp;patchBook, bool addNewLine)
{
    RFileIO::writeAscii(outFile,patchBook.patches,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    uint nElements = uint(patchBook.elementPatchMap.size());
    RFileIO::writeAscii(outFile,nElements,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    std::map&lt;uint,uint&gt;::const_iterator iter;
    uint i = 0;
    for (iter=patchBook.elementPatchMap.begin();iter!=patchBook.elementPatchMap.end();++iter)
    {
        if (i &lt; nElements)
        {
            RFileIO::writeAscii(outFile,uint(iter-&gt;first),addNewLine);
            RFileIO::writeAscii(outFile,uint(iter-&gt;second),addNewLine);
            if (i &lt; (nElements - 1) &amp;&amp; !addNewLine)
            {
                RFileIO::writeAscii(outFile,' ',false);
            }
        }
        i++;
    }
}

</t>
<t tx="leo.20201108101534.363">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RPatchBook &amp;patchBook)
{
    RFileIO::writeBinary(outFile,patchBook.patches);
    uint nElements = uint(patchBook.elementPatchMap.size());
    RFileIO::writeBinary(outFile,nElements);
    std::map&lt;uint,uint&gt;::const_iterator iter;
    uint i = 0;
    for (iter=patchBook.elementPatchMap.begin();iter!=patchBook.elementPatchMap.end();++iter)
    {
        if (i &lt; nElements)
        {
            RFileIO::writeBinary(outFile,uint(iter-&gt;first));
            RFileIO::writeBinary(outFile,uint(iter-&gt;second));
        }
        i++;
    }
}


/*********************************************************************
 *  RPatchInput                                                      *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.364">void RFileIO::readAscii(RFile &amp;inFile, RPatchInput &amp;patchInput)
{
    RFileIO::readAscii(inFile,patchInput.patchArea);
    RFileIO::readAscii(inFile,patchInput.patchSize);
    RFileIO::readAscii(inFile,patchInput.separationAngle);
    RFileIO::readAscii(inFile,patchInput.emitter);
    RFileIO::readAscii(inFile,patchInput.receiver);
}

</t>
<t tx="leo.20201108101534.365">void RFileIO::readBinary(RFile &amp;inFile, RPatchInput &amp;patchInput)
{
    RFileIO::readBinary(inFile,patchInput.patchArea);
    RFileIO::readBinary(inFile,patchInput.patchSize);
    RFileIO::readBinary(inFile,patchInput.separationAngle);
    RFileIO::readBinary(inFile,patchInput.emitter);
    RFileIO::readBinary(inFile,patchInput.receiver);
}

</t>
<t tx="leo.20201108101534.366">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RPatchInput &amp;patchInput, bool addNewLine)
{
    RFileIO::writeAscii(outFile,patchInput.patchArea,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,patchInput.patchSize,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,patchInput.separationAngle,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,patchInput.emitter,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,patchInput.receiver,addNewLine);
}

</t>
<t tx="leo.20201108101534.367">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RPatchInput &amp;patchInput)
{
    RFileIO::writeBinary(outFile,patchInput.patchArea);
    RFileIO::writeBinary(outFile,patchInput.patchSize);
    RFileIO::writeBinary(outFile,patchInput.separationAngle);
    RFileIO::writeBinary(outFile,patchInput.emitter);
    RFileIO::writeBinary(outFile,patchInput.receiver);
}


/*********************************************************************
 *  RViewFactorMatrixHeader                                          *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.368">void RFileIO::readAscii(RFile &amp;inFile, RViewFactorMatrixHeader &amp;viewFactorMatrixHeader)
{
    RFileIO::readAscii(inFile,viewFactorMatrixHeader.patchInput);
    RFileIO::readAscii(inFile,viewFactorMatrixHeader.hemicubeResolution);
    RFileIO::readAscii(inFile,viewFactorMatrixHeader.nElements);
}

</t>
<t tx="leo.20201108101534.369">void RFileIO::readBinary(RFile &amp;inFile, RViewFactorMatrixHeader &amp;viewFactorMatrixHeader)
{
    RFileIO::readBinary(inFile,viewFactorMatrixHeader.patchInput);
    RFileIO::readBinary(inFile,viewFactorMatrixHeader.hemicubeResolution);
    RFileIO::readBinary(inFile,viewFactorMatrixHeader.nElements);
}

</t>
<t tx="leo.20201108101534.37">void REntityGroupData::setDrawEqualArrowLength(bool drawEqualArrowLength)
{
    this-&gt;drawEqualArrowLength = drawEqualArrowLength;
}

</t>
<t tx="leo.20201108101534.370">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RViewFactorMatrixHeader &amp;viewFactorMatrixHeader, bool addNewLine)
{
    RFileIO::writeAscii(outFile,viewFactorMatrixHeader.patchInput,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,viewFactorMatrixHeader.hemicubeResolution,addNewLine);
    if (!addNewLine)
    {
        RFileIO::writeAscii(outFile,' ',false);
    }
    RFileIO::writeAscii(outFile,viewFactorMatrixHeader.nElements,addNewLine);
}

</t>
<t tx="leo.20201108101534.371">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RViewFactorMatrixHeader &amp;viewFactorMatrixHeader)
{
    RFileIO::writeBinary(outFile,viewFactorMatrixHeader.patchInput);
    RFileIO::writeBinary(outFile,viewFactorMatrixHeader.hemicubeResolution);
    RFileIO::writeBinary(outFile,viewFactorMatrixHeader.nElements);
}


/*********************************************************************
 *  RViewFactorRow                                                   *
 *********************************************************************/

</t>
<t tx="leo.20201108101534.372">void RFileIO::readAscii(RFile &amp;inFile, RViewFactorRow &amp;viewFactorRow)
{
    RFileIO::readAscii(inFile,viewFactorRow.viewFactors);
}

</t>
<t tx="leo.20201108101534.373">void RFileIO::readBinary(RFile &amp;inFile, RViewFactorRow &amp;viewFactorRow)
{
    RFileIO::readBinary(inFile,viewFactorRow.viewFactors);
}

</t>
<t tx="leo.20201108101534.374">void RFileIO::writeAscii(RSaveFile &amp;outFile, const RViewFactorRow &amp;viewFactorRow, bool addNewLine)
{
    RFileIO::writeAscii(outFile,viewFactorRow.viewFactors,addNewLine);
}

</t>
<t tx="leo.20201108101534.375">void RFileIO::writeBinary(RSaveFile &amp;outFile, const RViewFactorRow &amp;viewFactorRow)
{
    RFileIO::writeBinary(outFile,viewFactorRow.viewFactors);
}
</t>
<t tx="leo.20201108101534.376">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_file_manager.cpp                                     *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-th August 2012                                        *
 *                                                                   *
 *  DESCRIPTION: File manager class definitions                      *
 *********************************************************************/

#include &lt;QDir&gt;
#include &lt;QFileInfo&gt;

#include &lt;rblib.h&gt;

#include "rml_file_manager.h"
#include "rml_file_io.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101534.377">void RFileManager::remove(const QString &amp;fileName)
{
    if (!QFile::remove(fileName))
    {
        throw RError(R_ERROR_REMOVE_FILE,R_ERROR_REF,"Failed to remove the file \'" + fileName + "\'");
    }
}

</t>
<t tx="leo.20201108101534.378">void RFileManager::rename(const QString &amp;srcFileName, const QString &amp;dstFileName)
{
    if (!QFile::rename(srcFileName,dstFileName))
    {
        throw RError(R_ERROR_REMOVE_FILE,R_ERROR_REF,"Failed to rename the file \'" + srcFileName + "\' to \'" + dstFileName + "\'");
    }
}

</t>
<t tx="leo.20201108101534.379">unsigned int RFileManager::listDirectory(const QString &amp;directory,
                                         QVector&lt;QString&gt; &amp;directories,
                                         QVector&lt;QString&gt; &amp;files)
{
    QDir dir(directory);

    QStringList dirList = dir.entryList(QDir::Dirs);
    QStringList fileList = dir.entryList(QDir::Files);

    directories = dirList.toVector();
    files = fileList.toVector();

    return directories.size() + files.size();
}

QString RFileManager::getExtension(const QString &amp;fileName)
{
    QFileInfo fi(fileName);
    return fi.suffix();
}

QString RFileManager::removeExtension(const QString &amp;fileName)
{
    QFileInfo fi(fileName);
    return RFileManager::buildPath(fi.path(),fi.baseName());
}

QString RFileManager::buildPath(const QString &amp;dirName, const QString &amp;fileName)
{
    QDir dir(dirName);
    return dir.filePath(fileName);
}

QString RFileManager::getFileNameWithTimeStep(const QString &amp;fileName, unsigned int timeStepNumber, unsigned int numberWidth)
{
    if (fileName.isEmpty())
    {
        return QString();
    }

    QString timeStepString = QString("%1").arg(timeStepNumber, numberWidth, 10, QChar('0')).toUpper();

    QString fileNameWithTs(fileName);

    int dashPos = fileName.lastIndexOf("-");
    int dotPos = fileName.lastIndexOf(".");

    if (dotPos &lt; 0)
    {
        dotPos = fileName.size();
    }

    if (dashPos &lt; 0)
    {
        dashPos = dotPos;
    }

    bool replace = false;
    if (dashPos != dotPos &amp;&amp; (dotPos-dashPos-1) == int(numberWidth))
    {
        replace = true;
        for (uint i=0;i&lt;numberWidth;i++)
        {
            if (!fileName[i+dashPos+1].isDigit())
            {
                replace = false;
                break;
            }
        }
    }
    if (replace)
    {
        fileNameWithTs.replace(dashPos+1,dotPos-dashPos-1,timeStepString);
    }
    else
    {
        fileNameWithTs.insert(dotPos,QString("-").append(timeStepString));
    }

    return fileNameWithTs;
}

QString RFileManager::getFileNameWithOutTimeStep(const QString &amp;fileName, unsigned int numberWidth)
{
    if (fileName.isEmpty())
    {
        return QString();
    }

    int dashPos = fileName.lastIndexOf("-");
    int dotPos = fileName.lastIndexOf(".");

    if (dotPos &lt; 0)
    {
        dotPos = fileName.size();
    }

    if (dashPos &lt; 0)
    {
        return fileName;
    }

    if (dashPos != dotPos &amp;&amp; (dotPos-dashPos-1) == int(numberWidth))
    {
        for (uint i=0;i&lt;numberWidth;i++)
        {
            if (!fileName[i+dashPos].isDigit())
            {
                return fileName;
            }
        }
        QString fileNameWithoutTs(fileName);

        fileNameWithoutTs.remove(dashPos,dotPos-dashPos);

        return fileNameWithoutTs;
    }
    else
    {
        return fileName;
    }
}

QString RFileManager::getFileNameWithSuffix(const QString &amp;fileName, const QString &amp;suffix)
{
    return RFileManager::removeExtension(fileName) + "-" + suffix + "." + RFileManager::getExtension(fileName);
}

QString RFileManager::getSuffix(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        return QString();
    }

    int dashPos = fileName.lastIndexOf("-");
    int dotPos = fileName.lastIndexOf(".");

    if (dotPos &lt; 0)
    {
        dotPos = fileName.size();
    }

    if (dashPos &lt; 0)
    {
        return QString();
    }

    if (dashPos != dotPos &amp;&amp; dotPos &gt; dashPos)
    {
        QString suffix(fileName);

        suffix.remove(dotPos,suffix.length() - dotPos);
        suffix.remove(0,dashPos);

        return suffix;
    }
    else
    {
        return QString();
    }
}

</t>
<t tx="leo.20201108101534.38">bool REntityGroupData::getDrawArrowFrom(void) const
{
    return this-&gt;drawArrowFrom;
}

</t>
<t tx="leo.20201108101534.380">bool RFileManager::fileExists(const QString &amp;fileName)
{
    return QFile::exists(fileName);
}

QString RFileManager::findLastFile(const QString &amp;filePattern)
{
    QFileInfo fileInfo(filePattern);

    QStringList nameFilters;
    nameFilters &lt;&lt; fileInfo.fileName();

    QDir dir(fileInfo.absolutePath());

    QStringList fileList = dir.entryList(nameFilters,QDir::Files,QDir::Reversed);

    if (fileList.count() &gt; 0)
    {
        return dir.filePath(fileList.at(0));
    }
    return QString();
}

QStringList RFileManager::findFiles(const QString &amp;filePattern)
{
    QFileInfo fileInfo(filePattern);

    QStringList nameFilters;
    nameFilters &lt;&lt; fileInfo.fileName();

    QDir dir(fileInfo.absolutePath());

    QStringList fileList = dir.entryList(nameFilters,QDir::Files,QDir::Reversed);

    QStringList fileNames;
    for (int i=0; i&lt;fileList.count();i++)
    {
        fileNames.append(dir.filePath(fileList.at(i)));
    }
    return fileNames;
}

</t>
<t tx="leo.20201108101534.381">void RFileManager::writeLink(const QString &amp;linkFileName, const QString &amp;targetFileName, const RVersion &amp;version, bool binary)
{
    if (linkFileName.isEmpty() || targetFileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

//    QString ext = RFileManager::getExtension(linkFileName);
    // Find relative path.
    QDir linkFileDir(QFileInfo(linkFileName).absoluteDir());
    QString relativeTargetFileName(linkFileDir.relativeFilePath(targetFileName));

    if (binary)
    {
        RLogger::info("Writing binary link file \'%s\'\n",linkFileName.toUtf8().constData());

        RSaveFile linkFile(linkFileName,RSaveFile::BINARY);

        if (!linkFile.open(QIODevice::WriteOnly))
        {
            throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",linkFileName.toUtf8().constData());
        }

        RFileIO::writeBinary(linkFile,RFileHeader(R_FILE_TYPE_LINK,version,relativeTargetFileName));

        linkFile.commit();
    }
    else
    {
        RLogger::info("Writing ascii link file \'%s\'\n",linkFileName.toUtf8().constData());

        RSaveFile linkFile(linkFileName,RSaveFile::ASCII);

        if (!linkFile.open(QIODevice::WriteOnly | QIODevice::Text))
        {
            throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",linkFileName.toUtf8().constData());
        }

        RFileIO::writeAscii(linkFile,RFileHeader(R_FILE_TYPE_LINK,version,"\"" + relativeTargetFileName + "\""));

        linkFile.commit();
    }
}

QString RFileManager::findLinkTargetFileName(const QString &amp;linkFileName, const QString &amp;targetFileName)
{
    QString processedTargetFileName(targetFileName);
    if (QFileInfo(processedTargetFileName).isRelative())
    {
        processedTargetFileName = QDir::cleanPath(RFileManager::buildPath(QFileInfo(linkFileName).absoluteDir().absolutePath(),processedTargetFileName));
    }

    return processedTargetFileName;
}
</t>
<t tx="leo.20201108101534.382">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rbl_gl_display_properties.cpp                            *
 *  GROUP:  RBL                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   22-nd February 2012                                      *
 *                                                                   *
 *  DESCRIPTION: OpenGL display properties class definition          *
 *********************************************************************/

#include &lt;QColor&gt;
#include &lt;QOpenGLFunctions&gt;

#include "rml_gl_display_properties.h"
#include "rml_file.h"
#include "rml_file_header.h"
#include "rml_file_io.h"
#include "rml_file_manager.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101534.383">static int lightNums[8] = {
    GL_LIGHT0,
    GL_LIGHT1,
    GL_LIGHT2,
    GL_LIGHT3,
    GL_LIGHT4,
    GL_LIGHT5,
    GL_LIGHT6,
    GL_LIGHT7
};

static const RVersion _version = RVersion(FILE_MAJOR_VERSION,FILE_MINOR_VERSION,FILE_RELEASE_VERSION);

</t>
<t tx="leo.20201108101534.384">void RGLDisplayProperties::_init(const RGLDisplayProperties *pDisplayProperties)
{
    if (pDisplayProperties)
    {
        this-&gt;drawGlobalAxis = pDisplayProperties-&gt;drawGlobalAxis;
        this-&gt;drawLocalAxis = pDisplayProperties-&gt;drawLocalAxis;
        this-&gt;showModelEdges = pDisplayProperties-&gt;showModelEdges;
        this-&gt;showModelDimensions = pDisplayProperties-&gt;showModelDimensions;
        this-&gt;showErrors = pDisplayProperties-&gt;showErrors;
        this-&gt;bgColor = pDisplayProperties-&gt;bgColor;
        this-&gt;bgGradient = pDisplayProperties-&gt;bgGradient;
        this-&gt;lights = pDisplayProperties-&gt;lights;
    }
}

RGLDisplayProperties::RGLDisplayProperties()
    : drawGlobalAxis(true)
    , drawLocalAxis(true)
    , showModelEdges(true)
    , showModelDimensions(true)
    , showErrors(true)
    , bgGradient(true)
{
    this-&gt;bgColor = QColor::fromCmykF(0.39, 0.39, 0.0, 0.0).darker();
    this-&gt;lights.resize(2);
    this-&gt;lights[0].setEnabled(true);
    this-&gt;lights[0].setAmbient(QColor("#191919"));
    this-&gt;lights[0].setDiffuse(QColor("#DFDFDF"));
    this-&gt;lights[0].setSpecular(QColor("#FFFFFF"));
    this-&gt;lights[0].setDirection(RR3Vector(0.6,0.6,0.3));
    this-&gt;lights[0].setPosition(RR3Vector(-1.0,1.0,10));
    this-&gt;lights[0].setLightNumber(lightNums[0]);
    this-&gt;lights[0].setLightNumber(0);
    this-&gt;lights[1].setEnabled(false);
    this-&gt;lights[1].setAmbient(QColor("#191919"));
    this-&gt;lights[1].setDiffuse(QColor("#DFDFDF"));
    this-&gt;lights[1].setSpecular(QColor("#FFFFFF"));
    this-&gt;lights[1].setDirection(RR3Vector(-0.6,0.6,0.3));
    this-&gt;lights[1].setPosition(RR3Vector(1.0,1.0,10));
    this-&gt;lights[1].setLightNumber(lightNums[1]);
    this-&gt;lights[1].setLightNumber(1);
    this-&gt;_init();
}

RGLDisplayProperties::RGLDisplayProperties(const RGLDisplayProperties &amp;displayProperties)
{
    this-&gt;_init(&amp;displayProperties);
}

RGLDisplayProperties::~RGLDisplayProperties()
{
}

RGLDisplayProperties &amp; RGLDisplayProperties::operator =(const RGLDisplayProperties &amp;displayProperties)
{
    this-&gt;_init(&amp;displayProperties);
    return (*this);
}

</t>
<t tx="leo.20201108101534.385">bool RGLDisplayProperties::getDrawGlobalAxis() const
{
    return this-&gt;drawGlobalAxis;
}

</t>
<t tx="leo.20201108101534.386">void RGLDisplayProperties::setDrawGlobalAxis(bool drawGlobalAxis)
{
    this-&gt;drawGlobalAxis = drawGlobalAxis;
}

</t>
<t tx="leo.20201108101534.387">bool RGLDisplayProperties::getDrawLocalAxis(void) const
{
    return this-&gt;drawLocalAxis;
}

</t>
<t tx="leo.20201108101534.388">void RGLDisplayProperties::setDrawLocalAxis(bool drawLocalAxis)
{
    this-&gt;drawLocalAxis = drawLocalAxis;
}

</t>
<t tx="leo.20201108101534.389">bool RGLDisplayProperties::getShowModelEdges(void) const
{
    return this-&gt;showModelEdges;
}

</t>
<t tx="leo.20201108101534.39">void REntityGroupData::setDrawArrowFrom(bool drawArrowFrom)
{
    this-&gt;drawArrowFrom = drawArrowFrom;
}

</t>
<t tx="leo.20201108101534.390">void RGLDisplayProperties::setShowModelEdges(bool showModelEdges)
{
    this-&gt;showModelEdges = showModelEdges;
}

</t>
<t tx="leo.20201108101534.391">bool RGLDisplayProperties::getShowModelDimensions(void) const
{
    return this-&gt;showModelDimensions;
}

</t>
<t tx="leo.20201108101534.392">void RGLDisplayProperties::setShowModelDimensions(bool showModelDimensions)
{
    this-&gt;showModelDimensions = showModelDimensions;
}

</t>
<t tx="leo.20201108101534.393">bool RGLDisplayProperties::getShowErrors(void) const
{
    return this-&gt;showErrors;
}

</t>
<t tx="leo.20201108101534.394">void RGLDisplayProperties::setShowErrors(bool showErrors)
{
    this-&gt;showErrors = showErrors;
}

</t>
<t tx="leo.20201108101534.395">const QColor &amp; RGLDisplayProperties::getBgColor(void) const
{
    return this-&gt;bgColor;
}

</t>
<t tx="leo.20201108101534.396">void RGLDisplayProperties::setBgColor(const QColor &amp;bgColor)
{
    this-&gt;bgColor = bgColor;
}

</t>
<t tx="leo.20201108101534.397">bool RGLDisplayProperties::getBgGradient(void) const
{
    return this-&gt;bgGradient;
}

</t>
<t tx="leo.20201108101534.398">void RGLDisplayProperties::setBgGradient(bool bgGradient)
{
    this-&gt;bgGradient = bgGradient;
}

uint RGLDisplayProperties::getNLights(void) const
{
    return uint(this-&gt;lights.size());
}

</t>
<t tx="leo.20201108101534.399">void RGLDisplayProperties::setNLights(uint nLights)
{
    R_ERROR_ASSERT(nLights &lt; 8);

    this-&gt;lights.resize(int(nLights));
    for (uint i=0;i&lt;nLights;i++)
    {
        this-&gt;lights[int(i)].setLightNumber(lightNums[i]);
    }
}

</t>
<t tx="leo.20201108101534.4">const RRVector &amp;RElementShapeFunction::getN(void) const
{
    return this-&gt;N;
}

</t>
<t tx="leo.20201108101534.40">bool REntityGroupData::getColorByPatch(void) const
{
    return this-&gt;colorByPatch;
}

</t>
<t tx="leo.20201108101534.400">const RGLLight &amp;RGLDisplayProperties::getLight(uint lightID) const
{
    R_ERROR_ASSERT(lightID &lt; this-&gt;getNLights());

    return this-&gt;lights[int(lightID)];
}

RGLLight &amp;RGLDisplayProperties::getLight(uint lightID)
{
    R_ERROR_ASSERT(lightID &lt; this-&gt;getNLights());

    return this-&gt;lights[int(lightID)];
}

</t>
<t tx="leo.20201108101534.401">void RGLDisplayProperties::setLight(uint lightID, const RGLLight &amp;glLight)
{
    R_ERROR_ASSERT(lightID &lt; this-&gt;getNLights());

    this-&gt;lights[int(lightID)] = glLight;
}

</t>
<t tx="leo.20201108101534.402">void RGLDisplayProperties::read(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QString targetFileName(fileName);

    while (!targetFileName.isEmpty())
    {
        QString ext = RFileManager::getExtension(targetFileName);

        try
        {
            if (ext == RGLDisplayProperties::getDefaultFileExtension(false))
            {
                targetFileName = this-&gt;readAscii(targetFileName);
            }
            else if (ext == RGLDisplayProperties::getDefaultFileExtension(true))
            {
                targetFileName = this-&gt;readBinary(targetFileName);
            }
            else
            {
                throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
            }
        }
        catch (RError &amp;error)
        {
            throw error;
        }
        catch (std::bad_alloc&amp;)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Memory allocation failed.");
        }
        catch (const std::exception&amp; x)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "%s.", typeid(x).name());
        }
        catch (...)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Unknown exception.");
        }
    }
}

</t>
<t tx="leo.20201108101534.403">void RGLDisplayProperties::write(const QString &amp;fileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QString ext = RFileManager::getExtension(fileName);

    try
    {
        if (ext == RGLDisplayProperties::getDefaultFileExtension(false))
        {
            this-&gt;writeAscii(fileName);
        }
        else if (ext == RGLDisplayProperties::getDefaultFileExtension(true))
        {
            this-&gt;writeBinary(fileName);
        }
        else
        {
            throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
        }
    }
    catch (RError &amp;error)
    {
        throw error;
    }
    catch (std::bad_alloc&amp;)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Memory allocation failed.");
    }
    catch (const std::exception&amp; x)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "%s.", typeid(x).name());
    }
    catch (...)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Unknown exception.");
    }
}

QString RGLDisplayProperties::getDefaultFileExtension(bool binary)
{
    if (binary)
    {
        return "rbd";
    }
    else
    {
        return "rad";
    }
}

QString RGLDisplayProperties::readAscii(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Reading ascii display properties file \'%s\'\n",fileName.toUtf8().constData());

    RFile file(fileName,RFile::ASCII);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileHeader fileHeader;

    RFileIO::readAscii(file,fileHeader);
    if (fileHeader.getType() == R_FILE_TYPE_LINK)
    {
        QString targetFileName(RFileManager::findLinkTargetFileName(fileName,fileHeader.getInformation()));
        RLogger::info("File \'%s\' is a link file pointing to \'%s\'\n",fileName.toUtf8().constData(),targetFileName.toUtf8().constData());
        return targetFileName;
    }
    if (fileHeader.getType() != R_FILE_TYPE_DISPLAY_PROPERTIES)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF,"File type of the file \'" + fileName + "\' is not DISPLAY PROPERTIES.");
    }

    // Set file version
    file.setVersion(fileHeader.getVersion());

    RFileIO::readAscii(file,(*this));

    file.close();

    return QString();
}

QString RGLDisplayProperties::readBinary(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Reading binary display properties file \'%s\'\n",fileName.toUtf8().constData());

    RFile file(fileName,RFile::BINARY);

    if (!file.open(QIODevice::ReadOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileHeader fileHeader;

    RFileIO::readBinary(file,fileHeader);
    if (fileHeader.getType() == R_FILE_TYPE_LINK)
    {
        QString targetFileName(RFileManager::findLinkTargetFileName(fileName,fileHeader.getInformation()));
        RLogger::info("File \'%s\' is a link file pointing to \'%s\'\n",fileName.toUtf8().constData(),targetFileName.toUtf8().constData());
        return targetFileName;
    }
    if (fileHeader.getType() != R_FILE_TYPE_DISPLAY_PROPERTIES)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF,"File type of the file \'" + fileName + "\' is not DISPLAY PROPERTIES.");
    }

    // Set file version
    file.setVersion(fileHeader.getVersion());

    RFileIO::readBinary(file,(*this));

    file.close();

    return QString();
}

</t>
<t tx="leo.20201108101534.404">void RGLDisplayProperties::writeAscii(const QString &amp;fileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Writing ascii display properties file \'%s\'\n",fileName.toUtf8().constData());

    RSaveFile file(fileName,RSaveFile::ASCII);

    if (!file.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileIO::writeAscii(file,RFileHeader(R_FILE_TYPE_DISPLAY_PROPERTIES,_version));
    RFileIO::writeAscii(file,(*this));

    file.commit();
}

</t>
<t tx="leo.20201108101534.405">void RGLDisplayProperties::writeBinary(const QString &amp;fileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Writing binary display properties file \'%s\'\n",fileName.toUtf8().constData());

    RSaveFile file(fileName,RSaveFile::BINARY);

    if (!file.open(QIODevice::WriteOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileIO::writeBinary(file,RFileHeader(R_FILE_TYPE_DISPLAY_PROPERTIES,_version));
    RFileIO::writeBinary(file,(*this));

    file.commit();
}
</t>
<t tx="leo.20201108101534.41">void REntityGroupData::setColorByPatch(bool colorByPatch)
{
    this-&gt;colorByPatch = colorByPatch;
}

</t>
<t tx="leo.20201108101534.42">bool REntityGroupData::getColorByViewFactor(void) const
{
    return this-&gt;colorByViewFactor;
}

</t>
<t tx="leo.20201108101534.43">void REntityGroupData::setColorByViewFactor(bool colorByViewFactor)
{
    this-&gt;colorByViewFactor = colorByViewFactor;
}

</t>
<t tx="leo.20201108101534.44">const std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt; &amp;REntityGroupData::getVariableData(void) const
{
    return this-&gt;variableData;
}

std::map&lt;RVariableType, REntityGroupVariableDisplayTypeMask&gt; &amp;REntityGroupData::getVariableData(void)
{
    return this-&gt;variableData;
}

</t>
<t tx="leo.20201108101534.45">void REntityGroupData::setVariableData(std::map&lt;RVariableType, REntityGroupVariableDisplayTypeMask&gt; &amp;variableData)
{
    this-&gt;variableData = variableData;
}

RVariableType REntityGroupData::findVariableByDisplayType(REntityGroupVariableDisplayTypeMask displayType) const
{
    std::map&lt;RVariableType,REntityGroupVariableDisplayTypeMask&gt;::const_iterator iter;
    for (iter = this-&gt;variableData.begin();
         iter != this-&gt;variableData.end();
         ++iter)
    {
        if (iter-&gt;second &amp; displayType)
        {
            return iter-&gt;first;
        }
    }
    return R_VARIABLE_NONE;
}

</t>
<t tx="leo.20201108101534.46">const QString &amp;REntityGroupData::getVariableDisplayName(REntityGroupVariableDisplayTypeMask type)
{
    switch (type)
    {
        case R_ENTITY_GROUP_VARIABLE_DISPLAY_SCALAR:
            return elementGroupVariableDisplayDesc[1].name;
        case R_ENTITY_GROUP_VARIABLE_DISPLAY_DISPLACEMENT:
            return elementGroupVariableDisplayDesc[2].name;
        default:
            return elementGroupVariableDisplayDesc[0].name;
    }
}

</t>
<t tx="leo.20201108101534.47">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_environment_condition.cpp                            *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Environment condition class definition              *
 *********************************************************************/

#include "rml_environment_condition.h"
#include "rml_problem.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101534.48">typedef struct _REnvironmentConditionDesc
{
    QString          id;
    QString          name;
    RProblemTypeMask problemTypeMask;
} REnvironmentConditionDesc;

</t>
<t tx="leo.20201108101534.49">const REnvironmentConditionDesc environmentConditionDesc [] =
{
    { "ec-none", "None",
      R_PROBLEM_NONE },
    { "ec-gravitational_acceleration", "Gravitational acceleration",
      R_PROBLEM_FLUID | R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL | R_PROBLEM_POTENTIAL },
    { "ec-temperature", "Temperature",
      R_PROBLEM_ACOUSTICS | R_PROBLEM_FLUID_PARTICLE | R_PROBLEM_ELECTROSTATICS | R_PROBLEM_FLUID | R_PROBLEM_HEAT | R_PROBLEM_RADIATIVE_HEAT | R_PROBLEM_FLUID_HEAT | R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL | R_PROBLEM_POTENTIAL | R_PROBLEM_WAVE },
    { "ec-custom", "Custom",
      R_PROBLEM_NONE }
};


REnvironmentCondition::REnvironmentCondition (REnvironmentConditionType type)
{
    this-&gt;setType (type);
    this-&gt;_init ();
} /* REnvironmentCondition::REnvironmentCondition */


REnvironmentCondition::REnvironmentCondition
                                 (const REnvironmentCondition &amp;condition)
                                              : RCondition (condition)
{
    this-&gt;_init (&amp;condition);
} /* REnvironmentCondition::REnvironmentCondition (copy) */


REnvironmentCondition::~REnvironmentCondition ()
{
} /* REnvironmentCondition::~REnvironmentCondition */


</t>
<t tx="leo.20201108101534.5">const RRMatrix &amp;RElementShapeFunction::getDN(void) const
{
    return this-&gt;dN;
}

</t>
<t tx="leo.20201108101534.50">void REnvironmentCondition::_init (const REnvironmentCondition *pCondition)
{
    if (pCondition)
    {
        this-&gt;setTypeSafe (pCondition-&gt;getType());
    }
} /* REnvironmentCondition::_init */


REnvironmentConditionType REnvironmentCondition::getType (void) const
{
    return this-&gt;type;
} /* REnvironmentCondition::getType */


</t>
<t tx="leo.20201108101534.51">void REnvironmentCondition::setType (REnvironmentConditionType type)
{
    std::vector&lt;RVariableType&gt; componentTypes;
    RConditionComponent component;

    this-&gt;setTypeSafe (type);
    this-&gt;clear ();

    componentTypes = REnvironmentCondition::getDefaultComponents (type);

    for (unsigned int i=0;i&lt;componentTypes.size();i++)
    {
        component.setType (componentTypes[i]);
        this-&gt;addComponent (component);
    }
} /* REnvironmentCondition::setType */


</t>
<t tx="leo.20201108101534.52">void REnvironmentCondition::setTypeSafe (REnvironmentConditionType type)
{
    this-&gt;type = type;
    this-&gt;name = REnvironmentCondition::getName (type);
    this-&gt;problemTypeMask = REnvironmentCondition::getProblemTypeMask (type);
} /* REnvironmentCondition::setTypeSafe */


REnvironmentCondition &amp; REnvironmentCondition::operator =
                              (const REnvironmentCondition &amp;condition)
{
    this-&gt;RCondition::operator = (condition);
    this-&gt;_init (&amp;condition);
    return (*this);
} /* REnvironmentCondition::operator = */


REnvironmentConditionType REnvironmentCondition::getTypeFromId(const QString &amp;ecId)
{
    for (uint type=uint(R_ENVIRONMENT_CONDITION_NONE);type&lt;uint(R_ENVIRONMENT_CONDITION_N_TYPES);type++)
    {
        if (environmentConditionDesc[type].id == ecId)
        {
            return REnvironmentConditionType(type);
        }
    }

    return R_ENVIRONMENT_CONDITION_NONE;
} /* REnvironmentCondition::getTypeFromId */


QString REnvironmentCondition::getId(REnvironmentConditionType type)
{
    R_ERROR_ASSERT (R_ENVIRONMENT_CONDITION_TYPE_IS_VALID (type));
    return environmentConditionDesc[type].id;
} /* REnvironmentCondition::getId */


</t>
<t tx="leo.20201108101534.53">const QString &amp;REnvironmentCondition::getName(REnvironmentConditionType type)
{
    R_ERROR_ASSERT (R_ENVIRONMENT_CONDITION_TYPE_IS_VALID (type));
    return environmentConditionDesc[type].name;
} /* REnvironmentCondition::getName */


RProblemTypeMask REnvironmentCondition::getProblemTypeMask
                                      (REnvironmentConditionType type)
{
    R_ERROR_ASSERT (R_ENVIRONMENT_CONDITION_TYPE_IS_VALID (type));
    return environmentConditionDesc[type].problemTypeMask;
} /* REnvironmentCondition::getProblemTypeMask */


std::vector&lt;RVariableType&gt; REnvironmentCondition::getDefaultComponents
                                         (REnvironmentConditionType type)
{
    std::vector&lt;RVariableType&gt; componentTypes;

    R_ERROR_ASSERT (R_ENVIRONMENT_CONDITION_TYPE_IS_VALID (type));

    switch (type)
    {
        case R_ENVIRONMENT_CONDITION_NONE:
            break;
        case R_ENVIRONMENT_CONDITION_G_ACCELERATION:
            componentTypes.push_back(R_VARIABLE_G_ACCELERATION_X);
            componentTypes.push_back(R_VARIABLE_G_ACCELERATION_Y);
            componentTypes.push_back(R_VARIABLE_G_ACCELERATION_Z);
            break;
        case R_ENVIRONMENT_CONDITION_TEMPERATURE:
            componentTypes.push_back(R_VARIABLE_TEMPERATURE);
            break;
        case R_ENVIRONMENT_CONDITION_CUSTOM:
            break;
        default:
            break;
    }

    return componentTypes;
} /* REnvironmentCondition::getDefaultComponents */


</t>
<t tx="leo.20201108101534.54">void operator ++(REnvironmentConditionType &amp;type, int increment)
{
    type = (REnvironmentConditionType)((int)type+increment+1);
} /* operator ++ */
</t>
<t tx="leo.20201108101534.55">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_file.cpp                                             *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   9-th November 2015                                       *
 *                                                                   *
 *  DESCRIPTION: File class definition                               *
 *********************************************************************/

#include "rml_file.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101534.56">void RFile::_init(const RFile *pFile)
{
    if (pFile)
    {
        this-&gt;fileName = pFile-&gt;fileName;
        this-&gt;type = pFile-&gt;type;
        this-&gt;fileVersion = pFile-&gt;fileVersion;
//        this-&gt;textStream = pFile-&gt;textStream;
    }
    if (this-&gt;type == RFile::ASCII)
    {
        this-&gt;textStream.setDevice(this);
    }
}

RFile::RFile(const QString &amp;fileName, RFile::Type type)
    : QFile(fileName)
    , fileName(fileName)
    , type(type)
    , fileVersion(RVersion(0,0,0))
{
    this-&gt;_init();
}

RFile::RFile(const RFile &amp;file)
    : QFile(fileName)
{
    this-&gt;_init(&amp;file);
}

RFile::~RFile()
{

}

RFile &amp;RFile::operator =(const RFile &amp;file)
{
    this-&gt;_init(&amp;file);
    return (*this);
}

</t>
<t tx="leo.20201108101534.57">const RVersion &amp;RFile::getVersion(void) const
{
    return this-&gt;fileVersion;
}

</t>
<t tx="leo.20201108101534.58">void RFile::setVersion(const RVersion &amp;fileVersion)
{
    this-&gt;fileVersion = fileVersion;
}

QTextStream &amp;RFile::getTextStream(void)
{
    return this-&gt;textStream;
}

QString RFile::getTextStreamStatusStringt(QTextStream::Status status)
{
    switch (status)
    {
        case QTextStream::Ok:
            return "ok";
        case QTextStream::ReadPastEnd:
            return "read past end";
        case QTextStream::ReadCorruptData:
            return "read corrupt data";
        case QTextStream::WriteFailed:
            return "write failed";
        default:
            return "unknown";
    }
}
</t>
<t tx="leo.20201108101534.59">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_file_header.cpp                                      *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   29-th August 2012                                        *
 *                                                                   *
 *  DESCRIPTION: File header class definitions                       *
 *********************************************************************/

#include "rml_file_header.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101534.6">const double &amp;RElementShapeFunction::getW(void) const
{
    return this-&gt;w;
}
</t>
<t tx="leo.20201108101534.60">void RFileHeader::_init(const RFileHeader *pHeader)
{
    if (pHeader)
    {
        this-&gt;version = pHeader-&gt;version;
        this-&gt;type = pHeader-&gt;type;
        this-&gt;information = pHeader-&gt;information;
    }
}

RFileHeader::RFileHeader(RFileType type,
                         RVersion version,
</t>
<t tx="leo.20201108101534.61">                         const QString &amp;information) :
    version(version),
    type(type),
    information(information)
{
    this-&gt;_init();
}

RFileHeader::RFileHeader(const RFileHeader &amp;header)
{
    this-&gt;_init(&amp;header);
}

RFileHeader::~RFileHeader()
{
}

RFileHeader &amp;RFileHeader::operator =(const RFileHeader &amp;header)
{
    this-&gt;_init(&amp;header);
    return (*this);
}

</t>
<t tx="leo.20201108101534.62">const RVersion &amp;RFileHeader::getVersion(void) const
{
    return this-&gt;version;
}

</t>
<t tx="leo.20201108101534.63">void RFileHeader::setVersion(const RVersion &amp;version)
{
    this-&gt;version = version;
}

RFileType RFileHeader::getType(void) const
{
    return this-&gt;type;
}

</t>
<t tx="leo.20201108101534.64">void RFileHeader::setType(RFileType type)
{
    this-&gt;type = type;
}

</t>
<t tx="leo.20201108101534.65">const QString &amp;RFileHeader::getInformation(void) const
{
    return this-&gt;information;
}

</t>
<t tx="leo.20201108101534.66">void RFileHeader::setInformation(const QString &amp;information)
{
    this-&gt;information = information;
}
</t>
<t tx="leo.20201108101534.67">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_file_io.cpp                                          *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   21-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: File IO operation functions definitions             *
 *********************************************************************/

#include "rml_file_io.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101534.68">void RFileIO::writeNewLineAscii(RSaveFile &amp;outFile)
{
    outFile.getTextStream() &lt;&lt; RConstants::endl;
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write the new line.");
    }
} /* RFileIO::writeNewLineAscii */


</t>
<t tx="leo.20201108101534.69">void RFileIO::writeNewLineAscii(RFile &amp;outFile)
{
    outFile.getTextStream() &lt;&lt; RConstants::endl;
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write the new line.");
    }
} /* RFileIO::writeNewLineAscii */


/*********************************************************************
 *  bool                                                             *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.7">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_entity_group.h                                       *
 *  GROUP:  RML                                                      *
 *  TYPE:   header file (*.h)                                        *
 *  DATE:   15-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Entity group class declaration                      *
 *********************************************************************/

#include "rml_entity_group.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101534.70">void RFileIO::readAscii(RFile &amp;inFile, bool &amp;bValue)
{
    char c;
    inFile.getTextStream() &gt;&gt; c;
    bValue = (c == 0);
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read bool value.");
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.71">void RFileIO::readBinary(RFile &amp;inFile, bool &amp;bValue)
{
    inFile.read((char*)&amp;bValue,sizeof(bool));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read bool value.");
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.72">void RFileIO::writeAscii(RSaveFile &amp;outFile, const bool &amp;bValue, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; bValue;
    }
    else
    {
        outFile.getTextStream() &lt;&lt; char(bValue) &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write bool value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.73">void RFileIO::writeBinary(RSaveFile &amp;outFile, const bool &amp;bValue)
{
    outFile.write((char*)&amp;bValue,sizeof(bool));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write bool value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  char                                                             *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.74">void RFileIO::readAscii(RFile &amp;inFile, char &amp;cValue)
{
    inFile.getTextStream() &gt;&gt; cValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read char value.");
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.75">void RFileIO::readBinary(RFile &amp;inFile, char &amp;cValue)
{

    inFile.read((char*)&amp;cValue,sizeof(char));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read char value.");
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.76">void RFileIO::writeAscii(RSaveFile &amp;outFile, const char &amp;cValue, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; cValue;
    }
    else
    {
        outFile.getTextStream() &lt;&lt; cValue &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write char value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.77">void RFileIO::writeAscii(RFile &amp;outFile, const char &amp;cValue, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; cValue;
    }
    else
    {
        outFile.getTextStream() &lt;&lt; cValue &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write char value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.78">void RFileIO::writeBinary(RSaveFile &amp;outFile, const char &amp;cValue)
{
    outFile.write((char*)&amp;cValue,sizeof(char));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write char value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  int                                                              *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.79">void RFileIO::readAscii(RFile &amp;inFile, int &amp;iValue)
{
    inFile.getTextStream() &gt;&gt; iValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read int value.");
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.8">void REntityGroup::_init(const REntityGroup *pEntityGroup)
{
    if (pEntityGroup)
    {
        this-&gt;name = pEntityGroup-&gt;name;
        this-&gt;data = pEntityGroup-&gt;data;
    }
}

REntityGroup::REntityGroup()
{
    this-&gt;_init();
}

REntityGroup::REntityGroup(const REntityGroup &amp;entityGroup)
{
    this-&gt;_init(&amp;entityGroup);
}

REntityGroup::~REntityGroup()
{
}

REntityGroup &amp;REntityGroup::operator =(const REntityGroup &amp;entityGroup)
{
    this-&gt;_init(&amp;entityGroup);
    return (*this);
}

</t>
<t tx="leo.20201108101534.80">void RFileIO::readBinary(RFile &amp;inFile, int &amp;iValue)
{
    inFile.read((char*)&amp;iValue,sizeof(int));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read int value.");
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.81">void RFileIO::writeAscii(RSaveFile &amp;outFile, const int &amp;iValue, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; iValue;
    }
    else
    {
        outFile.getTextStream() &lt;&lt; iValue &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write int value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.82">void RFileIO::writeBinary(RSaveFile &amp;outFile, const int &amp;iValue)
{
    outFile.write((char*)&amp;iValue,sizeof(int));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write int value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  unsigned int                                                     *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.83">void RFileIO::readAscii(RFile &amp;inFile, unsigned int &amp;uValue)
{
    inFile.getTextStream() &gt;&gt; uValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read unsigned int value.");
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.84">void RFileIO::readBinary(RFile &amp;inFile, unsigned int &amp;uValue)
{
    inFile.read((char*)&amp;uValue,sizeof(unsigned int));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read unsigned int value.");
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.85">void RFileIO::writeAscii(RSaveFile &amp;outFile, const unsigned int &amp;uValue, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; uValue;
    }
    else
    {
        outFile.getTextStream() &lt;&lt; uValue &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write unsigned int value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.86">void RFileIO::writeAscii(RFile &amp;outFile, const unsigned int &amp;uValue, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; uValue;
    }
    else
    {
        outFile.getTextStream() &lt;&lt; uValue &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write unsigned int value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.87">void RFileIO::writeBinary(RSaveFile &amp;outFile, const unsigned int &amp;uValue)
{
    outFile.write((char*)&amp;uValue,sizeof(unsigned int));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write unsigned int value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  double                                                           *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.88">void RFileIO::readAscii(RFile &amp;inFile, double &amp;dValue)
{
    inFile.getTextStream() &gt;&gt; dValue;
    if (inFile.getTextStream().status() != QTextStream::Ok)
    {
        if (inFile.getTextStream().status() == QTextStream::ReadCorruptData)
        {
            inFile.getTextStream().resetStatus();
            return;
        }
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read double value.");
    }
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.89">void RFileIO::readBinary(RFile &amp;inFile, double &amp;dValue)
{
    inFile.read((char*)&amp;dValue,sizeof(double));
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read double value.");
    }
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.9">const QString &amp;REntityGroup::getName(void) const
{
    return this-&gt;name;
} /* REntityGroup::getName */

</t>
<t tx="leo.20201108101534.90">void RFileIO::writeAscii(RSaveFile &amp;outFile, const double &amp;dValue, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; dValue;
    }
    else
    {
        outFile.getTextStream() &lt;&lt; dValue &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write double value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.91">void RFileIO::writeAscii(RFile &amp;outFile, const double &amp;dValue, bool addNewLine)
{
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; dValue;
    }
    else
    {
        outFile.getTextStream() &lt;&lt; dValue &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write double value.");
    }
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.92">void RFileIO::writeBinary(RSaveFile &amp;outFile, const double &amp;dValue)
{
    outFile.write((char*)&amp;dValue,sizeof(double));
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write double value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  QString                                                          *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.93">void RFileIO::readAscii(RFile &amp;inFile, QString &amp;sValue)
{
//    QTextCodec *textCodec = inFile.codec();
//    bool autoDetectUnicode = inFile.autoDetectUnicode();

//    inFile.setCodec("UTF-8");
//    inFile.setAutoDetectUnicode(true);

    sValue.clear();
    QChar endChar = '\0';

    bool sStarted = false;
    bool cStarted = false;
    bool readNext = true;
    while (readNext)
    {
        QChar c;
        inFile.getTextStream() &gt;&gt; c;
        if (inFile.getTextStream().status() != QTextStream::Ok)
        {
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read string value.");
        }
        if (c == '"')
        {
            if (cStarted)
            {
                readNext = false;
            }
            cStarted = true;
        }
        else if (c.isSpace())
        {
            if (!cStarted &amp;&amp; sStarted)
            {
                readNext = false;
            }
            if (cStarted &amp;&amp; sStarted)
            {
                sValue += c;
                sStarted = true;
            }
        }
        else
        {
            sValue += c;
            sStarted = true;
        }
    }

    if (!sValue.isEmpty())
    {
        if (sValue[sValue.length()-1] == endChar &amp;&amp; sValue.length() &gt; 1)
        {
            sValue.remove(sValue.length()-1,1);
        }
        if (sValue[0] == endChar)
        {
            sValue.remove(0,1);
        }
    }

//    inFile.setCodec(textCodec);
//    inFile.setAutoDetectUnicode(autoDetectUnicode);
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.94">void RFileIO::readBinary(RFile &amp;inFile, QString &amp;sValue)
{
    int stringSize = 0;
    RFileIO::readBinary(inFile,stringSize);
    QByteArray array = inFile.read(stringSize);
    if (inFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF, "Failed to read string value.");
    }
    sValue.clear();
    sValue.append(array);
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101534.95">void RFileIO::writeAscii(RSaveFile &amp;outFile, const QString &amp;sValue, bool addNewLine)
{
//    QTextCodec *textCodec = outFile.codec();
//    outFile.setCodec("UTF-8");
    QString oValue(sValue);
    if (oValue.isEmpty())
    {
        oValue = "\"\"";
    }
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; oValue;
    }
    else
    {
        outFile.getTextStream() &lt;&lt; oValue &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF, "Failed to write string value.");
    }
//    outFile.setCodec(textCodec);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.96">void RFileIO::writeAscii(RFile &amp;outFile, const QString &amp;sValue, bool addNewLine)
{
//    QTextCodec *textCodec = outFile.codec();
//    outFile.setCodec("UTF-8");
    QString oValue(sValue);
    if (oValue.isEmpty())
    {
        oValue = "\"\"";
    }
    if (!addNewLine)
    {
        outFile.getTextStream() &lt;&lt; oValue;
    }
    else
    {
        outFile.getTextStream() &lt;&lt; oValue &lt;&lt; RConstants::endl;
    }
    if (outFile.getTextStream().status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF, "Failed to write string value.");
    }
//    outFile.setCodec(textCodec);
} /* RFileIO::writeAscii */


</t>
<t tx="leo.20201108101534.97">void RFileIO::writeBinary(RSaveFile &amp;outFile, const QString &amp;sValue)
{
    QByteArray array = sValue.toUtf8();
    RFileIO::writeBinary(outFile,array.size());
    outFile.write(array,array.size());
    if (outFile.error() != RFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF, "Failed to write string value.");
    }
} /* RFileIO::writeBinary */


/*********************************************************************
 *  std::string                                                      *
 *********************************************************************/


</t>
<t tx="leo.20201108101534.98">void RFileIO::readAscii(RFile &amp;inFile, std::string &amp;sValue)
{
    QString qString;
    RFileIO::readAscii(inFile,qString);
    sValue = qString.toStdString();
} /* RFileIO::readAscii */


</t>
<t tx="leo.20201108101534.99">void RFileIO::readBinary(RFile &amp;inFile, std::string &amp;sValue)
{
    QString qString;
    RFileIO::readBinary(inFile,qString);
    sValue = qString.toStdString();
} /* RFileIO::readBinary */


</t>
<t tx="leo.20201108101535.1">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_initial_condition.cpp                                *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Initial condition class definition                  *
 *********************************************************************/

#include "rml_initial_condition.h"
#include "rml_problem.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.10">void RInterpolatedElement::_init(const RInterpolatedElement *pInterpolatedElement)
{
    if (pInterpolatedElement)
    {

    }
}

RInterpolatedElement::RInterpolatedElement()
{
    this-&gt;_init();
}

RInterpolatedElement::RInterpolatedElement(const RInterpolatedElement &amp;interpolatedElement)
    : std::vector&lt;RInterpolatedNode&gt;(interpolatedElement)
{
    this-&gt;_init(&amp;interpolatedElement);
}

RInterpolatedElement::~RInterpolatedElement()
{
}

RInterpolatedElement &amp;RInterpolatedElement::operator =(const RInterpolatedElement &amp;interpolatedElement)
{
    this-&gt;std::vector&lt;RInterpolatedNode&gt;::operator = (interpolatedElement);
    this-&gt;_init(&amp;interpolatedElement);
    return (*this);
}

</t>
<t tx="leo.20201108101535.100">const QString &amp;RMatrixSolverConf::getName(RMatrixSolverType type)
{
    return matrixSolverDesc[type].name;
}

</t>
<t tx="leo.20201108101535.101">const QString &amp;RMatrixSolverConf::getId(RMatrixSolverType type)
{
    return matrixSolverDesc[type].id;
}
</t>
<t tx="leo.20201108101535.102">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_mesh_generator.cpp                                   *
 *  GROUP:  RModel                                                   *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: RMeshGenerator class definition                     *
 *********************************************************************/

#include &lt;QString&gt;
#include &lt;cstring&gt;

#include &lt;tetgen.h&gt;

#include "rml_mesh_generator.h"
#include "rml_tetgen.h"
#include "rml_model_raw.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.103">void RMeshGenerator::generate(const RMeshInput &amp;meshInput, RModel &amp;model)
{
    if (model.getNSurfaces() == 0 &amp;&amp; model.getNVolumes() == 0)
    {
        throw RError(R_ERROR_INVALID_INPUT,R_ERROR_REF, "Model contains no surface nor volume elements.");
    }

    QStringList parameters;
    RModel modelTmp, *pInModel = nullptr, *pOutModel = nullptr;

    if (meshInput.getUseTetGenInputParams())
    {
        parameters.append(meshInput.getTetGenInputParams());
    }
    else
    {
        parameters.append(model.generateMeshTetGenInputParams(meshInput));
        if (meshInput.getUseSizeFunction())
        {
            RMeshInput tmpMeshInput(meshInput);
            tmpMeshInput.setUseSizeFunction(false);
            parameters.append(model.generateMeshTetGenInputParams(tmpMeshInput));
            modelTmp = model;
        }
    }

    try
    {

        RLogger::info("Mesh generation loop.\n");
        RLogger::indent();
        for (int i=0;i&lt;parameters.size();i++)
        {
            RLogger::info("Step %d of %d.\n",i+1,parameters.size());
            if (i==0)
            {
                pInModel = &amp;model;
            }
            else
            {
                pInModel = &amp;modelTmp;
            }
            if (i+1 == parameters.size() || parameters.size() == 1)
            {
                pOutModel = &amp;model;
            }
            else
            {
                pOutModel = &amp;modelTmp;
            }
            bool keepResults = meshInput.getKeepResults();
            if (i+1 &lt; parameters.size() &amp;&amp; parameters.size() &gt; 1)
            {
                keepResults = false;
            }

            RTetGen tetgenIn;
            RTetGen tetgenOut;

            // Convert Range model to TetGen mesh.
            try
            {
                RLogger::info("Converting Range model to TetGen mesh.\n");
                RLogger::indent();
                tetgenIn.importModel(*pInModel,
                                     meshInput.getReconstruct() &amp;&amp; pInModel-&gt;getNVolumes() &gt; 0,
                                     meshInput.getUseSizeFunction() &amp;&amp; i == 0 ? meshInput.getSizeFunctionValues() : RRVector());
                RLogger::unindent();
                RLogger::info("Successfully converted Range model to TetGen mesh.\n");
            }
            catch (const RError &amp;error)
            {
                RLogger::unindent();
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to export mesh to TetGen format: %s", error.getMessage().toUtf8().constData());
            }
            char *args = new char[uint(parameters.at(i).size()) + 1];
            snprintf(args,uint(parameters.at(i).size()) + 1,"%s",parameters.at(i).toUtf8().constData());

            // Generate 3D mesh.
            try
            {
                RLogger::info("Generating volume mesh with parameters \"%s\".\n", args);
                RLogger::indent();
                tetgen_set_print_func(RLogger::info);
                tetrahedralize(args,&amp;tetgenIn,&amp;tetgenOut);
                RLogger::unindent();
                RLogger::info("Mesh generation has finished successfully.\n");
            }
            catch (int errorCode)
            {
                RLogger::unindent();
                delete [] args;
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Mesh generation failed with error code \"%d\"", errorCode);
            }

            delete [] args;

            // Convert TetGen mesh to Range model.
            try
            {
                RLogger::info("Converting TetGen mesh to Range model.\n");
                RLogger::indent();
                tetgenOut.exportMesh(*pOutModel,keepResults);
                RLogger::unindent();
                RLogger::info("Successfully converted TetGen mesh to Range model.\n");
            }
            catch (const RError &amp;error)
            {
                RLogger::unindent();
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to import mesh from TetGen format: %s", error.getMessage().toUtf8().constData());
            }
        }
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to import mesh from TetGen format: %s", error.getMessage().toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101535.104">void RMeshGenerator::generate(const std::vector&lt;RNode&gt; &amp;nodes, const std::vector&lt;RElement&gt; &amp;elements, std::vector&lt;RNode&gt; &amp;steinerNodes, std::vector&lt;RElement&gt; &amp;volumes)
{
    RModel model;

    model.setNNodes(uint(nodes.size()));
    for (uint i=0;i&lt;nodes.size();i++)
    {
        model.setNode(i,nodes[i]);
    }
    model.setNElements(uint(elements.size()));
    for (uint i=0;i&lt;elements.size();i++)
    {
        model.setElement(i,elements[i],true);
    }

    model.purgeUnusedElements();
    model.purgeUnusedNodes();

    RMeshInput input;
    input.setVerbose(false);
    input.setSurfaceIntegrityCheck(true);
    input.setQualityMesh(false);
    input.setKeepResults(false);
    input.setOutputEdges(false);

    try
    {
        RMeshGenerator::generate(input,model);
    }
    catch (const RError &amp;error)
    {
        throw error;
    }

    uint nSteinerNodes = model.getNNodes() - uint(nodes.size());

    steinerNodes.resize(nSteinerNodes,RNode(0.0,0.0,0.0));

    for (uint i=0;i&lt;nSteinerNodes;i++)
    {
        steinerNodes[i] = model.getNode(uint(nodes.size()) + i);
    }

    for (uint i=0;i&lt;model.getNVolumes();i++)
    {
        const RVolume &amp;rVolume = model.getVolume(i);
        for (uint j=0;j&lt;rVolume.size();j++)
        {
            const RElement &amp;rElement = model.getElement(rVolume.get(j));
            if (rElement.getType() != R_ELEMENT_TETRA1)
            {
                continue;
            }
            volumes.push_back(rElement);
        }
    }
}

std::vector&lt;RTetrahedron&gt; RMeshGenerator::generate(const std::vector&lt;RTriangle&gt; &amp;triangles)
{
    RModelRaw modelRaw;
    for (uint i=0;i&lt;triangles.size();i++)
    {
        modelRaw.addTriangle(triangles[i].getNode1(),triangles[i].getNode2(),triangles[i].getNode3());
    }
    RModel model(modelRaw);

    RMeshInput input;
    input.setVerbose(false);
    input.setSurfaceIntegrityCheck(true);
    input.setQualityMesh(false);
    input.setKeepResults(false);
    input.setOutputEdges(false);

    try
    {
        RMeshGenerator::generate(input,model);
    }
    catch (const RError &amp;error)
    {
        throw error;
    }

    std::vector&lt;RTetrahedron&gt; tetrahedrons;
    for (uint i=0;i&lt;model.getNVolumes();i++)
    {
        const RVolume &amp;rVolume = model.getVolume(i);
        for (uint j=0;j&lt;rVolume.size();j++)
        {
            const RElement &amp;rElement = model.getElement(rVolume.get(j));
            if (rElement.getType() != R_ELEMENT_TETRA1)
            {
                continue;
            }
            uint n1 = rElement.getNodeId(0);
            uint n2 = rElement.getNodeId(1);
            uint n3 = rElement.getNodeId(2);
            uint n4 = rElement.getNodeId(3);

            tetrahedrons.push_back(RTetrahedron(model.getNode(n1),model.getNode(n2),model.getNode(n3),model.getNode(n4)));
        }
    }

    return tetrahedrons;
}
</t>
<t tx="leo.20201108101535.105">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_mesh_input.cpp                                       *
 *  GROUP:  RModel                                                   *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: RMeshInput class definition                         *
 *********************************************************************/

#include "rml_mesh_input.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.106">void RMeshInput::_init(const RMeshInput *pMeshInput)
{
    if (pMeshInput)
    {
        this-&gt;verbose = pMeshInput-&gt;verbose;
        this-&gt;volumeMesh = pMeshInput-&gt;volumeMesh;
        this-&gt;qualityMesh = pMeshInput-&gt;qualityMesh;
        this-&gt;outputEdges = pMeshInput-&gt;outputEdges;
        this-&gt;reconstruct = pMeshInput-&gt;reconstruct;
        this-&gt;useSizeFunction = pMeshInput-&gt;useSizeFunction;
        this-&gt;sizeFunctionValues = pMeshInput-&gt;sizeFunctionValues;
        this-&gt;radiusEdgeRatio = pMeshInput-&gt;radiusEdgeRatio;
        this-&gt;volumeConstraint = pMeshInput-&gt;volumeConstraint;
        this-&gt;tolerance = pMeshInput-&gt;tolerance;
        this-&gt;surfaceIntegrityCheck = pMeshInput-&gt;surfaceIntegrityCheck;
        this-&gt;keepResults = pMeshInput-&gt;keepResults;
        this-&gt;useTetGenInputParams = pMeshInput-&gt;useTetGenInputParams;
        this-&gt;tetGenInputParams = pMeshInput-&gt;tetGenInputParams;
    }
}

RMeshInput::RMeshInput() :
    verbose(true),
    volumeMesh(true),
    qualityMesh(true),
    outputEdges(false),
    reconstruct(true),
    useSizeFunction(false),
    radiusEdgeRatio(1.6),
    volumeConstraint(0.1),
    tolerance(1.0e-10),
    surfaceIntegrityCheck(false),
    keepResults(true),
    useTetGenInputParams(false),
    tetGenInputParams(QString())
{
    this-&gt;_init();
}

RMeshInput::RMeshInput(const RMeshInput &amp;meshInput)
{
    this-&gt;_init(&amp;meshInput);
}

RMeshInput::~RMeshInput()
{
}

RMeshInput &amp;RMeshInput::operator =(const RMeshInput &amp;meshInput)
{
    this-&gt;_init(&amp;meshInput);
    return (*this);
}

</t>
<t tx="leo.20201108101535.107">bool RMeshInput::getVerbose(void) const
{
    return this-&gt;verbose;
}

</t>
<t tx="leo.20201108101535.108">void RMeshInput::setVerbose(bool verbose)
{
    this-&gt;verbose = verbose;
}

</t>
<t tx="leo.20201108101535.109">bool RMeshInput::getVolumeMesh(void) const
{
    return this-&gt;volumeMesh;
}

</t>
<t tx="leo.20201108101535.11">void RInterpolatedElement::sortNodes(void)
{
    this-&gt;removeDuplicateNodes();

    if (this-&gt;size() &lt; 3)
    {
        return;
    }

    if (this-&gt;size() == 4)
    {
        RTriangle t1(this-&gt;operator [](0),
                     this-&gt;operator [](1),
                     this-&gt;operator [](2));
        RTriangle t2(this-&gt;operator [](0),
                     this-&gt;operator [](2),
                     this-&gt;operator [](3));

        double angleNormal = std::fabs(RR3Vector::angle(t1.getNormal(),t2.getNormal()));
        if (angleNormal &gt; RConstants::pi/2.0 &amp;&amp; angleNormal &lt; 3.0*RConstants::pi/2.0)
        {
            RInterpolatedNode nTmp = this-&gt;operator [](2);
            this-&gt;operator [](2) = this-&gt;operator [](3);
            this-&gt;operator [](3) = nTmp;
        }
        return;
    }

    RR3Vector c(0.0,0.0,0.0);

    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        c[0] += this-&gt;operator [](i).getX();
        c[1] += this-&gt;operator [](i).getY();
        c[2] += this-&gt;operator [](i).getZ();
    }

    if (this-&gt;size() &gt; 1)
    {
        c[0] /= double(this-&gt;size());
        c[1] /= double(this-&gt;size());
        c[2] /= double(this-&gt;size());
    }

    RTriangle triangle(this-&gt;operator [](0),
                       this-&gt;operator [](1),
                       RNode(c[0],c[1],c[2]));

    const RR3Vector &amp;normal = triangle.getNormal();

    RR3Vector v1(this-&gt;operator [](0).getX() - c[0],
                 this-&gt;operator [](0).getY() - c[1],
                 this-&gt;operator [](0).getZ() - c[2]);

    std::map&lt;double,RInterpolatedNode&gt; nodeBook;

    nodeBook[0.0] = this-&gt;operator [](0);

    RR3Vector vn;
    for (unsigned int i=1;i&lt;this-&gt;size();i++)
    {
        RR3Vector v2(this-&gt;operator [](i).getX() - c[0],
                     this-&gt;operator [](i).getY() - c[1],
                     this-&gt;operator [](i).getZ() - c[2]);

        double angle = std::fabs(RR3Vector::angle(v1,v2));

        if (angle &lt; RConstants::pi)
        {
            RR3Vector::cross(v1,v2,vn);

            double angleNormal = std::fabs(RR3Vector::angle(normal,vn));
            if (angleNormal &gt; RConstants::pi/2.0 &amp;&amp; angleNormal &lt; 3.0*RConstants::pi/2.0)
            {
                angle = 2.0 * RConstants::pi - angle;
            }
        }

        nodeBook[angle] = this-&gt;operator [](i);
    }

    this-&gt;clear();

    for (std::map&lt;double,RInterpolatedNode&gt;::iterator iter = nodeBook.begin(); iter != nodeBook.end(); iter++)
    {
        this-&gt;push_back(iter-&gt;second);
    }
}

</t>
<t tx="leo.20201108101535.110">void RMeshInput::setVolumeMesh(bool volumeMesh)
{
    this-&gt;volumeMesh = volumeMesh;
}

</t>
<t tx="leo.20201108101535.111">bool RMeshInput::getQualityMesh(void) const
{
    return this-&gt;qualityMesh;
}

</t>
<t tx="leo.20201108101535.112">void RMeshInput::setQualityMesh(bool qualityMesh)
{
    this-&gt;qualityMesh = qualityMesh;
}

</t>
<t tx="leo.20201108101535.113">bool RMeshInput::getOutputEdges(void) const
{
    return this-&gt;outputEdges;
}

</t>
<t tx="leo.20201108101535.114">void RMeshInput::setOutputEdges(bool outputEdges)
{
    this-&gt;outputEdges = outputEdges;
}

</t>
<t tx="leo.20201108101535.115">bool RMeshInput::getReconstruct(void) const
{
    return this-&gt;reconstruct;
}

</t>
<t tx="leo.20201108101535.116">void RMeshInput::setReconstruct(bool reconstruct)
{
    this-&gt;reconstruct = reconstruct;
}

</t>
<t tx="leo.20201108101535.117">bool RMeshInput::getUseSizeFunction(void) const
{
    return this-&gt;useSizeFunction;
}

</t>
<t tx="leo.20201108101535.118">void RMeshInput::setUseSizeFunction(bool useSizeFunction)
{
    this-&gt;useSizeFunction = useSizeFunction;
}

</t>
<t tx="leo.20201108101535.119">const RRVector &amp;RMeshInput::getSizeFunctionValues(void) const
{
    return this-&gt;sizeFunctionValues;
}

</t>
<t tx="leo.20201108101535.12">void RInterpolatedElement::removeDuplicateNodes(void)
{
    RInterpolatedElement nodes;

    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        bool duplicateFound = false;
        for (unsigned int j=i+1;j&lt;this-&gt;size();j++)
        {
            if (std::fabs(this-&gt;operator [](i).getDistance(this-&gt;operator [](j))) &lt; RConstants::eps)
            {
                duplicateFound = true;
            }
        }
        if (!duplicateFound)
        {
            nodes.push_back(this-&gt;operator [](i));
        }
    }
    this-&gt;operator =(nodes);
}

</t>
<t tx="leo.20201108101535.120">void RMeshInput::setSizeFunctionValues(const RRVector &amp;sizeFunctionValues)
{
    this-&gt;sizeFunctionValues = sizeFunctionValues;
}

double RMeshInput::getRadiusEdgeRatio(void) const
{
    return this-&gt;radiusEdgeRatio;
}

</t>
<t tx="leo.20201108101535.121">void RMeshInput::setRadiusEdgeRatio(double radiusEdgeRatio)
{
    this-&gt;radiusEdgeRatio = radiusEdgeRatio;
}

double RMeshInput::getVolumeConstraint(void) const
{
    return this-&gt;volumeConstraint;
}

</t>
<t tx="leo.20201108101535.122">void RMeshInput::setVolumeConstraint(double volumeConstrain)
{
    this-&gt;volumeConstraint = volumeConstrain;
}

double RMeshInput::getTolerance(void) const
{
    return this-&gt;tolerance;
}

</t>
<t tx="leo.20201108101535.123">void RMeshInput::setTolerance(double tolerance)
{
    this-&gt;tolerance = tolerance;
}

</t>
<t tx="leo.20201108101535.124">bool RMeshInput::getSurfaceIntegrityCheck(void) const
{
    return this-&gt;surfaceIntegrityCheck;
}

</t>
<t tx="leo.20201108101535.125">void RMeshInput::setSurfaceIntegrityCheck(bool surfaceIntegrityCheck)
{
    this-&gt;surfaceIntegrityCheck = surfaceIntegrityCheck;
}

</t>
<t tx="leo.20201108101535.126">bool RMeshInput::getKeepResults(void) const
{
    return this-&gt;keepResults;
}

</t>
<t tx="leo.20201108101535.127">void RMeshInput::setKeepResults(bool keepResults)
{
    this-&gt;keepResults = keepResults;
}

</t>
<t tx="leo.20201108101535.128">bool RMeshInput::getUseTetGenInputParams(void) const
{
    return this-&gt;useTetGenInputParams;
}

</t>
<t tx="leo.20201108101535.129">void RMeshInput::setUseTetGenInputParams(bool useTetGenInputParams)
{
    this-&gt;useTetGenInputParams = useTetGenInputParams;
}

</t>
<t tx="leo.20201108101535.13">void RInterpolatedElement::findCenter(double &amp;cx, double &amp;cy, double &amp;cz) const
{
    cx = cy = cz = 0.0;
    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        cx += this-&gt;at(i).getX();
        cy += this-&gt;at(i).getY();
        cz += this-&gt;at(i).getZ();
    }
    if (this-&gt;size() != 0)
    {
        cx /= double(this-&gt;size());
        cy /= double(this-&gt;size());
        cz /= double(this-&gt;size());
    }
}

</t>
<t tx="leo.20201108101535.130">const QString &amp;RMeshInput::getTetGenInputParams(void) const
{
    return this-&gt;tetGenInputParams;
}

</t>
<t tx="leo.20201108101535.131">void RMeshInput::setTetGenInputParams(const QString &amp;tetGenInputParams)
{
    this-&gt;tetGenInputParams = tetGenInputParams;
}
</t>
<t tx="leo.20201108101535.14">bool RInterpolatedElement::findNormal(double &amp;nx, double &amp;ny, double &amp;nz) const
{
    if (this-&gt;size() &lt; 3)
    {
        return false;
    }
    std::vector&lt;RR3Vector&gt; nodes;
    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        nodes.push_back(RR3Vector(this-&gt;at(i).getX(),this-&gt;at(i).getY(),this-&gt;at(i).getZ()));
    }
    RPolygon p(nodes);
    nx = p.getNormal()[0];
    ny = p.getNormal()[1];
    nz = p.getNormal()[2];

    return true;
}

</t>
<t tx="leo.20201108101535.15">bool RInterpolatedElement::findPickDistance(const RR3Vector &amp;position, const RR3Vector &amp;direction, double tolerance, double &amp;distance) const
{
    bool found = false;

    if (this-&gt;size() == 1)
    {
        RSegment ray(RNode(position),RNode(position[0]+direction[0],position[1]+direction[1],position[2]+direction[2]));
        double u = ray.findPointDistance(this-&gt;at(0).toVector());
        if (u &lt;= tolerance)
        {
            distance = this-&gt;at(0).getDistance(position);
            found = true;
        }
    }
    else if (this-&gt;size() == 2)
    {
        std::vector&lt;RNode&gt; nodes(this-&gt;size());
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            nodes[i] = this-&gt;at(i);
        }
        RElement line(R_ELEMENT_TRUSS1);
        line.setNodeId(0,0);
        line.setNodeId(1,1);
        double u;
        if (line.findPickDistance(nodes,position,direction,tolerance,u))
        {
            distance = u;
            found = true;
        }
    }
    else if (this-&gt;size() &gt;= 3)
    {
        std::vector&lt;RNode&gt; nodes(this-&gt;size());
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            nodes[i] = this-&gt;at(i);
        }

        std::vector&lt;RElement&gt; triangles = RPolygon::triangulate(nodes,true);

        for (uint i=0;i&lt;triangles.size();i++)
        {
            const RElement &amp;rElement = triangles[i];
            double u;
            if (rElement.findPickDistance(nodes,position,direction,tolerance,u))
            {
                if (!found || u &lt; distance)
                {
                    distance = u;
                    found = true;
                }
            }
        }
    }

    return found;
}

</t>
<t tx="leo.20201108101535.16">void RInterpolatedElement::findScalarNodeValues(const std::vector&lt;RNode&gt; &amp;rNodes,
                                                const std::vector&lt;RElement&gt; &amp;rElements,
                                                const RVariable &amp;rVariable,
                                                std::vector&lt;double&gt; &amp;values) const
{
    values.resize(this-&gt;size());

    double minValue = rVariable.getVariableData().getMinDisplayValue();
    double maxValue = rVariable.getVariableData().getMaxDisplayValue();

    if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            const RElement &amp;element = rElements[this-&gt;at(i).getElementID()];
            std::vector&lt;double&gt; nodeValues;
            nodeValues.resize(element.size(),0.0);
            for (uint j=0;j&lt;element.size();j++)
            {
                nodeValues[j] = rVariable.getValue(element.getNodeId(j));
            }
            values[i] = element.interpolate(rNodes,this-&gt;at(i),nodeValues);
        }
    }
    else if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            values[i] = rVariable.getValue(this-&gt;at(i).getElementID());
        }
    }

    for (uint i=0;i&lt;values.size();i++)
    {
        values[i] = (values[i] - minValue) / (maxValue - minValue);

        values[i] = std::min(values[i],0.99);
        values[i] = std::max(values[i],0.01);
    }
}

</t>
<t tx="leo.20201108101535.17">void RInterpolatedElement::findDisplacementNodeValues(const std::vector&lt;RNode&gt; &amp;rNodes,
                                                      const std::vector&lt;RElement&gt; &amp;rElements,
                                                      const RVariable &amp;rVariable,
                                                      std::vector&lt;RR3Vector&gt; &amp;values) const
{
    values.resize(this-&gt;size());

    if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            const RElement &amp;element = rElements[this-&gt;at(i).getElementID()];
            std::vector&lt;double&gt; xNodeValues;
            std::vector&lt;double&gt; yNodeValues;
            std::vector&lt;double&gt; zNodeValues;
            xNodeValues.resize(element.size(),0.0);
            yNodeValues.resize(element.size(),0.0);
            zNodeValues.resize(element.size(),0.0);
            for (uint j=0;j&lt;element.size();j++)
            {
                xNodeValues[j] = rVariable.getValue(0,element.getNodeId(j));
                yNodeValues[j] = rVariable.getValue(1,element.getNodeId(j));
                zNodeValues[j] = rVariable.getValue(2,element.getNodeId(j));
            }
            values[i][0] = element.interpolate(rNodes,this-&gt;at(i),xNodeValues);
            values[i][1] = element.interpolate(rNodes,this-&gt;at(i),yNodeValues);
            values[i][2] = element.interpolate(rNodes,this-&gt;at(i),zNodeValues);
        }
    }
    else if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        for (uint i=0;i&lt;this-&gt;size();i++)
        {
            values[i][0] = rVariable.getValue(0,this-&gt;at(i).getElementID());
            values[i][1] = rVariable.getValue(1,this-&gt;at(i).getElementID());
            values[i][2] = rVariable.getValue(2,this-&gt;at(i).getElementID());
        }
    }

    double scale = rVariable.getVariableData().getScale();

    for (uint i=0;i&lt;values.size();i++)
    {
        values[i] *= scale;
    }
}
</t>
<t tx="leo.20201108101535.18">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_interpolated_entity.cpp                              *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   31-st May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Interpolated entity class definition                *
 *********************************************************************/

#include "rml_interpolated_entity.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.19">void RInterpolatedEntity::_init(const RInterpolatedEntity *pInterpolatedEntity)
{
    if (pInterpolatedEntity)
    {

    }
}

RInterpolatedEntity::RInterpolatedEntity()
{
    this-&gt;_init();
}

RInterpolatedEntity::RInterpolatedEntity(const RInterpolatedEntity &amp;interpolatedEntity)
    : REntityGroup(interpolatedEntity)
    , std::vector&lt;RInterpolatedElement&gt; (interpolatedEntity)
{
    this-&gt;_init(&amp;interpolatedEntity);
}

RInterpolatedEntity::~RInterpolatedEntity()
{
}

RInterpolatedEntity &amp;RInterpolatedEntity::operator =(const RInterpolatedEntity &amp;interpolatedEntity)
{
    this-&gt;REntityGroup::operator = (interpolatedEntity);
    this-&gt;std::vector&lt;RInterpolatedElement&gt;::operator = (interpolatedEntity);
    this-&gt;_init(&amp;interpolatedEntity);
    return (*this);
}
</t>
<t tx="leo.20201108101535.2">typedef struct _RInitialConditionDesc
{
    QString          id;
    QString          name;
    RProblemTypeMask problemTypeMask;
} RInitialConditionDesc;

</t>
<t tx="leo.20201108101535.20">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_interpolated_node.cpp                                *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   31-st May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Interpolated node class definition                  *
 *********************************************************************/

#include "rml_interpolated_node.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.21">void RInterpolatedNode::_init(const RInterpolatedNode *pInterpolatedNode)
{
    if (pInterpolatedNode)
    {
        this-&gt;elementID = pInterpolatedNode-&gt;elementID;
    }
}

RInterpolatedNode::RInterpolatedNode(unsigned int elementID)
    : elementID(elementID)
{
    this-&gt;_init();
}

RInterpolatedNode::RInterpolatedNode(unsigned int elementID, double x, double y, double z)
    : RNode(x,y,z)
    , elementID(elementID)
{
    this-&gt;_init();
}

RInterpolatedNode::RInterpolatedNode(unsigned int elementID, const RR3Vector &amp;vector)
    : RNode(vector)
    , elementID(elementID)
{
    this-&gt;_init();
}

RInterpolatedNode::RInterpolatedNode(const RInterpolatedNode &amp;interpolatedNode)
    : RNode(interpolatedNode)
{
    this-&gt;_init(&amp;interpolatedNode);
}

RInterpolatedNode::~RInterpolatedNode()
{
}

RInterpolatedNode &amp;RInterpolatedNode::operator =(const RInterpolatedNode &amp;interpolatedNode)
{
    this-&gt;RNode::operator =(interpolatedNode);
    this-&gt;_init(&amp;interpolatedNode);
    return (*this);
}

</t>
<t tx="leo.20201108101535.22">unsigned int RInterpolatedNode::getElementID(void) const
{
    return this-&gt;elementID;
}

</t>
<t tx="leo.20201108101535.23">void RInterpolatedNode::setElementID(unsigned int elementID)
{
    this-&gt;elementID = elementID;
}
</t>
<t tx="leo.20201108101535.24">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_iso.cpp                                              *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: ISO class definition                                *
 *********************************************************************/

#include "rml_iso.h"

const QString RIso::defaultName("ISO");

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.25">void RIso::_init(const RIso *pIso)
{
    if (pIso)
    {
        this-&gt;variableType = pIso-&gt;variableType;
        this-&gt;variableValue = pIso-&gt;variableValue;
        this-&gt;elementGroupIDs = pIso-&gt;elementGroupIDs;
    }
}

RIso::RIso()
{
    this-&gt;name = RIso::defaultName;
    this-&gt;_init();
}

RIso::RIso(const RIso &amp;iso)
    : RInterpolatedEntity(iso)
{
    this-&gt;_init(&amp;iso);
}

RIso::~RIso()
{
}

RIso &amp;RIso::operator =(const RIso &amp;iso)
{
    this-&gt;RInterpolatedEntity::operator = (iso);
    this-&gt;_init(&amp;iso);
    return (*this);
}

RVariableType RIso::getVariableType(void) const
{
    return this-&gt;variableType;
}

</t>
<t tx="leo.20201108101535.26">void RIso::setVariableType(RVariableType variableType)
{
    this-&gt;variableType = variableType;
}

double RIso::getVariableValue(void) const
{
    return this-&gt;variableValue;
}

</t>
<t tx="leo.20201108101535.27">void RIso::setVariableValue(double variableValue)
{
    this-&gt;variableValue = variableValue;
}

</t>
<t tx="leo.20201108101535.28">const std::vector&lt;uint&gt; &amp;RIso::getElementGroupIDs(void) const
{
    return this-&gt;elementGroupIDs;
}

std::vector&lt;uint&gt; &amp;RIso::getElementGroupIDs(void)
{
    return this-&gt;elementGroupIDs;
}

</t>
<t tx="leo.20201108101535.29">bool RIso::addElementGroupID(uint elementGroupID)
{
    if (std::find(this-&gt;elementGroupIDs.begin(),this-&gt;elementGroupIDs.end(),elementGroupID) != this-&gt;elementGroupIDs.end())
    {
        return false;
    }

    this-&gt;elementGroupIDs.push_back(elementGroupID);

    std::sort(this-&gt;elementGroupIDs.begin(),this-&gt;elementGroupIDs.end());

    return true;
}

</t>
<t tx="leo.20201108101535.3">const RInitialConditionDesc initialConditionDesc [] =
{
    { "ic-none", "None",
      R_PROBLEM_NONE },
    { "ic-displacement", "Displacement",
      R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "ic-electric_potential", "Electric potential",
      R_PROBLEM_ELECTROSTATICS },
    { "ic-particle_contamination", "Particle concentration",
      R_PROBLEM_FLUID_PARTICLE },
    { "ic-pressure", "Pressure",
      R_PROBLEM_FLUID | R_PROBLEM_POTENTIAL | R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "ic-temperature", "Temperature",
      R_PROBLEM_HEAT | R_PROBLEM_RADIATIVE_HEAT | R_PROBLEM_FLUID_HEAT },
    { "ic-velocity", "Velocity",
      R_PROBLEM_FLUID | R_PROBLEM_POTENTIAL | R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "ic-velocity_potential", "Velocity potential",
      R_PROBLEM_ACOUSTICS },
    { "ic-wave_displacement", "Wave displacement",
      R_PROBLEM_WAVE },
    { "ic-custom", "Custom",
      R_PROBLEM_NONE }
};


RInitialCondition::RInitialCondition (RInitialConditionType type)
{
    this-&gt;setType (type);
    this-&gt;_init ();
} /* RInitialCondition::RInitialCondition */


RInitialCondition::RInitialCondition
                                  (const RInitialCondition &amp;condition)
                                              : RCondition (condition)
{
    this-&gt;_init (&amp;condition);
} /* RInitialCondition::RInitialCondition (copy) */


RInitialCondition::~RInitialCondition ()
{
} /* RInitialCondition::~RInitialCondition */


</t>
<t tx="leo.20201108101535.30">bool RIso::removeElementGroupID(uint elementGroupID, bool decrement)
{
    bool removed = false;
    std::vector&lt;uint&gt;::iterator iter = std::find(this-&gt;elementGroupIDs.begin(),this-&gt;elementGroupIDs.end(),elementGroupID);
    if (iter != this-&gt;elementGroupIDs.end())
    {
        this-&gt;elementGroupIDs.erase(iter);
        removed = true;
    }
    if (decrement)
    {
        for (uint i=0;i&lt;this-&gt;elementGroupIDs.size();i++)
        {
            if (this-&gt;elementGroupIDs[i] &gt; elementGroupID)
            {
                this-&gt;elementGroupIDs[i]--;
            }
        }
    }
    return removed;
}

</t>
<t tx="leo.20201108101535.31">void RIso::clearElementGroupIDs(void)
{
    this-&gt;elementGroupIDs.clear();
}
</t>
<t tx="leo.20201108101535.32">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_line.cpp                                             *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th December 2011                                       *
 *                                                                   *
 *  DESCRIPTION: Line class definition                               *
 *********************************************************************/

#include "rml_element.h"
#include "rml_line.h"

const QString RLine::defaultName("Line");

RLine::RLine () : crossArea(0.0)
{
    this-&gt;name = RLine::defaultName;
    this-&gt;_init ();
} /* RLine::RLine */


RLine::RLine (const RLine &amp;line) : RElementGroup (line)
{
    this-&gt;_init (&amp;line);
} /* RLine::RLine */


RLine::~RLine ()
{
} /* RLine::~RLine */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.33">void RLine::_init (const RLine *pLine)
{
    if (pLine)
    {
        this-&gt;setCrossArea (pLine-&gt;getCrossArea());
    }
} /* RLine::_init */


double RLine::getCrossArea (void) const
{
    return this-&gt;crossArea;
} /* RLine::getCrossArea */


</t>
<t tx="leo.20201108101535.34">void RLine::setCrossArea (double crossArea)
{
    this-&gt;crossArea = crossArea;
} /* RLine::setCrossArea */


double RLine::findLength(const std::vector&lt;RNode&gt; &amp;nodes, const std::vector&lt;RElement&gt; &amp;elements) const
{
    double lineLength = 0.0;

    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        const RElement &amp;rElement = elements[this-&gt;get(i)];

        double elementLength = 0.0;
        if (rElement.findLength(nodes,elementLength))
        {
            lineLength += elementLength;
        }
    }

    return lineLength;
} /* RLine::findLength */


RLine &amp; RLine::operator = (const RLine &amp;line)
{
    this-&gt;RElementGroup::operator = (line);
    this-&gt;_init (&amp;line);
    return (*this);
} /* RLine::operator = */

</t>
<t tx="leo.20201108101535.35">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_material.cpp                                         *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   16-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Material class definition                           *
 *********************************************************************/

#include &lt;algorithm&gt;
#include &lt;stdexcept&gt;

#include "rml_material.h"
#include "rml_file_io.h"
#include "rml_file_manager.h"

static const RVersion _version = RVersion(FILE_MAJOR_VERSION,FILE_MINOR_VERSION,FILE_RELEASE_VERSION);

static bool propertyTypeCompareFunc(const RMaterialProperty &amp;p1,const RMaterialProperty &amp;p2);

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.36">void RMaterial::_init (const RMaterial *pMaterial)
{
    this-&gt;id = 0;
    if (pMaterial)
    {
        this-&gt;id = pMaterial-&gt;id;
        this-&gt;name = pMaterial-&gt;name;
        this-&gt;state = pMaterial-&gt;state;
        this-&gt;properties = pMaterial-&gt;properties;
    }
} /* RMaterial::_init */


RMaterial::RMaterial (RMaterialState state)
{
    this-&gt;setState (state);
    this-&gt;_init ();
} /* RMaterial::RMaterial */


RMaterial::RMaterial (const RMaterial &amp;material)
{
    this-&gt;_init (&amp;material);
} /* RMaterial::RMaterial (copy) */


RMaterial::~RMaterial ()
{
} /* RMaterial::~RMaterial */


RMaterial &amp; RMaterial::operator = (const RMaterial &amp;material)
{
    this-&gt;_init (&amp;material);
    return (*this);
} /* RMaterial::operator = */

</t>
<t tx="leo.20201108101535.37">bool RMaterial::propertiesEqual(const RMaterial &amp;material) const
{
    if (this-&gt;properties.size() != material.properties.size())
    {
        return false;
    }
    for (unsigned int i=0;i&lt;this-&gt;properties.size();i++)
    {
        if (this-&gt;properties[i] != material.properties[i])
        {
            return false;
        }
    }
    return true;
} /* RMaterial::propertiesEqual */


</t>
<t tx="leo.20201108101535.38">unsigned int RMaterial::getID (void) const
{
    return this-&gt;id;
} /* RMaterial::getID */


</t>
<t tx="leo.20201108101535.39">void RMaterial::setID (unsigned int id)
{
    this-&gt;id = id;
} /* RMaterial::setID */


</t>
<t tx="leo.20201108101535.4">void RInitialCondition::_init (const RInitialCondition *pCondition)
{
    if (pCondition)
    {
        this-&gt;setTypeSafe (pCondition-&gt;getType());
    }
} /* RInitialCondition::_init */


RInitialConditionType RInitialCondition::getType (void) const
{
    return this-&gt;type;
} /* RInitialCondition::getType */


</t>
<t tx="leo.20201108101535.40">const QString &amp;RMaterial::getName(void) const
{
    return this-&gt;name;
} /* RMaterial::getName */


</t>
<t tx="leo.20201108101535.41">void RMaterial::setName (const QString &amp;name)
{
    this-&gt;name = name;
} /* RMaterial::setName */


RMaterialState RMaterial::getState (void) const
{
    return this-&gt;state;
} /* RMaterial::getState */


</t>
<t tx="leo.20201108101535.42">void RMaterial::setState (RMaterialState state)
{
    this-&gt;state = state;
} /* RMaterial::setState */


</t>
<t tx="leo.20201108101535.43">unsigned int RMaterial::size (void) const
{
    return (unsigned int)this-&gt;properties.size();
} /* RMaterial::size */


</t>
<t tx="leo.20201108101535.44">bool RMaterial::add (const RMaterialProperty &amp;property)
{
    unsigned int position = 0;

    position = this-&gt;findPosition (property.getType());

    if (position &gt;= this-&gt;size())
    {
        this-&gt;properties.push_back(property);
        std::sort(this-&gt;properties.begin(),this-&gt;properties.end(),propertyTypeCompareFunc);
        return true;
    }
    else
    {
        this-&gt;properties[position] = property;
        return false;
    }
} /* RMaterial::add */


</t>
<t tx="leo.20201108101535.45">const RMaterialProperty &amp; RMaterial::get (unsigned int position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;size());
    return this-&gt;properties[position];
} /* RMaterial::get */


RMaterialProperty &amp;RMaterial::get(unsigned int position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;size());
    return this-&gt;properties[position];
} /* RMaterial::get */


</t>
<t tx="leo.20201108101535.46">void RMaterial::remove (unsigned int position)
{
    std::vector&lt;RMaterialProperty&gt;::iterator iter;

    iter = this-&gt;properties.begin();
    std::advance (iter, position);

    this-&gt;properties.erase (iter);
} /* RMaterial::remove */


</t>
<t tx="leo.20201108101535.47">void RMaterial::clear(void)
{
    this-&gt;id = 0;
    this-&gt;name.clear();
    this-&gt;state = R_MATERIAL_STATE_NONE;
    this-&gt;properties.clear();
} /* RMaterial::clear */


</t>
<t tx="leo.20201108101535.48">unsigned int RMaterial::findPosition (RMaterialPropertyType type) const
{
    std::vector&lt;RMaterialProperty&gt;::const_iterator iter;
    unsigned int i = 0;

    for (iter = this-&gt;properties.begin();
         iter != this-&gt;properties.end();
         ++iter)
    {
        if (iter-&gt;getType() == type)
        {
           return i;
        }
        i++;
    }

    return this-&gt;size();
} /* RMaterial::find_position */


</t>
<t tx="leo.20201108101535.49">bool RMaterial::hasProperties (const std::vector&lt;RMaterialPropertyType&gt; &amp;propertyTypes) const
{
    if (propertyTypes.size() == 0)
    {
        return false;
    }
    for (unsigned int i=0;i&lt;propertyTypes.size();i++)
    {
        if (this-&gt;findPosition(propertyTypes[i]) == this-&gt;size())
        {
            return false;
        }
    }
    return true;
} /* RMaterial::hasProperties */


RMaterial RMaterial::generateDefault(void)
{
    RMaterial material;

    material.setName("Default");
    for (RMaterialPropertyType type=RMaterialPropertyType(R_MATERIAL_PROPERTY_NONE+1);
         type&lt;RMaterialPropertyType(R_MATERIAL_PROPERTY_N_TYPES-1);
         type++)
    {
        RMaterialProperty property(type);
        material.add(property);
    }

    return material;
} /* RMaterial::generateDefault */


</t>
<t tx="leo.20201108101535.5">void RInitialCondition::setType (RInitialConditionType type)
{
    std::vector&lt;RVariableType&gt; componentTypes;
    RConditionComponent component;

    this-&gt;setTypeSafe (type);
    this-&gt;clear ();

    componentTypes = RInitialCondition::getDefaultComponents (type);

    for (unsigned int i=0;i&lt;componentTypes.size();i++)
    {
        component.setType (componentTypes[i]);
        this-&gt;addComponent (component);
    }
} /* RInitialCondition::setType */


</t>
<t tx="leo.20201108101535.50">void RMaterial::read(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QString ext = RFileManager::getExtension(fileName);

    try
    {
        if (ext == RMaterial::getDefaultFileExtension(false))
        {
            this-&gt;readAscii(fileName);
        }
        else if (ext == RMaterial::getDefaultFileExtension(true))
        {
            this-&gt;readBinary(fileName);
        }
        else
        {
            throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
        }
    }
    catch (RError &amp;error)
    {
        throw error;
    }
    catch (const std::exception &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "%s", error.what());
    }
    catch (...)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Unknown exception.");
    }
} /* RMaterial::read */


</t>
<t tx="leo.20201108101535.51">void RMaterial::write(const QString &amp;fileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file was name provided.");
    }

    QString ext = RFileManager::getExtension(fileName);

    try
    {
        if (ext == RMaterial::getDefaultFileExtension(false))
        {
            this-&gt;writeAscii(fileName);
        }
        else if (ext == RMaterial::getDefaultFileExtension(true))
        {
            this-&gt;writeBinary(fileName);
        }
        else
        {
            throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
        }
    }
    catch (RError &amp;error)
    {
        throw error;
    }
    catch (const std::exception &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "%s", error.what());
    }
    catch (...)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Unknown exception.");
    }
} /* RMaterial::write */


</t>
<t tx="leo.20201108101535.52">void RMaterial::import(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file was name provided.");
    }

    try
    {
        RFile file(fileName,RFile::ASCII);

        if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
        {
            throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
        }

        QString flag;
        QString fVersion;
        uint nProperties = 0;
        QVector&lt;QString&gt; tableFlags;
        QVector&lt;uint&gt; tableSizes;

        while (true)
        {

            file.getTextStream() &gt;&gt; flag;
            if (file.getTextStream().status() != QTextStream::Ok)
            {
                if (file.getTextStream().atEnd())
                {
                    break;
                }
                throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read the file \'%s\'",fileName.toUtf8().constData());
            }

            if (flag == "!VERSION")
            {
                RFileIO::readAscii(file,fVersion);
            }
            else if (flag == "NAME:")
            {
                RFileIO::readAscii(file,this-&gt;name);
            }
            else if (flag == "NPROP:")
            {
                RFileIO::readAscii(file,nProperties);
            }
            else if (flag == "properties:")
            {
                QString propertyName;
                QString propertyDimension;
                double propertyValue;
                uint propertyNTableValues;
                for (uint i=0;i&lt;nProperties;i++)
                {
                    RFileIO::readAscii(file,propertyName);
                    RFileIO::readAscii(file,propertyValue);
                    RFileIO::readAscii(file,propertyDimension);
                    RFileIO::readAscii(file,propertyNTableValues);

                    tableFlags.push_back(QString(propertyName + "/temperature:").replace(' ','_'));
                    tableSizes.push_back(std::max(propertyNTableValues,uint(0)));

                    RMaterialProperty property;

                    propertyName = propertyName.toLower();
                    if (propertyName == "density")
                    {
                        property.setType(R_MATERIAL_PROPERTY_DENSITY);
                    }
                    else if (propertyName == "dynamic viscosity")
                    {
                        property.setType(R_MATERIAL_PROPERTY_DYNAMIC_VISCOSITY);
                    }
                    else if (propertyName == "electrical conductivity")
                    {
                        property.setType(R_MATERIAL_PROPERTY_ELECTRICAL_CONDUCTIVITY);
                    }
                    else if (propertyName == "emissivity")
                    {
                        property.setType(R_MATERIAL_PROPERTY_EMISSIVITY);
                    }
                    else if (propertyName == "heat capacity")
                    {
                        property.setType(R_MATERIAL_PROPERTY_HEAT_CAPACITY);
                    }
                    else if (propertyName == "modulus of elasticity")
                    {
                        property.setType(R_MATERIAL_PROPERTY_MODULUS_OF_ELASTICITY);
                    }
                    else if (propertyName == "permeability")
                    {
                        property.setType(R_MATERIAL_PROPERTY_PERMEABILITY_TO_FLUIDS);
                    }
                    else if (propertyName == "poissons ratio")
                    {
                        property.setType(R_MATERIAL_PROPERTY_POISSON_RATIO);
                    }
                    else if (propertyName == "relative permittivity")
                    {
                        property.setType(R_MATERIAL_PROPERTY_RELATIVE_PERMITTIVITY);
                    }
                    else if (propertyName == "speed of sound")
                    {
                        property.setType(R_MATERIAL_PROPERTY_SOUND_SPEED);
                    }
                    else if (propertyName == "thermal conductivity")
                    {
                        property.setType(R_MATERIAL_PROPERTY_THERMAL_CONDUCTIVITY);
                    }
                    else if (propertyName == "thermal expansion coefficient")
                    {
                        property.setType(R_MATERIAL_PROPERTY_THERMAL_EXPANSION_COEFFICIENT);
                    }
                    if (propertyNTableValues &lt; 1)
                    {
                        property.add(293.15,propertyValue);
                    }

                    this-&gt;add(property);
                }
            }
            else
            {
                for (int i=0;i&lt;tableFlags.size();i++)
                {
                    if (flag == tableFlags[i])
                    {
                        for (uint j=0;j&lt;tableSizes[i];j++)
                        {
                            double key, value;
                            RFileIO::readAscii(file,key);
                            RFileIO::readAscii(file,value);
                            this-&gt;get(i).add(key,value);
                        }
                    }
                }
            }
        }
    }
    catch (RError &amp;error)
    {
        throw error;
    }
    catch (const std::exception &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "%s", error.what());
    }
    catch (...)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Unknown exception.");
    }
} /* RMaterial::import */


QString RMaterial::findMaterialFileName(bool binary) const
{
    return QString::number(this-&gt;getID()) + QString(".") + RMaterial::getDefaultFileExtension(binary);
} /* RMaterial::findMaterialFileName */


</t>
<t tx="leo.20201108101535.53">bool RMaterial::validForProblemType(RProblemTypeMask problemTypeMask) const
{
    return this-&gt;hasProperties(RMaterialProperty::getTypes(problemTypeMask));
} /* RMaterial::findMaterialFileName */


QString RMaterial::getDefaultFileExtension(bool binary)
{
    if (binary)
    {
        return "rbmt";
    }
    else
    {
        return "ramt";
    }
} /* RMaterial::getDefaultFileExtension */


</t>
<t tx="leo.20201108101535.54">void RMaterial::readAscii(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided");
    }

    RFile materialFile(fileName,RFile::ASCII);

    if (!materialFile.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the material file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileHeader fileHeader;

    RFileIO::readAscii(materialFile,fileHeader);
    if (fileHeader.getType() != R_FILE_TYPE_MATERIAL)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF,"File type of the file \'" + fileName + "\' is not MATERIAL.");
    }

    // Set file version
    materialFile.setVersion(fileHeader.getVersion());

    RFileIO::readAscii(materialFile,*this);

    materialFile.close();
} /* RMaterial::readAscii */


</t>
<t tx="leo.20201108101535.55">void RMaterial::readBinary(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided");
    }

    RFile materialFile(fileName,RFile::BINARY);

    if (!materialFile.open(QIODevice::ReadOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the material file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileHeader fileHeader;

    RFileIO::readBinary(materialFile,fileHeader);
    if (fileHeader.getType() != R_FILE_TYPE_MATERIAL)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF,"Filed type of the file \'" + fileName + "\' is not MATERIAL.");
    }

    // Set file version
    materialFile.setVersion(fileHeader.getVersion());

    RFileIO::readBinary(materialFile,*this);

    materialFile.close();
} /* RMaterial::readBinary */


</t>
<t tx="leo.20201108101535.56">void RMaterial::writeAscii(const QString &amp;fileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RSaveFile materialFile(fileName,RSaveFile::ASCII);

    if (!materialFile.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the material file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileIO::writeAscii(materialFile,RFileHeader(R_FILE_TYPE_MATERIAL,_version));
    RFileIO::writeAscii(materialFile,*this);

    materialFile.commit();
} /* RMaterial::writeAscii */


</t>
<t tx="leo.20201108101535.57">void RMaterial::writeBinary(const QString &amp;fileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RSaveFile materialFile(fileName,RSaveFile::BINARY);

    if (!materialFile.open(QIODevice::WriteOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the material file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileIO::writeBinary(materialFile,RFileHeader(R_FILE_TYPE_MATERIAL,_version));
    RFileIO::writeBinary(materialFile,*this);

    materialFile.commit();
} /* RMaterial::writeBinary */


</t>
<t tx="leo.20201108101535.58">static bool propertyTypeCompareFunc(const RMaterialProperty &amp;p1,const RMaterialProperty &amp;p2)
{
    return (p1.getType()&lt;p2.getType());
}
</t>
<t tx="leo.20201108101535.59">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_material_list.cpp                                    *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: Material list class definition                      *
 *********************************************************************/

#include &lt;sstream&gt;

#include &lt;QDir&gt;
#include &lt;QVector&gt;

#include &lt;rblib.h&gt;

#include "rml_file_manager.h"
#include "rml_material_list.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.6">void RInitialCondition::setTypeSafe (RInitialConditionType type)
{
    this-&gt;type = type;
    this-&gt;name = RInitialCondition::getName (type);
    this-&gt;problemTypeMask = RInitialCondition::getProblemTypeMask (type);
} /* RInitialCondition::setTypeSafe */


RInitialCondition &amp; RInitialCondition::operator =
                                  (const RInitialCondition &amp;condition)
{
    this-&gt;RCondition::operator = (condition);
    this-&gt;_init (&amp;condition);
    return (*this);
} /* RInitialCondition::operator = */


RInitialConditionType RInitialCondition::getTypeFromId(const QString &amp;icId)
{
    for (uint type=uint(R_INITIAL_CONDITION_NONE);type&lt;uint(R_INITIAL_CONDITION_N_TYPES);type++)
    {
        if (initialConditionDesc[type].id == icId)
        {
            return RInitialConditionType(type);
        }
    }

    return R_INITIAL_CONDITION_NONE;
} /* RInitialCondition::getTypeFromId */


QString RInitialCondition::getId(RInitialConditionType type)
{
    R_ERROR_ASSERT (R_INITIAL_CONDITION_TYPE_IS_VALID (type));
    return initialConditionDesc[type].id;
} /* RInitialCondition::getId */


</t>
<t tx="leo.20201108101535.60">void RMaterialList::_init(const RMaterialList *pMaterialList)
{
    if (pMaterialList)
    {
        this-&gt;materials = pMaterialList-&gt;materials;
        this-&gt;storePath = pMaterialList-&gt;storePath;
    }
} /* RMaterialList::_init */


RMaterialList::RMaterialList()
{
    this-&gt;_init();
} /* RMaterialList::RMaterialList */


RMaterialList::RMaterialList(const RMaterialList &amp;materialList)
{
    this-&gt;_init(&amp;materialList);
} /* RMaterialList::RMaterialList (copy) */


RMaterialList::~RMaterialList()
{
} /* RMaterialList::~RMaterialList */


RMaterialList &amp;RMaterialList::operator =(const RMaterialList &amp;materialList)
{
    this-&gt;_init(&amp;materialList);
    return (*this);
} /* RMaterialList::operator = */


</t>
<t tx="leo.20201108101535.61">unsigned int RMaterialList::size(void) const
{
    return (unsigned int)this-&gt;materials.size();
} /* RMaterialList::size */


</t>
<t tx="leo.20201108101535.62">const QString &amp;RMaterialList::getStorePath(void) const
{
    return this-&gt;storePath;
} /* RMaterialList::getStorePath */


</t>
<t tx="leo.20201108101535.63">void RMaterialList::setStorePath(const QString &amp;storePath)
{
    this-&gt;storePath = storePath;
    this-&gt;readStore();
} /* RMaterialList::setStorePath */


</t>
<t tx="leo.20201108101535.64">void RMaterialList::add(RMaterial &amp;material)
{
    if (this-&gt;containName(material.getName()))
    {
        RMaterial oldMaterial = this-&gt;get(material.getName());
        material.setID(oldMaterial.getID());
    }
    else
    {
        if (!this-&gt;validateID(material.getID()))
        {
            material.setID(this-&gt;findAvailableID());
        }
    }

    QString baseName = material.findMaterialFileName(true);
    this-&gt;materials[material.getName()] = baseName;
    QString fileName = RFileManager::buildPath(this-&gt;getStorePath(),baseName);
    try
    {
        material.write(fileName);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to write the material to file \'%s\' with error: %s\n",fileName.toUtf8().constData(),error.getMessage().toUtf8().constData());
    }
} /* RMaterialList::add */


</t>
<t tx="leo.20201108101535.65">unsigned int RMaterialList::remove(const QString &amp;materialName, unsigned int *id)
{
    if (id)
    {
        RMaterial material = this-&gt;get(materialName);
        (*id) = material.getID();
    }

    QString fileName = RFileManager::buildPath(this-&gt;getStorePath(),this-&gt;materials[materialName]);
    try
    {
        RLogger::info("Removing material \'%s\'\n",fileName.toUtf8().constData());
        RFileManager::remove(fileName);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to delete the material file '%s' with error: %s\n",error.getMessage().toUtf8().constData());
    }

    return (unsigned int)this-&gt;materials.erase(materialName);
} /* RMaterialList::remove */


</t>
<t tx="leo.20201108101535.66">bool RMaterialList::rename(const QString &amp;materialOldName, const QString &amp;materialNewName, bool override)
{
    if (materialOldName == materialNewName)
    {
        return false;
    }

    std::map&lt;QString,QString&gt;::const_iterator iter = this-&gt;materials.find(materialNewName);
    if (iter == this-&gt;materials.end() || (iter != this-&gt;materials.end() &amp;&amp; override))
    {
        if (iter != this-&gt;materials.end())
        {
            this-&gt;remove(materialNewName);
        }
        this-&gt;materials[materialNewName] = this-&gt;materials[materialOldName];
        this-&gt;materials.erase(materialOldName);
        RMaterial material = this-&gt;get(materialNewName);
        material.setName(materialNewName);
        QString fileName = RFileManager::buildPath(this-&gt;getStorePath(),this-&gt;materials[materialNewName]);
        try
        {
            RLogger::info("Writing material \'%s\'\n",fileName.toUtf8().constData());
            material.write(fileName);
        }
        catch (const RError &amp;error)
        {
            RLogger::error("Failed to write the material to file \'%s\' with error: %s\n",fileName.toUtf8().constData(),error.getMessage().toUtf8().constData());
        }
        return true;
    }
    return false;
} /* RMaterialList::rename */


RMaterial RMaterialList::get(const QString &amp;materialName)
{
    RMaterial material;

    if (this-&gt;containName(materialName))
    {
        QString fileName = RFileManager::buildPath(this-&gt;getStorePath(),this-&gt;materials[materialName]);
        try
        {
            material.read(fileName);
        }
        catch (const RError &amp;error)
        {
            RLogger::error("Failed to read the material from file \'%s\' with error: %s\n",fileName.toUtf8().constData(),error.getMessage().toUtf8().constData());
            material.setName(materialName);
            try
            {
                material.write(fileName);
            }
            catch (const RError &amp;error)
            {
                RLogger::error("Failed to write the material to file \'%s\' with error: %s\n",fileName.toUtf8().constData(),error.getMessage().toUtf8().constData());
            }
        }
    }
    else
    {
        material.setName(materialName);
        this-&gt;add(material);
    }
    return material;
} /* RMaterialList::get */


</t>
<t tx="leo.20201108101535.67">bool RMaterialList::find(const QString &amp;materialName, RMaterial &amp;material) const
{
    std::map&lt;QString,QString&gt;::const_iterator iter = this-&gt;materials.find(materialName);

    if (iter != this-&gt;materials.end())
    {
        material.read(this-&gt;getStorePath() + iter-&gt;second);
        return true;
    }
    else
    {
        return false;
    }
} /* RMaterialList::find */

QString RMaterialList::getFileName(const QString &amp;materialName) const
{
    std::map&lt;QString,QString&gt;::const_iterator iter = this-&gt;materials.find(materialName);

    if (iter != this-&gt;materials.end())
    {
        return iter-&gt;second;
    }
    else
    {
        return QString();
    }
} /* RMaterialList::getFileName */


</t>
<t tx="leo.20201108101535.68">bool RMaterialList::containName(const QString &amp;materialName) const
{
    if (this-&gt;materials.find(materialName) == this-&gt;materials.end())
    {
        return false;
    }
    else
    {
        return true;
    }
} /* RMaterialList::containName */


std::vector&lt;QString&gt; RMaterialList::getMaterialNames(const std::vector&lt;RMaterialPropertyType&gt; &amp;propertyTypes) const
{
    std::vector&lt;QString&gt; materialNames;
    std::map&lt;QString,QString&gt;::const_iterator iter;

    for (iter=this-&gt;materials.begin();
         iter != this-&gt;materials.end();
         iter++)
    {
        if (propertyTypes.size() == 0)
        {
            materialNames.push_back(iter-&gt;first);
            continue;
        }
        RMaterial material;
        if (this-&gt;find(iter-&gt;first,material))
        {
            if (material.hasProperties(propertyTypes))
            {
                materialNames.push_back(iter-&gt;first);
                continue;
            }
        }
    }

    return materialNames;
} /* RMaterialList::getMaterialNames */


std::vector&lt;RMaterial&gt; RMaterialList::getMaterials(const std::vector&lt;RMaterialPropertyType&gt; &amp;propertyTypes) const
{
    std::vector&lt;QString&gt; materialNames = this-&gt;getMaterialNames(propertyTypes);
    std::vector&lt;RMaterial&gt; materialList;

    for (unsigned int i=0;i&lt;materialNames.size();i++)
    {
        RMaterial material;
        if (this-&gt;find(materialNames[i],material))
        {
            materialList.push_back(material);
        }
    }

    return materialList;
} /* RMaterialList::getMaterials */


QString RMaterialList::findID(unsigned int id) const
{
    std::map&lt;QString,QString&gt;::const_iterator iter;

    for (iter=this-&gt;materials.begin();
         iter != this-&gt;materials.end();
         iter++)
    {
        RMaterial material;
        if (this-&gt;find(iter-&gt;first,material))
        {
            if (material.getID() == id)
            {
                return material.getName();
            }
        }
    }

    return QString();
} /* RMaterialList::find */


</t>
<t tx="leo.20201108101535.69">bool RMaterialList::validateID(unsigned int id) const
{
    if (id == 0)
    {
        return false;
    }
    QString materiaName = this-&gt;findID(id);
    if (materiaName.isEmpty())
    {
        return true;
    }
    else
    {
        return false;
    }
} /* RMaterialList::validateID */


</t>
<t tx="leo.20201108101535.7">const QString &amp;RInitialCondition::getName(RInitialConditionType type)
{
    R_ERROR_ASSERT (R_INITIAL_CONDITION_TYPE_IS_VALID (type));
    return initialConditionDesc[type].name;
} /* RInitialCondition::getName */


RProblemTypeMask RInitialCondition::getProblemTypeMask
                                          (RInitialConditionType type)
{
    R_ERROR_ASSERT (R_INITIAL_CONDITION_TYPE_IS_VALID (type));
    return initialConditionDesc[type].problemTypeMask;
} /* RInitialCondition::getProblemTypeMask */


std::vector&lt;RVariableType&gt; RInitialCondition::getDefaultComponents
                                          (RInitialConditionType type)
{
    std::vector&lt;RVariableType&gt; componentTypes;

    R_ERROR_ASSERT (R_INITIAL_CONDITION_TYPE_IS_VALID (type));

    switch (type)
    {
        case R_INITIAL_CONDITION_NONE:
            break;
        case R_INITIAL_CONDITION_DISPLACEMENT:
            componentTypes.push_back (R_VARIABLE_DISPLACEMENT_X);
            componentTypes.push_back (R_VARIABLE_DISPLACEMENT_Y);
            componentTypes.push_back (R_VARIABLE_DISPLACEMENT_Z);
            break;
        case R_INITIAL_CONDITION_ELECTRIC_POTENTIAL:
            componentTypes.push_back (R_VARIABLE_ELECTRIC_POTENTIAL);
            break;
        case R_INITIAL_CONDITION_PARTICLE_CONCENTRATION:
            componentTypes.push_back (R_VARIABLE_PARTICLE_CONCENTRATION);
            break;
        case R_INITIAL_CONDITION_PRESSURE:
            componentTypes.push_back (R_VARIABLE_PRESSURE);
            break;
        case R_INITIAL_CONDITION_TEMPERATURE:
            componentTypes.push_back (R_VARIABLE_TEMPERATURE);
            break;
        case R_INITIAL_CONDITION_VELOCITY:
            componentTypes.push_back (R_VARIABLE_VELOCITY_X);
            componentTypes.push_back (R_VARIABLE_VELOCITY_Y);
            componentTypes.push_back (R_VARIABLE_VELOCITY_Z);
            break;
        case R_INITIAL_CONDITION_VELOCITY_POTENTIAL:
            componentTypes.push_back (R_VARIABLE_POTENTIAL);
            break;
        case R_INITIAL_CONDITION_WAVE_DISPLACEMENT:
            componentTypes.push_back (R_VARIABLE_WAVE_DISPLACEMENT);
            break;
        case R_INITIAL_CONDITION_CUSTOM:
            break;
        default:
            break;
    }

    return componentTypes;
} /* RInitialCondition::getDefaultComponents */


</t>
<t tx="leo.20201108101535.70">unsigned int RMaterialList::findAvailableID(void) const
{
    unsigned int id = 1;

    while (!this-&gt;validateID(id))
    {
        id++;
    }

    return id;
} /* RMaterialList::findAvailableID */


</t>
<t tx="leo.20201108101535.71">void RMaterialList::readStore(void)
{
    RLogger::info("Reading material store \'%s\'\n",this-&gt;storePath.toUtf8().constData());
    RLogger::indent();

    this-&gt;materials.clear();

    QVector&lt;QString&gt; directoryList;
    QVector&lt;QString&gt; fileList;

    try
    {
        RFileManager::listDirectory(this-&gt;storePath,directoryList,fileList);
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to list directory with error: %s\n", error.getMessage().toUtf8().constData());
        RLogger::unindent();
        return;
    }

    RLogger::info("Found %d files\n",fileList.size());

    for (int i=0;i&lt;fileList.size();i++)
    {
        QString fileName = RFileManager::buildPath(this-&gt;storePath,fileList[i]);
        RMaterial material;
        try
        {
            RLogger::info("Found material file \'%s\'\n",fileName.toUtf8().constData());
            material.read(fileName);
        }
        catch (const RError &amp;error)
        {
            RLogger::error("Failed to read material from file \'%s\' with error: %s\n", fileName.toUtf8().constData(), error.getMessage().toUtf8().constData());
            continue;
        }
        this-&gt;materials[material.getName()] = material.findMaterialFileName(true);
    }

    RLogger::unindent();
} /* RMaterialList::readStore */
</t>
<t tx="leo.20201108101535.72">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_material_property.cpp                                *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Material property class definition                  *
 *********************************************************************/

#include "rml_material_property.h"
#include "rml_problem.h"
#include "rml_variable.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.73">typedef struct _RMaterialPropertyDesc
{
    QString          id;
    RVariableType    variableType;
    RProblemTypeMask problemTypeMask;
} RMaterialPropertyDesc;

</t>
<t tx="leo.20201108101535.74">const RMaterialPropertyDesc materialPropertyDesc [] =
{
    { "prop-none",                          R_VARIABLE_NONE,                          R_PROBLEM_NONE },
    { "prop-density",                       R_VARIABLE_DENSITY,                       R_PROBLEM_ACOUSTICS | R_PROBLEM_FLUID_PARTICLE | R_PROBLEM_ELECTROSTATICS | R_PROBLEM_FLUID | R_PROBLEM_FLUID_HEAT | R_PROBLEM_HEAT | R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL | R_PROBLEM_POTENTIAL | R_PROBLEM_WAVE },
    { "prop-dynamic_viscosity",             R_VARIABLE_DYNAMIC_VISCOSITY,             R_PROBLEM_FLUID | R_PROBLEM_FLUID_HEAT },
    { "prop-electrical_conductivity",       R_VARIABLE_ELECTRICAL_CONDUCTIVITY,       R_PROBLEM_ELECTROSTATICS },
    { "prop-emissivity",                    R_VARIABLE_EMISSIVITY,                    R_PROBLEM_HEAT },
    { "prop-heat_capacity",                 R_VARIABLE_HEAT_CAPACITY,                 R_PROBLEM_HEAT | R_PROBLEM_FLUID_HEAT },
    { "prop-modulus_of_elasticity",         R_VARIABLE_MODULUS_OF_ELASTICITY,         R_PROBLEM_ACOUSTICS | R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "prop-permeability_to_fluids",        R_VARIABLE_PERMEABILITY_TO_FLUIDS,        R_PROBLEM_POTENTIAL },
    { "prop-poisson_ratio",                 R_VARIABLE_POISSON_RATIO,                 R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "prop-relative_permittivity",         R_VARIABLE_RELATIVE_PERMITTIVITY,         R_PROBLEM_ELECTROSTATICS },
    { "prop-soubd_speed",                   R_VARIABLE_SOUND_SPEED,                   R_PROBLEM_NONE },
    { "prop-thermal_conductivity",          R_VARIABLE_THERMAL_CONDUCTIVITY,          R_PROBLEM_HEAT | R_PROBLEM_FLUID_HEAT },
    { "prop-thermal_expansion_coefficient", R_VARIABLE_THERMAL_EXPANSION_COEFFICIENT, R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "prop-custom",                        R_VARIABLE_CUSTOM,                        R_PROBLEM_NONE }
};


</t>
<t tx="leo.20201108101535.75">void RMaterialProperty::_init
                          (const RMaterialProperty *pMaterialProperty)
{
    this-&gt;keyType = R_VARIABLE_TEMPERATURE;
    this-&gt;RValueTable::setKeyName (RVariable::getName (this-&gt;getKeyType()));
    this-&gt;RValueTable::setKeyUnits (RVariable::getUnits (this-&gt;getKeyType()));
    if (pMaterialProperty)
    {
        this-&gt;type = pMaterialProperty-&gt;getType();
        this-&gt;RValueTable::setValueName (RMaterialProperty::getName (this-&gt;type));
        this-&gt;RValueTable::setValueUnits (RMaterialProperty::getUnits (this-&gt;type));
    }
} /* RMaterialProperty::_init */


RMaterialProperty::RMaterialProperty (RMaterialPropertyType type)
{
    this-&gt;_init ();
    this-&gt;setType (type);
} /* RMaterialProperty::RMaterialProperty */


RMaterialProperty::RMaterialProperty
                           (const RMaterialProperty &amp;materialProperty)
                                      : RValueTable (materialProperty)
{
    this-&gt;_init (&amp;materialProperty);
} /* RMaterialProperty::RMaterialProperty (copy) */


RMaterialProperty::~RMaterialProperty ()
{
} /* RMaterialProperty::~RMaterialProperty */


RMaterialProperty &amp; RMaterialProperty::operator =
                           (const RMaterialProperty &amp;materialProperty)
{
    this-&gt;RValueTable::operator = (materialProperty);
    this-&gt;_init (&amp;materialProperty);
    return (*this);
} /* RMaterialProperty::operator = */


</t>
<t tx="leo.20201108101535.76">bool RMaterialProperty::operator ==(const RMaterialProperty &amp;materialProperty) const
{
    if (this-&gt;keyType != materialProperty.keyType)
    {
        return false;
    }
    if (this-&gt;type != materialProperty.type)
    {
        return false;
    }
    if (this-&gt;RValueTable::operator !=(materialProperty))
    {
        return false;
    }
    return true;
} /* RMaterialProperty::operator == */


</t>
<t tx="leo.20201108101535.77">bool RMaterialProperty::operator !=(const RMaterialProperty &amp;materialProperty) const
{
    return !(this-&gt;operator ==(materialProperty));
} /* RMaterialProperty::operator != */


RVariableType RMaterialProperty::getKeyType (void) const
{
    return this-&gt;keyType;
} /* RMaterialProperty::get_key_type */


RMaterialPropertyType RMaterialProperty::getType (void) const
{
    return this-&gt;type;
} /* RMaterialProperty::get_type */


</t>
<t tx="leo.20201108101535.78">void RMaterialProperty::setType (RMaterialPropertyType type)
{
    R_ERROR_ASSERT (R_MATERIAL_PROPERTY_TYPE_IS_VALID(type));

    this-&gt;type = type;
    this-&gt;RValueTable::setValueName (RMaterialProperty::getName (type));
    this-&gt;RValueTable::setValueUnits (RMaterialProperty::getUnits (type));
    this-&gt;clear ();
    this-&gt;add (RVariable::getInitValue (this-&gt;getKeyType()),
               RMaterialProperty::getInitValue (this-&gt;type));
} /* RMaterialProperty::setType */


</t>
<t tx="leo.20201108101535.79">const QString &amp;RMaterialProperty::getName(void) const
{
    return this-&gt;getValueName ();
} /* RMaterialProperty::set_name */


</t>
<t tx="leo.20201108101535.8">void operator ++(RInitialConditionType &amp;type, int increment)
{
    type = (RInitialConditionType)((int)type+increment+1);
} /* operator ++ */
</t>
<t tx="leo.20201108101535.80">void RMaterialProperty::setName (const QString &amp;name)
{
    this-&gt;RValueTable::setValueName (name);
} /* RMaterialProperty::set_name */


</t>
<t tx="leo.20201108101535.81">const QString &amp;RMaterialProperty::getUnits(void) const
{
    return this-&gt;getValueUnits ();
} /* RMaterialProperty::getUnits */


</t>
<t tx="leo.20201108101535.82">void RMaterialProperty::setUnits (const QString &amp;units)
{
    this-&gt;RValueTable::setValueUnits (units);
} /* RMaterialProperty::setUnits */


RMaterialPropertyType RMaterialProperty::getTypeFromId(const QString &amp;materialId)
{
    for (uint type=uint(R_MATERIAL_PROPERTY_NONE);type&lt;uint(R_MATERIAL_PROPERTY_N_TYPES);type++)
    {
        if (materialPropertyDesc[type].id == materialId)
        {
            return RMaterialPropertyType(type);
        }
    }

    return R_MATERIAL_PROPERTY_NONE;
} /* RMaterialProperty::getTypeFromId */


QString RMaterialProperty::getId(RMaterialPropertyType type)
{
    R_ERROR_ASSERT (R_MATERIAL_PROPERTY_TYPE_IS_VALID (type));
    return materialPropertyDesc[type].id;
} /* RMaterialProperty::getId */


</t>
<t tx="leo.20201108101535.83">const QString &amp;RMaterialProperty::getName(RMaterialPropertyType type)
{
    R_ERROR_ASSERT (R_MATERIAL_PROPERTY_TYPE_IS_VALID (type));
    return RVariable::getName(RMaterialProperty::getVariableType(type));
} /* RMaterialProperty::getName */


</t>
<t tx="leo.20201108101535.84">const QString &amp;RMaterialProperty::getUnits(RMaterialPropertyType type)
{
    R_ERROR_ASSERT (R_MATERIAL_PROPERTY_TYPE_IS_VALID (type));
    return RVariable::getUnits(RMaterialProperty::getVariableType(type));
} /* RMaterialProperty::getUnits */


double RMaterialProperty::getInitValue (RMaterialPropertyType type)
{
    R_ERROR_ASSERT (R_MATERIAL_PROPERTY_TYPE_IS_VALID (type));
    return RVariable::getInitValue(RMaterialProperty::getVariableType(type));
} /* RMaterialProperty::getInitValue */


RProblemTypeMask RMaterialProperty::getProblemTypeMask(RMaterialPropertyType type)
{
    R_ERROR_ASSERT (R_MATERIAL_PROPERTY_TYPE_IS_VALID (type));
    return materialPropertyDesc[type].problemTypeMask;
} /* RMaterialProperty::getProblemTypeMask */


std::vector&lt;RMaterialPropertyType&gt; RMaterialProperty::getTypes(RProblemTypeMask problemTypeMask)
{
    R_ERROR_ASSERT (R_PROBLEM_TYPE_MASK_IS_VALID (problemTypeMask));

    std::vector&lt;RProblemType&gt; prbTypes = RProblem::getTypes(problemTypeMask);

    std::vector&lt;bool&gt; bcBook;
    bcBook.resize(R_MATERIAL_PROPERTY_N_TYPES,false);

    for (unsigned int i=0;i&lt;prbTypes.size();i++)
    {
        for (unsigned int j=0;j&lt;bcBook.size();j++)
        {
            if (bcBook[j])
            {
                continue;
            }
            if (RMaterialProperty::getProblemTypeMask(RMaterialPropertyType(j)) &amp; prbTypes[i])
            {
                bcBook[j] = true;
            }
        }
    }

    std::vector&lt;RMaterialPropertyType&gt; propertyTypes;
    for (unsigned int i=0;i&lt;bcBook.size();i++)
    {
        if (bcBook[i])
        {
            propertyTypes.push_back(RMaterialPropertyType(i));
        }
    }

    return propertyTypes;
} /* RMaterialProperty::getTypes */


RVariableType RMaterialProperty::getVariableType(RMaterialPropertyType type)
{
    R_ERROR_ASSERT (R_MATERIAL_PROPERTY_TYPE_IS_VALID (type));
    return materialPropertyDesc[type].variableType;
} /* RMaterialProperty::getVariableType */


</t>
<t tx="leo.20201108101535.85">void operator ++(RMaterialPropertyType &amp;type, int increment)
{
    type = (RMaterialPropertyType)((int)type+increment+1);
} /* operator ++ */
</t>
<t tx="leo.20201108101535.86">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_matrix_solver.cpp                                    *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   16-th August 2012                                        *
 *                                                                   *
 *  DESCRIPTION: Matrix Solver class definition                      *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "rml_matrix_solver_conf.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.87">typedef struct _RMatrixSolverDesc
{
    QString name;
    QString id;
} RMatrixSolverDesc;

</t>
<t tx="leo.20201108101535.88">static RMatrixSolverDesc matrixSolverDesc [] =
{
    { "None", "NONE" },
    { "Conjugate Gradient", "mxs-CG" },
    { "Generalized Minimal Residual", "mxs-GMRES" }
};

</t>
<t tx="leo.20201108101535.89">void RMatrixSolverConf::_init(const RMatrixSolverConf *pMatrixSolver)
{
    if (pMatrixSolver)
    {
        this-&gt;type = pMatrixSolver-&gt;type;
        this-&gt;nInnerIterations = pMatrixSolver-&gt;nInnerIterations;
        this-&gt;nOuterIterations = pMatrixSolver-&gt;nOuterIterations;
        this-&gt;solverCvgValue = pMatrixSolver-&gt;solverCvgValue;
        this-&gt;outputFrequency = pMatrixSolver-&gt;outputFrequency;
        this-&gt;outputFileName = pMatrixSolver-&gt;outputFileName;
    }
}

RMatrixSolverConf::RMatrixSolverConf(RMatrixSolverType type)
    : type(type)
    , nInnerIterations(10)
    , nOuterIterations(1000)
    , solverCvgValue(RConstants::eps)
    , outputFrequency(100)
{
    switch (this-&gt;type)
    {
        case CG:
        {
            nInnerIterations = 10;
            nOuterIterations = 1000;
            break;
        }
        case GMRES:
        {
            nInnerIterations = 10;
            nOuterIterations = 10;
            break;
        }
    }
    this-&gt;_init();
}

RMatrixSolverConf::RMatrixSolverConf(const RMatrixSolverConf &amp;matrixSolver)
{
    this-&gt;_init(&amp;matrixSolver);
}

RMatrixSolverConf::~RMatrixSolverConf()
{
}

RMatrixSolverConf &amp;RMatrixSolverConf::operator =(const RMatrixSolverConf &amp;matrixSolver)
{
    this-&gt;_init(&amp;matrixSolver);
    return (*this);
}

RMatrixSolverType RMatrixSolverConf::getType(void) const
{
    return this-&gt;type;
}

</t>
<t tx="leo.20201108101535.9">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_interpolated_element.cpp                             *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   31-st May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Interpolated element class definition               *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rml_interpolated_element.h"
#include "rml_polygon.h"
#include "rml_triangle.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101535.90">void RMatrixSolverConf::setType(RMatrixSolverType type)
{
    this-&gt;type = type;
}

</t>
<t tx="leo.20201108101535.91">unsigned int RMatrixSolverConf::getNInnerIterations(void) const
{
    return this-&gt;nInnerIterations;
}

</t>
<t tx="leo.20201108101535.92">void RMatrixSolverConf::setNInnerIterations(unsigned int nInnerIterations)
{
    this-&gt;nInnerIterations = nInnerIterations;
}

</t>
<t tx="leo.20201108101535.93">unsigned int RMatrixSolverConf::getNOuterIterations(void) const
{
    return this-&gt;nOuterIterations;
}

</t>
<t tx="leo.20201108101535.94">void RMatrixSolverConf::setNOuterIterations(unsigned int nOuterIterations)
{
    this-&gt;nOuterIterations = nOuterIterations;
}

double RMatrixSolverConf::getSolverCvgValue(void) const
{
    return this-&gt;solverCvgValue;
}

</t>
<t tx="leo.20201108101535.95">void RMatrixSolverConf::setSolverCvgValue(double solverCvgValue)
{
    this-&gt;solverCvgValue = solverCvgValue;
}

</t>
<t tx="leo.20201108101535.96">unsigned int RMatrixSolverConf::getOutputFrequency(void) const
{
    return this-&gt;outputFrequency;
}

</t>
<t tx="leo.20201108101535.97">void RMatrixSolverConf::setOutputFrequency(unsigned int outputFrequency)
{
    this-&gt;outputFrequency = outputFrequency;
}

</t>
<t tx="leo.20201108101535.98">const QString &amp;RMatrixSolverConf::getOutputFileName(void) const
{
    return this-&gt;outputFileName;
}

</t>
<t tx="leo.20201108101535.99">void RMatrixSolverConf::setOutputFileName(const QString &amp;outputFileName)
{
    this-&gt;outputFileName = outputFileName;
}

</t>
<t tx="leo.20201108101536.1">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_mesh_setup.cpp                                       *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th October 2018                                       *
 *                                                                   *
 *  DESCRIPTION: Mesh setup class definition                         *
 *********************************************************************/

#include "rml_mesh_setup.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101536.10">void RModalSetup::setMethod(RModalMethod modalMethod)
{
    this-&gt;method = modalMethod;
}

uint RModalSetup::getNIterations(void) const
{
    return this-&gt;nIterations;
}

</t>
<t tx="leo.20201108101536.100">void RModel::addStreamLine(const RStreamLine &amp;streamLine)
{
    this-&gt;streamLines.push_back(streamLine);
    this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_STREAM_LINE,uint(this-&gt;streamLines.size()-1)));
} /* RModel::addStreamLine */


</t>
<t tx="leo.20201108101536.101">void RModel::setStreamLine(uint position, const RStreamLine &amp;streamLine)
{
    R_ERROR_ASSERT (position &lt; this-&gt;streamLines.size());
    this-&gt;streamLines[position] = streamLine;
} /* RModel::setStreamLine */


</t>
<t tx="leo.20201108101536.102">void RModel::removeStreamLine(uint position)
{
    this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_STREAM_LINE,position));

    std::vector&lt;RStreamLine&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;streamLines.size());

    iter = this-&gt;streamLines.begin();
    std::advance (iter, position);

    this-&gt;streamLines.erase (iter);
} /* RModel::removeStreamLine */


/*********************************************************************
 * Cut interface                                                     *
 *********************************************************************/


uint RModel::getNCuts() const
{
    return uint(this-&gt;cuts.size());
} /* RModel::getNCuts */


</t>
<t tx="leo.20201108101536.103">void RModel::setNCuts(uint nCuts)
{
    uint oldSize=uint(this-&gt;cuts.size());
    this-&gt;cuts.resize(nCuts);
    for (uint i=oldSize;i&lt;nCuts;i++)
    {
        this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_CUT,oldSize));
    }
    for (uint i=nCuts;i&lt;oldSize;i++)
    {
        this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_CUT,nCuts));
    }
} /* RModel::setNCuts */


</t>
<t tx="leo.20201108101536.104">const RCut *RModel::getCutPtr(uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;cuts.size());
    return &amp;this-&gt;cuts[position];
} /* RModel::getCutPtr */


RCut *RModel::getCutPtr(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;cuts.size());
    return &amp;this-&gt;cuts[position];
} /* RModel::getCutPtr */


</t>
<t tx="leo.20201108101536.105">const RCut &amp;RModel::getCut(uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;cuts.size());
    return this-&gt;cuts[position];
} /* RModel::getCut */


RCut &amp;RModel::getCut(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;cuts.size());
    return this-&gt;cuts[position];
} /* RModel::getCut */


</t>
<t tx="leo.20201108101536.106">void RModel::addCut(const RCut &amp;cut)
{
    this-&gt;cuts.push_back(cut);
    this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_CUT,uint(this-&gt;cuts.size()-1)));
} /* RModel::addCut */


</t>
<t tx="leo.20201108101536.107">void RModel::setCut(uint position, const RCut &amp;cut)
{
    R_ERROR_ASSERT (position &lt; this-&gt;cuts.size());

    this-&gt;cuts[position] = cut;
} /* RModel::setCut */


</t>
<t tx="leo.20201108101536.108">void RModel::removeCut(uint position)
{
    this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_CUT,position));

    std::vector&lt;RCut&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;cuts.size());

    iter = this-&gt;cuts.begin();
    std::advance (iter, position);

    this-&gt;cuts.erase (iter);
} /* RModel::removeCut */


/*********************************************************************
 * ISO interface                                                     *
 *********************************************************************/


uint RModel::getNIsos() const
{
    return uint(this-&gt;isos.size());
} /* RModel::getNIsos */


</t>
<t tx="leo.20201108101536.109">void RModel::setNIsos(uint nIsos)
{
    uint oldSize=uint(this-&gt;isos.size());
    this-&gt;isos.resize(nIsos);
    for (uint i=oldSize;i&lt;nIsos;i++)
    {
        this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_ISO,oldSize));
    }
    for (uint i=nIsos;i&lt;oldSize;i++)
    {
        this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_ISO,nIsos));
    }
} /* RModel::setNIsos */


</t>
<t tx="leo.20201108101536.11">void RModalSetup::setNIterations(uint nModalIterations)
{
    this-&gt;nIterations = nModalIterations;
}

uint RModalSetup::getNModesToExtract(void) const
{
    return this-&gt;nModesToExtract;
}

</t>
<t tx="leo.20201108101536.110">const RIso *RModel::getIsoPtr(uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;isos.size());
    return &amp;this-&gt;isos[position];
} /* RModel::getIsoPtr */


RIso *RModel::getIsoPtr(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;isos.size());
    return &amp;this-&gt;isos[position];
} /* RModel::getIsoPtr */


</t>
<t tx="leo.20201108101536.111">const RIso &amp;RModel::getIso(uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;isos.size());
    return this-&gt;isos[position];
} /* RModel::getIso */


RIso &amp;RModel::getIso(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;isos.size());
    return this-&gt;isos[position];
} /* RModel::getIso */


</t>
<t tx="leo.20201108101536.112">void RModel::addIso(const RIso &amp;iso)
{
    this-&gt;isos.push_back(iso);
    this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_ISO,uint(this-&gt;isos.size()-1)));
} /* RModel::addIso */


</t>
<t tx="leo.20201108101536.113">void RModel::setIso(uint position, const RIso &amp;iso)
{
    R_ERROR_ASSERT (position &lt; this-&gt;isos.size());
    this-&gt;isos[position] = iso;
} /* RModel::setIso */


</t>
<t tx="leo.20201108101536.114">void RModel::removeIso(uint position)
{
    this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_ISO,position));

    std::vector&lt;RIso&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;isos.size());

    iter = this-&gt;isos.begin();
    std::advance (iter, position);

    this-&gt;isos.erase (iter);
} /* RModel::removeIso */


</t>
<t tx="leo.20201108101536.115">const RVariable *RModel::findVariableByDisplayType(REntityGroupVariableDisplayTypeMask displayTypeMask, REntityGroupType entityType, uint entityID) const
{
    uint groupID = this-&gt;getEntityGroupID(entityType,entityID);
    if (groupID == RConstants::eod)
    {
        return nullptr;
    }

    const REntityGroup *pEntity = this-&gt;getEntityGroupPtr(groupID);
    if (!pEntity)
    {
        return nullptr;
    }

    RVariableType variableType = pEntity-&gt;getData().findVariableByDisplayType(displayTypeMask);

    uint variablePosition = this-&gt;findVariable(variableType);
    if (variablePosition == RConstants::eod)
    {
        return nullptr;
    }

    return &amp;this-&gt;getVariable(variablePosition);
} /* RModel::findVariableByDisplayType */


std::vector&lt;RRVector&gt; RModel::getElementResultsValues(RVariableType variableType,
                                                      uint elementID) const
{
    uint variablePosition = this-&gt;findVariable(variableType);
    if (variablePosition == RConstants::eod)
    {
        return std::vector&lt;RRVector&gt;();
    }

    std::vector&lt;RRVector&gt; variableVectors;

    const RVariable &amp;rVariable = this-&gt;getVariable(variablePosition);
    if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        variableVectors.push_back(rVariable.getValueVector(elementID));
    }
    else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        const RElement &amp;rElement = this-&gt;getElement(elementID);
        for (uint i=0;i&lt;rElement.size();i++)
        {
            variableVectors.push_back(rVariable.getValueVector(rElement.getNodeId(i)));
        }
    }

    return variableVectors;
} /* RModel::getElementResultsValues */


RRVector RModel::getNodeResultsValues(RVariableType variableType,
                                      uint nodeID) const
{
    uint variablePosition = this-&gt;findVariable(variableType);
    if (variablePosition == RConstants::eod)
    {
        return RRVector();
    }
    const RVariable &amp;rVariable = this-&gt;getVariable(variablePosition);
    if (rVariable.getApplyType() != R_VARIABLE_APPLY_NODE)
    {
        return RRVector();
    }

    return rVariable.getValueVector(nodeID);
} /* RModel::getNodeResultsValues */


std::vector&lt;RRVector&gt; RModel::getInterpolatedElementResultsValues(RVariableType variableType,
                                                                  REntityGroupType entityGroupType,
                                                                  uint entityID,
                                                                  uint elementID) const
{
    uint variablePosition = this-&gt;findVariable(variableType);
    if (variablePosition == RConstants::eod)
    {
        return std::vector&lt;RRVector&gt;();
    }

    const RInterpolatedElement *pIElement = nullptr;
    switch (entityGroupType)
    {
        case R_ENTITY_GROUP_CUT:
        {
            pIElement = &amp;this-&gt;getCut(entityID).at(elementID);
            break;
        }
        case R_ENTITY_GROUP_ISO:
        {
            pIElement = &amp;this-&gt;getIso(entityID).at(elementID);
            break;
        }
        default:
        {
            return std::vector&lt;RRVector&gt;();
        }
    }
    if (!pIElement)
    {
        return std::vector&lt;RRVector&gt;();
    }
    if (pIElement-&gt;size() == 0)
    {
        return std::vector&lt;RRVector&gt;();
    }

    std::vector&lt;RRVector&gt; resultsValues;

    const RVariable &amp;rVariable = this-&gt;getVariable(variablePosition);

    if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        resultsValues.push_back(rVariable.getValueVector(pIElement-&gt;at(0).getElementID()));
    }
    else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        for (uint i=0;i&lt;pIElement-&gt;size();i++)
        {
            resultsValues.push_back(this-&gt;getInterpolatedNodeResultsValues(variableType,entityGroupType,entityID,elementID,i));
        }
    }

    return resultsValues;
} /* RModel::getInterpolatedElementResultsValues */


RRVector RModel::getInterpolatedNodeResultsValues(RVariableType variableType,
                                                  REntityGroupType entityGroupType,
                                                  uint entityID,
                                                  uint elementID,
                                                  uint nodeID) const
{
    uint variablePosition = this-&gt;findVariable(variableType);
    if (variablePosition == RConstants::eod)
    {
        return RRVector();
    }

    const RInterpolatedElement *pIElement = nullptr;
    switch (entityGroupType)
    {
        case R_ENTITY_GROUP_CUT:
        {
            pIElement = &amp;this-&gt;getCut(entityID).at(elementID);
            break;
        }
        case R_ENTITY_GROUP_ISO:
        {
            pIElement = &amp;this-&gt;getIso(entityID).at(elementID);
            break;
        }
        default:
        {
            return RRVector();
        }
    }
    if (!pIElement)
    {
        return RRVector();
    }

    const RInterpolatedNode &amp;rINode = pIElement-&gt;at(nodeID);

    const RVariable &amp;rVariable = this-&gt;getVariable(variablePosition);

    if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        return rVariable.getValueVector(rINode.getElementID());
    }
    else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        const RElement &amp;rElement = this-&gt;getElement(rINode.getElementID());

        RRVector nodeValues;
        nodeValues.resize(rElement.size());

        RRVector resultsValues(rVariable.getNVectors());

        for (uint i=0;i&lt;rVariable.getNVectors();i++)
        {
            for (uint j=0;j&lt;rElement.size();j++)
            {
                nodeValues[j] = rVariable.getValue(i,rElement.getNodeId(j));
            }
            resultsValues[i] = rElement.interpolate(this-&gt;getNodes(),rINode,nodeValues);
        }
        return resultsValues;
    }

    return RRVector();
} /* RModel::getInterpolatedNodeResultsValues */


RRVector RModel::getInterpolatedResultsValues(RVariableType variableType, const RNode &amp;rNode, REntityGroupTypeMask entityGroup) const
{
    uint variablePosition = this-&gt;findVariable(variableType);
    if (variablePosition == RConstants::eod)
    {
        return RRVector();
    }

    RRVector volumes;

    // Find element containing given position.
    uint elementPos = RConstants::eod;
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(i);
        if (RElementGroup::getGroupType(rElement.getType()) &amp; entityGroup)
        {
            if (rElement.isInside(this-&gt;getNodes(),rNode,volumes))
            {
                elementPos = i;
                break;
            }
        }
    }
    if (elementPos == RConstants::eod)
    {
        return RRVector();
    }

    const RVariable &amp;rVariable = this-&gt;getVariable(variablePosition);

    if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
    {
        return rVariable.getValueVector(elementPos);
    }
    else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
    {
        const RElement &amp;rElement = this-&gt;getElement(elementPos);
        RRVector nodeValues(rElement.size());

        RRVector resultsValues(rVariable.getNVectors());

        for (uint i=0;i&lt;rVariable.getNVectors();i++)
        {
            for (uint j=0;j&lt;rElement.size();j++)
            {
                nodeValues[j] = rVariable.getValue(i,rElement.getNodeId(j));
            }
            resultsValues[i] = rElement.interpolate(this-&gt;getNodes(),rNode,nodeValues,volumes);
        }
        return resultsValues;
    }

    return RRVector();
} /* RModel::getInterpolatedResultsValues */


/*************************************************************
 * Geometry transformation                                   *
 *************************************************************/


</t>
<t tx="leo.20201108101536.116">void RModel::rotateGeometry(const QSet&lt;uint&gt; &amp;nodeIDs, const RR3Vector &amp;rotationVector, const RR3Vector &amp;rotationCenter)
{
    RLogger::info("Rotate\n");
    RLogger::info("  Vector: %s\n",rotationVector.toString(true).toUtf8().constData());
    RLogger::info("  Center: %s\n",rotationCenter.toString(true).toUtf8().constData());

    RR3Vector t(-rotationCenter[0],-rotationCenter[1],-rotationCenter[2]);

    double rx = R_DEG_TO_RAD(rotationVector[0]);
    double ry = R_DEG_TO_RAD(rotationVector[1]);
    double rz = R_DEG_TO_RAD(rotationVector[2]);

    RRMatrix R = RRMatrix::generateRotationMatrix(rx,ry,rz);

    foreach (uint i, nodeIDs)
    {
        this-&gt;getNode(i).transform(R,t,true);
        this-&gt;getNode(i).translate(rotationCenter);
    }
} /* RModel::rotateGeometry */


</t>
<t tx="leo.20201108101536.117">void RModel::scaleGeometry(const QSet&lt;uint&gt; &amp;nodeIDs, const RR3Vector &amp;scaleVector, const RR3Vector &amp;scaleCenter)
{
    RLogger::info("Scale\n");
    RLogger::info("  Vector: %s\n",scaleVector.toString(true).toUtf8().constData());
    RLogger::info("  Center: %s\n",scaleCenter.toString(true).toUtf8().constData());

    foreach (uint i, nodeIDs)
    {
        this-&gt;getNode(i).translate(scaleCenter.getOpposite());
        this-&gt;getNode(i).scale(scaleVector);
        this-&gt;getNode(i).translate(scaleCenter);
    }
} /* RModel::scaleGeometry */


</t>
<t tx="leo.20201108101536.118">void RModel::scaleGeometry(double scaleFactor)
{
    RLogger::info("Scale\n");
    RLogger::info("  Factor: %g\n",scaleFactor);

    for (uint i=0;i&lt;this-&gt;nodes.size();i++)
    {
        this-&gt;nodes[i].scale(scaleFactor);
    }
} /* RModel::scaleGeometry */


</t>
<t tx="leo.20201108101536.119">void RModel::translateGeometry(const QSet&lt;uint&gt; &amp;nodeIDs, const RR3Vector &amp;translateVector)
{
    RLogger::info("Translate\n");
    RLogger::info("  Vector: %s\n",translateVector.toString(true).toUtf8().constData());
    foreach (uint i, nodeIDs)
    {
        this-&gt;getNode(i).translate(translateVector);
    }
} /* RModel::translateGeometry */


/*************************************************************
 * Other methods                                             *
 *************************************************************/


RModelProblemTypeMask RModel::checkMesh(bool printOutput) const
{
    RModelProblemTypeMask problemType = R_MODEL_PROBLEM_NONE;

    // Points
    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        const RPoint &amp;rPoint = this-&gt;getPoint(i);
        for (uint j=0;j&lt;rPoint.size();j++)
        {
            uint elementID = rPoint.get(j);
            RElementType elementType = this-&gt;getElement(elementID).getType();
            if (!R_ELEMENT_TYPE_IS_POINT(elementType))
            {
                problemType |= R_MODEL_PROBLEM_INVALID_ELEMENT_TYPE;
                if (printOutput)
                {
                    RLogger::warning("Point element #%u (%u nodes) has an invalid type %d (%s)\n",elementID,this-&gt;getElement(elementID).size(),int(elementType),RElement::getName(elementType).toUtf8().constData());
                }
            }
        }
    }

    // Lines
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        const RLine &amp;rLine = this-&gt;getLine(i);
        for (uint j=0;j&lt;rLine.size();j++)
        {
            uint elementID = rLine.get(j);
            RElementType elementType = this-&gt;getElement(elementID).getType();
            if (!R_ELEMENT_TYPE_IS_LINE(elementType))
            {
                problemType |= R_MODEL_PROBLEM_INVALID_ELEMENT_TYPE;
                if (printOutput)
                {
                    RLogger::warning("Line element #%u (%u nodes) has an invalid type %d (%s)\n",elementID,this-&gt;getElement(elementID).size(),int(elementType),RElement::getName(elementType).toUtf8().constData());
                }
            }
        }
    }

    // Surfaces
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        const RSurface &amp;rSurface = this-&gt;getSurface(i);
        for (uint j=0;j&lt;rSurface.size();j++)
        {
            uint elementID = rSurface.get(j);
            RElementType elementType = this-&gt;getElement(elementID).getType();
            if (!R_ELEMENT_TYPE_IS_SURFACE(elementType))
            {
                problemType |= R_MODEL_PROBLEM_INVALID_ELEMENT_TYPE;
                if (printOutput)
                {
                    RLogger::warning("Surface element #%u (%u nodes) has an invalid type %d (%s)\n",elementID,this-&gt;getElement(elementID).size(),int(elementType),RElement::getName(elementType).toUtf8().constData());
                }
            }
        }
    }

    // Volumes
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        const RVolume &amp;rVolume = this-&gt;getVolume(i);
        for (uint j=0;j&lt;rVolume.size();j++)
        {
            uint elementID = rVolume.get(j);
            RElementType elementType = this-&gt;getElement(elementID).getType();
            if (!R_ELEMENT_TYPE_IS_VOLUME(elementType))
            {
                problemType |= R_MODEL_PROBLEM_INVALID_ELEMENT_TYPE;
                if (printOutput)
                {
                    RLogger::warning("Volume element #%u (%u nodes) has an invalid type %d (%s)\n",elementID,this-&gt;getElement(elementID).size(),int(elementType),RElement::getName(elementType).toUtf8().constData());
                }
            }
        }
    }

    // Check element neighbors.
#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(this-&gt;getNElements());i++)
    {
        const std::vector&lt;uint&gt; *pNeighbors = this-&gt;getNeighborIDs(uint(i));
        if (!pNeighbors)
        {
            continue;
        }
        for (uint j=0;j&lt;pNeighbors-&gt;size();j++)
        {
            if (RElementGroup::getGroupType(this-&gt;getElement(uint(i)).getType())
                ==
                RElementGroup::getGroupType(this-&gt;getElement(pNeighbors-&gt;at(j)).getType()))
            {
                // TODO: Cross check for element neighbors.
            }
            else
            {
                problemType |= R_MODEL_PROBLEM_INVALID_NEIGHBORS;
                if (printOutput)
                {
                    RLogger::warning("Two neighboring elements %u and %u have incompatible types %d (%s) / %d (%s)\n",
                                     i,
                                     pNeighbors-&gt;at(j),
                                     int(this-&gt;getElement(uint(i)).getType()),
                                     RElement::getName(this-&gt;getElement(uint(i)).getType()).toUtf8().constData(),
                                     int(this-&gt;getElement(pNeighbors-&gt;at(j)).getType()),
                                     RElement::getName(this-&gt;getElement(pNeighbors-&gt;at(j)).getType()).toUtf8().constData());
                }
            }
        }
    }

    return problemType;
} /* RModel::checkMesh */


QVector&lt;bool&gt; RModel::findEdgeNodes() const
{
    RLogger::info("Finding edge nodes\n");
    RLogger::indent();
    RProgressInitialize("Finding edge nodes");

    QVector&lt;bool&gt; edgeNodes;

    QVector&lt;uint&gt; nodeCount;
    QVector&lt;uint&gt; nodeGroup;

    edgeNodes.resize(int(this-&gt;getNNodes()));
    edgeNodes.fill(true);
    nodeCount.resize(int(this-&gt;getNNodes()));
    nodeCount.fill(0);
    nodeGroup.resize(int(this-&gt;getNNodes()));
    nodeGroup.fill(0);

    uint nodeGroupCounter = 1;

    uint nNodeGroupCounter = this-&gt;getNPoints()
                                   + this-&gt;getNLines()
                                   + this-&gt;getNSurfaces()
                                   + this-&gt;getNVolumes();

    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        RProgressPrint(nodeGroupCounter,nNodeGroupCounter);
        const RPoint &amp;point = this-&gt;getPoint(i);
        for (uint j=0;j&lt;point.size();j++)
        {
            const RElement &amp;element = this-&gt;getElement(point.get(j));
            for (uint k=0;k&lt;element.size();k++)
            {
                int nodeID = int(element.getNodeId(k));
                if (nodeGroup[nodeID] != nodeGroupCounter)
                {
                    nodeGroup[nodeID] = nodeGroupCounter;
                    nodeCount[nodeID]++;
                }
            }
        }
        nodeGroupCounter++;
    }

    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        RProgressPrint(nodeGroupCounter,nNodeGroupCounter);
        const RLine &amp;line = this-&gt;getLine(i);
        for (uint j=0;j&lt;line.size();j++)
        {
            const RElement &amp;element = this-&gt;getElement(line.get(j));
            for (uint k=0;k&lt;element.size();k++)
            {
                int nodeID = int(element.getNodeId(k));
                if (nodeGroup[nodeID] != nodeGroupCounter)
                {
                    nodeGroup[nodeID] = nodeGroupCounter;
                    nodeCount[nodeID]++;
                }
            }
        }
        nodeGroupCounter++;
    }

    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        RProgressPrint(nodeGroupCounter,nNodeGroupCounter);
        const RSurface &amp;surface = this-&gt;getSurface(i);
        for (uint j=0;j&lt;surface.size();j++)
        {
            const RElement &amp;element = this-&gt;getElement(surface.get(j));
            for (uint k=0;k&lt;element.size();k++)
            {
                int nodeID = int(element.getNodeId(k));
                if (nodeGroup[nodeID] != nodeGroupCounter)
                {
                    nodeGroup[nodeID] = nodeGroupCounter;
                    nodeCount[nodeID]++;
                }
            }
        }
        nodeGroupCounter++;
    }

    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        RProgressPrint(nodeGroupCounter,nNodeGroupCounter);
        const RVolume &amp;volume = this-&gt;getVolume(i);
        for (uint j=0;j&lt;volume.size();j++)
        {
            const RElement &amp;element = this-&gt;getElement(volume.get(j));
            for (uint k=0;k&lt;element.size();k++)
            {
                int nodeID = int(element.getNodeId(k));
                if (nodeGroup[nodeID] != nodeGroupCounter)
                {
                    nodeGroup[nodeID] = nodeGroupCounter;
                    nodeCount[nodeID]++;
                }
            }
        }
        nodeGroupCounter++;
    }

    for (uint i=0;i&lt;this-&gt;getNNodes();i++)
    {
        edgeNodes[int(i)] = (nodeCount[int(i)] &gt; 1);
    }

    // Add to edge nodes element nodes which neighbor count is less than expected.
    if (this-&gt;surfaceNeigs.size() == this-&gt;getNElements())
    {
        for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
        {
            const RSurface &amp;rSurface = this-&gt;getSurface(i);
            for (uint j=0;j&lt;rSurface.size();j++)
            {
                uint elementID = rSurface.get(j);
                const RElement &amp;rElement = this-&gt;getElement(elementID);
                if (rElement.getNNeighbors(rElement.getType()) != this-&gt;surfaceNeigs[elementID].size())
                {
                    for (uint k=0;k&lt;rElement.size();k++)
                    {
                        edgeNodes[int(rElement.getNodeId(k))] = true;
                    }
                }
            }
        }
    }
    if (this-&gt;volumeNeigs.size() == this-&gt;getNElements())
    {
        for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
        {
            const RVolume &amp;rVolume = this-&gt;getVolume(i);
            for (uint j=0;j&lt;rVolume.size();j++)
            {
                uint elementID = rVolume.get(j);
                const RElement &amp;rElement = this-&gt;getElement(elementID);
                uint nEdges = rElement.getNEdgeElements();
                RBVector edgeBook(nEdges,false);
                for (uint k=0;k&lt;this-&gt;volumeNeigs[elementID].size();k++)
                {
                    uint edgePosition = rElement.findEdgePositionForNeighborElement(this-&gt;getElement(this-&gt;volumeNeigs[elementID][k]));
                    if (edgePosition != RConstants::eod)
                    {
                        edgeBook[edgePosition] = true;
                    }
                }
                for (uint k=0;k&lt;edgeBook.size();k++)
                {
                    if (edgeBook[k])
                    {
                        continue;
                    }
                    for (uint l=0;l&lt;rElement.size();l++)
                    {
                        if (rElement.nodeIsOnEdge(l,k))
                        {
                            edgeNodes[int(rElement.getNodeId(l))] = true;
                        }
                    }
                }
            }
        }
    }

    RProgressFinalize();
    RLogger::unindent();

    return edgeNodes;
} /* RModel::findEdgeNodes */


struct LineElementItem
{
    uint id;
    uint n1;
    uint n2;
};


QList&lt;uint&gt; RModel::sortLineElements(const QList&lt;RElement&gt; &amp;edges, uint firstID) const
{
    if (edges.size() == 0)
    {
        return QList&lt;uint&gt;();
    }

    QList&lt;LineElementItem&gt; items;

    QList&lt;RElement&gt; sortedEdges(edges);
    for (int i=0;i&lt;sortedEdges.size();i++)
    {
        uint n1 = sortedEdges[i].getNodeId(0);
        uint n2 = sortedEdges[i].getNodeId(1);
        LineElementItem item;
        item.id = uint(i);
        item.n1 = RConstants::eod;
        item.n2 = RConstants::eod;
        for (int j=0;j&lt;sortedEdges.size();j++)
        {
            if (i == j)
            {
                continue;
            }
            if (n1 == sortedEdges[j].getNodeId(0) || n2 == sortedEdges[j].getNodeId(1))
            {
                sortedEdges[j].swapNodeIds(0,1);
            }
            if (n1 == sortedEdges[j].getNodeId(1))
            {
                item.n1 = uint(j);
            }
            if (n2 == sortedEdges[j].getNodeId(0))
            {
                item.n2 = uint(j);
            }
            if (item.n1 != RConstants::eod &amp;&amp; item.n2 != RConstants::eod)
            {
                break;
            }
        }
        items.append(item);
    }

    // Find first node.
    uint firstItemID = 0;
    if (firstID != RConstants::eod)
    {
        firstItemID = firstID;
    }
    else
    {
        for (int i=0;i&lt;items.size();i++)
        {
            if (items[i].n1 == RConstants::eod)
            {
                firstItemID = uint(i);
                break;
            }
        }
    }

    QList&lt;uint&gt; elementIDs;

    uint n = firstItemID;

    while (n != RConstants::eod)
    {
        elementIDs.append(items[int(n)].id);
        uint next = items[int(n)].n2;
        items[int(n)].n2 = RConstants::eod;
        n = next;
    }
    if (elementIDs.last() == elementIDs.first())
    {
        elementIDs.erase(elementIDs.end()-1);
    }

    return elementIDs;
} /* RModel::sortLineElements */


QList&lt;uint&gt; RModel::findNodeEdgeRing(uint nodeID) const
{
    std::vector&lt;uint&gt; elementPositions = this-&gt;findElementPositionsByNodeId(nodeID);

    QList&lt;RElement&gt; edges;
    for (std::vector&lt;uint&gt;::reverse_iterator rIterEps = elementPositions.rbegin(); rIterEps != elementPositions.rend(); ++rIterEps)
    {
        std::vector&lt;RElement&gt; edgeElements = this-&gt;getElement(*rIterEps).generateEdgeElements();
        for (uint i=0;i&lt;edgeElements.size();i++)
        {
            if (edgeElements[i].hasNodeId(nodeID) || !R_ELEMENT_TYPE_IS_LINE(edgeElements[i].getType()))
            {
                continue;
            }
            edges.append(edgeElements[i]);
        }
    }

    QList&lt;uint&gt; elementIDs = this-&gt;sortLineElements(edges);

    QList&lt;uint&gt; nodeIDs;
    nodeIDs.reserve(elementIDs.size());

    for (int i=0;i&lt;elementIDs.size();i++)
    {
        nodeIDs.append(edges[int(elementIDs[i])].getNodeId(0));
    }

    return nodeIDs;
} /* RModel::findNodeEdgeRing */


double RModel::findMinimumNodeDistance() const
{
    double minDistance = 0.0;
    bool first = true;

    for (uint i=0;i&lt;this-&gt;getNNodes()-1;i++)
    {
        for (uint j=i+1;j&lt;this-&gt;getNNodes();j++)
        {
            double distance = this-&gt;getNode(i).getDistance(this-&gt;getNode(j));
            if (first)
            {
                minDistance = distance;
                first = false;
            }
            else
            {
                minDistance = std::min(minDistance,distance);
            }
        }
    }

    return minDistance;
} /* RModel::findShortestEdgeLength */


</t>
<t tx="leo.20201108101536.12">void RModalSetup::setNModesToExtract(uint nModesToExtract)
{
    this-&gt;nModesToExtract = nModesToExtract;
}

double RModalSetup::getConvergenceValue(void) const
{
    return convergenceValue;
}

</t>
<t tx="leo.20201108101536.120">void RModel::createCut(RCut &amp;rCut) const
{
    std::vector&lt;uint&gt; elementIDs;

    const std::vector&lt;uint&gt; &amp;elementGroupIDs = rCut.getElementGroupIDs();
    for (uint i=0;i&lt;elementGroupIDs.size();i++)
    {
        const RElementGroup *pGrp = this-&gt;getElementGroupPtr(elementGroupIDs[i]);
        if (pGrp)
        {
            for (uint j=0;j&lt;pGrp-&gt;size();j++)
            {
                elementIDs.push_back(pGrp-&gt;get(j));
            }
        }
    }

    rCut.clear();

#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(elementIDs.size());i++)
    {
        const RElement &amp;element = this-&gt;getElement(elementIDs[uint(i)]);

        RInterpolatedElement iElement = element.createInterpolatedElement(rCut.getPlane(),this-&gt;getNodes(),elementIDs[uint(i)]);
        if (iElement.size() &gt; 0)
        {
#pragma omp critical
            {
                rCut.push_back(iElement);
            }
        }
    }
} /* RModel::createCut */


</t>
<t tx="leo.20201108101536.121">void RModel::createIso(RIso &amp;rIso) const
{
    std::vector&lt;uint&gt; elementIDs;

    const std::vector&lt;uint&gt; &amp;elementGroupIDs = rIso.getElementGroupIDs();
    for (uint i=0;i&lt;elementGroupIDs.size();i++)
    {
        const RElementGroup *pGrp = this-&gt;getElementGroupPtr(elementGroupIDs[i]);
        if (pGrp)
        {
            for (uint j=0;j&lt;pGrp-&gt;size();j++)
            {
                elementIDs.push_back(pGrp-&gt;get(j));
            }
        }
    }

    rIso.clear();

    uint variablePosition = this-&gt;findVariable(rIso.getVariableType());
    if (variablePosition == RConstants::eod)
    {
        return;
    }

    const RVariable &amp;rVariable = this-&gt;getVariable(variablePosition);

#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(elementIDs.size());i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(elementIDs[uint(i)]);
        std::vector&lt;double&gt; nodeValues;
        nodeValues.resize(rElement.size(),0.0);
        for (uint j=0;j&lt;rElement.size();j++)
        {
            if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
            {
                nodeValues[j] = rVariable.getValue(rElement.getNodeId(j));
            }
            else if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
            {
                nodeValues[j] = rVariable.getValue(elementIDs[uint(i)]);
            }
        }

        RInterpolatedElement iElement = rElement.createInterpolatedElement(rIso.getVariableValue(),nodeValues,this-&gt;getNodes(),elementIDs[uint(i)]);
        if (iElement.size() &gt; 0)
        {
#pragma omp critical
            {
                rIso.push_back(iElement);
            }
        }
    }
} /* RModel::createIso */


</t>
<t tx="leo.20201108101536.122">void RModel::createStreamLine(RStreamLine &amp;rStreamLine) const
{
    rStreamLine.clear();

    uint variablePosition = this-&gt;findVariable(rStreamLine.getVariableType());
    if (variablePosition == RConstants::eod)
    {
        return;
    }
    const RVariable &amp;rVariable = this-&gt;getVariable(variablePosition);

    RNode startNode(rStreamLine.getPosition());

    // Find starting element.
    uint pointElementID = RConstants::eod;
    uint lineElementID = RConstants::eod;
    uint surfaceElementID = RConstants::eod;
    uint volumeElementID = RConstants::eod;

#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(this-&gt;getNElements());i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(uint(i));

        if (R_ELEMENT_TYPE_IS_POINT(rElement.getType()) &amp;&amp; pointElementID == RConstants::eod)
        {
            if (rElement.isInside(this-&gt;getNodes(),startNode))
            {
#pragma omp critical
                {
                    pointElementID = uint(i);
                }
            }
        }
        if (R_ELEMENT_TYPE_IS_LINE(rElement.getType()) &amp;&amp; lineElementID == RConstants::eod)
        {
            if (rElement.isInside(this-&gt;getNodes(),startNode))
            {
#pragma omp critical
                {
                    lineElementID = uint(i);
                }
            }
        }
        if (R_ELEMENT_TYPE_IS_SURFACE(rElement.getType()) &amp;&amp; surfaceElementID == RConstants::eod)
        {
            if (rElement.isInside(this-&gt;getNodes(),startNode))
            {
#pragma omp critical
                {
                    surfaceElementID = uint(i);
                }
            }
        }
        if (R_ELEMENT_TYPE_IS_VOLUME(rElement.getType()) &amp;&amp; volumeElementID == RConstants::eod)
        {
            if (rElement.isInside(this-&gt;getNodes(),startNode))
            {
#pragma omp critical
                {
                    volumeElementID = uint(i);
                }
            }
        }
    }

    uint elementID = RConstants::eod;

    elementID = (pointElementID != RConstants::eod) ? pointElementID : elementID;
    elementID = (lineElementID != RConstants::eod) ? lineElementID : elementID;
    elementID = (surfaceElementID != RConstants::eod) ? surfaceElementID : elementID;
    elementID = (volumeElementID != RConstants::eod) ? volumeElementID : elementID;

    if (elementID == RConstants::eod)
    {
        RLogger::warning("Could not find start of the stream line \'%s\'\n",this-&gt;getName().toUtf8().constData());
        return;
    }

    RR3Vector vectorStart(startNode.toVector());
    RR3Vector vectorStartNext;

    // Find variable vector
    RR3Vector oldVariableVector(0.0,0.0,0.0);
    bool firstTime = true;

    while (elementID != RConstants::eod)
    {
        const RElement &amp;rElement = this-&gt;getElement(elementID);

        // Find variable vector
        RR3Vector variableVector(0.0,0.0,0.0);
        if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            if (rVariable.getNVectors() &gt; 0)
            {
                variableVector[0] = rVariable.getValue(0,elementID);
            }
            if (rVariable.getNVectors() &gt; 1)
            {
                variableVector[1] = rVariable.getValue(1,elementID);
            }
            if (rVariable.getNVectors() &gt; 2)
            {
                variableVector[2] = rVariable.getValue(2,elementID);
            }
        }
        else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            std::vector&lt;double&gt; nodeValues;
            nodeValues.resize(rElement.size(),0);

            for (uint i=0;i&lt;rVariable.getNVectors() &amp;&amp; i&lt;3;i++)
            {
                for (uint j=0;j&lt;rElement.size();j++)
                {
                    nodeValues[j] = rVariable.getValue(i,rElement.getNodeId(j));
                }
                variableVector[i] = rElement.interpolate(this-&gt;getNodes(),RNode(vectorStart),nodeValues);
            }
        }
        variableVector.normalize();

        // Find intersected element side/face
        uint intersectedSide = rElement.findIntersectedSide(this-&gt;getNodes(),
                                                            vectorStart,
                                                            variableVector,
                                                            vectorStartNext);

        if (intersectedSide == RConstants::eod)
        {
            if (!firstTime)
            {
                // It could be that the vector is pointing back into the current element.
                // Therefore this vector is replaced with the previous one to push it forward.
                variableVector = oldVariableVector;
                @others
} /* RModel::createStreamLine */


</t>
<t tx="leo.20201108101536.123">            intersectedSide = rElement.findIntersectedSide(this-&gt;getNodes(),
                                                           vectorStart,
                                                           variableVector,
                                                           vectorStartNext);
        }
        if (intersectedSide == RConstants::eod)
        {
            break;
        }
    }

    RInterpolatedElement iElement;
    iElement.push_back(RInterpolatedNode(elementID,vectorStart));
    iElement.push_back(RInterpolatedNode(elementID,vectorStartNext));
    if (iElement.size() &gt; 0)
    {
        rStreamLine.push_back(iElement);
    }

    elementID = this-&gt;getNeighbor(elementID,intersectedSide);

    vectorStart = vectorStartNext;
    oldVariableVector = variableVector;

    firstTime = false;
}
</t>
<t tx="leo.20201108101536.124">void RModel::createDependentEntities()
{
    for (uint i=0;i&lt;this-&gt;getNCuts();i++)
    {
        this-&gt;createCut(this-&gt;getCut(i));
    }
    for (uint i=0;i&lt;this-&gt;getNIsos();i++)
    {
        this-&gt;createIso(this-&gt;getIso(i));
    }
    for (uint i=0;i&lt;this-&gt;getNStreamLines();i++)
    {
        this-&gt;createStreamLine(this-&gt;getStreamLine(i));
    }
} /* RModel::createDependentEntities */


uint RModel::getNeighbor(uint elementID, uint neighborPosition) const
{
    const std::vector&lt;uint&gt; *pNeighbors = this-&gt;getNeighborIDs(elementID);

    if (!pNeighbors)
    {
        return RConstants::eod;
    }

    for (uint i=0;i&lt;pNeighbors-&gt;size();i++)
    {
        uint neighborID = pNeighbors-&gt;at(i);

        if (this-&gt;getElement(elementID).findEdgePositionForNeighborElement(this-&gt;getElement(neighborID)) == neighborPosition)
        {
            return neighborID;
        }
    }

    return RConstants::eod;
} /* RModel::getNeighbor */


</t>
<t tx="leo.20201108101536.125">const std::vector&lt;uint&gt; *RModel::getNeighborIDs(uint elementID) const
{
    switch (this-&gt;getElement(elementID).getType())
    {
        case R_ELEMENT_TRI1:
        case R_ELEMENT_TRI2:
        case R_ELEMENT_QUAD1:
        case R_ELEMENT_QUAD2:
        {
            if (this-&gt;surfaceNeigs.size() != this-&gt;getNElements())
            {
                return nullptr;
            }
            return &amp;this-&gt;surfaceNeigs[elementID];
        }
        case R_ELEMENT_TETRA1:
        {
            if (this-&gt;volumeNeigs.size() != this-&gt;getNElements())
            {
                return nullptr;
            }
            return &amp;this-&gt;volumeNeigs[elementID];
        }
        default:
        {
            return nullptr;
        }
    }
} /* RModel::getNeighborIDs */


</t>
<t tx="leo.20201108101536.126">void RModel::setSurfaceNeighbors(const std::vector&lt;RUVector&gt; &amp;surfaceNeigs)
{
    R_ERROR_ASSERT (surfaceNeigs.size() == this-&gt;getNElements());
    this-&gt;surfaceNeigs = surfaceNeigs;
} /* RModel::setSurfaceNeighbors */


</t>
<t tx="leo.20201108101536.127">void RModel::setVolumeNeighbors(const std::vector&lt;RUVector&gt; &amp;volumeNeigs)
{
    R_ERROR_ASSERT (volumeNeigs.size() == this-&gt;getNElements());
    this-&gt;volumeNeigs = volumeNeigs;
} /* RModel::setVolumeNeighbors */


</t>
<t tx="leo.20201108101536.128">void RModel::clearSurfaceNeighbors()
{
    this-&gt;surfaceNeigs.clear();
} /* RModel::clearSurfaceNeighbors */


</t>
<t tx="leo.20201108101536.129">void RModel::clearVolumeNeighbors()
{
    this-&gt;volumeNeigs.clear();
} /* RModel::clearVolumeNeighbors */


uint RModel::fixSliverElements(double edgeRatio)
{
    RLogger::info("Fixing sliver elements\n");
    RLogger::indent();
    RLogger::info("Edge (aspect) ratio limit = %g\n",edgeRatio);

    uint nAffected = 0;

    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(i);
        double lMax = 0.0;
        double lMin = 0.0;
        bool firstTime = true;
        uint n1 = RConstants::eod;
        uint n2 = RConstants::eod;
        for (uint j=0;j&lt;rElement.size();j++)
        {
            for (uint k=j+1;k&lt;rElement.size();k++)
            {
                double distance = this-&gt;nodes[rElement.getNodeId(j)].getDistance(this-&gt;nodes[rElement.getNodeId(k)]);
                if (firstTime)
                {
                    lMax = lMin = distance;
                    n1 = rElement.getNodeId(j);
                    n2 = rElement.getNodeId(k);
                    firstTime = false;
                }
                else
                {
                    lMax = std::max(lMax,distance);
                    if (lMin &gt; distance)
                    {
                        lMin = distance;
                        n1 = rElement.getNodeId(j);
                        n2 = rElement.getNodeId(k);
                    }
                }
            }
        }

        if (n1 == RConstants::eod || n2 == RConstants::eod || n1 == n2)
        {
            continue;
        }

        if (lMin &lt;= RConstants::eps || (lMax/lMin) &gt;= edgeRatio)
        {
            try
            {
                this-&gt;mergeNodes(n1,n2,true,true);
            }
            catch (const RError &amp;rError)
            {
                RLogger::unindent();
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to merge nodes %u and %u. %s",n1,n2,rError.getMessage().toUtf8().constData());
            }

            nAffected++;
        }
    }

    this-&gt;fixElementGroupRelations();

    RLogger::unindent();
    return nAffected;
} /* RModel::fixSliverElements */


uint RModel::fixElementGroupRelations()
{
    RLogger::info("Moving elements to apropriate groups.\n");
    RLogger::indent();

    RPoint pointGroup;
    RLine lineGroup;
    RSurface surfaceGroup;

    pointGroup.setName("Downgraded");
    lineGroup.setName("Downgraded");
    surfaceGroup.setName("Downgraded");

    uint nAffected = 0;

    // Move elements to appropriate groups.
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        RLine &amp;rLine = this-&gt;getLine(i);
        for (uint j=0;j&lt;rLine.size();j++)
        {
            uint elementID = rLine.get(j);
            if (R_ELEMENT_TYPE_IS_POINT(this-&gt;getElement(elementID).getType()))
            {
                rLine.remove(j);
                pointGroup.add(elementID);
                j--;
                nAffected++;
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        RSurface &amp;rSurface = this-&gt;getSurface(i);
        for (uint j=0;j&lt;rSurface.size();j++)
        {
            uint elementID = rSurface.get(j);
            if (R_ELEMENT_TYPE_IS_POINT(this-&gt;getElement(elementID).getType()))
            {
                rSurface.remove(j);
                pointGroup.add(elementID);
                j--;
                nAffected++;
            }
            else if (R_ELEMENT_TYPE_IS_LINE(this-&gt;getElement(elementID).getType()))
            {
                rSurface.remove(j);
                lineGroup.add(elementID);
                j--;
                nAffected++;
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        RVolume &amp;rVolume = this-&gt;getVolume(i);
        for (uint j=0;j&lt;rVolume.size();j++)
        {
            uint elementID = rVolume.get(j);
            if (R_ELEMENT_TYPE_IS_POINT(this-&gt;getElement(elementID).getType()))
            {
                rVolume.remove(j);
                pointGroup.add(elementID);
                j--;
                nAffected++;
            }
            else if (R_ELEMENT_TYPE_IS_LINE(this-&gt;getElement(elementID).getType()))
            {
                rVolume.remove(j);
                lineGroup.add(elementID);
                j--;
                nAffected++;
            }
            else if (R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getElement(elementID).getType()))
            {
                rVolume.remove(j);
                surfaceGroup.add(elementID);
                j--;
                nAffected++;
            }
        }
    }

    if (pointGroup.size() &gt; 0)
    {
        this-&gt;addPoint(pointGroup);
    }
    if (lineGroup.size() &gt; 0)
    {
        this-&gt;addLine(lineGroup);
    }
    if (surfaceGroup.size() &gt; 0)
    {
        this-&gt;addSurface(surfaceGroup);
    }

    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        if (this-&gt;getPoint(i).size() == 0)
        {
            this-&gt;removePoint(i);
            i--;
        }
    }
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        if (this-&gt;getLine(i).size() == 0)
        {
            this-&gt;removeLine(i);
            i--;
        }
    }
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        if (this-&gt;getSurface(i).size() == 0)
        {
            this-&gt;removeSurface(i);
            i--;
        }
    }
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        if (this-&gt;getVolume(i).size() == 0)
        {
            this-&gt;removeVolume(i);
            i--;
        }
    }
    RLogger::info("Number of affected elements: %u\n",nAffected);
    RLogger::unindent();

    return nAffected;
}

QList&lt;uint&gt; RModel::findSliverElements(double edgeRatio) const
{
    RLogger::info("Finding sliver elements\n");
    RLogger::indent();

    QList&lt;uint&gt; elementIDs;
    elementIDs.reserve(int(this-&gt;getNElements()));

    uint nSlivers = 0;

    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(i);
        double lMax = 0.0;
        double lMin = 0.0;
        bool firstTime = true;
        uint n1 = RConstants::eod;
        uint n2 = RConstants::eod;
        for (uint j=0;j&lt;rElement.size();j++)
        {
            for (uint k=j+1;k&lt;rElement.size();k++)
            {
                double distance = this-&gt;nodes[rElement.getNodeId(j)].getDistance(this-&gt;nodes[rElement.getNodeId(k)]);
                if (firstTime)
                {
                    lMax = lMin = distance;
                    n1 = rElement.getNodeId(j);
                    n2 = rElement.getNodeId(k);
                    firstTime = false;
                }
                else
                {
                    lMax = std::max(lMax,distance);
                    if (lMin &gt; distance)
                    {
                        lMin = distance;
                        n1 = rElement.getNodeId(j);
                        n2 = rElement.getNodeId(k);
                    }
                }
            }
        }

        if (n1 == RConstants::eod || n2 == RConstants::eod || n1 == n2)
        {
            continue;
        }

        if (lMin &lt;= RConstants::eps || (lMax/lMin) &gt;= edgeRatio)
        {
            elementIDs.append(i);
            nSlivers++;
        }
    }
    elementIDs.reserve(int(nSlivers));

    RLogger::unindent();

    return elementIDs;
} /* RModel::findSliverElements */

QList&lt;uint&gt; RModel::findIntersectedElements() const
{
    RLogger::info("Finding intersected elements\n");
    RLogger::indent();

    QVector&lt;bool&gt; intElements;
    intElements.resize(int(this-&gt;getNElements()));
    intElements.fill(false);

    RLimitBox limitBox1;

    RProgressInitialize("Finding intersected elements");
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        RProgressPrint(i,this-&gt;getNElements());
        this-&gt;getElement(i).findLimitBox(this-&gt;getNodes(),limitBox1);

#pragma omp parallel for default(shared)
        for (int64_t j=int64_t(i)+1;j&lt;int64_t(this-&gt;getNElements());j++)
        {
            RLimitBox limitBox2;
            bool bothIntersected = false;
#pragma omp critical
            bothIntersected = (intElements[int(i)] &amp;&amp; intElements[int(j)]);
            if (bothIntersected)
            {
                continue;
            }
            this-&gt;getElement(uint(j)).findLimitBox(this-&gt;getNodes(),limitBox2);
            if (!RLimitBox::areIntersecting(limitBox1,limitBox2))
            {
                continue;
            }

            std::set&lt;RR3Vector&gt; x;
            if (RElement::findIntersectionPoints(this-&gt;getElement(i),this-&gt;getElement(uint(j)),this-&gt;getNodes(),x))
            {
#pragma omp critical
                {
//                    RLogger::warning("Elements %u and %u are intersecting.\n",i,j);
                    intElements[int(i)] = intElements[int(j)] = true;
                }
            }
        }
    }
    RProgressFinalize("Done");

    uint nIntersected = 0;
    for (int i=0;i&lt;intElements.size();i++)
    {
        if (intElements[i])
        {
            nIntersected++;
        }
    }

    QList&lt;uint&gt; elementIDs;
    elementIDs.reserve(int(nIntersected));

    for (int i=0;i&lt;intElements.size();i++)
    {
        if (intElements[i])
        {
            elementIDs.append(uint(i));
        }
    }

    RLogger::unindent();

    return elementIDs;
} /* RModel::findIntersectedElements */


uint RModel::breakIntersectedElements(uint nIterations)
{
    std::vector&lt;uint&gt; elementIDs;
    uint ne = this-&gt;getNElements();
    elementIDs.resize(ne);
    for (uint i=0;i&lt;ne;i++)
    {
        elementIDs[i] = i;
    }
    return this-&gt;breakIntersectedElements(nIterations,elementIDs);
} /* RModel::breakIntersectedElements */


uint RModel::breakIntersectedElements(uint nIterations, const std::vector&lt;uint&gt; &amp;elementIDs)
{
    uint oldNNodes = this-&gt;getNNodes();
    uint nIntersected = 0;
    uint iteration = 0;
    double tolerance = RConstants::findMachineDoubleEpsilon()*100;
//    double tolerance = 100.0*RConstants::eps;

    std::vector&lt;uint&gt; bElementIDs(elementIDs);

    while (iteration &lt; nIterations)
    {
        bool intersectionFound = false;

        iteration++;
        RLogger::info("Iteration %u of %u\n",iteration,nIterations);
        RLogger::indent();

        std::vector&lt; std::set&lt;RR3Vector&gt; &gt; intersectionPoints;
        intersectionPoints.resize(bElementIDs.size());

        // Find intersection points.
        RLogger::info("Finding intersection points\n");
        RLogger::indent();

        RProgressPrintToLog(false);
        RProgressInitialize("Finding intersection points");

        for (uint i=0;i&lt;bElementIDs.size();i++)
        {
            RProgressPrint(i,uint(bElementIDs.size()));

            if (this-&gt;getElement(bElementIDs[i]).hasDuplicateNodes())
            {
                continue;
            }

            RLimitBox limitBox1;
            this-&gt;getElement(bElementIDs[i]).findLimitBox(this-&gt;getNodes(),limitBox1);

#pragma omp parallel for default(shared)
            for (int64_t j=int64_t(i)+1;j&lt;int64_t(bElementIDs.size());j++)
            {
                if (this-&gt;getElement(bElementIDs[uint(j)]).hasDuplicateNodes())
                {
                    continue;
                }

                RLimitBox limitBox2;
                this-&gt;getElement(bElementIDs[uint(j)]).findLimitBox(this-&gt;getNodes(),limitBox2);
                if (!RLimitBox::areIntersecting(limitBox1,limitBox2))
                {
                    continue;
                }

                std::set&lt;RR3Vector&gt; x;
                if (RElement::findIntersectionPoints(this-&gt;getElement(bElementIDs[i]),this-&gt;getElement(bElementIDs[uint(j)]),this-&gt;getNodes(),x))
                {
#pragma omp critical
                    {
                        std::set&lt;RR3Vector&gt;::reverse_iterator it;
                        for (it=x.rbegin();it!=x.rend();++it)
                        {
                            // Insert only nodes which are not in the verticies.
                            bool nodeFound = false;
                            std::set&lt;RR3Vector&gt;::const_iterator cit;
                            for (cit=intersectionPoints[i].begin();cit!=intersectionPoints[i].end();++cit)
                            {
                                if (RR3Vector::findDistance(*it,*cit) &lt; tolerance)
                                {
                                    nodeFound = true;
                                    break;
                                }
                            }
                            if (!nodeFound)
                            {
                                intersectionPoints[i].insert(*it);
                                intersectionFound = true;
                            }
                            nodeFound = false;
                            for (cit=intersectionPoints[uint(j)].begin();cit!=intersectionPoints[uint(j)].end();++cit)
                            {
                                if (RR3Vector::findDistance(*it,*cit) &lt; tolerance)
                                {
                                    nodeFound = true;
                                    break;
                                }
                            }
                            if (!nodeFound)
                            {
                                intersectionPoints[uint(j)].insert(*it);
                                intersectionFound = true;
                            }
                        }
                    }
                }
            }
        }

        RProgressFinalize("Done");
        RLogger::unindent();

        if (!intersectionFound)
        {
            RLogger::info("No intersections were found.\n");
            RLogger::unindent();
            break;
        }
        else
        {
            uint nIntersectedFound = 0;
            for (uint i=0;i&lt;intersectionPoints.size();i++)
            {
                if (intersectionPoints[i].size() &gt; 0)
                {
                    nIntersectedFound++;
                }
            }
            RLogger::info("Number of intersected elements found = %d.\n", nIntersectedFound);
        }

        // Create element -&gt; group book.
        RLogger::info("Creating element to group map\n");
        RLogger::indent();
        std::vector&lt;uint&gt; elementGroupBook;
        elementGroupBook.resize(this-&gt;getNElements(),RConstants::eod);

        for (uint i=0;i&lt;this-&gt;getNPoints();i++)
        {
            for (uint j=0;j&lt;this-&gt;getPoint(i).size();j++)
            {
                elementGroupBook[this-&gt;getPoint(i).get(j)] = i;
            }
        }
        for (uint i=0;i&lt;this-&gt;getNLines();i++)
        {
            for (uint j=0;j&lt;this-&gt;getLine(i).size();j++)
            {
                elementGroupBook[this-&gt;getLine(i).get(j)] = i;
            }
        }
        for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
        {
            for (uint j=0;j&lt;this-&gt;getSurface(i).size();j++)
            {
                elementGroupBook[this-&gt;getSurface(i).get(j)] = i;
            }
        }
        for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
        {
            for (uint j=0;j&lt;this-&gt;getVolume(i).size();j++)
            {
                elementGroupBook[this-&gt;getVolume(i).get(j)] = i;
            }
        }
        RLogger::unindent();

        // Break intersected elements.
        RLogger::info("Breaking intersected elements\n");
        RLogger::indent();

        RProgressPrintToLog(false);
        RProgressInitialize("Breaking intersected elemets");
        for (uint i=0;i&lt;intersectionPoints.size();i++)
        {
            RProgressPrint(i,uint(intersectionPoints.size()));
            if (intersectionPoints[i].size() &gt; 0)
            {
                std::vector&lt;uint&gt; breakNodeIDs;

                std::set&lt;RR3Vector&gt;::const_iterator iter;
                for (iter=intersectionPoints[i].begin();iter!=intersectionPoints[i].end();++iter)
                {
                    this-&gt;addNode((*iter)[0],(*iter)[1],(*iter)[2]);
                    breakNodeIDs.push_back(this-&gt;getNNodes() - 1);
                }

                std::vector&lt;RElement&gt; newElements;

                this-&gt;getElement(bElementIDs[i]).breakWithNodes(this-&gt;getNodes(),breakNodeIDs,newElements);
                if (newElements.size() &gt; 0)
                {
                    for (uint j=0;j&lt;newElements.size();j++)
                    {
                        this-&gt;addElement(newElements[j],
                                         elementGroupBook[bElementIDs[i]] != RConstants::eod,
                                         elementGroupBook[bElementIDs[i]]);
                        bElementIDs.push_back(this-&gt;getNElements()-1);
                    }
                    nIntersected++;
                }
            }
        }

        RProgressFinalize("Done");
        RLogger::unindent();

        // Merge near/duplicate nodes.
        RLogger::info("Merging near/duplicate nodes\n");
        RLogger::indent();
        uint nMerged = 0;
        for (uint i=this-&gt;getNNodes()-1;i&gt;=oldNNodes;i--)
        {
            uint nId = this-&gt;findNearNode(this-&gt;getNode(i),tolerance,false,i);
            if (nId != RConstants::eod)
            {
                this-&gt;mergeNodes(nId,i,false,false);
                nMerged ++;
            }
        }
        RLogger::info("Merged near/duplicate nodes = %u\n",nMerged);
        RLogger::unindent();

        // Remove duplicate elements / making them having duplicate nodes (degenerated).
        RLogger::info("Removing duplicate elements\n");
        RLogger::indent();

        for (uint i=0;i&lt;bElementIDs.size();i++)
        {
            const RElement &amp;rElement1 = this-&gt;getElement(bElementIDs[i]);
            if (rElement1.hasDuplicateNodes())
            {
                continue;
            }
            for (uint j=i+1;j&lt;bElementIDs.size();j++)
            {
                RElement &amp;rElement2 = this-&gt;getElement(bElementIDs[j]);
                if (rElement1 == rElement2)
                {
                    rElement2.setNodeId(1,rElement2.getNodeId(0));
                }
            }
        }

        RLogger::unindent();

        RLogger::unindent();
    }

    // Remove degenerated elements.
    RLogger::info("Removing degenerated elements\n");
    RLogger::indent();
    QList&lt;uint&gt; dElementIDs;
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (this-&gt;getElement(i).hasDuplicateNodes())
        {
            dElementIDs.push_back(i);
        }
    }
    this-&gt;removeElements(dElementIDs,false);
    RLogger::unindent();

    return nIntersected;
} /* RModel::breakIntersectedElements */


</t>
<t tx="leo.20201108101536.13">void RModalSetup::setConvergenceValue(double modalCvgValue)
{
    this-&gt;convergenceValue = modalCvgValue;
}

uint RModalSetup::getMode(void) const
{
    return this-&gt;mode;
}

</t>
<t tx="leo.20201108101536.130">bool RModel::boolDifference(uint nIterations, QList&lt;uint&gt; surfaceEntityIDs, uint cuttingSurfaceEntityId)
{
    // First check if all surfaces form closed surface.
    for (int i=0;i&lt;surfaceEntityIDs.size();i++)
    {
        if (!this-&gt;checkIfSurfaceIsClosed(surfaceEntityIDs[i]))
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Cut surface \'%s\' is not closed.\n",this-&gt;getSurface(surfaceEntityIDs[i]).getName().toUtf8().constData());
        }
    }
    if (!this-&gt;checkIfSurfaceIsClosed(cuttingSurfaceEntityId))
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Cutting surface \'%s\' is not closed.\n",this-&gt;getSurface(cuttingSurfaceEntityId).getName().toUtf8().constData());
    }

    // Backup arrays
    std::vector &lt;RNode&gt; nodesBkp(this-&gt;nodes);
    std::vector &lt;RElement&gt; elementsBkp(this-&gt;elements);
    RSurface cuttingSurfaceBkp(this-&gt;getSurface(cuttingSurfaceEntityId));
    std::vector&lt;RSurface&gt; surfacesBkp;
    for (int i=0;i&lt;surfaceEntityIDs.size();i++)
    {
        surfacesBkp.push_back(this-&gt;getSurface(surfaceEntityIDs[i]));
    }

    // Break intersected elemements
    try
    {
        std::vector&lt;uint&gt; allSurfaceEntityIDs;
        allSurfaceEntityIDs.push_back(cuttingSurfaceEntityId);
        for (int i=0;i&lt;surfaceEntityIDs.size();i++)
        {
            allSurfaceEntityIDs.push_back(surfaceEntityIDs[i]);
        }
        uint nIntersected = this-&gt;breakIntersectedElements(nIterations,this-&gt;findElementIDs(R_ENTITY_GROUP_SURFACE,allSurfaceEntityIDs));
        if (nIntersected == 0)
        {
            RLogger::info("No intersections were found\n.");
        }
    }
    catch (const RError &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to break intersected elements. %s", error.getMessage().toUtf8().constData());
    }

    // Remove elements
    std::vector&lt;bool&gt; elementRemoveBook;
    elementRemoveBook.resize(this-&gt;getNElements(),true);

    const RSurface &amp;rCuttingSurface = this-&gt;getSurface(cuttingSurfaceEntityId);

    for (int i=0;i&lt;surfaceEntityIDs.size();i++)
    {
        const RSurface &amp;rSurface = this-&gt;getSurface(surfaceEntityIDs[i]);

        std::vector&lt;RR3Vector&gt; elementCenters;
        std::vector&lt;bool&gt; insideBook;

        // Remove elements from cutted surface
        elementCenters.resize(rSurface.size());

        for (uint j=0;j&lt;rSurface.size();j++)
        {
            this-&gt;getElement(rSurface.get(j)).findCenter(this-&gt;nodes,elementCenters[j][0],elementCenters[j][1],elementCenters[j][2]);
        }
        try
        {
            insideBook = cuttingSurfaceBkp.pointsInside(nodesBkp,elementsBkp,elementCenters,true);
        }
        catch (const RError &amp;error)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to check if element centers are inside surface. %s",
                         error.getMessage().toUtf8().constData());
        }

        for (uint j=0;j&lt;rSurface.size();j++)
        {
            if (!insideBook[j])
            {
                elementRemoveBook[rSurface.get(j)] = false;
            }
        }

        // Remove elements from cutting surface
        elementCenters.resize(rCuttingSurface.size());

        for (uint j=0;j&lt;rCuttingSurface.size();j++)
        {
            this-&gt;getElement(rCuttingSurface.get(j)).findCenter(this-&gt;nodes,elementCenters[j][0],elementCenters[j][1],elementCenters[j][2]);
        }

        try
        {
            insideBook = surfacesBkp[uint(i)].pointsInside(nodesBkp,elementsBkp,elementCenters,false);
        }
        catch (const RError &amp;error)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to check if element centers are inside surface. %s",
                         error.getMessage().toUtf8().constData());
        }

        for (uint j=0;j&lt;rCuttingSurface.size();j++)
        {
            if (insideBook[j])
            {
                elementRemoveBook[rCuttingSurface.get(j)] = false;
            }
        }
    }

    QList&lt;uint&gt; elementsToRemove;
    for (uint i=0;i&lt;elementRemoveBook.size();i++)
    {
        if (elementRemoveBook[i])
        {
            elementsToRemove.push_back(i);
        }
    }

    this-&gt;removeElements(elementsToRemove,false);

    return (elementsToRemove.size() &gt; 0);
} /* RModel::boolDifference */


</t>
<t tx="leo.20201108101536.131">bool RModel::boolIntersection(uint nIterations, QList&lt;uint&gt; surfaceEntityIDs)
{
    // Backup arrays
    std::vector &lt;RNode&gt; nodesBkp(this-&gt;nodes);
    std::vector &lt;RElement&gt; elementsBkp(this-&gt;elements);
    std::vector&lt;RSurface&gt; surfacesBkp;
    for (int i=0;i&lt;surfaceEntityIDs.size();i++)
    {
        surfacesBkp.push_back(this-&gt;getSurface(surfaceEntityIDs[i]));
    }

    // Break intersected elemements
    try
    {
        uint nIntersected = this-&gt;breakIntersectedElements(nIterations,this-&gt;findElementIDs(R_ENTITY_GROUP_SURFACE,surfaceEntityIDs.toVector().toStdVector()));
        if (nIntersected == 0)
        {
            RLogger::info("No intersections were found\n.");
        }
    }
    catch (const RError &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to break intersected elements. %s", error.getMessage().toUtf8().constData());
    }

    // Remove elements
    std::set&lt;uint&gt; elementIDsSet;
    for (int i=0;i&lt;surfaceEntityIDs.size();i++)
    {
        for (int j=0;j&lt;surfaceEntityIDs.size();j++)
        {
            if (i == j)
            {
                continue;
            }
            const RSurface &amp;rSurface = this-&gt;getSurface(surfaceEntityIDs[j]);

            std::vector&lt;RR3Vector&gt; elementCenters;
            elementCenters.resize(rSurface.size());

            for (uint k=0;k&lt;rSurface.size();k++)
            {
                this-&gt;getElement(rSurface.get(k)).findCenter(this-&gt;nodes,elementCenters[k][0],elementCenters[k][1],elementCenters[k][2]);
            }

            std::vector&lt;bool&gt; insideBook;
            try
            {
                insideBook = surfacesBkp[uint(i)].pointsInside(nodesBkp,elementsBkp,elementCenters,true);
            }
            catch (const RError &amp;error)
            {
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to check if element centers are inside surface. %s",
                             error.getMessage().toUtf8().constData());
            }

            for (uint k=0;k&lt;rSurface.size();k++)
            {
                if (!insideBook[k])
                {
                    elementIDsSet.insert(rSurface.get(k));
                }
            }
        }
    }

    QList&lt;uint&gt; elementsToRemove;
    elementsToRemove.reserve(int(elementIDsSet.size()));

    std::set&lt;uint&gt;::const_iterator iter;
    for (iter=elementIDsSet.begin();iter!=elementIDsSet.end();++iter)
    {
        elementsToRemove.push_back(*iter);
    }

    this-&gt;removeElements(elementsToRemove,false);

    return (elementsToRemove.size() &gt; 0);
} /* RModel::boolIntersection */


</t>
<t tx="leo.20201108101536.132">bool RModel::boolUnion(uint nIterations, QList&lt;uint&gt; surfaceEntityIDs)
{
    // Backup arrays
    std::vector &lt;RNode&gt; nodesBkp(this-&gt;nodes);
    std::vector &lt;RElement&gt; elementsBkp(this-&gt;elements);
    std::vector&lt;RSurface&gt; surfacesBkp;
    for (int i=0;i&lt;surfaceEntityIDs.size();i++)
    {
        surfacesBkp.push_back(this-&gt;getSurface(surfaceEntityIDs[i]));
    }

    // Break intersected elemements
    try
    {
        uint nIntersected = this-&gt;breakIntersectedElements(nIterations,this-&gt;findElementIDs(R_ENTITY_GROUP_SURFACE,surfaceEntityIDs.toVector().toStdVector()));
        if (nIntersected == 0)
        {
            RLogger::info("No intersections were found\n.");
        }
    }
    catch (const RError &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to break intersected elements. %s", error.getMessage().toUtf8().constData());
    }

    // Remove elements
    std::set&lt;uint&gt; elementIDsSet;
    for (int i=0;i&lt;surfaceEntityIDs.size();i++)
    {
        for (int j=0;j&lt;surfaceEntityIDs.size();j++)
        {
            if (i == j)
            {
                continue;
            }
            const RSurface &amp;rSurface = this-&gt;getSurface(surfaceEntityIDs[j]);

            std::vector&lt;RR3Vector&gt; elementCenters;
            elementCenters.resize(rSurface.size());

            for (uint k=0;k&lt;rSurface.size();k++)
            {
                this-&gt;getElement(rSurface.get(k)).findCenter(this-&gt;nodes,elementCenters[k][0],elementCenters[k][1],elementCenters[k][2]);
            }

            std::vector&lt;bool&gt; insideBook;
            try
            {
                insideBook = surfacesBkp[uint(i)].pointsInside(nodesBkp,elementsBkp,elementCenters,false);
            }
            catch (const RError &amp;error)
            {
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to check if element centers are inside surface. %s",
                             error.getMessage().toUtf8().constData());
            }

            for (uint k=0;k&lt;rSurface.size();k++)
            {
                if (insideBook[k])
                {
                    elementIDsSet.insert(rSurface.get(k));
                }
            }
        }
    }

    QList&lt;uint&gt; elementsToRemove;
    elementsToRemove.reserve(int(elementIDsSet.size()));

    std::set&lt;uint&gt;::const_iterator iter;
    for (iter=elementIDsSet.begin();iter!=elementIDsSet.end();++iter)
    {
        elementsToRemove.push_back(*iter);
    }

    this-&gt;removeElements(elementsToRemove,false);

    return (elementsToRemove.size() &gt; 0);
} /* RModel::boolUnion */


uint RModel::coarsenSurfaceElements(const std::vector&lt;uint&gt; surfaceIDs, double edgeLength, double elementArea)
{
    std::vector&lt;bool&gt; ecBook;
    ecBook.resize(this-&gt;getNElements(),false);
    std::vector&lt;bool&gt; edBook;
    edBook.resize(this-&gt;getNElements(),false);

    for (uint i=0;i&lt;surfaceIDs.size();i++)
    {
        const RSurface &amp;rSurface = this-&gt;getSurface(surfaceIDs[i]);
        for (uint j=0;j&lt;rSurface.size();j++)
        {
            ecBook[rSurface.get(j)] = true;
        }
    }

    bool elementDeleted = false;

    RProgressInitialize("Coarsening surface elements",true);
    uint nDeleted = 0;
    do
    {
        elementDeleted = false;
        for (uint i=0;i&lt;this-&gt;getNElements();i++)
        {
            if (!ecBook[i])
            {
                continue;
            }
            if (edBook[i])
            {
                continue;
            }
            RProgressPrint(1.0);

            const RElement &amp;rElement = this-&gt;getElement(i);
            if (!R_ELEMENT_TYPE_IS_SURFACE(rElement.getType()))
            {
                continue;
            }

            double length = 0.0;
            uint np1 = 0;
            uint np2 = 0;
            if (!rElement.findShortestEdge(this-&gt;nodes,length,np1,np2))
            {
                continue;
            }
            uint node1 = rElement.getNodeId(np1);
            uint node2 = rElement.getNodeId(np2);

            if (length &lt; edgeLength)
            {
                if (node1 != node2)
                {
                    this-&gt;mergeNodes(node1,node2,true,false);
                }
                edBook[i] = true;
                elementDeleted = true;
                nDeleted++;
                continue;
            }

            double area = 0.0;
            if (!rElement.findArea(this-&gt;nodes,area))
            {
                continue;
            }

            if (area &lt; elementArea)
            {
                if (node1 != node2)
                {
                    this-&gt;mergeNodes(node1,node2,true,false);
                }
                edBook[i] = true;
                elementDeleted = true;
                nDeleted++;
            }
        }
    } while (elementDeleted);

    //! Delete elements with duplicate nodes.
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(i);
        if (rElement.hasDuplicateNodes())
        {
            edBook[i] = true;
            nDeleted++;
        }
    }

    QList&lt;uint&gt; elementIDs;
    elementIDs.reserve(int(nDeleted));

    for (uint i=0;i&lt;edBook.size();i++)
    {
        if (edBook[i])
        {
            elementIDs.push_back(i);
        }
    }
    RProgressFinalize("Done");

    this-&gt;removeElements(elementIDs,false);

    this-&gt;purgeUnusedNodes();

    return nDeleted;
} /* RModel::coarsenSurfaceElements */


uint RModel::tetrahedralizeSurface(const std::vector&lt;uint&gt; surfaceIDs)
{
    // Remove all volume elements
    while (this-&gt;getNVolumes() &gt; 0)
    {
        this-&gt;removeVolume(0);
    }
    this-&gt;purgeUnusedElements();

    // Create combined surface.
    RSurface surface;

    uint nElements = 0;
    for (uint i=0;i&lt;surfaceIDs.size();i++)
    {
        nElements += this-&gt;getSurface(surfaceIDs[i]).size();
    }

    surface.resize(nElements);

    nElements = 0;
    for (uint i=0;i&lt;surfaceIDs.size();i++)
    {
        const RSurface &amp;rSurface = this-&gt;getSurface(surfaceIDs[i]);
        for (uint j=0;j&lt;rSurface.size();j++)
        {
            surface.set(nElements++,rSurface.get(j));
        }
    }

    // Generate tetrahedrons.
    std::vector&lt;RNode&gt; steinerNodes;
    std::vector&lt;RElement&gt; volumeElements;
    try
    {
        surface.tetrahedralize(this-&gt;getNodes(),this-&gt;getElements(),steinerNodes,volumeElements);
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to tetrahedralize surface. %s", error.getMessage().toUtf8().constData());
    }

    // Add steiner nodes.
    uint nNodes = uint(this-&gt;nodes.size());
    this-&gt;nodes.resize(this-&gt;nodes.size() + steinerNodes.size());
    for (uint i=0;i&lt;steinerNodes.size();i++)
    {
        this-&gt;nodes[nNodes + i] = steinerNodes[i];
    }

    // Add tetrahedrons to volume.
    for (uint i=0;i&lt;volumeElements.size();i++)
    {
        this-&gt;addElement(volumeElements[i],true,0);
    }

    return uint(volumeElements.size());
} /* RModel::tetrahedralizeSurface */


RRVector RModel::generateMeshSizeFunction(const QSet&lt;RVariableType&gt; variableTypes, double minValue, double maxValue, double trimValueRatio) const
{
    if (variableTypes.size() == 0)
    {
        return RRVector();
    }

    RRVector nodeWeights(this-&gt;getNNodes(),0.0);

    foreach (RVariableType variableType, variableTypes)
    {
        uint variablePosition = this-&gt;findVariable(variableType);

        if (variablePosition == RConstants::eod)
        {
            continue;
        }
        const RVariable &amp;rVariable = this-&gt;getVariable(variablePosition);
        if (rVariable.getType() != variableType)
        {
            continue;

        }

        RRVector nodeValues(this-&gt;getNNodes());

        if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            double minValue = rVariable.getMinValue();
            double maxValue = rVariable.getMaxValue();
            double magValue = maxValue - minValue;
            if (magValue == 0.0)
            {
                continue;
            }
            for (uint i=0;i&lt;rVariable.getNValues();i++)
            {
                nodeValues[i] = (rVariable.getValue(i) - minValue) / magValue;
            }
        }
        else
        {
            RVariable newVariable(rVariable);
            newVariable.setApplyType(R_VARIABLE_APPLY_NODE);
            newVariable.resize(rVariable.getNVectors(),this-&gt;getNNodes());
#pragma omp parallel for default(shared)
            for (int64_t j=0;j&lt;int64_t(rVariable.getNVectors());j++)
            {
                RRVector elementValues = rVariable.getValues(uint(j));
                RRVector lNodeValues(this-&gt;getNNodes());
                RBVector explicitFlags;
                explicitFlags.resize(this-&gt;getNElements(),false);
                this-&gt;convertElementToNodeVector(elementValues,explicitFlags,lNodeValues);
                for (uint k=0;k&lt;this-&gt;getNNodes();k++)
                {
                    newVariable.setValue(uint(j),k,lNodeValues[k]);
                }
            }
            double minValue = newVariable.getMinValue();
            double maxValue = newVariable.getMaxValue();
            double magValue = maxValue - minValue;
            if (magValue == 0.0)
            {
                continue;
            }
#pragma omp parallel for default(shared)
            for (int64_t i=0;i&lt;int64_t(newVariable.getNValues());i++)
            {
                nodeValues[uint(i)] = (newVariable.getValue(uint(i)) - minValue) / magValue;
            }
        }

#pragma omp parallel for default(shared)
        for (int64_t i=0;i&lt;int64_t(this-&gt;getNElements());i++)
        {
            const RElement &amp;rElement = this-&gt;getElement(uint(i));
            for (uint j=0;j&lt;rElement.size();j++)
            {
                uint nodeId1 = rElement.getNodeId(j);
                for (uint k=j+1;k&lt;rElement.size();k++)
                {
                    uint nodeId2 = rElement.getNodeId(k);
                    double nodeWeight = std::abs(nodeValues[nodeId1] - nodeValues[nodeId2]);
#pragma omp critical
                    {
                        nodeWeights[nodeId1] = std::max(nodeWeights[nodeId1],nodeWeight);
                        nodeWeights[nodeId2] = std::max(nodeWeights[nodeId2],nodeWeight);
                    }
                }
            }
        }
    }

    double minWeight = RStatistics::findMinimumValue(nodeWeights);
    double maxWeight = RStatistics::findMaximumValue(nodeWeights);

    maxWeight = maxWeight - trimValueRatio * (maxWeight - minWeight);

    double scaleWeight = maxWeight - minWeight;
    double scaleValue = maxValue - minValue;

    RRVector meshSizes(this-&gt;getNNodes(),0.0);

#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(this-&gt;getNNodes());i++)
    {
        meshSizes[uint(i)] = ((1.0 - (std::min(nodeWeights[uint(i)],maxWeight) - minWeight) / scaleWeight) * scaleValue) + minValue;
    }

    return meshSizes;
} /* RModel::generateMeshSizeFunction */


QString RModel::generateMeshTetGenInputParams(const RMeshInput &amp;meshInput) const
{
    QString parameters;

    parameters += "npA";
    if (meshInput.getVerbose())
    {
        parameters += "V";
    }
    if (meshInput.getOutputEdges())
    {
        parameters += "e";
    }
    if (meshInput.getReconstruct() &amp;&amp; this-&gt;getNVolumes() &gt; 0)
    {
        parameters += "r";
    }
    if (meshInput.getUseSizeFunction())
    {
        parameters += "m";
    }
    if (meshInput.getQualityMesh())
    {
        parameters += "q" + QString::number(meshInput.getRadiusEdgeRatio())
                   + "a" + QString::number(meshInput.getVolumeConstraint())
                   + "T" + QString::number(meshInput.getTolerance());
    }
    else
    {
        parameters += "Y";
    }
    return parameters;
} /* RModel::generateMeshTetGenInputParams */


</t>
<t tx="leo.20201108101536.133">void RModel::generatePatchSurface(const std::vector&lt;RPatchInput&gt; &amp;patchInput, RPatchBook &amp;book) const
{
    R_ERROR_ASSERT (patchInput.size() == this-&gt;getNSurfaces());

    book.clear();

    RDistanceVector&lt;uint&gt; distanceVector(this-&gt;getNElements(),RConstants::eod);
    RLogger::info("Patch surface generation\n");
    RLogger::indent();

    for (uint surfaceID=0;surfaceID&lt;this-&gt;getNSurfaces();surfaceID++)
    {
        const RSurface &amp;rSurface = this-&gt;getSurface(surfaceID);

        if (rSurface.size() == 0)
        {
            continue;
        }
        if (!patchInput[surfaceID].getEmitter() &amp;&amp; !patchInput[surfaceID].getReceiver())
        {
            continue;
        }

        RLogger::info("Generating patch on surface \'%s\'\n", rSurface.getName().toUtf8().constData());
        RLogger::indent();
        RLogger::info("Max. patch size  = %g [%s]\n",patchInput[surfaceID].getPatchArea(),RVariable::getUnits(R_VARIABLE_PATCH_AREA).toUtf8().constData());
        RLogger::info("Max. patch size  = %u [%s]\n",patchInput[surfaceID].getPatchSize(),RVariable::getUnits(R_VARIABLE_PATCH_SIZE).toUtf8().constData());
        RLogger::info("Separation angle = %g [%s]\n",patchInput[surfaceID].getSeparationAngle(),RVariable::getUnits(R_VARIABLE_SEPARATION_ANGLE).toUtf8().constData());
        RLogger::unindent();

        // Separation angle in radians.
        double separationAngleRad = patchInput[surfaceID].getSeparationAngle() * RConstants::pi / 180.0;

        RProgressPrintToLog(false);
        RProgressInitialize("Patch generation:");

        for (uint i=0;i&lt;rSurface.size();i++)
        {
            uint elementID = rSurface.get(i);

            if (book.findPatchID(elementID) != RConstants::eod)
            {
                continue;
            }
            RProgressPrint(i,rSurface.size());

            const RElement &amp;rElement = this-&gt;getElement(elementID);
            double elementArea = 0.0;

            if (!rElement.findArea(this-&gt;nodes,elementArea))
            {
                RLogger::unindent(true);
                RProgressFinalize("Failed");
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Could not calculate element area\n");
            }

            // Build distance map.
            this-&gt;generateElementDistanceVector(elementID,patchInput[surfaceID].getPatchSize(),separationAngleRad,distanceVector);

            uint patchID = book.createNewPatch(surfaceID);
            double patchArea = 0.0;
            bool addNextElement = true;

            for (uint j=0;j&lt;patchInput[surfaceID].getPatchSize();j++)
            {
                std::vector&lt;uint&gt; distancePositions = distanceVector.getDistancePositions(j);
                for (uint k=0;k&lt;distancePositions.size();k++)
                {
                    if (!this-&gt;getElement(distancePositions[k]).findArea(this-&gt;nodes,elementArea))
                    {
                        RLogger::unindent(true);
                        RProgressFinalize("Failed");
                        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Could not calculate element area\n");
                    }
                    if (book.findPatchID(distancePositions[k]) != RConstants::eod)
                    {
                        continue;
                    }
                    patchArea += elementArea;
                    book.registerElementID(patchID,distancePositions[k]);

                    if (patchArea &gt; patchInput[surfaceID].getPatchArea())
                    {
                        addNextElement = false;
                        break;
                    }
                }
                if (!addNextElement)
                {
                    break;
                }
            }
        }
        RProgressFinalize("Done");
    }
    RLogger::unindent(true);
} /* RModel::generatePatchSurface */


</t>
<t tx="leo.20201108101536.134">void RModel::generatePatchInputVector(std::vector&lt;RPatchInput&gt; &amp;patchInput) const
{
    patchInput.resize(this-&gt;getNSurfaces(),RPatchInput());
    std::fill(patchInput.begin(),patchInput.end(),RPatchInput());

    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        if (!this-&gt;getSurface(i).hasBoundaryCondition(R_BOUNDARY_CONDITION_RADIATION))
        {
            continue;
        }
        const RBoundaryCondition &amp;rBoundaryCondition = this-&gt;getSurface(i).getBoundaryCondition(R_BOUNDARY_CONDITION_RADIATION);

        uint bcPosition;
        if ((bcPosition = rBoundaryCondition.findComponentPosition(R_VARIABLE_PATCH_AREA)) != RConstants::eod)
        {
            patchInput[i].setPatchArea(rBoundaryCondition.getComponent(bcPosition).getValue(0));
        }
        if ((bcPosition = rBoundaryCondition.findComponentPosition(R_VARIABLE_PATCH_SIZE)) != RConstants::eod)
        {
            patchInput[i].setPatchSize(uint(std::ceil(rBoundaryCondition.getComponent(bcPosition).getValue(0))));
        }
        if ((bcPosition = rBoundaryCondition.findComponentPosition(R_VARIABLE_SEPARATION_ANGLE)) != RConstants::eod)
        {
            patchInput[i].setSeparationAngle(rBoundaryCondition.getComponent(bcPosition).getValue(0));
        }
        if ((bcPosition = rBoundaryCondition.findComponentPosition(R_VARIABLE_RADIATION_EMITTER)) != RConstants::eod)
        {
            patchInput[i].setEmitter(rBoundaryCondition.getComponent(bcPosition).getValue(0) != 0.0);
        }
        if ((bcPosition = rBoundaryCondition.findComponentPosition(R_VARIABLE_RADIATION_RECEIVER)) != RConstants::eod)
        {
            patchInput[i].setReceiver(rBoundaryCondition.getComponent(bcPosition).getValue(0) != 0.0);
        }
    }
} /* RModel::generatePatchInputVector */


</t>
<t tx="leo.20201108101536.135">void RModel::findPatchCenter(const RPatch &amp;rPatch, double &amp;cx, double &amp;cy, double &amp;cz) const
{
    const RUVector &amp;rElementIDs = rPatch.getElementIDs();

    cx = cy = cz = 0.0;

    double x,y,z;
    uint ne = uint(rElementIDs.size());
    for (uint i=0;i&lt;ne;i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(rElementIDs[i]);
        rElement.findCenter(this-&gt;getNodes(),x,y,z);
        cx += x;
        cy += y;
        cz += z;
    }
    if (ne &gt; 0)
    {
        cx /= double(ne);
        cy /= double(ne);
        cz /= double(ne);
    }
} /* RModel::findPatchCenter */


</t>
<t tx="leo.20201108101536.136">void RModel::findPatchNormal(const RPatch &amp;rPatch, double &amp;nx, double &amp;ny, double &amp;nz) const
{
    const RUVector &amp;rElementIDs = rPatch.getElementIDs();

    nx = ny = nz = 0.0;

    double x,y,z;
    uint ne = uint(rElementIDs.size());
    for (uint i=0;i&lt;ne;i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(rElementIDs[i]);
        rElement.findNormal(this-&gt;getNodes(),x,y,z);
        nx += x;
        ny += y;
        nz += z;
    }
    if (ne &gt; 0)
    {
        nx /= double(ne);
        ny /= double(ne);
        nz /= double(ne);
    }
    double len = sqrt(nx*nx+ny*ny+nz*nz);
    if (len &gt; 0.0)
    {
        nx /= len;
        ny /= len;
        nz /= len;
    }
} /* RModel::findPatchNormal */


</t>
<t tx="leo.20201108101536.137">void RModel::findPatchArea(const RPatch &amp;rPatch, double area) const
{
    const RUVector &amp;rElementIDs = rPatch.getElementIDs();

    area = 0.0;

    double a;
    uint ne = uint(rElementIDs.size());
    for (uint i=0;i&lt;ne;i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(rElementIDs[i]);
        rElement.findArea(this-&gt;getNodes(),a);
        area += a;
    }
} /* RModel::findPatchArea */


QString RModel::findRecentViewFactorMatrixFile() const
{
    QString viewFactorMatrixFile = this-&gt;getProblemSetup().getRadiationSetup().getViewFactorMatrixFile();
    if (!viewFactorMatrixFile.isEmpty())
    {
        viewFactorMatrixFile = RRadiationSetup::findRecentViewFactorMatrixFile(viewFactorMatrixFile, this-&gt;getTimeSolver().getCurrentTimeStep());
    }
    return viewFactorMatrixFile;
} /* RModel::findRecentViewFactorMatrixFile */


</t>
<t tx="leo.20201108101536.138">void RModel::generateViewFactorMatrixHeader(RViewFactorMatrixHeader &amp;viewFactorMatrixHeader) const
{
    viewFactorMatrixHeader.setHemicubeResolution(this-&gt;getProblemSetup().getRadiationSetup().getResolution());
    this-&gt;generatePatchInputVector(viewFactorMatrixHeader.getPatchInput());
    viewFactorMatrixHeader.setNElements(this-&gt;getNElements());
} /* RModel::generateViewFactorMatrixHeade */


QString RModel::writeViewFactorMatrix(const RViewFactorMatrix &amp;viewFactorMatrix, const QString &amp;fileName) const
{
    // Write view-factor matrix to file
    uint currentTimeStep = 0;
    if (this-&gt;getTimeSolver().getEnabled())
    {
        currentTimeStep = this-&gt;getTimeSolver().getCurrentTimeStep()+1;
    }
    QString newViewFactorMatrixFile = RFileManager::getFileNameWithTimeStep(fileName,currentTimeStep);
    QString linkViewFactorMatrixFile = RFileManager::getFileNameWithOutTimeStep(newViewFactorMatrixFile);

    RLogger::info("Writing view-factor matrix to file \'%s\'\n",newViewFactorMatrixFile.toUtf8().constData());
    viewFactorMatrix.write(newViewFactorMatrixFile,linkViewFactorMatrixFile);

    return linkViewFactorMatrixFile;
} /* RModel::writeViewFactorMatrix */


RBoundaryCondition RModel::generateDefaultBoundayCondition(RBoundaryConditionType type, REntityGroupType entityGroupType, uint entityID) const
{
    RBoundaryCondition bc(type);

    if (type == R_BOUNDARY_CONDITION_RADIATION &amp;&amp; entityGroupType == R_ENTITY_GROUP_SURFACE)
    {
        uint cPos;

        // Enable radiation emitter
        if ((cPos= bc.findComponentPosition(R_VARIABLE_RADIATION_EMITTER)) != RConstants::eod)
        {
            bc.getComponent(cPos).add(0,1.0);
        }
        // Enable radiation receiver
        if ((cPos= bc.findComponentPosition(R_VARIABLE_RADIATION_RECEIVER)) != RConstants::eod)
        {
            bc.getComponent(cPos).add(0,1.0);
        }
        // Set patch area
        if ((cPos= bc.findComponentPosition(R_VARIABLE_PATCH_AREA)) != RConstants::eod)
        {
            double surfaceArea = 0.0;
            double elementArea;
            for (uint i=0;i&lt;this-&gt;getSurface(entityID).size();i++)
            {
                const RElement &amp;rElement = this-&gt;getElement(this-&gt;getSurface(entityID).get(i));
                if (rElement.findArea(this-&gt;nodes,elementArea))
                {
                    surfaceArea += elementArea;
                }
            }
            bc.getComponent(cPos).add(0,10.0*surfaceArea/double(this-&gt;getSurface(entityID).size()));
        }
        // Set patch size
        if ((cPos= bc.findComponentPosition(R_VARIABLE_PATCH_SIZE)) != RConstants::eod)
        {
            bc.getComponent(cPos).add(0,10.0);
        }
        // Set separation angle
        if ((cPos= bc.findComponentPosition(R_VARIABLE_SEPARATION_ANGLE)) != RConstants::eod)
        {
            bc.getComponent(cPos).add(0,45.0);
        }
    }

    return bc;
} /* RModel::generateDefaultBoundayCondition */


QString RModel::generateNextEntityName(REntityGroupType groupType, const QString &amp;suggestedName) const
{
    QString entityName;
    uint cnt = 0;
    switch (groupType)
    {
        case R_ENTITY_GROUP_POINT:
        {
            QString templateName(suggestedName.isEmpty() ? RPoint::defaultName + " " : suggestedName);
            bool nameFound = false;
            do
            {
                entityName = templateName + QString::number(++cnt);
                nameFound = false;
                for (uint i=0;i&lt;this-&gt;getNPoints();i++)
                {
                    if (this-&gt;getPoint(i).getName() == entityName)
                    {
                        nameFound = true;
                        break;
                    }
                }
            } while (nameFound);
            break;
        }
        case R_ENTITY_GROUP_LINE:
        {
            QString templateName(suggestedName.isEmpty() ? RLine::defaultName + " " : suggestedName);
            bool nameFound = false;
            do
            {
                entityName = templateName + QString::number(++cnt);
                nameFound = false;
                for (uint i=0;i&lt;this-&gt;getNLines();i++)
                {
                    if (this-&gt;getLine(i).getName() == entityName)
                    {
                        nameFound = true;
                        break;
                    }
                }
            } while (nameFound);
            break;
        }
        case R_ENTITY_GROUP_SURFACE:
        {
            QString templateName(suggestedName.isEmpty() ? RSurface::defaultName + " " : suggestedName);
            bool nameFound = false;
            do
            {
                entityName = templateName + QString::number(++cnt);
                nameFound = false;
                for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
                {
                    if (this-&gt;getSurface(i).getName() == entityName)
                    {
                        nameFound = true;
                        break;
                    }
                }
            } while (nameFound);
            break;
        }
        case R_ENTITY_GROUP_VOLUME:
        {
            QString templateName(suggestedName.isEmpty() ? RVolume::defaultName + " " : suggestedName);
            bool nameFound = false;
            do
            {
                entityName = templateName + QString::number(++cnt);
                nameFound = false;
                for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
                {
                    if (this-&gt;getVolume(i).getName() == entityName)
                    {
                        nameFound = true;
                        break;
                    }
                }
            } while (nameFound);
            break;
        }
        case R_ENTITY_GROUP_VECTOR_FIELD:
        {
            QString templateName(suggestedName.isEmpty() ? RVectorField::defaultName + " " : suggestedName);
            bool nameFound = false;
            do
            {
                entityName = templateName + QString::number(++cnt);
                nameFound = false;
                for (uint i=0;i&lt;this-&gt;getNVectorFields();i++)
                {
                    if (this-&gt;getVectorField(i).getName() == entityName)
                    {
                        nameFound = true;
                        break;
                    }
                }
            } while (nameFound);
            break;
        }
        case R_ENTITY_GROUP_SCALAR_FIELD:
        {
            QString templateName(suggestedName.isEmpty() ? RScalarField::defaultName + " " : suggestedName);
            bool nameFound = false;
            do
            {
                entityName = templateName + QString::number(++cnt);
                nameFound = false;
                for (uint i=0;i&lt;this-&gt;getNScalarFields();i++)
                {
                    if (this-&gt;getScalarField(i).getName() == entityName)
                    {
                        nameFound = true;
                        break;
                    }
                }
            } while (nameFound);
            break;
        }
        case R_ENTITY_GROUP_STREAM_LINE:
        {
            QString templateName(suggestedName.isEmpty() ? RStreamLine::defaultName + " " : suggestedName);
            bool nameFound = false;
            do
            {
                entityName = templateName + QString::number(++cnt);
                nameFound = false;
                for (uint i=0;i&lt;this-&gt;getNStreamLines();i++)
                {
                    if (this-&gt;getStreamLine(i).getName() == entityName)
                    {
                        nameFound = true;
                        break;
                    }
                }
            } while (nameFound);
            break;
        }
        case R_ENTITY_GROUP_CUT:
        {
            QString templateName(suggestedName.isEmpty() ? RCut::defaultName + " " : suggestedName);
            bool nameFound = false;
            do
            {
                entityName = templateName + QString::number(++cnt);
                nameFound = false;
                for (uint i=0;i&lt;this-&gt;getNCuts();i++)
                {
                    if (this-&gt;getCut(i).getName() == entityName)
                    {
                        nameFound = true;
                        break;
                    }
                }
            } while (nameFound);
            break;
        }
        case R_ENTITY_GROUP_ISO:
        {
            QString templateName(suggestedName.isEmpty() ? RIso::defaultName + " " : suggestedName);
            bool nameFound = false;
            do
            {
                entityName = templateName + QString::number(++cnt);
                nameFound = false;
                for (uint i=0;i&lt;this-&gt;getNIsos();i++)
                {
                    if (this-&gt;getIso(i).getName() == entityName)
                    {
                        nameFound = true;
                        break;
                    }
                }
            } while (nameFound);
            break;
        }
        default:
        {
            break;
        }
    }
    return entityName;
} /* RModel::generateNextEntityName */


</t>
<t tx="leo.20201108101536.139">void RModel::convertElementToNodeVector(const RRVector &amp;elementValues,
                                        const RBVector &amp;setValues,
                                        RRVector &amp;nodeValues,
                                        bool onlySetValues) const
{
    nodeValues.resize(this-&gt;getNNodes(),0.0);

    if (onlySetValues)
    {
        for (uint i=0;i&lt;setValues.size();i++)
        {
            if (setValues[i])
            {
                const RElement &amp;rElement = this-&gt;getElement(i);
                for (uint j=0;j&lt;rElement.size();j++)
                {
                    nodeValues[rElement.getNodeId(j)] = 0.0;
                }
            }
        }
    }
    else
    {
        nodeValues.fill(0.0);
    }

    std::vector&lt;double&gt; nodeDistance;
    nodeDistance.resize(this-&gt;getNNodes(),0.0);

    if (!onlySetValues)
    {
        // Volume elements.
        for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
        {
            const RVolume &amp;rVolume = this-&gt;getVolume(i);
            for (uint j=0;j&lt;rVolume.size();j++)
            {
                uint elementID = rVolume.get(j);
                const RElement &amp;element = this-&gt;getElement(elementID);
                if (!setValues[elementID])
                {
                    RR3Vector center;
                    element.findCenter(this-&gt;nodes,center[0],center[1],center[2]);
                    for (uint j=0;j&lt;element.size();j++)
                    {
                        double d = this-&gt;nodes[element.getNodeId(j)].getDistance(RNode(center));
                        d = (d &lt; RConstants::eps) ? 1.0 / RConstants::eps : 1.0 / d;

                        nodeValues[element.getNodeId(j)] += d*elementValues[elementID];
                        nodeDistance[element.getNodeId(j)] += d;
                    }
                }
            }
        }
        // Surface elements.
        for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
        {
            const RSurface &amp;rSurface = this-&gt;getSurface(i);
            for (uint j=0;j&lt;rSurface.size();j++)
            {
                uint elementID = rSurface.get(j);
                const RElement &amp;element = this-&gt;getElement(elementID);
                if (!setValues[elementID])
                {
                    if (rSurface.getThickness() &gt; 0.0)
                    {
                        RR3Vector center;
                        element.findCenter(this-&gt;nodes,center[0],center[1],center[2]);
                        for (uint j=0;j&lt;element.size();j++)
                        {
                            double d = this-&gt;nodes[element.getNodeId(j)].getDistance(RNode(center));
                            d = (d &lt; RConstants::eps) ? 1.0 / RConstants::eps : 1.0 / d;

                            nodeValues[element.getNodeId(j)] += d*elementValues[elementID];
                            nodeDistance[element.getNodeId(j)] += d;
                        }
                    }
                }
            }
        }
        // Line elements.
        for (uint i=0;i&lt;this-&gt;getNLines();i++)
        {
            const RLine &amp;rLine = this-&gt;getLine(i);
            for (uint j=0;j&lt;rLine.size();j++)
            {
                uint elementID = rLine.get(j);
                const RElement &amp;element = this-&gt;getElement(elementID);
                if (!setValues[elementID])
                {
                    if (rLine.getCrossArea() &gt; 0.0)
                    {
                        RR3Vector center;
                        element.findCenter(this-&gt;nodes,center[0],center[1],center[2]);
                        for (uint j=0;j&lt;element.size();j++)
                        {
                            double d = this-&gt;nodes[element.getNodeId(j)].getDistance(RNode(center));
                            d = (d &lt; RConstants::eps) ? 1.0 / RConstants::eps : 1.0 / d;

                            nodeValues[element.getNodeId(j)] += d*elementValues[elementID];
                            nodeDistance[element.getNodeId(j)] += d;
                        }
                    }
                }
            }
        }
        // Point elements.
        for (uint i=0;i&lt;this-&gt;getNPoints();i++)
        {
            const RPoint &amp;rPoint = this-&gt;getPoint(i);
            for (uint j=0;j&lt;rPoint.size();j++)
            {
                uint elementID = rPoint.get(j);
                const RElement &amp;element = this-&gt;getElement(elementID);
                if (!setValues[elementID])
                {
                    if (rPoint.getVolume() &gt; 0.0)
                    {
                        for (uint j=0;j&lt;element.size();j++)
                        {
                            nodeValues[element.getNodeId(j)] += elementValues[elementID] / RConstants::eps;
                            nodeDistance[element.getNodeId(j)] += 1.0 / RConstants::eps;
                        }
                    }
                }
            }
        }
    }

    // Volume elements.
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        const RVolume &amp;rVolume = this-&gt;getVolume(i);
        for (uint j=0;j&lt;rVolume.size();j++)
        {
            uint elementID = rVolume.get(j);
            const RElement &amp;element = this-&gt;getElement(elementID);
            if (setValues[elementID])
            {
                for (uint j=0;j&lt;element.size();j++)
                {
                    nodeValues[element.getNodeId(j)] = elementValues[elementID];
                    nodeDistance[element.getNodeId(j)] = 1.0;
                }
            }
        }
    }
    // Surface elements.
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        const RSurface &amp;rSurface = this-&gt;getSurface(i);
        for (uint j=0;j&lt;rSurface.size();j++)
        {
            uint elementID = rSurface.get(j);
            const RElement &amp;element = this-&gt;getElement(elementID);
            if (setValues[elementID])
            {
                for (uint j=0;j&lt;element.size();j++)
                {
                    nodeValues[element.getNodeId(j)] = elementValues[elementID];
                    nodeDistance[element.getNodeId(j)] = 1.0;
                }
            }
        }
    }
    // Line elements.
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        const RLine &amp;rLine = this-&gt;getLine(i);
        for (uint j=0;j&lt;rLine.size();j++)
        {
            uint elementID = rLine.get(j);
            const RElement &amp;element = this-&gt;getElement(elementID);
            if (setValues[elementID])
            {
                for (uint j=0;j&lt;element.size();j++)
                {
                    nodeValues[element.getNodeId(j)] = elementValues[elementID];
                    nodeDistance[element.getNodeId(j)] = 1.0;
                }
            }
        }
    }
    // Point elements.
    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        const RPoint &amp;rPoint = this-&gt;getPoint(i);
        for (uint j=0;j&lt;rPoint.size();j++)
        {
            uint elementID = rPoint.get(j);
            const RElement &amp;element = this-&gt;getElement(elementID);
            if (setValues[elementID])
            {
                for (uint j=0;j&lt;element.size();j++)
                {
                    nodeValues[element.getNodeId(j)] = elementValues[elementID];
                    nodeDistance[element.getNodeId(j)] = 1.0;
                }
            }
        }
    }

    if (!onlySetValues)
    {
        for (uint i=0;i&lt;this-&gt;getNNodes();i++)
        {
            if (nodeDistance[i] == 0.0)
            {
                nodeValues[i] = 0.0;
            }
            else
            {
                nodeValues[i] /= double(nodeDistance[i]);
            }
        }
    }
} /* RModel::convertElementToNodeVector */


</t>
<t tx="leo.20201108101536.14">void RModalSetup::setMode(uint mode)
{
    this-&gt;mode = mode;
}

double RModalSetup::getFrequency(void) const
{
    return this-&gt;frequency;
}

</t>
<t tx="leo.20201108101536.140">void RModel::convertNodeToElementVector(const RRVector &amp;nodeValues,
                                        RRVector &amp;elementValues)
{
    elementValues.resize(this-&gt;getNElements(),0.0);

    // Point elements.
    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        const RPoint &amp;rPoint = this-&gt;getPoint(i);
#pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(rPoint.size());j++)
        {
            if (rPoint.getVolume() &lt;= 0.0)
            {
                continue;
            }
            uint elementID = rPoint.get(uint(j));
            elementValues[elementID] = 0.0;
            const RElement &amp;element = this-&gt;getElement(elementID);
            for (uint j=0;j&lt;element.size();j++)
            {
                elementValues[elementID] += nodeValues[element.getNodeId(j)];
            }
            elementValues[elementID] /= element.size();
        }
    }
    // Line elements.
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        const RLine &amp;rLine = this-&gt;getLine(i);
#pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;(rLine.size());j++)
        {
            if (rLine.getCrossArea() &lt;= 0.0)
            {
                continue;
            }
            uint elementID = rLine.get(uint(j));
            elementValues[elementID] = 0.0;
            const RElement &amp;element = this-&gt;getElement(elementID);
            for (uint j=0;j&lt;element.size();j++)
            {
                elementValues[elementID] += nodeValues[element.getNodeId(j)];
            }
            elementValues[elementID] /= element.size();
        }
    }
    // Surface elements.
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        const RSurface &amp;rSurface = this-&gt;getSurface(i);
#pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;(rSurface.size());j++)
        {
            if (rSurface.getThickness() &lt;= 0.0)
            {
                continue;
            }
            uint elementID = rSurface.get(uint(j));
            elementValues[elementID] = 0.0;
            const RElement &amp;element = this-&gt;getElement(elementID);
            for (uint j=0;j&lt;element.size();j++)
            {
                elementValues[elementID] += nodeValues[element.getNodeId(j)];
            }
            elementValues[elementID] /= element.size();
        }
    }
    // Volume elements.
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        const RVolume &amp;rVolume = this-&gt;getVolume(i);
#pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(rVolume.size());j++)
        {
            uint elementID = rVolume.get(uint(j));
            elementValues[elementID] = 0.0;
            const RElement &amp;element = this-&gt;getElement(elementID);
            for (uint j=0;j&lt;element.size();j++)
            {
                elementValues[elementID] += nodeValues[element.getNodeId(j)];
            }
            elementValues[elementID] /= element.size();
        }
    }
} /* RModel::convertNodeToElementVector */


</t>
<t tx="leo.20201108101536.141">void RModel::clearBoundaryConditions()
{
    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        this-&gt;getPoint(i).removeAllBoundaryConditions();
    }
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        this-&gt;getLine(i).removeAllBoundaryConditions();
    }
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        this-&gt;getSurface(i).removeAllBoundaryConditions();
    }
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        this-&gt;getVolume(i).removeAllBoundaryConditions();
    }
} /* RModel::clearBoundaryConditions */


</t>
<t tx="leo.20201108101536.142">void RModel::clearInitialConditions()
{
    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        this-&gt;getPoint(i).removeAllInitialConditions();
    }
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        this-&gt;getLine(i).removeAllInitialConditions();
    }
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        this-&gt;getSurface(i).removeAllInitialConditions();
    }
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        this-&gt;getVolume(i).removeAllInitialConditions();
    }
} /* RModel::clearInitialConditions */


</t>
<t tx="leo.20201108101536.143">void RModel::clearEnvironmentConditions()
{
    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        this-&gt;getPoint(i).removeAllEnvironmentConditions();
    }
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        this-&gt;getLine(i).removeAllEnvironmentConditions();
    }
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        this-&gt;getSurface(i).removeAllEnvironmentConditions();
    }
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        this-&gt;getVolume(i).removeAllEnvironmentConditions();
    }
} /* RModel::clearEnvironmentConditions */


</t>
<t tx="leo.20201108101536.144">void RModel::clearEntityVariableData()
{
    for (uint i=0;i&lt;this-&gt;getNEntityGroups();i++)
    {
        this-&gt;getEntityGroupPtr(i)-&gt;getData().getVariableData().clear();
    }
} /* RModel::clearEntityVariableData */


</t>
<t tx="leo.20201108101536.145">void RModel::clearEntityVariableData(RVariableType variableType)
{
    for (uint i=0;i&lt;this-&gt;getNEntityGroups();i++)
    {
        this-&gt;getEntityGroupPtr(i)-&gt;getData().getVariableData().erase(variableType);
    }
} /* RModel::clearEntityVariableData */


QString RModel::getDefaultFileExtension(bool binary)
{
    if (binary)
    {
        return "rbm";
    }
    else
    {
        return "ram";
    }
} /* RModel::getDefaultFileExtension */


</t>
<t tx="leo.20201108101536.146">void RModel::writeLink(const QString &amp;linkFileName, const QString &amp;targetFileName)
{
    if (linkFileName.isEmpty() || targetFileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    bool binary = true;
    QString ext = RFileManager::getExtension(linkFileName);

    if (ext == RModel::getDefaultFileExtension(false))
    {
        binary = false;
    }
    else if (ext == RModel::getDefaultFileExtension(true))
    {
        binary = true;
    }
    else
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
    }

    RFileManager::writeLink(linkFileName,targetFileName,_version,binary);
} /* RModel::writeLink */


QString RModel::readAscii(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Reading ascii model file \'%s\'\n",fileName.toUtf8().constData());

    RFile modelFile(fileName,RFile::ASCII);

    if (!modelFile.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileHeader fileHeader;

    RFileIO::readAscii(modelFile,fileHeader);
    if (fileHeader.getType() == R_FILE_TYPE_LINK)
    {
        QString targetFileName(RFileManager::findLinkTargetFileName(fileName,fileHeader.getInformation()));
        RLogger::info("File \'%s\' is a link file pointing to \'%s\'\n",fileName.toUtf8().constData(),targetFileName.toUtf8().constData());
        return targetFileName;
    }
    if (fileHeader.getType() != R_FILE_TYPE_MODEL)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF,"File type of the file \'" + fileName + "\' is not MODEL.");
    }

    // Set file version
    modelFile.setVersion(fileHeader.getVersion());

    // Reading mesh/model values

    RFileIO::readAscii(modelFile,this-&gt;name);
    RFileIO::readAscii(modelFile,this-&gt;description);
    uint nNodes = 0;
    RFileIO::readAscii(modelFile,nNodes);
    this-&gt;nodes.resize(nNodes);
    for (uint i=0;i&lt;nNodes;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;nodes[i]);
    }
    uint nElements = 0;
    RFileIO::readAscii(modelFile,nElements);
    this-&gt;elements.resize(nElements);
    for (uint i=0;i&lt;nElements;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;elements[i]);
    }
    uint nPoints = 0;
    RFileIO::readAscii(modelFile,nPoints);
    this-&gt;points.resize(nPoints);
    for (uint i=0;i&lt;nPoints;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;points[i]);
    }
    uint nLines = 0;
    RFileIO::readAscii(modelFile,nLines);
    this-&gt;lines.resize(nLines);
    for (uint i=0;i&lt;nLines;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;lines[i]);
    }
    uint nSurfaces = 0;
    RFileIO::readAscii(modelFile,nSurfaces);
    this-&gt;surfaces.resize(nSurfaces);
    for (uint i=0;i&lt;nSurfaces;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;surfaces[i]);
    }
    uint nVolumes = 0;
    RFileIO::readAscii(modelFile,nVolumes);
    this-&gt;volumes.resize(nVolumes);
    for (uint i=0;i&lt;nVolumes;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;volumes[i]);
    }
    uint nVectorFields = 0;
    RFileIO::readAscii(modelFile,nVectorFields);
    this-&gt;vectorFields.resize(nVectorFields);
    for (uint i=0;i&lt;nVectorFields;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;vectorFields[i]);
    }
    uint nScalarFields = 0;
    RFileIO::readAscii(modelFile,nScalarFields);
    this-&gt;scalarFields.resize(nScalarFields);
    for (uint i=0;i&lt;nScalarFields;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;scalarFields[i]);
    }
    uint nStreamLines = 0;
    RFileIO::readAscii(modelFile,nStreamLines);
    this-&gt;streamLines.resize(nStreamLines);
    for (uint i=0;i&lt;nStreamLines;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;streamLines[i]);
    }
    uint nCuts = 0;
    RFileIO::readAscii(modelFile,nCuts);
    this-&gt;cuts.resize(nCuts);
    for (uint i=0;i&lt;nCuts;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;cuts[i]);
    }
    uint nIsos = 0;
    RFileIO::readAscii(modelFile,nIsos);
    this-&gt;isos.resize(nIsos);
    for (uint i=0;i&lt;nIsos;i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;isos[i]);
    }
    RFileIO::readAscii(modelFile,this-&gt;modelData);

    // Reading problem values

    RFileIO::readAscii(modelFile,this-&gt;taskTree);
    RFileIO::readAscii(modelFile,this-&gt;timeSolver);
    RFileIO::readAscii(modelFile,this-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));
    if (modelFile.getVersion() &gt; RVersion(0,3,2))
    {
        RFileIO::readAscii(modelFile,this-&gt;getMatrixSolverConf(RMatrixSolverConf::GMRES));
    }
    RFileIO::readAscii(modelFile,this-&gt;monitoringPointManager);
    RFileIO::readAscii(modelFile,this-&gt;problemSetup);

    // Reading results values

    RFileIO::readAscii(modelFile,this-&gt;RResults::nnodes);
    RFileIO::readAscii(modelFile,this-&gt;RResults::nelements);
    uint nVariables = 0;
    RFileIO::readAscii(modelFile,nVariables);
    this-&gt;RResults::variables.resize(nVariables);
    for (uint i=0;i&lt;this-&gt;RResults::variables.size();i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;RResults::variables[i]);
    }

    // Reading neighbor information.
    uint nSurfaceNeigs = 0;
    RFileIO::readAscii(modelFile,nSurfaceNeigs);
    this-&gt;surfaceNeigs.resize(nSurfaceNeigs);
    for (uint i=0;i&lt;this-&gt;surfaceNeigs.size();i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;surfaceNeigs[i]);
    }
    uint nVolumeNeigs = 0;
    RFileIO::readAscii(modelFile,nVolumeNeigs);
    this-&gt;volumeNeigs.resize(nVolumeNeigs);
    for (uint i=0;i&lt;this-&gt;volumeNeigs.size();i++)
    {
        RFileIO::readAscii(modelFile,this-&gt;volumeNeigs[i]);
    }

    modelFile.close();

    return QString();
} /* RModel::readAscii */


QString RModel::readBinary(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Reading binary model file \'%s\'\n",fileName.toUtf8().constData());

    RFile modelFile(fileName,RFile::BINARY);

    if (!modelFile.open(QIODevice::ReadOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileHeader fileHeader;

    RFileIO::readBinary(modelFile,fileHeader);
    if (fileHeader.getType() == R_FILE_TYPE_LINK)
    {
        QString targetFileName(RFileManager::findLinkTargetFileName(fileName,fileHeader.getInformation()));
        RLogger::info("File \'%s\' is a link file pointing to \'%s\'\n",fileName.toUtf8().constData(),targetFileName.toUtf8().constData());
        return targetFileName;
    }
    if (fileHeader.getType() != R_FILE_TYPE_MODEL)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF,"File type of the file \'" + fileName + "\' is not MODEL.");
    }

    // Set file version
    modelFile.setVersion(fileHeader.getVersion());

    // Reading mesh/model values

    RFileIO::readBinary(modelFile,this-&gt;name);
    RFileIO::readBinary(modelFile,this-&gt;description);
    uint nNodes = 0;
    RFileIO::readBinary(modelFile,nNodes);
    this-&gt;nodes.resize(nNodes);
    for (uint i=0;i&lt;nNodes;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;nodes[i]);
    }
    uint nElements = 0;
    RFileIO::readBinary(modelFile,nElements);
    this-&gt;elements.resize(nElements);
    for (uint i=0;i&lt;nElements;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;elements[i]);
    }
    uint nPoints = 0;
    RFileIO::readBinary(modelFile,nPoints);
    this-&gt;points.resize(nPoints);
    for (uint i=0;i&lt;nPoints;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;points[i]);
    }
    uint nLines = 0;
    RFileIO::readBinary(modelFile,nLines);
    this-&gt;lines.resize(nLines);
    for (uint i=0;i&lt;nLines;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;lines[i]);
    }
    uint nSurfaces = 0;
    RFileIO::readBinary(modelFile,nSurfaces);
    this-&gt;surfaces.resize(nSurfaces);
    for (uint i=0;i&lt;nSurfaces;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;surfaces[i]);
    }
    uint nVolumes = 0;
    RFileIO::readBinary(modelFile,nVolumes);
    this-&gt;volumes.resize(nVolumes);
    for (uint i=0;i&lt;nVolumes;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;volumes[i]);
    }
    uint nVectorFields = 0;
    RFileIO::readBinary(modelFile,nVectorFields);
    this-&gt;vectorFields.resize(nVectorFields);
    for (uint i=0;i&lt;nVectorFields;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;vectorFields[i]);
    }
    uint nScalarFields = 0;
    RFileIO::readBinary(modelFile,nScalarFields);
    this-&gt;scalarFields.resize(nScalarFields);
    for (uint i=0;i&lt;nScalarFields;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;scalarFields[i]);
    }
    uint nStreamLines = 0;
    RFileIO::readBinary(modelFile,nStreamLines);
    this-&gt;streamLines.resize(nStreamLines);
    for (uint i=0;i&lt;nStreamLines;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;streamLines[i]);
    }
    uint nCuts = 0;
    RFileIO::readBinary(modelFile,nCuts);
    this-&gt;cuts.resize(nCuts);
    for (uint i=0;i&lt;nCuts;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;cuts[i]);
    }
    uint nIsos = 0;
    RFileIO::readBinary(modelFile,nIsos);
    this-&gt;isos.resize(nIsos);
    for (uint i=0;i&lt;nIsos;i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;isos[i]);
    }
    RFileIO::readBinary(modelFile,this-&gt;modelData);

    // Reading problem values

    RFileIO::readBinary(modelFile,this-&gt;taskTree);
    RFileIO::readBinary(modelFile,this-&gt;timeSolver);
    RFileIO::readBinary(modelFile,this-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));
    if (modelFile.getVersion() &gt; RVersion(0,3,2))
    {
        RFileIO::readBinary(modelFile,this-&gt;getMatrixSolverConf(RMatrixSolverConf::GMRES));
    }
    RFileIO::readBinary(modelFile,this-&gt;monitoringPointManager);
    RFileIO::readBinary(modelFile,this-&gt;problemSetup);

    // Reading results values

    RFileIO::readBinary(modelFile,this-&gt;RResults::nnodes);
    RFileIO::readBinary(modelFile,this-&gt;RResults::nelements);
    uint nVariables = 0;
    RFileIO::readBinary(modelFile,nVariables);
    this-&gt;RResults::variables.resize(nVariables);
    for (uint i=0;i&lt;this-&gt;RResults::variables.size();i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;RResults::variables[i]);
    }

    // Reading neighbor information.
    uint nSurfaceNeigs = 0;
    RFileIO::readBinary(modelFile,nSurfaceNeigs);
    this-&gt;surfaceNeigs.resize(nSurfaceNeigs);
    for (uint i=0;i&lt;this-&gt;surfaceNeigs.size();i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;surfaceNeigs[i]);
    }
    uint nVolumeNeigs = 0;
    RFileIO::readBinary(modelFile,nVolumeNeigs);
    this-&gt;volumeNeigs.resize(nVolumeNeigs);
    for (uint i=0;i&lt;this-&gt;volumeNeigs.size();i++)
    {
        RFileIO::readBinary(modelFile,this-&gt;volumeNeigs[i]);
    }

    modelFile.close();

    return QString();
} /* RModel::readBinary */


</t>
<t tx="leo.20201108101536.147">void RModel::writeAscii(const QString &amp;fileName) const
{
    RProgressInitialize("Writing model file");

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Writing ascii model file \'%s\'\n",fileName.toUtf8().constData());

    RSaveFile modelFile(fileName,RSaveFile::ASCII);

    if (!modelFile.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    uint nsteps = this-&gt;getNNodes()
                        + this-&gt;getNElements()
                        + this-&gt;getNPoints()
                        + this-&gt;getNLines()
                        + this-&gt;getNSurfaces()
                        + this-&gt;getNVolumes()
                        + this-&gt;getNVectorFields()
                        + this-&gt;getNScalarFields()
                        + this-&gt;getNStreamLines()
                        + this-&gt;getNCuts()
                        + this-&gt;getNIsos();
    uint cstep = 0;

    RFileIO::writeAscii(modelFile,RFileHeader(R_FILE_TYPE_MODEL,_version));

    // Writing mesh/model values

    RFileIO::writeAscii(modelFile,"\"" + this-&gt;name + "\"");
    RFileIO::writeAscii(modelFile,"\"" + this-&gt;description + "\"");
    RFileIO::writeAscii(modelFile,this-&gt;getNNodes());
    for (uint i=0;i&lt;this-&gt;getNNodes();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;nodes[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;elements[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;getNPoints());
    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;points[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;getNLines());
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;lines[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;getNSurfaces());
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;surfaces[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;getNVolumes());
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;volumes[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;getNVectorFields());
    for (uint i=0;i&lt;this-&gt;getNVectorFields();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;vectorFields[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;getNScalarFields());
    for (uint i=0;i&lt;this-&gt;getNScalarFields();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;scalarFields[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;getNStreamLines());
    for (uint i=0;i&lt;this-&gt;getNStreamLines();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;streamLines[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;getNCuts());
    for (uint i=0;i&lt;this-&gt;getNCuts();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;cuts[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;getNIsos());
    for (uint i=0;i&lt;this-&gt;getNIsos();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeAscii(modelFile,this-&gt;isos[i],false);
        RFileIO::writeNewLineAscii(modelFile);
    }
    RFileIO::writeAscii(modelFile,this-&gt;modelData);

    // Writing problem values

    RFileIO::writeAscii(modelFile,this-&gt;taskTree);
    RFileIO::writeAscii(modelFile,this-&gt;timeSolver);
    RFileIO::writeAscii(modelFile,this-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));
    RFileIO::writeAscii(modelFile,this-&gt;getMatrixSolverConf(RMatrixSolverConf::GMRES));
    RFileIO::writeAscii(modelFile,this-&gt;monitoringPointManager);
    RFileIO::writeAscii(modelFile,this-&gt;problemSetup);

    // Reading results values

    RFileIO::writeAscii(modelFile,this-&gt;RResults::nnodes);
    RFileIO::writeAscii(modelFile,this-&gt;RResults::nelements);
    RFileIO::writeAscii(modelFile,uint(this-&gt;RResults::variables.size()));
    for (uint i=0;i&lt;this-&gt;RResults::variables.size();i++)
    {
        RFileIO::writeAscii(modelFile,this-&gt;RResults::variables[i]);
    }

    // Writing neighbor information.
    RFileIO::writeAscii(modelFile,uint(this-&gt;surfaceNeigs.size()));
    for (uint i=0;i&lt;this-&gt;surfaceNeigs.size();i++)
    {
        RFileIO::writeAscii(modelFile,this-&gt;surfaceNeigs[i]);
    }
    RFileIO::writeAscii(modelFile,uint(this-&gt;volumeNeigs.size()));
    for (uint i=0;i&lt;this-&gt;volumeNeigs.size();i++)
    {
        RFileIO::writeAscii(modelFile,this-&gt;volumeNeigs[i]);
    }

    modelFile.commit();

    RProgressFinalize("Done");
} /* RModel::writeAscii */


</t>
<t tx="leo.20201108101536.148">void RModel::writeBinary(const QString &amp;fileName) const
{
    RProgressInitialize("Writing model file");

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Writing binary model file \'%s\'\n",fileName.toUtf8().constData());

    RSaveFile modelFile(fileName,RSaveFile::BINARY);

    if (!modelFile.open(QIODevice::WriteOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    uint nsteps = this-&gt;getNNodes()
                        + this-&gt;getNElements()
                        + this-&gt;getNPoints()
                        + this-&gt;getNLines()
                        + this-&gt;getNSurfaces()
                        + this-&gt;getNVolumes()
                        + this-&gt;getNVectorFields()
                        + this-&gt;getNScalarFields()
                        + this-&gt;getNStreamLines()
                        + this-&gt;getNCuts()
                        + this-&gt;getNIsos();
    uint cstep = 0;

    RFileIO::writeBinary(modelFile,RFileHeader(R_FILE_TYPE_MODEL,_version));

    // Writing mesh/model values

    RFileIO::writeBinary(modelFile,this-&gt;name);
    RFileIO::writeBinary(modelFile,this-&gt;description);
    RFileIO::writeBinary(modelFile,this-&gt;getNNodes());
    for (uint i=0;i&lt;this-&gt;getNNodes();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;nodes[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;elements[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;getNPoints());
    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;points[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;getNLines());
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;lines[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;getNSurfaces());
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;surfaces[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;getNVolumes());
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;volumes[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;getNVectorFields());
    for (uint i=0;i&lt;this-&gt;getNVectorFields();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;vectorFields[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;getNScalarFields());
    for (uint i=0;i&lt;this-&gt;getNScalarFields();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;scalarFields[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;getNStreamLines());
    for (uint i=0;i&lt;this-&gt;getNStreamLines();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;streamLines[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;getNCuts());
    for (uint i=0;i&lt;this-&gt;getNCuts();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;cuts[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;getNIsos());
    for (uint i=0;i&lt;this-&gt;getNIsos();i++)
    {
        RProgressPrint(cstep++,nsteps);
        RFileIO::writeBinary(modelFile,this-&gt;isos[i]);
    }
    RFileIO::writeBinary(modelFile,this-&gt;modelData);

    // Writing problem values

    RFileIO::writeBinary(modelFile,this-&gt;taskTree);
    RFileIO::writeBinary(modelFile,this-&gt;timeSolver);
    RFileIO::writeBinary(modelFile,this-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));
    RFileIO::writeBinary(modelFile,this-&gt;getMatrixSolverConf(RMatrixSolverConf::GMRES));
    RFileIO::writeBinary(modelFile,this-&gt;monitoringPointManager);
    RFileIO::writeBinary(modelFile,this-&gt;problemSetup);

    // Writing results values

    RFileIO::writeBinary(modelFile,this-&gt;RResults::nnodes);
    RFileIO::writeBinary(modelFile,this-&gt;RResults::nelements);
    RFileIO::writeBinary(modelFile,uint(this-&gt;RResults::variables.size()));
    for (uint i=0;i&lt;this-&gt;RResults::variables.size();i++)
    {
        RFileIO::writeBinary(modelFile,this-&gt;RResults::variables[i]);
    }

    // Writing neighbor information.
    RFileIO::writeBinary(modelFile,uint(this-&gt;surfaceNeigs.size()));
    for (uint i=0;i&lt;this-&gt;surfaceNeigs.size();i++)
    {
        RFileIO::writeBinary(modelFile,this-&gt;surfaceNeigs[i]);
    }
    RFileIO::writeBinary(modelFile,uint(this-&gt;volumeNeigs.size()));
    for (uint i=0;i&lt;this-&gt;volumeNeigs.size();i++)
    {
        RFileIO::writeBinary(modelFile,this-&gt;volumeNeigs[i]);
    }

    modelFile.commit();

    RProgressFinalize("Done");
} /* RModel::writeBinary */


std::vector&lt;RUVector&gt; RModel::findSurfaceNeighbors() const
{
    std::vector&lt;RUVector&gt; neigs;

    RLogger::info("Finding surface neighbors\n");
    RLogger::indent();
    RProgressInitialize("Finding surface neighbors");

    neigs.resize(this-&gt;getNElements());

    RUVector surfaceElements;
    surfaceElements.reserve(this-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (R_ELEMENT_TYPE_IS_SURFACE(this-&gt;getElement(i).getType()))
        {
            surfaceElements.push_back(i);
            neigs[i].reserve(RElement::getNNeighbors(this-&gt;getElement(i).getType()));
        }
    }

    uint nProcessed = 0;
#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(surfaceElements.size());i++)
    {
        uint elementID1 = surfaceElements[uint(i)];
#pragma omp critical
        {
            RProgressPrint(++nProcessed,uint(surfaceElements.size()));
        }
        RLimitBox lb1,lb2;
        this-&gt;getElement(elementID1).findLimitBox(this-&gt;getNodes(),lb1);

        for (uint j=uint(i+1);j&lt;surfaceElements.size();j++)
        {
            uint elementID2 = surfaceElements[j];
            this-&gt;getElement(elementID2).findLimitBox(this-&gt;getNodes(),lb2);
            if (!RLimitBox::areIntersecting(lb1,lb2))
            {
                continue;
            }

            if (this-&gt;getElement(elementID1).isNeighbor(this-&gt;getElement(elementID2)))
            {
#pragma omp critical
                {
                    neigs[elementID1].push_back(elementID2);
                    neigs[elementID2].push_back(elementID1);
                }
            }
        }
    }

    RProgressFinalize();
    RLogger::unindent();
    return neigs;
} /* RModel::findSurfaceNeighbors */

std::vector&lt;RUVector&gt; RModel::findVolumeNeighbors() const
{
    std::vector&lt;RUVector&gt; neigs;

    RLogger::info("Finding volume neighbors\n");
    RLogger::indent();
    RProgressInitialize("Finding volume neighbors");

    neigs.resize(this-&gt;getNElements());

    RUVector volumeElements;
    RUVector volumeNeighborCount;
    volumeElements.reserve(this-&gt;getNElements());
    volumeNeighborCount.resize(this-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (R_ELEMENT_TYPE_IS_VOLUME(this-&gt;getElement(i).getType()))
        {
            volumeElements.push_back(i);
            volumeNeighborCount[i] = RElement::getNNeighbors(this-&gt;getElement(i).getType());
            neigs[i].reserve(volumeNeighborCount[i]);
        }
    }

    uint nProcessed = 0;
#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(volumeElements.size());i++)
    {
#pragma omp critical
        {
            RProgressPrint(++nProcessed,uint(volumeElements.size()));
        }
        uint elementID1 = volumeElements[uint(i)];

        if (neigs[elementID1].size() &gt;= volumeNeighborCount[elementID1])
        {
            continue;
        }

        RLimitBox lb1,lb2;
        this-&gt;getElement(elementID1).findLimitBox(this-&gt;getNodes(),lb1);

        for (uint j=uint(i+1);j&lt;volumeElements.size();j++)
        {
            uint elementID2 = volumeElements[j];

            if (neigs[elementID2].size() &gt;= volumeNeighborCount[elementID2])
            {
                continue;
            }

            this-&gt;getElement(elementID2).findLimitBox(this-&gt;getNodes(),lb2);
            if (!RLimitBox::areIntersecting(lb1,lb2))
            {
                continue;
            }

            bool skip = false;
            if (this-&gt;getElement(elementID1).isNeighbor(this-&gt;getElement(elementID2)))
            {
#pragma omp critical
                {
                    neigs[elementID1].push_back(elementID2);
                    neigs[elementID2].push_back(elementID1);
                    if (neigs[elementID1].size() == volumeNeighborCount[elementID1])
                    {
                        skip = true;
                    }
                }
            }
            if (skip)
            {
                break;
            }
        }
    }

    RProgressFinalize();
    RLogger::unindent();

    return neigs;
} /* RModel::findVolumeNeighbors */


</t>
<t tx="leo.20201108101536.149">void RModel::markSurfaceNeighbors(uint elementID,
                                 double angle,
                                 const std::vector&lt;RUVector&gt; &amp;neighbors,
                                 std::vector&lt;uint&gt; &amp;marks)
{
    uint cElementID;
    uint nElementID;
    double cnAngle;
    bool cposChanged;
    int cpos = 0;
    std::vector&lt;uint&gt; stack;
    stack.resize(this-&gt;getNElements());
    stack[uint(cpos)] = elementID;
    RR3Vector cNormal;
    RR3Vector nNormal;

    while (cpos &gt;= 0)
    {
        cposChanged = false;
        cElementID = stack[uint(cpos)];
        for (uint i=0;i&lt;neighbors[cElementID].size();i++)
        {
            nElementID = neighbors[cElementID][i];

            if (marks[cElementID] == marks[nElementID])
            {
                continue;
            }

            if (!this-&gt;getElement(cElementID).findNormal(this-&gt;nodes,cNormal[0],cNormal[1],cNormal[2]))
            {
                RLogger::warning("Failed to find normal for element \'%u\'.\n",cElementID);
                continue;
            }
            if (!this-&gt;getElement(nElementID).findNormal(this-&gt;nodes,nNormal[0],nNormal[1],nNormal[2]))
            {
                RLogger::warning("Failed to find normal for element \'%u\'.\n",nElementID);
                continue;
            }

            cnAngle = R_RAD_TO_DEG(RR3Vector::angle(cNormal,nNormal));

            if (cnAngle &lt;= angle || cnAngle &gt;= (360.0 - angle))
            {
                marks[nElementID] = marks[cElementID];
                stack[uint(++cpos)] = nElementID;
                cposChanged = true;
                break;
            }
        }
        if (!cposChanged)
        {
            cpos--;
        }
    }
} /* RModel::markSurfaceNeighbors */


</t>
<t tx="leo.20201108101536.15">void RModalSetup::setFrequency(double modeFrequency)
{
    this-&gt;frequency = modeFrequency;
}

</t>
<t tx="leo.20201108101536.150">void RModel::addEntityGroupIdReference(uint entityGroupId)
{
    for (uint i=0;i&lt;this-&gt;getNVectorFields();i++)
    {
        std::vector&lt;uint&gt; &amp;groupIDs(this-&gt;getVectorField(i).getElementGroupIDs());
        for (uint j=0;j&lt;groupIDs.size();j++)
        {
            if (groupIDs[j] &gt;= entityGroupId)
            {
                groupIDs[j]++;
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;getNScalarFields();i++)
    {
        std::vector&lt;uint&gt; &amp;groupIDs(this-&gt;getScalarField(i).getElementGroupIDs());
        for (uint j=0;j&lt;groupIDs.size();j++)
        {
            if (groupIDs[j] &gt;= entityGroupId)
            {
                groupIDs[j]++;
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;getNCuts();i++)
    {
        std::vector&lt;uint&gt; &amp;groupIDs(this-&gt;getCut(i).getElementGroupIDs());
        for (uint j=0;j&lt;groupIDs.size();j++)
        {
            if (groupIDs[j] &gt;= entityGroupId)
            {
                groupIDs[j]++;
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;getNIsos();i++)
    {
        std::vector&lt;uint&gt; &amp;groupIDs(this-&gt;getIso(i).getElementGroupIDs());
        for (uint j=0;j&lt;groupIDs.size();j++)
        {
            if (groupIDs[j] &gt;= entityGroupId)
            {
                groupIDs[j]++;
            }
        }
    }
} /* RModel::addEntityGroupIdReference */


</t>
<t tx="leo.20201108101536.151">void RModel::removeEntityGroupIdReference(uint entityGroupId)
{
    for (uint i=0;i&lt;this-&gt;getNVectorFields();i++)
    {
        this-&gt;getVectorField(i).removeElementGroupID(entityGroupId,true);
    }
    for (uint i=0;i&lt;this-&gt;getNScalarFields();i++)
    {
        this-&gt;getScalarField(i).removeElementGroupID(entityGroupId,true);
    }
    for (uint i=0;i&lt;this-&gt;getNCuts();i++)
    {
        this-&gt;getCut(i).removeElementGroupID(entityGroupId,true);
    }
    for (uint i=0;i&lt;this-&gt;getNIsos();i++)
    {
        this-&gt;getIso(i).removeElementGroupID(entityGroupId,true);
    }
}

</t>
<t tx="leo.20201108101536.152">void RModel::updateEntityGroupIdReferences(const QMap&lt;REntityGroupType, RUVector&gt; oldMap)
{
    QMap&lt;REntityGroupType,RUVector&gt; newMap = this-&gt;getEntityIDMap();

    QList&lt;uint&gt; addGroupIDs;
    QList&lt;uint&gt; removeGroupIDs;

    QMap&lt;REntityGroupType,RUVector&gt;::const_iterator iter = newMap.constBegin();
    while (iter != newMap.constEnd())
    {
        uint oldSize = uint(oldMap[iter.key()].size());
        uint newSize = uint(iter.value().size());

        for (uint i=oldSize;i&lt;newSize;i++)
        {
            addGroupIDs.append(iter.value().at(i));
        }

        for (uint i=newSize;i&lt;oldSize;i++)
        {
            removeGroupIDs.append(oldMap[iter.key()].at(i));
        }

        ++iter;
    }

    std::sort(addGroupIDs.begin(),addGroupIDs.end());
    std::sort(removeGroupIDs.begin(),removeGroupIDs.end());
    std::reverse(removeGroupIDs.begin(),removeGroupIDs.end());

    foreach (uint gid, addGroupIDs)
    {
        this-&gt;addEntityGroupIdReference(gid);
    }
    foreach (uint gid, removeGroupIDs)
    {
        this-&gt;removeEntityGroupIdReference(gid);
    }
} /* RModel::removeEntityGroupIdReferences */


</t>
<t tx="leo.20201108101536.153">void RModel::generateElementDistanceVector(uint startElementID, uint maximumDistance, double separationAngle, RDistanceVector&lt;uint&gt; &amp;distanceVector) const
{
    distanceVector.resize(this-&gt;getNElements(),RConstants::eod);
    distanceVector.fill(RConstants::eod);

    std::stack&lt;uint&gt; elementStack;

    uint elementID = startElementID;
    uint distance = 0;

    RR3Vector n1;
    RR3Vector n2;

    do
    {
        bool popPrevious = true;
        if (distance &lt;= maximumDistance)
        {
            distanceVector[elementID] = distance;
            if (distance &lt; maximumDistance)
            {
                this-&gt;getElement(elementID).findNormal(this-&gt;nodes,n1[0],n1[1],n1[2]);
                const std::vector&lt;uint&gt; *neighborIDs = this-&gt;getNeighborIDs(elementID);
                if (neighborIDs)
                {
                    for (uint i=0;i&lt;neighborIDs-&gt;size();i++)
                    {
                        if (distanceVector[neighborIDs-&gt;at(i)] &gt; distanceVector[elementID] + 1)
                        {
                            this-&gt;getElement(neighborIDs-&gt;at(i)).findNormal(this-&gt;nodes,n2[0],n2[1],n2[2]);
                            if (RR3Vector::angle(n1,n2) &lt; separationAngle)
                            {
                                elementStack.push(elementID);
                                elementID = neighborIDs-&gt;at(i);
                                distance ++;
                                popPrevious = false;
                                break;
                            }
                        }
                    }
                }
            }
        }
        if (popPrevious &amp;&amp; elementStack.size() &gt; 0)
        {
            elementID = elementStack.top();
            distance = distanceVector[elementID];
            elementStack.pop();
        }
    } while (elementID != startElementID);
} /* RModel::generateElementDistanceVector */


uint RModel::findNearNode(const RNode &amp;node, double tolerance, bool findNearest, uint nodeID) const
{
    uint nn = this-&gt;getNNodes();
    uint nearNode = RConstants::eod;
    double minDistance = DBL_MAX;

    for (uint i=0;i&lt;nn;i++)
    {
        if (i == nodeID)
        {
            continue;
        }
        if (tolerance == 0.0)
        {
            if (this-&gt;getNode(i) == node)
            {
                nearNode = i;
                break;
            }
        }
        else
        {
            double distance = this-&gt;getNode(i).getDistance(node);
            if (distance &lt; tolerance)
            {
                if (distance &lt; minDistance)
                {
                    minDistance = distance;
                    nearNode = i;
                    if (!findNearest)
                    {
                        break;
                    }
                }
            }
        }
    }

    return nearNode;
} /* RModel::findNearNode */
</t>
<t tx="leo.20201108101536.154">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_model_data.cpp                                       *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Model data class definition                         *
 *********************************************************************/

#include "rml_model_data.h"

RModelData::RModelData()
{
    this-&gt;_init();
}

RModelData::RModelData(const RModelData &amp;modelData)
{
    this-&gt;_init(&amp;modelData);
}

RModelData::~RModelData()
{
}

RModelData &amp; RModelData::operator =(const RModelData &amp;modelData)
{
    this-&gt;_init(&amp;modelData);
    return (*this);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101536.155">void RModelData::_init(const RModelData *pModelData)
{
    if (pModelData)
    {
        this-&gt;selected = pModelData-&gt;selected;
    }
}

</t>
<t tx="leo.20201108101536.156">bool RModelData::getSelected(void) const
{
    return this-&gt;selected;
}

</t>
<t tx="leo.20201108101536.157">void RModelData::setSelected(bool selected)
{
    this-&gt;selected = selected;
}
</t>
<t tx="leo.20201108101536.158">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_model_msh.cpp                                        *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   21-st January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: MSH (old range) model class definition              *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "rml_model_msh.h"
#include "rml_file_io.h"
#include "rml_file.h"
#include "rml_file_manager.h"


#define FSREAD(_inFile,_data,_size,_descStr)                   \
{                                                              \
    _inFile.read((char*)_data,_size);                          \
    if (_inFile.error() != RFile::NoError)                     \
    {                                                          \
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,_descStr);  \
    }                                                          \
}


#define FSWRITE(_outFile,_data,_size,_descStr)                 \
{                                                              \
    _outFile.write((char*)_data,_size);                        \
    if (_outFile.error() != RFile::NoError)                    \
    {                                                          \
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,_descStr); \
    }                                                          \
}


RModelMsh::RModelMsh ()
{
    this-&gt;_init();
} /* RModelMsh::RModelMsh */


RModelMsh::RModelMsh (const RModelMsh &amp;modelMsh)
{
    this-&gt;_init(&amp;modelMsh);
} /* RModelMsh::RModelMsh (copy) */


RModelMsh::~RModelMsh ()
{
} /* RModelMsh::~RModelMsh */


RModelMsh &amp; RModelMsh::operator = (const RModelMsh &amp;modelMsh)
{
    this-&gt;_init(&amp;modelMsh);
    return (*this);
} /* RModelMsh::operator = */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101536.159">void RModelMsh::_init (const RModelMsh *pModelMsh)
{
    if (pModelMsh)
    {
        this-&gt;title = pModelMsh-&gt;title;
        this-&gt;comment = pModelMsh-&gt;comment;
        this-&gt;nodes = pModelMsh-&gt;nodes;
        this-&gt;bodiesAll = pModelMsh-&gt;bodiesAll;
        this-&gt;bodies = pModelMsh-&gt;bodies;
        this-&gt;bodiesNeighbors = pModelMsh-&gt;bodiesNeighbors;
        this-&gt;facesAll = pModelMsh-&gt;facesAll;
        this-&gt;faces = pModelMsh-&gt;faces;
        this-&gt;facesNeighbors = pModelMsh-&gt;facesNeighbors;
        this-&gt;linesAll = pModelMsh-&gt;linesAll;
        this-&gt;lines = pModelMsh-&gt;lines;
        this-&gt;pointsAll = pModelMsh-&gt;pointsAll;
        this-&gt;points = pModelMsh-&gt;points;
        this-&gt;facesThickness = pModelMsh-&gt;facesThickness;
        this-&gt;linesCarea = pModelMsh-&gt;linesCarea;
        this-&gt;pointsVolume = pModelMsh-&gt;pointsVolume;
        this-&gt;bodiesNames = pModelMsh-&gt;bodiesNames;
        this-&gt;facesNames = pModelMsh-&gt;facesNames;
        this-&gt;linesNames = pModelMsh-&gt;linesNames;
        this-&gt;pointsNames = pModelMsh-&gt;pointsNames;
    }
} /* RModelMsh::_init */


</t>
<t tx="leo.20201108101536.16">const QString &amp;RModalSetup::getMethodName(RModalMethod modalMethod)
{
    R_ERROR_ASSERT(R_MODAL_METHOD_TYPE_IS_VALID(modalMethod));
    return modalMethodNames[modalMethod];
}
</t>
<t tx="leo.20201108101536.160">void RModelMsh::clear (void)
{
    this-&gt;title.clear();
    this-&gt;comment.clear();
    this-&gt;nodes.clear();
    this-&gt;bodiesAll.clear();
    this-&gt;bodies.clear();
    this-&gt;bodiesNeighbors.clear();
    this-&gt;facesAll.clear();
    this-&gt;faces.clear();
    this-&gt;facesNeighbors.clear();
    this-&gt;linesAll.clear();
    this-&gt;lines.clear();
    this-&gt;pointsAll.clear();
    this-&gt;points.clear();
    this-&gt;facesThickness.clear();
    this-&gt;linesCarea.clear();
    this-&gt;pointsVolume.clear();
    this-&gt;bodiesNames.clear();
    this-&gt;facesNames.clear();
    this-&gt;linesNames.clear();
    this-&gt;pointsNames.clear();
    this-&gt;bodiesNeighborsComputed = false;
    this-&gt;facesNeighborsComputed = false;
} /* RModelMsh::clear */


</t>
<t tx="leo.20201108101536.161">void RModelMsh::read (const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QString ext = RFileManager::getExtension(fileName).toLower();

    if (ext == "tmsh")
    {
        this-&gt;readAscii(fileName);
    }
    else if (ext == "bmsh")
    {
        this-&gt;readBinary(fileName);
    }
    else
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + QString(ext.toUtf8().constData()) + "\".");
    }
} /* RModelMsh::read */


</t>
<t tx="leo.20201108101536.162">void RModelMsh::write (const QString &amp;fileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QString ext = RFileManager::getExtension(fileName).toLower();

    if (ext == "tmsh")
    {
        this-&gt;writeAscii(fileName);
    }
    else if (ext == "bmsh")
    {
        this-&gt;writeBinary(fileName);
    }
    else
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + QString(ext.toUtf8().constData()) + "\".");
    }
} /* RModelMsh::write */


</t>
<t tx="leo.20201108101536.163">void RModelMsh::readAscii (const QString &amp;fileName)
{
    RProgressInitialize("Reading ASCII MSH file");
    QString flag;
    QString fVersion;

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    bool dTitleFound = false;
    bool dCommentFound = false;
    bool dFacesNComputedFound = false;
    bool dBodiesNComputedFound = false;
    bool dNodesFound = false;
    bool dBodiesAllFound = false;
    bool dFacesAllFound = false;
    bool dLinesAllFound = false;
    bool dPointsAllFound = false;
    bool dBodiesFound = false;
    bool dFacesFound = false;
    bool dLinesFound = false;
    bool dPointsFound = false;
    bool nodesFound = false;
    bool facesNeighborsFound = false;
    bool bodiesNeighborsFound = false;
    bool bodiesNamesFound = false;
    bool facesNamesFound = false;
    bool linesNamesFound = false;
    bool pointsNamesFound = false;
    bool facesThicknessFound = false;
    bool linesCareaFound = false;
    bool pointsVolumeFound = false;
    bool bodiesAllFound = false;
    bool facesAllFound = false;
    bool linesAllFound = false;
    bool pointsAllFound = false;
    bool bodiesFound = false;
    bool facesFound = false;
    bool linesFound = false;
    bool pointsFound = false;

    RFile mshFile(fileName,RFile::ASCII);

    if (!mshFile.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    unsigned int nsteps = 23;
    unsigned int cstep = 0;

    RProgressPrint(cstep++,nsteps);
    while (true)
    {
        mshFile.getTextStream() &gt;&gt; flag;
        if (mshFile.getTextStream().status() != QTextStream::Ok)
        {
            if (mshFile.getTextStream().atEnd())
            {
                break;
            }
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read the file \'%s\'",fileName.toUtf8().constData());
        }

        if (flag == "!VERSION:")
        {
            RFileIO::readAscii(mshFile,fVersion);
            RLogger::info("File version %s\n",fVersion.toUtf8().constData());
        }
        else if (flag == "TITLE:")
        {
            RFileIO::readAscii(mshFile,this-&gt;title);
            dTitleFound = true;
        }
        else if (flag == "COMMENT:")
        {
            RFileIO::readAscii(mshFile,this-&gt;comment);
            dCommentFound = true;
        }
        else if (flag == "FACESNCOMPUTED:")
        {
            RFileIO::readAscii(mshFile,this-&gt;facesNeighborsComputed);
            dFacesNComputedFound = true;
        }
        else if (flag == "BODIESNCOMPUTED:")
        {
            RFileIO::readAscii(mshFile,this-&gt;bodiesNeighborsComputed);
            dBodiesNComputedFound = true;
        }
        else if (flag == "NODES:")
        {
            unsigned int nr;
            unsigned int nc;
            RFileIO::readAscii(mshFile,nr);
            RFileIO::readAscii(mshFile,nc);
            this-&gt;nodes.resize(nr,nc);
            dNodesFound = true;
        }
        else if (flag == "BODIES_A:")
        {
            unsigned int nr;
            unsigned int nc;
            RFileIO::readAscii(mshFile,nr);
            RFileIO::readAscii(mshFile,nc);
            this-&gt;bodiesAll.resize(nr,nc);
            this-&gt;bodiesNeighbors.resize(nr,4);
            dBodiesAllFound = true;
        }
        else if (flag == "FACES_A:")
        {
            unsigned int nr;
            unsigned int nc;
            RFileIO::readAscii(mshFile,nr);
            RFileIO::readAscii(mshFile,nc);
            this-&gt;facesAll.resize(nr,nc);
            this-&gt;facesNeighbors.resize(nr,3);
            dFacesAllFound = true;
        }
        else if (flag == "LINES_A:")
        {
            unsigned int nr;
            unsigned int nc;
            RFileIO::readAscii(mshFile,nr);
            RFileIO::readAscii(mshFile,nc);
            this-&gt;linesAll.resize(nr,nc);
            dLinesAllFound = true;
        }
        else if (flag == "POINTS_A:")
        {
            unsigned int nr;
            unsigned int nc;
            RFileIO::readAscii(mshFile,nr);
            RFileIO::readAscii(mshFile,nc);
            this-&gt;pointsAll.resize(nr,nc);
            dPointsAllFound = true;
        }
        else if (flag == "BODIES:")
        {
            unsigned int nr;
            unsigned int nc;
            RFileIO::readAscii(mshFile,nr);
            RFileIO::readAscii(mshFile,nc);
            this-&gt;bodies.resize(nr,nc);
            this-&gt;bodiesNames.resize(nc);
            dBodiesFound = true;
        }
        else if (flag == "FACES:")
        {
            unsigned int nr;
            unsigned int nc;
            RFileIO::readAscii(mshFile,nr);
            RFileIO::readAscii(mshFile,nc);
            this-&gt;faces.resize(nr,nc);
            this-&gt;facesNames.resize(nc);
            this-&gt;facesThickness.resize(nc);
            dFacesFound = true;
        }
        else if (flag == "LINES:")
        {
            unsigned int nr;
            unsigned int nc;
            RFileIO::readAscii(mshFile,nr);
            RFileIO::readAscii(mshFile,nc);
            this-&gt;lines.resize(nr,nc);
            this-&gt;linesNames.resize(nc);
            this-&gt;linesCarea.resize(nc);
            dLinesFound = true;
        }
        else if (flag == "POINTS:")
        {
            unsigned int nr;
            unsigned int nc;
            RFileIO::readAscii(mshFile,nr);
            RFileIO::readAscii(mshFile,nc);
            this-&gt;points.resize(nr,nc);
            this-&gt;pointsNames.resize(nc);
            this-&gt;pointsVolume.resize(nc);
            dPointsFound = true;
        }

        if (dTitleFound &amp;&amp;
            dCommentFound &amp;&amp;
            dFacesNComputedFound &amp;&amp;
            dBodiesNComputedFound &amp;&amp;
            dNodesFound &amp;&amp;
            dBodiesAllFound &amp;&amp;
            dFacesAllFound &amp;&amp;
            dLinesAllFound &amp;&amp;
            dPointsAllFound &amp;&amp;
            dBodiesFound &amp;&amp;
            dFacesFound &amp;&amp;
            dLinesFound &amp;&amp;
            dPointsFound)
        {
            break;
        }
    }
    if (!dTitleFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'TITLE\' information.");
    }
    if (!dCommentFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'COMMENT\' information.");
    }
    if (!dFacesNComputedFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'FACESNCOMPUTED\' information.");
    }
    if (!dBodiesNComputedFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'BODIESNCOMPUTED\' information.");
    }
    if (!dNodesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'NODES\' information.");
    }
    if (!dBodiesAllFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'BODIES_A\' information.");
    }
    if (!dFacesAllFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'FACES_A\' information.");
    }
    if (!dLinesAllFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'LINES_A\' information.");
    }
    if (!dPointsAllFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'POINTS_A\' information.");
    }
    if (!dBodiesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'BODIES\' information.");
    }
    if (!dFacesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'FACES\' information.");
    }
    if (!dLinesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'LINES\' information.");
    }
    if (!dPointsFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'POINTS\' information.");
    }

    mshFile.seek(0);

    while (true)
    {
        mshFile.getTextStream() &gt;&gt; flag;
        if (mshFile.getTextStream().status() != QTextStream::Ok)
        {
            if(mshFile.getTextStream().atEnd())
            {
                break;
            }
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read the file.");
        }

        if (flag == "nodes:")
        {
            RFileIO::readAscii(mshFile,this-&gt;nodes,false);
            nodesFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "faces_neighbors:")
        {
            RFileIO::readAscii(mshFile,this-&gt;facesNeighbors,false);
            facesNeighborsFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "bodies_neighbors:")
        {
            RFileIO::readAscii(mshFile,this-&gt;bodiesNeighbors,false);
            bodiesNeighborsFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "bodies_names:")
        {
            for (unsigned int i=0;i&lt;this-&gt;bodiesNames.size();i++)
            {
                RFileIO::readAscii(mshFile,this-&gt;bodiesNames[i]);
            }
            bodiesNamesFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "faces_names:")
        {
            for (unsigned int i=0;i&lt;this-&gt;facesNames.size();i++)
            {
                RFileIO::readAscii(mshFile,this-&gt;facesNames[i]);
            }
            facesNamesFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "lines_names:")
        {
            for (unsigned int i=0;i&lt;this-&gt;linesNames.size();i++)
            {
                RFileIO::readAscii(mshFile,this-&gt;linesNames[i]);
            }
            linesNamesFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "points_names:")
        {
            for (unsigned int i=0;i&lt;this-&gt;pointsNames.size();i++)
            {
                RFileIO::readAscii(mshFile,this-&gt;pointsNames[i]);
            }
            pointsNamesFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "faces_thickness:")
        {
            RFileIO::readAscii(mshFile,this-&gt;facesThickness,false);
            facesThicknessFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "lines_carea:")
        {
            RFileIO::readAscii(mshFile,this-&gt;linesCarea,false);
            linesCareaFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "points_volume:")
        {
            RFileIO::readAscii(mshFile,this-&gt;pointsVolume,false);
            pointsVolumeFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "bodies_all:")
        {
            RFileIO::readAscii(mshFile,this-&gt;bodiesAll,false);
            bodiesAllFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "faces_all:")
        {
            RFileIO::readAscii(mshFile,this-&gt;facesAll,false);
            facesAllFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "lines_all:")
        {
            RFileIO::readAscii(mshFile,this-&gt;linesAll,false);
            linesAllFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "points_all:")
        {
            RFileIO::readAscii(mshFile,this-&gt;pointsAll,false);
            pointsAllFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "bodies:")
        {
            RFileIO::readAscii(mshFile,this-&gt;bodies,false);
            bodiesFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "faces:")
        {
            RFileIO::readAscii(mshFile,this-&gt;faces,false);
            facesFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "lines:")
        {
            RFileIO::readAscii(mshFile,this-&gt;lines,false);
            linesFound = true;
            RProgressPrint(cstep++,nsteps);
        }
        else if (flag == "points:")
        {
            RFileIO::readAscii(mshFile,this-&gt;points,false);
            pointsFound = true;
            RProgressPrint(cstep++,nsteps);
        }

        if (nodesFound &amp;&amp;
            facesNeighborsFound &amp;&amp;
            bodiesNeighborsFound &amp;&amp;
            bodiesNamesFound &amp;&amp;
            facesNamesFound &amp;&amp;
            linesNamesFound &amp;&amp;
            pointsNamesFound &amp;&amp;
            facesThicknessFound &amp;&amp;
            linesCareaFound &amp;&amp;
            pointsVolumeFound &amp;&amp;
            bodiesAllFound &amp;&amp;
            facesAllFound &amp;&amp;
            linesAllFound &amp;&amp;
            pointsAllFound &amp;&amp;
            bodiesFound &amp;&amp;
            facesFound &amp;&amp;
            linesFound &amp;&amp;
            pointsFound)
        {
            break;
        }
    }

    if (!nodesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'nodes\' data.");
    }
    if (!facesNeighborsFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'faces_neighbors\' data.");
    }
    if (!bodiesNeighborsFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'bodies_neighbors\' data.");
    }
    if (!bodiesNamesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'bodies_names\' data.");
    }
    if (!facesNamesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'faces_names\' data.");
    }
    if (!linesNamesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'lines_names\' data.");
    }
    if (!pointsNamesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'points_names\' data.");
    }
    if (!facesThicknessFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'faces_thickness\' data.");
    }
    if (!linesCareaFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'lines_carea\' data.");
    }
    if (!pointsVolumeFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'points_volume\' data.");
    }
    if (!bodiesAllFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'bodies_all\' data.");
    }
    if (!facesAllFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'faces_all\' data.");
    }
    if (!linesAllFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'lines_all\' data.");
    }
    if (!pointsAllFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'points_all\' data.");
    }
    if (!bodiesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'bodies\' data.");
    }
    if (!facesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'faces\' data.");
    }
    if (!linesFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'lines\' data.");
    }
    if (!pointsFound)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF, "File is missing \'points\' data.");
    }

    this-&gt;bodies.transpose();
    RProgressPrint(cstep++,nsteps);
    this-&gt;faces.transpose();
    RProgressPrint(cstep++,nsteps);
    this-&gt;lines.transpose();
    RProgressPrint(cstep++,nsteps);
    this-&gt;points.transpose();
    RProgressPrint(cstep++,nsteps);

    mshFile.close();

    RProgressFinalize("Done");
} /* RModelMsh::readAscii */


</t>
<t tx="leo.20201108101536.164">void RModelMsh::readBinary (const QString &amp;fileName)
{
    unsigned int vMaj;
    unsigned int vMin;
    unsigned int vRel;
    int iValue;
    int iarr[18];
    char buffer[1024];

    RProgressInitialize("Reading binary MSH file");

    RFile mshFile(fileName,RFile::BINARY);

    if (!mshFile.open(QIODevice::ReadOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    FSREAD(mshFile,&amp;vMaj,sizeof(int),"Failed to read major version.");
    FSREAD(mshFile,&amp;vMin,sizeof(int),"Failed to read minor version.");
    FSREAD(mshFile,&amp;vRel,sizeof(int),"Failed to read release version.");
    RLogger::info("File version %u.%u.%u\n",vMaj,vMin,vRel);
    FSREAD(mshFile,&amp;iValue,sizeof(int),"Failed to read link flag.");
    FSREAD(mshFile,buffer,256*sizeof(char),"Failed to read model title.");
    this-&gt;title = buffer;
    FSREAD(mshFile,buffer,1024*sizeof(char),"Failed to read model comment.");
    this-&gt;comment = buffer;
    FSREAD(mshFile,iarr,18*sizeof(int),"Failed to read model size definitions.");

    unsigned int nn  = iarr[0];
    unsigned int nba = iarr[2];
    unsigned int nfa = iarr[4];
    unsigned int nla = iarr[6];
    unsigned int npa = iarr[8];
    unsigned int nb  = iarr[10];
    unsigned int nbc = iarr[11];
    unsigned int nf  = iarr[12];
    unsigned int nfc = iarr[13];
    unsigned int nl  = iarr[14];
    unsigned int nlc = iarr[15];
    unsigned int np  = iarr[16];
    unsigned int npc = iarr[17];

    this-&gt;nodes.resize (nn, 3);
    this-&gt;bodiesAll.resize (nba, 4);
    this-&gt;bodiesNeighbors.resize (nba, 4);
    this-&gt;facesAll.resize (nfa, 3);
    this-&gt;facesNeighbors.resize (nfa, 3);
    this-&gt;linesAll.resize (nla, 2);
    this-&gt;pointsAll.resize (npa, 1);
    this-&gt;bodies.resize (nb, nbc);
    this-&gt;bodiesNames.resize (nb);
    this-&gt;faces.resize (nf, nfc);
    this-&gt;facesNames.resize (nf);
    this-&gt;facesThickness.resize (nf);
    this-&gt;lines.resize (nl, nlc);
    this-&gt;linesNames.resize (nl);
    this-&gt;linesCarea.resize (nl);
    this-&gt;points.resize (np, npc);
    this-&gt;pointsNames.resize (np);
    this-&gt;pointsVolume.resize (np);

    FSREAD(mshFile,&amp;iValue,sizeof(int),"Failed to read body neighbors computed flag.");
    this-&gt;bodiesNeighborsComputed = (bool)iValue;
    FSREAD(mshFile,&amp;iValue,sizeof(int),"Failed to read face neighbors computed flag.");
    this-&gt;facesNeighborsComputed = (bool)iValue;

    unsigned int pst = 0;
    @others
} /* RModelMsh::readBinary */


</t>
<t tx="leo.20201108101536.165">unsigned int npst = 3*nn
 + 4*nba + 3*nfa + 2*nla + npa
 + nb*nbc + nb
 + nf*nfc + nf + nf
 + nl*nlc + nl + nl
 + np*npc + np + np;
if (this-&gt;bodiesNeighborsComputed) {
        npst += 4*nba;
}
if (this-&gt;facesNeighborsComputed) {
        npst += 3*nfa;
}

// nodes
for (unsigned int i=0;i&lt;nn;i++) {
    FSREAD(mshFile,&amp;this-&gt;nodes[i][0],sizeof(double),"Failed to read node X coordinate.");
    RProgressPrint(++pst,npst);
    FSREAD(mshFile,&amp;this-&gt;nodes[i][1],sizeof(double),"Failed to read node Y coordinate.");
    RProgressPrint(++pst,npst);
    FSREAD(mshFile,&amp;this-&gt;nodes[i][2],sizeof(double),"Failed to read node Z coordinate.");
    RProgressPrint(++pst,npst);
}
// bodies all
for (unsigned int i=0;i&lt;nba;i++) {
    FSREAD(mshFile,&amp;this-&gt;bodiesAll[i][0],sizeof(int),"Failed to read body element 1.st node.");
    RProgressPrint(++pst,npst);
    FSREAD(mshFile,&amp;this-&gt;bodiesAll[i][1],sizeof(int),"Failed to read body element 2.nd node.");
    RProgressPrint(++pst,npst);
    FSREAD(mshFile,&amp;this-&gt;bodiesAll[i][2],sizeof(int),"Failed to read body element 3.rd node.");
    RProgressPrint(++pst,npst);
    FSREAD(mshFile,&amp;this-&gt;bodiesAll[i][3],sizeof(int),"Failed to read body element 4.th node.");
    RProgressPrint(++pst,npst);
}
// faces all
for (unsigned int i=0;i&lt;nfa;i++) {
    FSREAD(mshFile,&amp;this-&gt;facesAll[i][0],sizeof(int),"Failed to read face element 1.st node.");
    RProgressPrint(++pst,npst);
    FSREAD(mshFile,&amp;this-&gt;facesAll[i][1],sizeof(int),"Failed to read face element 2.nd node.");
    RProgressPrint(++pst,npst);
    FSREAD(mshFile,&amp;this-&gt;facesAll[i][2],sizeof(int),"Failed to read face element 3.rd node.");
    RProgressPrint(++pst,npst);
}
// lines all
for (unsigned int i=0;i&lt;nla;i++) {
    FSREAD(mshFile,&amp;this-&gt;linesAll[i][0],sizeof(int),"Failed to read line element 1.st node.");
    RProgressPrint(++pst,npst);
    FSREAD(mshFile,&amp;this-&gt;linesAll[i][1],sizeof(int),"Failed to read line element 2.nd node.");
    RProgressPrint(++pst,npst);
}
// points all
for (unsigned int i=0;i&lt;npa;i++) {
    FSREAD(mshFile,&amp;this-&gt;pointsAll[i][0],sizeof(int),"Failed to read point element node.");
    RProgressPrint(++pst,npst);
}
// bodies
for (unsigned int i=0;i&lt;nb;i++) {
    for (unsigned int j=0;j&lt;nbc;j++) {
        FSREAD(mshFile,&amp;this-&gt;bodies[i][j],sizeof(int),"Failed to read body element.");
        RProgressPrint(++pst,npst);
    }
}
// faces
for (unsigned int i=0;i&lt;nf;i++) {
    for (unsigned int j=0;j&lt;nfc;j++) {
        FSREAD(mshFile,&amp;this-&gt;faces[i][j],sizeof(int),"Failed to read face element.");
        RProgressPrint(++pst,npst);
    }
}
// lines
for (unsigned int i=0;i&lt;nl;i++) {
    for (unsigned int j=0;j&lt;nlc;j++) {
        FSREAD(mshFile,&amp;this-&gt;lines[i][j],sizeof(int),"Failed to read line element.");
        RProgressPrint(++pst,npst);
    }
}
// points
for (unsigned int i=0;i&lt;np;i++) {
    for (unsigned int j=0;j&lt;npc;j++) {
        FSREAD(mshFile,&amp;this-&gt;points[i][j],sizeof(int),"Failed to read point element.");
        RProgressPrint(++pst,npst);
    }
}
// body names
for (unsigned int i=0;i&lt;nb;i++) {
    FSREAD(mshFile,buffer,256*sizeof(char),"Failed to read body name.");
    RProgressPrint(++pst,npst);
    this-&gt;bodiesNames[i] = buffer;
}
// face names
for (unsigned int i=0;i&lt;nf;i++) {
    FSREAD(mshFile,buffer,256*sizeof(char),"Failed to read face name.");
    RProgressPrint(++pst,npst);
    this-&gt;facesNames[i] = buffer;
}
// line names
for (unsigned int i=0;i&lt;nl;i++) {
    FSREAD(mshFile,buffer,256*sizeof(char),"Failed to read line name.");
    RProgressPrint(++pst,npst);
    this-&gt;linesNames[i] = buffer;
}
// point names
for (unsigned int i=0;i&lt;np;i++) {
    FSREAD(mshFile,buffer,256*sizeof(char),"Failed to read point name.");
    RProgressPrint(++pst,npst);
    this-&gt;pointsNames[i] = buffer;
}
// face thickness
for (unsigned int i=0;i&lt;nf;i++) {
    FSREAD(mshFile,&amp;this-&gt;facesThickness[i],sizeof(double),"Failed to read face thickness.");
    RProgressPrint(++pst,npst);
}
// line carea
for (unsigned int i=0;i&lt;nl;i++) {
    FSREAD(mshFile,&amp;this-&gt;linesCarea[i],sizeof(double),"Failed to read line cross-area.");
    RProgressPrint(++pst,npst);
}
// point volume
for (unsigned int i=0;i&lt;np;i++) {
    FSREAD(mshFile,&amp;this-&gt;pointsVolume[i],sizeof(double),"Failed to read point volume.");
    RProgressPrint(++pst,npst);
}
// body neighbors
if (this-&gt;bodiesNeighborsComputed)
{
    for (unsigned int i=0;i&lt;nba;i++) {
        FSREAD(mshFile,&amp;this-&gt;bodiesNeighbors[i][0],sizeof(int),"Failed to read body element 1.st neighbor.");
        RProgressPrint(++pst,npst);
        FSREAD(mshFile,&amp;this-&gt;bodiesNeighbors[i][1],sizeof(int),"Failed to read body element 2.nd neighbor.");
        RProgressPrint(++pst,npst);
        FSREAD(mshFile,&amp;this-&gt;bodiesNeighbors[i][2],sizeof(int),"Failed to read body element 3.rd neighbor.");
        RProgressPrint(++pst,npst);
        FSREAD(mshFile,&amp;this-&gt;bodiesNeighbors[i][3],sizeof(int),"Failed to read body element 4.th neighbor.");
        RProgressPrint(++pst,npst);
    }
}
// face neighbors
if (this-&gt;facesNeighborsComputed)
{
    for (unsigned int i=0;i&lt;nfa;i++) {
        FSREAD(mshFile,&amp;this-&gt;facesNeighbors[i][0],sizeof(int),"Failed to read face element 1.st neighbor.");
        RProgressPrint(++pst,npst);
        FSREAD(mshFile,&amp;this-&gt;facesNeighbors[i][1],sizeof(int),"Failed to read face element 2.nd neighbor.");
        RProgressPrint(++pst,npst);
        FSREAD(mshFile,&amp;this-&gt;facesNeighbors[i][2],sizeof(int),"Failed to read face element 3.rd neighbor.");
        RProgressPrint(++pst,npst);
    }
}

mshFile.close();

RProgressFinalize("Done");
</t>
<t tx="leo.20201108101536.166">void RModelMsh::writeAscii (const QString &amp;fileName) const
{
    RProgressInitialize("Writing ASCII MSH file");

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RSaveFile mshFile(fileName,RSaveFile::ASCII);

    if (!mshFile.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RIMatrix tmpMat;
    unsigned int cstep = 0;
    unsigned int nsteps = 20;
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"!VERSION: 2.3.0");
    RFileIO::writeAscii(mshFile,"# --== Range Software - Mesh File ==--");
    RFileIO::writeNewLineAscii(mshFile);
    RFileIO::writeAscii(mshFile,"# MESH DESCRIPTION");
    RFileIO::writeAscii(mshFile,"TITLE: \"" + this-&gt;title + "\"");
    RFileIO::writeAscii(mshFile,"COMMENT: \"" + this-&gt;comment + "\"");
    RFileIO::writeNewLineAscii(mshFile);
    RFileIO::writeAscii(mshFile,"# MESH SIZES");
    RFileIO::writeNewLineAscii(mshFile);
    RFileIO::writeAscii(mshFile,"FACESNCOMPUTED: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;facesNeighborsComputed);
    RFileIO::writeAscii(mshFile,"BODIESNCOMPUTED: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;bodiesNeighborsComputed);
    RFileIO::writeNewLineAscii(mshFile);
    RFileIO::writeAscii(mshFile,"NODES: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;nodes.getNRows(), false);
    RFileIO::writeAscii(mshFile," ",false);
    RFileIO::writeAscii(mshFile,this-&gt;nodes.getNColumns());
    RFileIO::writeAscii(mshFile,"BODIES_A: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;bodiesAll.getNRows(), false);
    RFileIO::writeAscii(mshFile," ",false);
    RFileIO::writeAscii(mshFile,this-&gt;bodiesAll.getNColumns());
    RFileIO::writeAscii(mshFile,"FACES_A: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;facesAll.getNRows(), false);
    RFileIO::writeAscii(mshFile," ",false);
    RFileIO::writeAscii(mshFile,this-&gt;facesAll.getNColumns());
    RFileIO::writeAscii(mshFile,"LINES_A: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;linesAll.getNRows(), false);
    RFileIO::writeAscii(mshFile," ",false);
    RFileIO::writeAscii(mshFile,this-&gt;linesAll.getNColumns());
    RFileIO::writeAscii(mshFile,"POINTS_A: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;pointsAll.getNRows(), false);
    RFileIO::writeAscii(mshFile," ",false);
    RFileIO::writeAscii(mshFile,this-&gt;pointsAll.getNColumns());
    RFileIO::writeAscii(mshFile,"BODIES: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;bodies.getNColumns(), false);
    RFileIO::writeAscii(mshFile," ",false);
    RFileIO::writeAscii(mshFile,this-&gt;bodies.getNRows());
    RFileIO::writeAscii(mshFile,"FACES: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;faces.getNColumns(), false);
    RFileIO::writeAscii(mshFile," ",false);
    RFileIO::writeAscii(mshFile,this-&gt;faces.getNRows());
    RFileIO::writeAscii(mshFile,"LINES: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;lines.getNColumns(), false);
    RFileIO::writeAscii(mshFile," ",false);
    RFileIO::writeAscii(mshFile,this-&gt;lines.getNRows());
    RFileIO::writeAscii(mshFile,"POINTS: ",false);
    RFileIO::writeAscii(mshFile,this-&gt;points.getNColumns(), false);
    RFileIO::writeAscii(mshFile," ",false);
    RFileIO::writeAscii(mshFile,this-&gt;points.getNRows());
    RFileIO::writeNewLineAscii(mshFile);
    RFileIO::writeAscii(mshFile,"# MESH VALUES");
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"nodes:");
    RFileIO::writeAscii(mshFile,this-&gt;nodes,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"faces_neighbors:");
    RFileIO::writeAscii(mshFile,this-&gt;facesNeighbors,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"bodies_neighbors:");
    RFileIO::writeAscii(mshFile,this-&gt;bodiesNeighbors,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"bodies_names:");
    for (unsigned int i=0;i&lt;this-&gt;bodiesNames.size();i++)
    {
        RFileIO::writeAscii(mshFile,this-&gt;bodiesNames[i]);
    }
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"faces_names:");
    for (unsigned int i=0;i&lt;this-&gt;facesNames.size();i++)
    {
        RFileIO::writeAscii(mshFile,this-&gt;facesNames[i]);
    }
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"lines_names:");
    for (unsigned int i=0;i&lt;this-&gt;linesNames.size();i++)
    {
        RFileIO::writeAscii(mshFile,this-&gt;linesNames[i]);
    }
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"points_names:");
    for (unsigned int i=0;i&lt;this-&gt;pointsNames.size();i++)
    {
        RFileIO::writeAscii(mshFile,this-&gt;pointsNames[i]);
    }
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"faces_thickness:");
    RFileIO::writeAscii(mshFile,this-&gt;facesThickness,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"lines_carea:");
    RFileIO::writeAscii(mshFile,this-&gt;linesCarea,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"points_volume:");
    RFileIO::writeAscii(mshFile,this-&gt;pointsVolume,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"bodies_all:");
    RFileIO::writeAscii(mshFile,this-&gt;bodiesAll,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"faces_all:");
    RFileIO::writeAscii(mshFile,this-&gt;facesAll,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"lines_all:");
    RFileIO::writeAscii(mshFile,this-&gt;linesAll,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"points_all:");
    RFileIO::writeAscii(mshFile,this-&gt;pointsAll,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"bodies:");
    tmpMat = this-&gt;bodies;
    tmpMat.transpose();
    RFileIO::writeAscii(mshFile,tmpMat,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"faces:");
    tmpMat = this-&gt;faces;
    tmpMat.transpose();
    RFileIO::writeAscii(mshFile,tmpMat,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"lines:");
    tmpMat = this-&gt;lines;
    tmpMat.transpose();
    RFileIO::writeAscii(mshFile,tmpMat,false);
    RFileIO::writeNewLineAscii(mshFile);
    RProgressPrint(cstep++,nsteps);
    RFileIO::writeAscii(mshFile,"points:");
    tmpMat = this-&gt;points;
    tmpMat.transpose();
    RFileIO::writeAscii(mshFile,tmpMat,false);
    RProgressPrint(cstep++,nsteps);

    mshFile.commit();

    RProgressFinalize("Done");
} /* RModelMsh::writeAscii */


</t>
<t tx="leo.20201108101536.167">void RModelMsh::writeBinary (const QString &amp;fileName) const
{
    unsigned int vMaj = 2;
    unsigned int vMin = 3;
    unsigned int vRel = 0;
    int iValue = 0;
    int iarr[18];
    char buffer[256];

    RProgressInitialize("Writing binary MSH file");

    RFile mshFile(fileName,RFile::BINARY);

    if (!mshFile.open(QIODevice::WriteOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    FSWRITE(mshFile,&amp;vMaj,sizeof(int),"Failed to write major version.");
    FSWRITE(mshFile,&amp;vMin,sizeof(int),"Failed to write minor version.");
    FSWRITE(mshFile,&amp;vRel,sizeof(int),"Failed to write release version.");
    FSWRITE(mshFile,&amp;iValue,sizeof(int),"Failed to write link flag.");
    snprintf(buffer,256,"%s",this-&gt;title.toUtf8().constData());
    FSWRITE(mshFile,buffer,256*sizeof(char),"Failed to write model title.");
    snprintf(buffer,256,"%s",this-&gt;comment.toUtf8().constData());
    FSWRITE(mshFile,buffer,256*sizeof(char),"Failed to write model comment.");

    iarr[0] = this-&gt;nodes.getNRows();
    iarr[1] = this-&gt;nodes.getNColumns();
    iarr[2] = this-&gt;bodiesAll.getNRows();
    iarr[3] = this-&gt;bodiesAll.getNColumns();
    iarr[4] = this-&gt;facesAll.getNRows();
    iarr[5] = this-&gt;facesAll.getNColumns();
    iarr[6] = this-&gt;linesAll.getNRows();
    iarr[7] = this-&gt;linesAll.getNColumns();
    iarr[8] = this-&gt;pointsAll.getNRows();
    iarr[9] = this-&gt;pointsAll.getNColumns();
    iarr[10] = this-&gt;bodies.getNRows();
    iarr[11] = this-&gt;bodies.getNColumns();
    iarr[12] = this-&gt;faces.getNRows();
    iarr[13] = this-&gt;faces.getNColumns();
    iarr[14] = this-&gt;lines.getNRows();
    iarr[15] = this-&gt;lines.getNColumns();
    iarr[16] = this-&gt;points.getNRows();
    iarr[17] = this-&gt;points.getNColumns();

    unsigned int nn  = iarr[0];
    unsigned int nba = iarr[2];
    unsigned int nfa = iarr[4];
    unsigned int nla = iarr[6];
    unsigned int npa = iarr[8];
    unsigned int nb  = iarr[10];
    unsigned int nbc = iarr[11];
    unsigned int nf  = iarr[12];
    unsigned int nfc = iarr[13];
    unsigned int nl  = iarr[14];
    unsigned int nlc = iarr[15];
    unsigned int np  = iarr[16];
    unsigned int npc = iarr[17];

    FSWRITE(mshFile,iarr,18*sizeof(int),"Failed to write model size definitions.");

    iValue = (int) this-&gt;bodiesNeighborsComputed;
    FSWRITE(mshFile,&amp;iValue,sizeof(int),"Failed to write body neighbors computed flag.");
    iValue = (int) this-&gt;facesNeighborsComputed;
    FSWRITE(mshFile,&amp;iValue,sizeof(int),"Failed to write face neighbors computed flag.");

    unsigned int pst = 0;
    @others
} /* RModelMsh::writeBinary */
</t>
<t tx="leo.20201108101536.168">unsigned int npst = 3*nn
 + 4*nba + 3*nfa + 2*nla + npa
 + nb*nbc + nb
 + nf*nfc + nf + nf
 + nl*nlc + nl + nl
 + np*npc + np + np;
if (this-&gt;bodiesNeighborsComputed) {
        npst += 4*nba;
}
if (this-&gt;facesNeighborsComputed) {
        npst += 3*nfa;
}

// nodes
for (unsigned int i=0;i&lt;nn;i++) {
    FSWRITE(mshFile,&amp;this-&gt;nodes[i][0],sizeof(double),"Failed to write node X coordinate.");
    RProgressPrint(++pst,npst);
    FSWRITE(mshFile,&amp;this-&gt;nodes[i][1],sizeof(double),"Failed to write node Y coordinate.");
    RProgressPrint(++pst,npst);
    FSWRITE(mshFile,&amp;this-&gt;nodes[i][2],sizeof(double),"Failed to write node Z coordinate.");
    RProgressPrint(++pst,npst);
}
// bodies all
for (unsigned int i=0;i&lt;nba;i++) {
    FSWRITE(mshFile,&amp;this-&gt;bodiesAll[i][0],sizeof(int),"Failed to write body element 1.st node.");
    RProgressPrint(++pst,npst);
    FSWRITE(mshFile,&amp;this-&gt;bodiesAll[i][1],sizeof(int),"Failed to write body element 2.nd node.");
    RProgressPrint(++pst,npst);
    FSWRITE(mshFile,&amp;this-&gt;bodiesAll[i][2],sizeof(int),"Failed to write body element 3.rd node.");
    RProgressPrint(++pst,npst);
    FSWRITE(mshFile,&amp;this-&gt;bodiesAll[i][3],sizeof(int),"Failed to write body element 4.th node.");
    RProgressPrint(++pst,npst);
}
// faces all
for (unsigned int i=0;i&lt;nfa;i++) {
    FSWRITE(mshFile,&amp;this-&gt;facesAll[i][0],sizeof(int),"Failed to write face element 1.st node.");
    RProgressPrint(++pst,npst);
    FSWRITE(mshFile,&amp;this-&gt;facesAll[i][1],sizeof(int),"Failed to write face element 2.nd node.");
    RProgressPrint(++pst,npst);
    FSWRITE(mshFile,&amp;this-&gt;facesAll[i][2],sizeof(int),"Failed to write face element 3.rd node.");
    RProgressPrint(++pst,npst);
}
// lines all
for (unsigned int i=0;i&lt;nla;i++) {
    FSWRITE(mshFile,&amp;this-&gt;linesAll[i][0],sizeof(int),"Failed to write line element 1.st node.");
    RProgressPrint(++pst,npst);
    FSWRITE(mshFile,&amp;this-&gt;linesAll[i][1],sizeof(int),"Failed to write line element 2.nd node.");
    RProgressPrint(++pst,npst);
}
// points all
for (unsigned int i=0;i&lt;npa;i++) {
    FSWRITE(mshFile,&amp;this-&gt;pointsAll[i][0],sizeof(int),"Failed to write point element node.");
    RProgressPrint(++pst,npst);
}
// bodies
for (unsigned int i=0;i&lt;nb;i++) {
    for (unsigned int j=0;j&lt;nbc;j++) {
        FSWRITE(mshFile,&amp;this-&gt;bodies[i][j],sizeof(int),"Failed to write body element.");
        RProgressPrint(++pst,npst);
    }
}
// faces
for (unsigned int i=0;i&lt;nf;i++) {
    for (unsigned int j=0;j&lt;nfc;j++) {
        FSWRITE(mshFile,&amp;this-&gt;faces[i][j],sizeof(int),"Failed to write face element.");
        RProgressPrint(++pst,npst);
    }
}
// lines
for (unsigned int i=0;i&lt;nl;i++) {
    for (unsigned int j=0;j&lt;nlc;j++) {
        FSWRITE(mshFile,&amp;this-&gt;lines[i][j],sizeof(int),"Failed to write line element.");
        RProgressPrint(++pst,npst);
    }
}
// points
for (unsigned int i=0;i&lt;np;i++) {
    for (unsigned int j=0;j&lt;npc;j++) {
        FSWRITE(mshFile,&amp;this-&gt;points[i][j],sizeof(int),"Failed to write point element.");
        RProgressPrint(++pst,npst);
    }
}
// body names
for (unsigned int i=0;i&lt;nb;i++) {
    snprintf(buffer,256,"%s",this-&gt;bodiesNames[i].toUtf8().constData());
    FSWRITE(mshFile,buffer,256*sizeof(char),"Failed to write body name.");
    RProgressPrint(++pst,npst);
}
// face names
for (unsigned int i=0;i&lt;nf;i++) {
    snprintf(buffer,256,"%s",this-&gt;facesNames[i].toUtf8().constData());
    FSWRITE(mshFile,buffer,256*sizeof(char),"Failed to write face name.");
    RProgressPrint(++pst,npst);
}
// line names
for (unsigned int i=0;i&lt;nl;i++) {
    snprintf(buffer,256,"%s",this-&gt;linesNames[i].toUtf8().constData());
    FSWRITE(mshFile,buffer,256*sizeof(char),"Failed to write line name.");
    RProgressPrint(++pst,npst);
}
// point names
for (unsigned int i=0;i&lt;np;i++) {
    snprintf(buffer,256,"%s",this-&gt;pointsNames[i].toUtf8().constData());
    FSWRITE(mshFile,buffer,256*sizeof(char),"Failed to write point name.");
    RProgressPrint(++pst,npst);
}
// face thickness
for (unsigned int i=0;i&lt;nf;i++) {
    FSWRITE(mshFile,&amp;this-&gt;facesThickness[i],sizeof(double),"Failed to write face thickness.");
    RProgressPrint(++pst,npst);
}
// line carea
for (unsigned int i=0;i&lt;nl;i++) {
    FSWRITE(mshFile,&amp;this-&gt;linesCarea[i],sizeof(double),"Failed to write line cross-area.");
    RProgressPrint(++pst,npst);
}
// point volume
for (unsigned int i=0;i&lt;np;i++) {
    FSWRITE(mshFile,&amp;this-&gt;pointsVolume[i],sizeof(double),"Failed to write point volume.");
    RProgressPrint(++pst,npst);
}
// body neighbors
if (this-&gt;bodiesNeighborsComputed)
{
    for (unsigned int i=0;i&lt;nba;i++) {
        FSWRITE(mshFile,&amp;this-&gt;bodiesNeighbors[i][0],sizeof(int),"Failed to write body element 1.st neighbor.");
        RProgressPrint(++pst,npst);
        FSWRITE(mshFile,&amp;this-&gt;bodiesNeighbors[i][1],sizeof(int),"Failed to write body element 2.nd neighbor.");
        RProgressPrint(++pst,npst);
        FSWRITE(mshFile,&amp;this-&gt;bodiesNeighbors[i][2],sizeof(int),"Failed to write body element 3.rd neighbor.");
        RProgressPrint(++pst,npst);
        FSWRITE(mshFile,&amp;this-&gt;bodiesNeighbors[i][3],sizeof(int),"Failed to write body element 4.th neighbor.");
        RProgressPrint(++pst,npst);
    }
}
// face neighbors
if (this-&gt;facesNeighborsComputed)
{
    for (unsigned int i=0;i&lt;nfa;i++) {
        FSWRITE(mshFile,&amp;this-&gt;facesNeighbors[i][0],sizeof(int),"Failed to write face element 1.st neighbor.");
        RProgressPrint(++pst,npst);
        FSWRITE(mshFile,&amp;this-&gt;facesNeighbors[i][1],sizeof(int),"Failed to write face element 2.nd neighbor.");
        RProgressPrint(++pst,npst);
        FSWRITE(mshFile,&amp;this-&gt;facesNeighbors[i][2],sizeof(int),"Failed to write face element 3.rd neighbor.");
        RProgressPrint(++pst,npst);
    }
}

mshFile.close();

RProgressFinalize("Done");
</t>
<t tx="leo.20201108101536.17">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_model.cpp                                            *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th December 2011                                       *
 *                                                                   *
 *  DESCRIPTION: Model class definition                              *
 *********************************************************************/

#include &lt;QDir&gt;
#include &lt;QSaveFile&gt;
#include &lt;QFile&gt;
#include &lt;QFileInfo&gt;
#include &lt;QTextStream&gt;
#include &lt;QSetIterator&gt;

#include &lt;vector&gt;
#include &lt;stack&gt;
#include &lt;cmath&gt;
#include &lt;float.h&gt;

#include &lt;rblib.h&gt;

#include "rml_model.h"
#include "rml_file_io.h"
#include "rml_file_manager.h"
#include "rml_view_factor_matrix.h"
#include "rml_polygon.h"
#include "rml_segment.h"


static const RVersion _version = RVersion(FILE_MAJOR_VERSION,FILE_MINOR_VERSION,FILE_RELEASE_VERSION);


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101536.18">void RModel::_init (const RModel *pModel)
{
    if (pModel)
    {
        this-&gt;name = pModel-&gt;name;
        this-&gt;description = pModel-&gt;description;
        this-&gt;nodes = pModel-&gt;nodes;
        this-&gt;elements = pModel-&gt;elements;
        this-&gt;points = pModel-&gt;points;
        this-&gt;lines = pModel-&gt;lines;
        this-&gt;surfaces = pModel-&gt;surfaces;
        this-&gt;volumes = pModel-&gt;volumes;
        this-&gt;vectorFields = pModel-&gt;vectorFields;
        this-&gt;scalarFields = pModel-&gt;scalarFields;
        this-&gt;streamLines = pModel-&gt;streamLines;
        this-&gt;cuts = pModel-&gt;cuts;
        this-&gt;isos = pModel-&gt;isos;
        this-&gt;surfaceNeigs = pModel-&gt;surfaceNeigs;
        this-&gt;volumeNeigs = pModel-&gt;volumeNeigs;
        this-&gt;modelData = pModel-&gt;modelData;
    }
} /* RModel::_init */


RModel::RModel ()
{
    this-&gt;_init ();
} /* RModel::RModel */


RModel::RModel (const RModel &amp;model) : RProblem (model)
                                     , RResults (model)
{
    this-&gt;_init (&amp;model);
} /* RModel::RModel copy */


RModel::RModel (const RModelMsh &amp;modelMsh)
{
    RNode node;
    RElement element;
    RUVector pointBook(modelMsh.pointsAll.getNRows());
    RUVector lineBook(modelMsh.linesAll.getNRows());
    RUVector faceBook(modelMsh.facesAll.getNRows());
    RUVector bodyBook(modelMsh.bodiesAll.getNRows());

    this-&gt;_init ();

    // Set name and description

    this-&gt;setName(modelMsh.title);
    this-&gt;setDescription(modelMsh.comment);

    // Convert nodes

    this-&gt;setNNodes(modelMsh.nodes.getNRows());
    for (uint i=0;i&lt;modelMsh.nodes.getNRows();i++)
    {
        node.set(modelMsh.nodes[i][0],modelMsh.nodes[i][1],modelMsh.nodes[i][2]);
        this-&gt;setNode(i,node);
    }

    // Convert elements

    this-&gt;setNElements(  modelMsh.pointsAll.getNRows()
                       + modelMsh.linesAll.getNRows()
                       + modelMsh.facesAll.getNRows()
                       + modelMsh.bodiesAll.getNRows());

    uint elNum = 0;
    element.setType(R_ELEMENT_POINT);
    for (uint i=0;i&lt;modelMsh.pointsAll.getNRows();i++)
    {
        pointBook[i] = elNum;
        element.setNodeId(0,uint(modelMsh.pointsAll[i][0]));
        this-&gt;setElement(elNum++,element);
    }

    element.setType(R_ELEMENT_TRUSS1);
    for (uint i=0;i&lt;modelMsh.linesAll.getNRows();i++)
    {
        lineBook[i] = elNum;
        element.setNodeId(0,uint(modelMsh.linesAll[i][0]));
        element.setNodeId(1,uint(modelMsh.linesAll[i][1]));
        this-&gt;setElement(elNum++,element);
    }

    element.setType(R_ELEMENT_TRI1);
    for (uint i=0;i&lt;modelMsh.facesAll.getNRows();i++)
    {
        faceBook[i] = elNum;
        element.setNodeId(0,uint(modelMsh.facesAll[i][0]));
        element.setNodeId(1,uint(modelMsh.facesAll[i][1]));
        element.setNodeId(2,uint(modelMsh.facesAll[i][2]));
        this-&gt;setElement(elNum++,element);
    }

    element.setType(R_ELEMENT_TETRA1);
    for (uint i=0;i&lt;modelMsh.bodiesAll.getNRows();i++)
    {
        bodyBook[i] = elNum;
        element.setNodeId(0,uint(modelMsh.bodiesAll[i][0]));
        element.setNodeId(1,uint(modelMsh.bodiesAll[i][1]));
        element.setNodeId(2,uint(modelMsh.bodiesAll[i][2]));
        element.setNodeId(3,uint(modelMsh.bodiesAll[i][3]));
        this-&gt;setElement(elNum++,element);
    }

    // Convert element groups

    this-&gt;setNPoints(modelMsh.points.getNRows());
    for (uint i=0;i&lt;modelMsh.points.getNRows();i++)
    {
        RPoint point;
        point.setName(modelMsh.pointsNames[i]);
        point.setVolume(modelMsh.pointsVolume[i]);
        point.resize(uint(modelMsh.points[i][1]));
        for (uint j=0;j&lt;uint(modelMsh.points[i][1]);j++)
        {
            point.set(j,pointBook[uint(modelMsh.points[i][j+2])]);
        }
        this-&gt;setPoint(i,point);
    }

    this-&gt;setNLines(modelMsh.lines.getNRows());
    for (uint i=0;i&lt;modelMsh.lines.getNRows();i++)
    {
        RLine line;
        line.setName(modelMsh.linesNames[i]);
        line.setCrossArea(modelMsh.linesCarea[i]);
        line.resize(uint(modelMsh.lines[i][1]));
        for (uint j=0;j&lt;uint(modelMsh.lines[i][1]);j++)
        {
            line.set(j,lineBook[uint(modelMsh.lines[i][j+2])]);
        }
        this-&gt;setLine(i,line);
    }

    this-&gt;setNSurfaces(modelMsh.faces.getNRows());
    for (uint i=0;i&lt;modelMsh.faces.getNRows();i++)
    {
        RSurface surface;
        surface.setName(modelMsh.facesNames[i]);
        surface.setThickness(modelMsh.facesThickness[i]);
        surface.resize(uint(modelMsh.faces[i][1]));
        for (uint j=0;j&lt;uint(modelMsh.faces[i][1]);j++)
        {
            surface.set(j,faceBook[uint(modelMsh.faces[i][j+2])]);
        }
        this-&gt;setSurface(i,surface);
    }

    this-&gt;setNVolumes(modelMsh.bodies.getNRows());
    for (uint i=0;i&lt;modelMsh.bodies.getNRows();i++)
    {
        RVolume volume;
        volume.setName(modelMsh.bodiesNames[i]);
        volume.resize(uint(modelMsh.bodies[i][1]));
        for (uint j=0;j&lt;uint(modelMsh.bodies[i][1]);j++)
        {
            volume.set(j,bodyBook[uint(modelMsh.bodies[i][j+2])]);
        }
        this-&gt;setVolume(i,volume);
    }
} /* RModel::RModel copy - MSH */


RModel::RModel (const RModelStl &amp;modelStl)
{
    this-&gt;_init ();
    this-&gt;setName(modelStl.getName());
    this-&gt;setDescription(modelStl.getDescription());
    this-&gt;setNNodes(modelStl.getNNodes());
    for (uint i=0;i&lt;this-&gt;getNNodes();i++)
    {
        this-&gt;setNode(i,modelStl.getNode(i));
    }
    this-&gt;setNElements(modelStl.getNElements());
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        this-&gt;setElement(i,modelStl.getElement(i));
    }
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        if (this-&gt;getSurface(i).getName().isEmpty())
        {
            this-&gt;getSurface(i).setName(QString("Surface ") + QString::number(i+1));
        }
    }
} /* RModel::RModel copy - STL */


RModel::RModel (const RModelRaw &amp;modelRaw,
</t>
<t tx="leo.20201108101536.19">                const QString &amp;name,
                const QString &amp;description)
{
    this-&gt;_init ();
    this-&gt;setName(name);
    this-&gt;setDescription(description);
    this-&gt;setNNodes(modelRaw.getNNodes());
    for (uint i=0;i&lt;this-&gt;getNNodes();i++)
    {
        this-&gt;setNode(i,modelRaw.getNode(i));
    }
    this-&gt;setNElements(modelRaw.getNElements());
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        this-&gt;setElement(i,modelRaw.getElement(i));
    }
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        if (this-&gt;getSurface(i).getName().isEmpty())
        {
            this-&gt;getSurface(i).setName(QString("Surface ") + QString::number(i+1));
        }
    }
} /* RModel::RModel copy - RAW */


RModel::~RModel ()
{
} /* RModel::~RModel */


RModel &amp; RModel::operator = (const RModel &amp;model)
{
    this-&gt;RProblem::operator = (model);
    this-&gt;RResults::operator = (model);
    this-&gt;_init (&amp;model);
    return (*this);
} /* RModel::operator = */

</t>
<t tx="leo.20201108101536.2">void RMeshSetup::_init(const RMeshSetup *pMeshSetup)
{
    if (pMeshSetup)
    {
        this-&gt;variables = pMeshSetup-&gt;variables;
        this-&gt;minEdgeLength = pMeshSetup-&gt;minEdgeLength;
        this-&gt;maxEdgeLength = pMeshSetup-&gt;maxEdgeLength;
    }
}

RMeshSetup::RMeshSetup()
    : minEdgeLength(0.0)
    , maxEdgeLength(0.0)
{
    this-&gt;_init();
}

RMeshSetup::RMeshSetup(const RMeshSetup &amp;meshSetup)
{
    this-&gt;_init(&amp;meshSetup);
}

RMeshSetup::~RMeshSetup()
{

}

RMeshSetup &amp;RMeshSetup::operator =(const RMeshSetup &amp;meshSetup)
{
    this-&gt;_init(&amp;meshSetup);
    return (*this);
}

</t>
<t tx="leo.20201108101536.20">void RModel::update(const RModel &amp;rModel)
{
    QMap&lt;REntityGroupType,RUVector&gt; oldEIDMap = this-&gt;getEntityIDMap();
//    QMap&lt;REntityGroupType,RUVector&gt; newEIDMap = rModel.getEntityIDMap();


    uint nUpdatePoints = std::min(this-&gt;getNPoints(),rModel.getNPoints());
    std::vector&lt;REntityGroupData&gt; updatePointGroupData;
    for (uint i=0;i&lt;nUpdatePoints;i++)
    {
        updatePointGroupData.push_back(this-&gt;getPoint(i).getData());
    }

    uint nUpdateLines = std::min(this-&gt;getNLines(),rModel.getNLines());
    std::vector&lt;REntityGroupData&gt; updateLineGroupData;
    for (uint i=0;i&lt;nUpdateLines;i++)
    {
        updateLineGroupData.push_back(this-&gt;getLine(i).getData());
    }

    uint nUpdateSurfaces = std::min(this-&gt;getNSurfaces(),rModel.getNSurfaces());
    std::vector&lt;REntityGroupData&gt; updateSurfaceGroupData;
    for (uint i=0;i&lt;nUpdateSurfaces;i++)
    {
        updateSurfaceGroupData.push_back(this-&gt;getSurface(i).getData());
    }

    uint nUpdateVolumes = std::min(this-&gt;getNVolumes(),rModel.getNVolumes());
    std::vector&lt;REntityGroupData&gt; updateVolumeGroupData;
    for (uint i=0;i&lt;nUpdateVolumes;i++)
    {
        updateVolumeGroupData.push_back(this-&gt;getVolume(i).getData());
    }

    std::vector&lt;RScalarField&gt; scalarFields;
    for (uint i=0;i&lt;this-&gt;getNScalarFields();i++)
    {
        scalarFields.push_back(this-&gt;getScalarField(i));
    }

    std::vector&lt;RVectorField&gt; vectorFields;
    for (uint i=0;i&lt;this-&gt;getNVectorFields();i++)
    {
        vectorFields.push_back(this-&gt;getVectorField(i));
    }

    std::vector&lt;RStreamLine&gt; streamLines;
    for (uint i=0;i&lt;this-&gt;getNStreamLines();i++)
    {
        streamLines.push_back(this-&gt;getStreamLine(i));
    }

    std::vector&lt;RCut&gt; cuts;
    for (uint i=0;i&lt;this-&gt;getNCuts();i++)
    {
        cuts.push_back(this-&gt;getCut(i));
    }

    std::vector&lt;RIso&gt; isos;
    for (uint i=0;i&lt;this-&gt;getNIsos();i++)
    {
        isos.push_back(this-&gt;getIso(i));
    }

    uint nUpdateVariables = std::min(this-&gt;getNVariables(),rModel.getNVariables());
    std::vector&lt;RVariableData&gt; updateVariableData;
    std::vector&lt;RVariableType&gt; updateVariableType;
    for (uint i=0;i&lt;nUpdateVariables;i++)
    {
        updateVariableData.push_back(this-&gt;getVariable(i).getVariableData());
        updateVariableType.push_back(this-&gt;getVariable(i).getType());
    }

    RTimeSolver timeSolver(this-&gt;getTimeSolver());

    this-&gt;operator =(rModel);

    for (uint i=0;i&lt;nUpdatePoints;i++)
    {
        this-&gt;getPoint(i).setData(updatePointGroupData[i]);
    }

    for (uint i=0;i&lt;nUpdateLines;i++)
    {
        this-&gt;getLine(i).setData(updateLineGroupData[i]);
    }

    for (uint i=0;i&lt;nUpdateSurfaces;i++)
    {
        this-&gt;getSurface(i).setData(updateSurfaceGroupData[i]);
    }

    for (uint i=0;i&lt;nUpdateVolumes;i++)
    {
        this-&gt;getVolume(i).setData(updateVolumeGroupData[i]);
    }

    this-&gt;setNScalarFields(uint(scalarFields.size()));
    for (uint i=0;i&lt;this-&gt;getNScalarFields();i++)
    {
        this-&gt;setScalarField(i,scalarFields[i]);
    }

    this-&gt;setNVectorFields(uint(vectorFields.size()));
    for (uint i=0;i&lt;this-&gt;getNVectorFields();i++)
    {
        this-&gt;setVectorField(i,vectorFields[i]);
    }

    this-&gt;setNStreamLines(uint(streamLines.size()));
    for (uint i=0;i&lt;this-&gt;getNStreamLines();i++)
    {
        this-&gt;setStreamLine(i,streamLines[i]);
    }

    this-&gt;setNCuts(uint(cuts.size()));
    for (uint i=0;i&lt;this-&gt;getNCuts();i++)
    {
        this-&gt;setCut(i,cuts[i]);
    }

    this-&gt;setNIsos(uint(isos.size()));
    for (uint i=0;i&lt;this-&gt;getNIsos();i++)
    {
        this-&gt;setIso(i,isos[i]);
    }

    for (uint i=0;i&lt;nUpdateVariables;i++)
    {
        if (this-&gt;getVariable(i).getType() == updateVariableType[i])
        {
            this-&gt;getVariable(i).setVariableData(updateVariableData[i]);
        }
    }

    this-&gt;getTimeSolver().setInputNTimeSteps(timeSolver.getInputNTimeSteps());
    this-&gt;getTimeSolver().setInputStartTime(timeSolver.getInputStartTime());
    this-&gt;getTimeSolver().setInputTimeStepSize(timeSolver.getInputTimeStepSize());
    this-&gt;getTimeSolver().setTimes(timeSolver.getTimes());

    this-&gt;updateEntityGroupIdReferences(oldEIDMap);
} /* RModel::update */


</t>
<t tx="leo.20201108101536.21">void RModel::read(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QString targetFileName(fileName);

    while (!targetFileName.isEmpty())
    {
        QString ext = RFileManager::getExtension(targetFileName);

        try
        {
            if (ext == RModel::getDefaultFileExtension(false))
            {
                targetFileName = this-&gt;readAscii(targetFileName);
            }
            else if (ext == RModel::getDefaultFileExtension(true))
            {
                targetFileName = this-&gt;readBinary(targetFileName);
            }
            else
            {
                throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
            }
        }
        catch (RError &amp;error)
        {
            throw error;
        }
        catch (std::bad_alloc&amp;)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Memory allocation failed.");
        }
        catch (const std::exception&amp; x)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "%s.", typeid(x).name());
        }
        catch (...)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Unknown exception.");
        }
    }

    RModelProblemTypeMask modelProblemType = this-&gt;checkMesh();
    if (modelProblemType != R_MODEL_PROBLEM_NONE)
    {
        RLogger::warning("Inconsistent mesh was loaded which needs to be repaired.\n");
        if (modelProblemType == R_MODEL_PROBLEM_INVALID_NEIGHBORS)
        {
            RLogger::info("Recalculating element neighbors\n");
            RLogger::indent();
            this-&gt;setSurfaceNeighbors(this-&gt;findSurfaceNeighbors());
            this-&gt;setVolumeNeighbors(this-&gt;findVolumeNeighbors());
            RLogger::unindent();
        }
    }
} /* RModel::read */


QString RModel::write(const QString &amp;fileName, bool writeLinkFile) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QString ext = RFileManager::getExtension(fileName);
    QString targetFileName(fileName);
    QString linkFileName = RFileManager::getFileNameWithOutTimeStep(fileName);

    uint recordNumber = 0;

    if (this-&gt;getTimeSolver().getEnabled())
    {
        recordNumber = this-&gt;getTimeSolver().getCurrentTimeStep() + 1;
    }
    else
    {
        if (this-&gt;getProblemTaskTree().getProblemTypeMask() &amp; R_PROBLEM_STRESS_MODAL)
        {
            recordNumber = this-&gt;getProblemSetup().getModalSetup().getMode() + 1;
        }
    }

    targetFileName = RFileManager::getFileNameWithTimeStep(linkFileName,recordNumber);

    try
    {
        if (writeLinkFile)
        {
            RModel::writeLink(linkFileName,targetFileName);
        }

        if (ext == RModel::getDefaultFileExtension(false))
        {
            this-&gt;writeAscii(writeLinkFile?targetFileName:linkFileName);
        }
        else if (ext == RModel::getDefaultFileExtension(true))
        {
            this-&gt;writeBinary(writeLinkFile?targetFileName:linkFileName);
        }
        else
        {
            throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
        }
    }
    catch (RError &amp;error)
    {
        throw error;
    }
    catch (std::bad_alloc&amp;)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Memory allocation failed.");
    }
    catch (const std::exception&amp; x)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "%s.", typeid(x).name());
    }
    catch (...)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Unknown exception.");
    }

    return linkFileName;
} /* RModel::write */


</t>
<t tx="leo.20201108101536.22">void RModel::exportTo (RModelMsh &amp;modelMsh) const
{
    modelMsh.clear();
    modelMsh.title = this-&gt;getName();
    modelMsh.comment = this-&gt;getDescription();
    modelMsh.facesNeighborsComputed = false;
    modelMsh.bodiesNeighborsComputed = false;

    uint nn = this-&gt;getNNodes();
    uint ne = this-&gt;getNElements();
    uint np = 0;
    uint nl = 0;
    uint nf = 0;
    uint nb = 0;
    uint npg = this-&gt;getNPoints();
    uint nlg = this-&gt;getNLines();
    uint nfg = this-&gt;getNSurfaces();
    uint nbg = this-&gt;getNVolumes();

    std::vector&lt;uint&gt; elementIDs(ne);
    const RElement *pElement = nullptr;
    for (uint i=0;i&lt;ne;i++)
    {
        pElement = this-&gt;getElementPtr(i);

        if (pElement-&gt;getType() == R_ELEMENT_POINT)
        {
            elementIDs[i] = np;
            np++;
        }
        else if (pElement-&gt;getType() == R_ELEMENT_TRUSS1 ||
                 pElement-&gt;getType() == R_ELEMENT_TRUSS2)
        {
            elementIDs[i] = nl;
            nl++;
        }
        else if (pElement-&gt;getType() == R_ELEMENT_TRI1 ||
                 pElement-&gt;getType() == R_ELEMENT_TRI2)
        {
            elementIDs[i] = nf;
            nf++;
        }
        else if (pElement-&gt;getType() == R_ELEMENT_TETRA1)
        {
            elementIDs[i] = nb;
            nb++;
        }
        else
        {
            RLogger::warning("Unsupported element (%u) type \'%s\'\n",i+1,RElement::getName(pElement-&gt;getType()).toUtf8().constData());
        }
    }

    uint nppg = 0;
    for (uint i=0;i&lt;npg;i++)
    {
        if (this-&gt;getPoint(i).size() &gt; nppg)
        {
            nppg = this-&gt;getPoint(i).size();
        }
    }
    uint nlpg = 0;
    for (uint i=0;i&lt;nlg;i++)
    {
        if (this-&gt;getLine(i).size() &gt; nlpg)
        {
            nlpg = this-&gt;getLine(i).size();
        }
    }
    uint nfpg = 0;
    for (uint i=0;i&lt;nfg;i++)
    {
        if (this-&gt;getSurface(i).size() &gt; nfpg)
        {
            nfpg = this-&gt;getSurface(i).size();
        }
    }
    uint nbpg = 0;
    for (uint i=0;i&lt;nbg;i++)
    {
        if (this-&gt;getVolume(i).size() &gt; nbpg)
        {
            nbpg = this-&gt;getVolume(i).size();
        }
    }

    modelMsh.nodes.resize(nn,3);

    modelMsh.pointsAll.resize(np,1);
    modelMsh.points.resize(npg,nlpg+2,-9);
    modelMsh.pointsNames.resize(npg);
    modelMsh.pointsVolume.resize(npg);

    modelMsh.linesAll.resize(nl,2);
    modelMsh.lines.resize(nlg,nlpg+2,-9);
    modelMsh.linesNames.resize(nlg);
    modelMsh.linesCarea.resize(nlg);

    modelMsh.facesAll.resize(nf,3);
    modelMsh.faces.resize(nfg,nfpg+2,-9);
    modelMsh.facesNames.resize(nfg);
    modelMsh.facesThickness.resize(nfg);
    modelMsh.facesNeighbors.resize(nf,3,-9);

    modelMsh.bodiesAll.resize(nb,4);
    modelMsh.bodies.resize(nbg,nbpg+2,-9);
    modelMsh.bodiesNames.resize(nbg);
    modelMsh.bodiesNeighbors.resize(nb,4,-9);

    for (uint i=0;i&lt;nn;i++)
    {
        modelMsh.nodes[i][0] = this-&gt;getNode(i).getX();
        modelMsh.nodes[i][1] = this-&gt;getNode(i).getY();
        modelMsh.nodes[i][2] = this-&gt;getNode(i).getZ();
    }

    uint elementID = 0;
    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        nlpg = 0;
        const RPoint *pPoint = this-&gt;getPointPtr(i);
        for (uint j=0;j&lt;pPoint-&gt;size();j++)
        {
            elementID = pPoint-&gt;get(j);
            pElement = this-&gt;getElementPtr(elementID);
            if (pElement-&gt;getType() == R_ELEMENT_POINT)
            {
                modelMsh.pointsAll[elementIDs[elementID]][0] = int(pElement-&gt;getNodeId(0));
                modelMsh.points[i][nlpg+2] = int(elementIDs[elementID]);
                nlpg++;
            }
        }
        modelMsh.points[i][0] = int(i+1);
        modelMsh.points[i][1] = int(nlpg);
        modelMsh.pointsNames[i] = pPoint-&gt;getName();
        modelMsh.pointsVolume[i] = pPoint-&gt;getVolume();
    }

    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        nlpg = 0;
        const RLine *pLine = this-&gt;getLinePtr(i);
        for (uint j=0;j&lt;pLine-&gt;size();j++)
        {
            elementID = pLine-&gt;get(j);
            pElement = this-&gt;getElementPtr(elementID);
            if (pElement-&gt;getType() == R_ELEMENT_TRUSS1 ||
                pElement-&gt;getType() == R_ELEMENT_TRUSS2)
            {
                modelMsh.linesAll[elementIDs[elementID]][0] = int(pElement-&gt;getNodeId(0));
                modelMsh.linesAll[elementIDs[elementID]][1] = int(pElement-&gt;getNodeId(1));
                modelMsh.lines[i][nlpg+2] = int(elementIDs[elementID]);
                nlpg++;
            }
        }
        modelMsh.lines[i][0] = int(i+1);
        modelMsh.lines[i][1] = int(nlpg);
        modelMsh.linesNames[i] = pLine-&gt;getName();
        modelMsh.linesCarea[i] = pLine-&gt;getCrossArea();
    }

    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        nfpg = 0;
        const RSurface *pSurface = this-&gt;getSurfacePtr(i);
        for (uint j=0;j&lt;pSurface-&gt;size();j++)
        {
            elementID = pSurface-&gt;get(j);
            pElement = this-&gt;getElementPtr(elementID);
            if (pElement-&gt;getType() == R_ELEMENT_TRI1 ||
                pElement-&gt;getType() == R_ELEMENT_TRI2)
            {
                modelMsh.facesAll[elementIDs[elementID]][0] = int(pElement-&gt;getNodeId(0));
                modelMsh.facesAll[elementIDs[elementID]][1] = int(pElement-&gt;getNodeId(1));
                modelMsh.facesAll[elementIDs[elementID]][2] = int(pElement-&gt;getNodeId(2));
                modelMsh.faces[i][nfpg+2] = int(elementIDs[elementID]);
                nfpg++;
            }
        }
        modelMsh.faces[i][0] = int(i+1);
        modelMsh.faces[i][1] = int(nfpg);
        modelMsh.facesNames[i] = pSurface-&gt;getName();
        modelMsh.facesThickness[i] = pSurface-&gt;getThickness();
    }

    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        nbpg = 0;
        const RVolume *pVolume = this-&gt;getVolumePtr(i);
        for (uint j=0;j&lt;pVolume-&gt;size();j++)
        {
            elementID = pVolume-&gt;get(j);
            pElement = this-&gt;getElementPtr(elementID);
            if (pElement-&gt;getType() == R_ELEMENT_TETRA1)
            {
                modelMsh.bodiesAll[elementIDs[elementID]][0] = int(pElement-&gt;getNodeId(0));
                modelMsh.bodiesAll[elementIDs[elementID]][1] = int(pElement-&gt;getNodeId(1));
                modelMsh.bodiesAll[elementIDs[elementID]][2] = int(pElement-&gt;getNodeId(2));
                modelMsh.bodiesAll[elementIDs[elementID]][3] = int(pElement-&gt;getNodeId(3));
                modelMsh.bodies[i][nbpg+2] = int(elementIDs[elementID]);
                nbpg++;
            }
        }
        modelMsh.bodies[i][0] = int(i+1);
        modelMsh.bodies[i][1] = int(nbpg);
        modelMsh.bodiesNames[i] = pVolume-&gt;getName();
    }
} /* RModel::exportTo */


</t>
<t tx="leo.20201108101536.23">void RModel::exportTo (RModelRaw &amp;modelRaw) const
{
    modelRaw.clear();

    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(i);
        if (rElement.getType() == R_ELEMENT_POINT)
        {
            modelRaw.addPoint(this-&gt;getNode(rElement.getNodeId(0)),false);
        }
        else if (rElement.getType() == R_ELEMENT_BEAM1 ||
                 rElement.getType() == R_ELEMENT_BEAM2 ||
                 rElement.getType() == R_ELEMENT_TRUSS1 ||
                 rElement.getType() == R_ELEMENT_TRUSS2)
        {
            modelRaw.addSegment(this-&gt;getNode(rElement.getNodeId(0)),
                                this-&gt;getNode(rElement.getNodeId(1)),
                                false);
        }
        else if (rElement.getType() == R_ELEMENT_TRI1 ||
                 rElement.getType() == R_ELEMENT_TRI2)
        {
            modelRaw.addTriangle(this-&gt;getNode(rElement.getNodeId(0)),
                                 this-&gt;getNode(rElement.getNodeId(1)),
                                 this-&gt;getNode(rElement.getNodeId(2)),
                                 false);
        }
        else if (rElement.getType() == R_ELEMENT_QUAD1 ||
                 rElement.getType() == R_ELEMENT_QUAD2)
        {
            modelRaw.addQuadrilateral(this-&gt;getNode(rElement.getNodeId(0)),
                                      this-&gt;getNode(rElement.getNodeId(1)),
                                      this-&gt;getNode(rElement.getNodeId(2)),
                                      this-&gt;getNode(rElement.getNodeId(3)),
                                      false);
        }
    }
} /* RModel::exportTo */


</t>
<t tx="leo.20201108101536.24">void RModel::exportTo (RModelStl &amp;modelStl) const
{
    modelStl.clear();
    modelStl.setName(this-&gt;getName());
    modelStl.setDescription(this-&gt;getDescription());

    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(i);
        if (rElement.getType() == R_ELEMENT_TRI1 ||
            rElement.getType() == R_ELEMENT_TRI2)
        {
            modelStl.addTriangle(this-&gt;getNode(rElement.getNodeId(0)),
                                 this-&gt;getNode(rElement.getNodeId(1)),
                                 this-&gt;getNode(rElement.getNodeId(2)),
                                 false);
        }
        if (rElement.getType() == R_ELEMENT_QUAD1 ||
            rElement.getType() == R_ELEMENT_QUAD2)
        {
            modelStl.addTriangle(this-&gt;getNode(rElement.getNodeId(0)),
                                 this-&gt;getNode(rElement.getNodeId(1)),
                                 this-&gt;getNode(rElement.getNodeId(2)),
                                 false);
            modelStl.addTriangle(this-&gt;getNode(rElement.getNodeId(0)),
                                 this-&gt;getNode(rElement.getNodeId(2)),
                                 this-&gt;getNode(rElement.getNodeId(3)),
                                 false);
        }
    }
} /* RModel::exportTo */


QString RModel::getName() const
{
    return this-&gt;name;
} /* RModel::getName */


</t>
<t tx="leo.20201108101536.25">void RModel::setName (const QString &amp;name)
{
    this-&gt;name = name;
} /* RModel::setName */


QString RModel::getDescription() const
{
    return this-&gt;description;
} /* RModel::getDescription */


</t>
<t tx="leo.20201108101536.26">void RModel::setDescription (const QString &amp;description)
{
    this-&gt;description = description;
} /* RModel::setDescription */


</t>
<t tx="leo.20201108101536.27">void RModel::addElementToGroup (uint elementID,
                                uint groupID)
{
    R_ERROR_ASSERT (elementID &lt; this-&gt;getNElements());

    RElementType elementType = this-&gt;getElement(elementID).getType();

    if (R_ELEMENT_TYPE_IS_POINT (elementType))
    {
        if (this-&gt;getNPoints() &lt;= groupID)
        {
            this-&gt;setNPoints (groupID+1);
        }
        this-&gt;getPoint(groupID).add (elementID);
    }
    else if (R_ELEMENT_TYPE_IS_LINE (elementType))
    {
        if (this-&gt;getNLines() &lt;= groupID)
        {
            this-&gt;setNLines (groupID+1);
        }
        this-&gt;getLine(groupID).add (elementID);
    }
    else if (R_ELEMENT_TYPE_IS_SURFACE (elementType))
    {
        if (this-&gt;getNSurfaces() &lt;= groupID)
        {
            this-&gt;setNSurfaces (groupID+1);
        }
        this-&gt;getSurface(groupID).add (elementID);
    }
    else if (R_ELEMENT_TYPE_IS_VOLUME (elementType))
    {
        if (this-&gt;getNVolumes() &lt;= groupID)
        {
            this-&gt;setNVolumes (groupID+1);
        }
        this-&gt;getVolume(groupID).add (elementID);
    }
} /* RModel::addElementToGroup */


</t>
<t tx="leo.20201108101536.28">void RModel::setProblemTaskTree (const RProblemTaskItem &amp;taskTree)
{
    RProblem::setProblemTaskTree(taskTree);

    RProblemTypeMask typeMask = taskTree.getProblemTypeMask();
    RProblemTypeMask conditionTypeMask;
    RElementGroup *pElementGroup = nullptr;

    uint ng = 0;
    uint pos = 0;

    std::vector&lt;REntityGroupType&gt; grpTypes = REntityGroup::getAllTypes();

    for (uint i=0;i&lt;grpTypes.size();i++)
    {
        switch (grpTypes[i])
        {
            case R_ENTITY_GROUP_POINT:
                ng = this-&gt;getNPoints();
                break;
            case R_ENTITY_GROUP_LINE:
                ng = this-&gt;getNLines();
                break;
            case R_ENTITY_GROUP_SURFACE:
                ng = this-&gt;getNSurfaces();
                break;
            case R_ENTITY_GROUP_VOLUME:
                ng = this-&gt;getNVolumes();
                break;
            default:
                ng = 0;
                break;
        }
        for (uint j=0;j&lt;ng;j++)
        {
            if (grpTypes[i] == R_ENTITY_GROUP_POINT)
            {
                pElementGroup = this-&gt;getPointPtr(j);
            }
            else if (grpTypes[i] == R_ENTITY_GROUP_LINE)
            {
                pElementGroup = this-&gt;getLinePtr(j);
            }
            else if (grpTypes[i] == R_ENTITY_GROUP_SURFACE)
            {
                pElementGroup = this-&gt;getSurfacePtr(j);
            }
            else if (grpTypes[i] == R_ENTITY_GROUP_VOLUME)
            {
                pElementGroup = this-&gt;getVolumePtr(j);
            }
            else
            {
                pElementGroup = nullptr;
            }

            // Check all boundary conditions
            pos = 0;
            while (pos &lt; pElementGroup-&gt;getNBoundaryConditions())
            {
                conditionTypeMask = RBoundaryCondition::getProblemTypeMask(pElementGroup-&gt;getBoundaryCondition(pos).getType());
                if (!(conditionTypeMask &amp; typeMask))
                {
                    pElementGroup-&gt;removeBoundaryCondition (pos);
                }
                else
                {
                    pos++;
                }
            }

            // Check all environment conditions
            pos = 0;
            while (pos &lt; pElementGroup-&gt;getNEnvironmentConditions())
            {
                conditionTypeMask = REnvironmentCondition::getProblemTypeMask(pElementGroup-&gt;getEnvironmentCondition(pos).getType());
                if (!(conditionTypeMask &amp; typeMask))
                {
                    pElementGroup-&gt;removeEnvironmentCondition (pos);
                }
                else
                {
                    pos++;
                }
            }

            // Check all initial conditions
            pos = 0;
            while (pos &lt; pElementGroup-&gt;getNInitialConditions())
            {
                conditionTypeMask = RInitialCondition::getProblemTypeMask(pElementGroup-&gt;getInitialCondition(pos).getType());
                if (!(conditionTypeMask &amp; typeMask))
                {
                    pElementGroup-&gt;removeInitialCondition (pos);
                }
                else
                {
                    pos++;
                }
            }
        }
    }
}/* RModel::setProblemTypeMask */


/*********************************************************************
 * Node interface                                                    *
 *********************************************************************/


</t>
<t tx="leo.20201108101536.29">void RModel::removeVariable(uint position)
{
    RVariableType variableType = this-&gt;getVariable(position).getType();
    this-&gt;RResults::removeVariable(position);
    this-&gt;clearEntityVariableData(variableType);
}/* RModel::removeVariable */


</t>
<t tx="leo.20201108101536.3">const QSet&lt;RVariableType&gt; &amp;RMeshSetup::getVariables() const
{
    return this-&gt;variables;
}

QSet&lt;RVariableType&gt; &amp;RMeshSetup::getVariables()
{
    return this-&gt;variables;
}

</t>
<t tx="leo.20201108101536.30">void RModel::removeAllVariables()
{
    this-&gt;RResults::removeAllVariables();
    this-&gt;clearEntityVariableData();
}/* RModel::removeAllVariables */


/*********************************************************************
 * Node interface                                                    *
 *********************************************************************/


uint RModel::getNNodes () const
{
    return uint(this-&gt;nodes.size());
} /* RModel::getNNodes */


</t>
<t tx="leo.20201108101536.31">void RModel::setNNodes (uint nnodes)
{
    this-&gt;nodes.resize(nnodes);
    this-&gt;RResults::setNNodes (nnodes);
} /* RModel::setNNodes */


</t>
<t tx="leo.20201108101536.32">const RNode * RModel::getNodePtr (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;nodes.size());
    return &amp;this-&gt;nodes[position];
} /* RModel::get_node_ptr */


RNode * RModel::getNodePtr (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;nodes.size());
    return &amp;this-&gt;nodes[position];
} /* RModel::get_node_ptr */


</t>
<t tx="leo.20201108101536.33">const RNode &amp; RModel::getNode (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;nodes.size());
    return this-&gt;nodes[position];
} /* RModel::getNode */


RNode &amp; RModel::getNode (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;nodes.size());
    return this-&gt;nodes[position];
} /* RModel::getNode */


</t>
<t tx="leo.20201108101536.34">const std::vector&lt;RNode&gt; &amp;RModel::getNodes() const
{
    return this-&gt;nodes;
} /* RModel::getNodes */


</t>
<t tx="leo.20201108101536.35">void RModel::addNode (const RNode &amp;node,
                      double  value)
{
    this-&gt;nodes.push_back (node);
    this-&gt;RResults::addNode (value);
} /* RModel::addNode */


</t>
<t tx="leo.20201108101536.36">void RModel::addNode (double x, 
                      double y,
                      double z,
                      double value)
{
    RNode node;

    node.set (x, y, z);

    this-&gt;addNode (node);
    this-&gt;RResults::addNode (value);
} /* RModel::addNode */


</t>
<t tx="leo.20201108101536.37">void RModel::setNode (uint  position,
                       const RNode  &amp;node)
{
    R_ERROR_ASSERT (position &lt; this-&gt;nodes.size());
    this-&gt;nodes[position] = node;
} /* RModel::set_node */


</t>
<t tx="leo.20201108101536.38">void RModel::removeNode (uint                position,
                         std::vector&lt;uint&gt; * removedElements,
                         std::vector&lt;uint&gt; * removedPoints,
                         std::vector&lt;uint&gt; * removedLines,
                         std::vector&lt;uint&gt; * removedSurfaces,
                         std::vector&lt;uint&gt; * removedVolumes)
{
    R_ERROR_ASSERT (position &lt; this-&gt;nodes.size());

    // Loop over all elements and remove each containing the node
    std::vector&lt;uint&gt; eps = this-&gt;findElementPositionsByNodeId(position);
    if (removedElements)
    {
        (*removedElements) = eps;
    }

    for (std::vector&lt;uint&gt;::reverse_iterator rIterEps = eps.rbegin(); rIterEps != eps.rend(); ++rIterEps)
    {
        this-&gt;removeElement (*rIterEps,
                              true,
                              removedPoints,
                              removedLines,
                              removedSurfaces,
                              removedVolumes);
    }

    // Remove node from nodes vector
    std::vector&lt;RNode&gt;::iterator iterNode = this-&gt;nodes.begin();
    std::advance (iterNode, position);

    this-&gt;nodes.erase (iterNode);
    this-&gt;RResults::removeNode (position);

    // Decrease each node ID which is greater then possitin s by one
    for (std::vector&lt;RElement&gt;::iterator iterElement = this-&gt;elements.begin();
         iterElement != this-&gt;elements.end();
         ++iterElement)
    {
        for (uint i=0;i&lt;iterElement-&gt;size();i++)
        {
            uint nodeID = iterElement-&gt;getNodeId (i);
            if (nodeID &gt; position)
            {
                iterElement-&gt;setNodeId (i, nodeID-1);
            }
        }
    }
} /* RModel::removeNode */


</t>
<t tx="leo.20201108101536.39">void RModel::removeNodes(const QList&lt;uint&gt; &amp;nodeIDs, bool closeHole)
{
    QList&lt;uint&gt; sortedNodeIDs(nodeIDs);

    std::sort(sortedNodeIDs.begin(),sortedNodeIDs.end());

    for (int i=sortedNodeIDs.size()-1;i&gt;=0;i--)
    {
        RLogger::info("Removing node #%u\n",sortedNodeIDs[i]);

        QList&lt;uint&gt; edgeNodeIds;
        if (closeHole)
        {
            edgeNodeIds = this-&gt;findNodeEdgeRing(sortedNodeIDs[i]);
        }

        for (int j=0;j&lt;edgeNodeIds.size();j++)
        {
            if (edgeNodeIds[j] &gt; sortedNodeIDs[i])
            {
                edgeNodeIds[j]--;
            }
        }

        this-&gt;removeNode(sortedNodeIDs[i]);

        if (closeHole)
        {
            std::vector&lt;RNode&gt; edgeNodes;
            edgeNodes.resize(uint(edgeNodeIds.size()));
            for (uint i=0;i&lt;edgeNodes.size();i++)
            {
                edgeNodes[i] = this-&gt;getNode(edgeNodeIds[int(i)]);
            }

            if (edgeNodes.size() &gt; 0)
            {
                std::vector&lt;RElement&gt; patchEelements = RPolygon::triangulate(edgeNodes,true);
                for (uint j=0;j&lt;patchEelements.size();j++)
                {
                    for (uint k=0;k&lt;patchEelements[j].size();k++)
                    {
                        patchEelements[j].setNodeId(k,edgeNodeIds[int(patchEelements[j].getNodeId(k))]);
                    }
                    this-&gt;addElement(patchEelements[j]);
                }
            }
        }
    }
} /* RModel::removeNodes */


</t>
<t tx="leo.20201108101536.4">void RMeshSetup::setVariables(const QSet&lt;RVariableType&gt; &amp;variables)
{
    this-&gt;variables = variables;
}

double RMeshSetup::getMinEdgeLength() const
{
    return this-&gt;minEdgeLength;
}

</t>
<t tx="leo.20201108101536.40">void RModel::mergeNodes(uint position1, uint position2, bool average, bool allowDowngrade)
{
    R_ERROR_ASSERT (position1 != position2);

    uint n1 = (position1 &lt; position2) ? position1 : position2;
    uint n2 = (position1 &lt; position2) ? position2 : position1;

    if (average)
    {
        double x = (this-&gt;getNode(n1).getX() + this-&gt;getNode(n2).getX())/2.0;
        double y = (this-&gt;getNode(n1).getY() + this-&gt;getNode(n2).getY())/2.0;
        double z = (this-&gt;getNode(n1).getZ() + this-&gt;getNode(n2).getZ())/2.0;

        this-&gt;getNode(n1).set(x,y,z);
    }

    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        this-&gt;getElement(i).mergeNodes(n1,n2,allowDowngrade);
    }
    this-&gt;removeNode(n2);
} /* RModel::mergeNodes */


std::vector&lt;uint&gt; RModel::findNearNodePositions(const RNode &amp;node, double tolerance) const
{
    double dl;
    const RNode *pNode = nullptr;
    std::vector&lt;uint&gt; nearNodes;

    for (uint i=0;i&lt;this-&gt;nodes.size();i++)
    {
        pNode = this-&gt;getNodePtr(i);

        dl = pNode-&gt;getDistance(node);

        if (dl &lt; tolerance)
        {
            nearNodes.push_back(i);
        }
    }
    return nearNodes;
} /* RModel::findNearNodePositions */


uint RModel::mergeNearNodes(double tolerance)
{
    uint nMerged = 0;
    for (uint i=0;i&lt;this-&gt;getNNodes();i++)
    {
        uint nodeID = i+1;
        while (nodeID &lt; this-&gt;getNNodes())
        {
            if (this-&gt;getNode(i).getDistance(this-&gt;getNode(nodeID)) &lt;= tolerance)
            {
                this-&gt;mergeNodes(i,nodeID,false,true);
                nMerged++;
            }
            nodeID++;
        }
    }

    this-&gt;fixElementGroupRelations();
    return nMerged;
} /* RModel::mergeNearNodes */


uint RModel::removeDuplicateElements()
{
    RBVector elementBook(this-&gt;getNElements(),false);

#pragma omp parallel for default(shared)
    for(int64_t i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (elementBook[uint(i)])
        {
            continue;
        }
        const RElement &amp;rElement1 = this-&gt;getElement(uint(i));
        for(int64_t j=i+1;j&lt;this-&gt;getNElements();j++)
        {
            if (elementBook[uint(j)])
            {
                continue;
            }
            const RElement &amp;rElement2 = this-&gt;getElement(uint(j));

            if (rElement1.getType() != rElement2.getType())
            {
                continue;
            }

            bool isEqual = true;
            for (uint k=0;k&lt;rElement2.size();k++)
            {
                if (!rElement1.hasNodeId(rElement2.getNodeId(k)))
                {
                    isEqual = false;
                    break;
                }
            }
            if (isEqual)
            {
                elementBook[uint(j)] = true;
            }
        }
    }

    QList&lt;uint&gt; elementsToRemove;
    elementsToRemove.reserve(int(this-&gt;getNElements()));

    for (uint i=0;i&lt;elementBook.size();i++)
    {
        if (elementBook[i])
        {
            elementsToRemove.append(i);
        }
    }

    uint nRemoved = this-&gt;getNElements();

    this-&gt;removeElements(elementsToRemove,false);

    nRemoved -= this-&gt;getNElements();

    return nRemoved;
} /* RModel::removeDuplicateElements */


</t>
<t tx="leo.20201108101536.41">void RModel::findNodeLimits(double &amp;xmin, double &amp;xmax, double &amp;ymin, double &amp;ymax, double &amp;zmin, double &amp;zmax) const
{
    xmin = xmax = ymin = ymax = zmin = zmax = 0.0;
    for (uint i=0;i&lt;this-&gt;nodes.size();i++)
    {
        if (i == 0)
        {
            xmin = xmax = this-&gt;getNode(i).getX();
            ymin = ymax = this-&gt;getNode(i).getY();
            zmin = zmax = this-&gt;getNode(i).getZ();
        }
        xmin = std::min(xmin,this-&gt;getNode(i).getX());
        xmax = std::max(xmax,this-&gt;getNode(i).getX());
        ymin = std::min(ymin,this-&gt;getNode(i).getY());
        ymax = std::max(ymax,this-&gt;getNode(i).getY());
        zmin = std::min(zmin,this-&gt;getNode(i).getZ());
        zmax = std::max(zmax,this-&gt;getNode(i).getZ());
    }
} /* RModel::getNodeLimits */


double RModel::findNodeScale() const
{
    double xmin,xmax,ymin,ymax,zmin,zmax;
    this-&gt;findNodeLimits(xmin,xmax,ymin,ymax,zmin,zmax);
    double dx = xmax - xmin;
    double dy = ymax - ymin;
    double dz = zmax - zmin;

    if (dx &gt;= dy &amp;&amp; dx &gt;= dz &amp;&amp; dx != 0.0)
    {
        return 1.0/dx;
    }
    if (dy &gt;= dx &amp;&amp; dy &gt;= dz &amp;&amp; dy != 0.0)
    {
        return 1.0/dy;
    }
    if (dz &gt;= dx &amp;&amp; dz &gt;= dy &amp;&amp; dz != 0.0)
    {
        return 1.0/dz;
    }

    return 1.0;
} /* RModel::getNodeScale */


</t>
<t tx="leo.20201108101536.42">void RModel::findNodeCenter(double &amp;xc, double &amp;yc, double &amp;zc) const
{
    double xmin,xmax,ymin,ymax,zmin,zmax;

    this-&gt;findNodeLimits(xmin,xmax,ymin,ymax,zmin,zmax);

    xc = (xmin + xmax)/2.0;
    yc = (ymin + ymax)/2.0;
    zc = (zmin + zmax)/2.0;
} /* RModel::getNodeCenter */


RStatistics RModel::findNodeDistanceStatistics() const
{
    QMap&lt; QPair&lt;uint,uint&gt; , double &gt; distMap;

    for (uint i=0;i&lt;this-&gt;elements.size();i++)
    {
        for (uint j=0;j&lt;this-&gt;elements[i].size();j++)
        {
            for (uint k=j+1;k&lt;this-&gt;elements[i].size();k++)
            {
                uint n1 = this-&gt;elements[i].getNodeId(j);
                uint n2 = this-&gt;elements[i].getNodeId(k);
                if (n1 &gt; n2)
                {
                    std::swap(n1,n2);
                }
                QPair&lt;uint,uint&gt; key(n1,n2);
                if (!distMap.contains(key))
                {
                    distMap.insert(key,this-&gt;nodes[n1].getDistance(this-&gt;nodes[n2]));
                }
            }
        }
    }

    RRVector nodeDist;
    nodeDist.reserve(uint(distMap.size()));

    foreach (double distance, distMap)
    {
        nodeDist.push_back(distance);
    }

    return RStatistics(nodeDist,100,true);
} /* RModel::findNodeDistanceStatistics */


</t>
<t tx="leo.20201108101536.43">bool RModel::isNodeUsed(uint nodeID) const
{
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (this-&gt;getElement(i).hasNodeId(nodeID))
        {
            return true;
        }
    }
    return false;
} /* RModel::isNodeUsed */


uint RModel::purgeUnusedNodes()
{
    RLogger::info("Purging unused nodes\n");
    RLogger::indent();

    // Find unused nodes.
    std::vector&lt;uint&gt; nodeBook(this-&gt;getNNodes(),RConstants::eod);

//#pragma omp parallel for default(shared)
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        const RElement &amp;rElement = this-&gt;getElement(i);
        for (uint j=0;j&lt;rElement.size();j++)
        {
            nodeBook[rElement.getNodeId(j)] = 0;
        }
    }

    // Remove unused nodes.
    uint nn = this-&gt;getNNodes();
    for (uint i=0;i&lt;nn;i++)
    {
        uint pos = nn - i - 1;
        if (nodeBook[pos] == RConstants::eod)
        {
            this-&gt;nodes.erase(this-&gt;nodes.begin()+pos);
            this-&gt;RResults::removeNode(pos);
        }
    }

    // Fix node IDs
    uint nNodes = 0;
    for (uint i=0;i&lt;nodeBook.size();i++)
    {
        if (nodeBook[i] != RConstants::eod)
        {
            nodeBook[i] = nNodes++;
        }
    }

//#pragma omp parallel for default(shared)
    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        RElement &amp;rElement = this-&gt;getElement(i);
        for (uint j=0;j&lt;rElement.size();j++)
        {
            rElement.setNodeId(j,nodeBook[rElement.getNodeId(j)]);
        }
    }
    RLogger::unindent();

    return uint(nodeBook.size()) - nNodes;
} /* RModel::purgeUnusedNodes */


/*********************************************************************
 * Element interface                                                 *
 *********************************************************************/


uint RModel::getNElements (RElementType elementType) const
{
    if (elementType == R_ELEMENT_NONE)
    {
        return uint(this-&gt;elements.size());
    }
    uint nElements = 0;
    for (uint i=0;i&lt;this-&gt;elements.size();i++)
    {
        if (this-&gt;getElement(i).getType() == elementType)
        {
            nElements++;
        }
    }
    return nElements;
} /* RModel::getNElements */


uint RModel::getNElements(REntityGroupType elementGroupType) const
{
    if (elementGroupType == R_ENTITY_GROUP_NONE)
    {
        return uint(this-&gt;elements.size());
    }
    uint nElements = 0;
    for (uint i=0;i&lt;this-&gt;elements.size();i++)
    {
        if (RElementGroup::getGroupType(this-&gt;getElement(i).getType()) == elementGroupType)
        {
            nElements++;
        }
    }
    return nElements;
} /* RModel::getNElements */


</t>
<t tx="leo.20201108101536.44">void RModel::setNElements (uint nelements)
{
    this-&gt;elements.resize(nelements);
    this-&gt;RResults::setNElements(nelements);

    for (uint i=0;i&lt;this-&gt;elements.size();i++)
    {
        this-&gt;elements[i].setType(R_ELEMENT_NONE);
    }
    for (uint i=0;i&lt;this-&gt;getNPoints();i++)
    {
        this-&gt;getPoint(i).resize(0);
    }
    for (uint i=0;i&lt;this-&gt;getNLines();i++)
    {
        this-&gt;getLine(i).resize(0);
    }
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        this-&gt;getSurface(i).resize(0);
    }
    for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
    {
        this-&gt;getVolume(i).resize(0);
    }
} /* RModel::getNElements */


</t>
<t tx="leo.20201108101536.45">const RElement * RModel::getElementPtr (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;elements.size());
    return &amp;this-&gt;elements[position];
} /* RModel::getElementPtr */


RElement * RModel::getElementPtr (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;elements.size());
    return &amp;this-&gt;elements[position];
} /* RModel::getElementPtr */


</t>
<t tx="leo.20201108101536.46">const RElement &amp; RModel::getElement (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;elements.size());
    return this-&gt;elements[position];
} /* RModel::getElement */


RElement &amp; RModel::getElement (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;elements.size());
    return this-&gt;elements[position];
} /* RModel::getElement */


</t>
<t tx="leo.20201108101536.47">const std::vector&lt;RElement&gt; &amp;RModel::getElements() const
{
    return this-&gt;elements;
} /* RModel::getElements */


std::vector&lt;RElement&gt; &amp;RModel::getElements()
{
    return this-&gt;elements;
} /* RModel::getElements */


</t>
<t tx="leo.20201108101536.48">void RModel::addElement (const RElement &amp;element,
                         bool            addToGroup,
                         uint            groupID)
{
    this-&gt;elements.push_back(element);
    this-&gt;RResults::addElement(0.0);

    if (addToGroup)
    {
        this-&gt;addElementToGroup(this-&gt;getNElements()-1,groupID);
    }
    else
    {
        uint oldGroupID = 0;

        if (R_ELEMENT_TYPE_IS_POINT(element.getType()))
        {
            oldGroupID = this-&gt;getNPoints();
//            this-&gt;volumeNeigs.p
        }
        else if (R_ELEMENT_TYPE_IS_LINE(element.getType()))
        {
            oldGroupID = this-&gt;getNLines();
        }
        else if (R_ELEMENT_TYPE_IS_SURFACE(element.getType()))
        {
            oldGroupID = this-&gt;getNSurfaces();
            // Following works only for surface elements.
            double minNormalAngle = RConstants::pi;
            const RElement &amp;rElement = this-&gt;getElement(this-&gt;getNElements()-1);
            RR3Vector en;
            rElement.findNormal(this-&gt;getNodes(),en[0],en[1],en[2]);
            for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
            {
                const RSurface &amp;rSurface = this-&gt;getSurface(i);
                for (uint j=0;j&lt;rSurface.size();j++)
                {
                    uint elementID = rSurface.get(j);
                    RR3Vector nn;
                    this-&gt;getElement(elementID).findNormal(this-&gt;getNodes(),nn[0],nn[1],nn[2]);

                    double angle = RR3Vector::angle(en,nn);
                    if (angle &lt; minNormalAngle)
                    {
                        minNormalAngle = angle;
                        oldGroupID = i;
                    }
                }
            }
        }
        else if (R_ELEMENT_TYPE_IS_VOLUME(element.getType()))
        {
            oldGroupID = this-&gt;getNVolumes();
        }
        this-&gt;addElementToGroup(this-&gt;getNElements()-1,oldGroupID);
    }

    // HACK: In case of point and line elements enlarge negbor arrays to avoid costly recalculations.
    if (R_ELEMENT_TYPE_IS_POINT(element.getType()) ||
        R_ELEMENT_TYPE_IS_LINE(element.getType()))
    {
        this-&gt;surfaceNeigs.push_back(RUVector());
        this-&gt;volumeNeigs.push_back(RUVector());
    }
} /* RModel::addElement */


</t>
<t tx="leo.20201108101536.49">void RModel::setElement (uint    position,
                         const RElement &amp;element,
                         bool            addToGroup)
{
    R_ERROR_ASSERT (position &lt; this-&gt;elements.size());

    REntityGroupType oldType = RElementGroup::getGroupType (this-&gt;elements[position].getType());
    REntityGroupType newType = RElementGroup::getGroupType (element.getType());

    this-&gt;elements[position] = element;

    if (oldType != newType)
    {
        uint grpPosition;

        // Remove element ID from its current group
        if (oldType == R_ENTITY_GROUP_POINT)
        {
            for (uint i=0;i&lt;this-&gt;getNPoints();i++)
            {
                if (this-&gt;getPoint(i).findPosition(position,&amp;grpPosition))
                {
                    this-&gt;getPoint(i).remove(grpPosition);
                }
            }
        }
        else if (oldType == R_ENTITY_GROUP_LINE)
        {
            for (uint i=0;i&lt;this-&gt;getNLines();i++)
            {
                if (this-&gt;getLine(i).findPosition(position,&amp;grpPosition))
                {
                    this-&gt;getLine(i).remove(grpPosition);
                }
            }
        }
        else if (oldType == R_ENTITY_GROUP_SURFACE)
        {
            for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
            {
                if (this-&gt;getSurface(i).findPosition(position,&amp;grpPosition))
                {
                    this-&gt;getSurface(i).remove(grpPosition);
                }
            }
        }
        else if (oldType == R_ENTITY_GROUP_VOLUME)
        {
            for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
            {
                if (this-&gt;getVolume(i).findPosition(position,&amp;grpPosition))
                {
                    this-&gt;getVolume(i).remove(grpPosition);
                }
            }
        }

        // Add element ID to its appropriate group
        if (addToGroup)
        {
            this-&gt;addElementToGroup (position);
        }
    }
} /* RModel::setElement */


</t>
<t tx="leo.20201108101536.5">void RMeshSetup::setMinEdgeLength(double minEdgeLength)
{
    this-&gt;minEdgeLength = minEdgeLength;
}

double RMeshSetup::getMaxEdgeLength() const
{
    return this-&gt;maxEdgeLength;
}

</t>
<t tx="leo.20201108101536.50">void RModel::removeElement (uint                position,
                            bool                removeGroups,
                            std::vector&lt;uint&gt; * removedPoints,
                            std::vector&lt;uint&gt; * removedLines,
                            std::vector&lt;uint&gt; * removedSurfaces,
                            std::vector&lt;uint&gt; * removedVolumes)
{
    R_ERROR_ASSERT (position &lt; this-&gt;elements.size());

    if (removeGroups)
    {
        // Remove element from element groups
        RElementType elementType = this-&gt;getElement(position).getType();
        uint ePosition;
        for (std::vector&lt;RPoint&gt;::reverse_iterator rIter = this-&gt;points.rbegin();rIter != this-&gt;points.rend();++rIter)
        {
            if (R_ELEMENT_TYPE_IS_POINT(elementType))
            {
                if (rIter-&gt;findPosition(position,&amp;ePosition))
                {
                    rIter-&gt;remove(ePosition);
                }
            }
            // Check if element group is empty
            if (rIter-&gt;empty())
            {
                // Remove empty element group
                if (removedPoints)
                {
                    uint gPosition = uint(std::distance(this-&gt;points.begin(),(rIter+1).base()));
                    removedPoints-&gt;push_back(gPosition);
                }
                this-&gt;points.erase ((rIter+1).base());
            }
            else
            {
                // Decrease all element IDs by one which element ID
                // is greater then position of remved element.
                for (uint i=0;i&lt;rIter-&gt;size();i++)
                {
                    uint elementID = rIter-&gt;get(i);
                    if (elementID &gt; position)
                    {
                        rIter-&gt;set(i,elementID-1);
                    }
                }
            }
        }
        for (std::vector&lt;RLine&gt;::reverse_iterator rIter = this-&gt;lines.rbegin();rIter != this-&gt;lines.rend();++rIter)
        {
            if (R_ELEMENT_TYPE_IS_LINE(elementType))
            {
                if (rIter-&gt;findPosition(position,&amp;ePosition))
                {
                    rIter-&gt;remove(ePosition);
                }
            }
            // Check if element group is empty
            if (rIter-&gt;empty())
            {
                // Remove empty element group
                if (removedLines)
                {
                    uint gPosition = uint(std::distance(this-&gt;lines.begin(),(rIter+1).base()));
                    removedLines-&gt;push_back(gPosition);
                }
                this-&gt;lines.erase((rIter+1).base());
            }
            else
            {
                // Decrease all element IDs by one which element ID
                // is greater then position of removed element.
                for (uint i=0;i&lt;rIter-&gt;size();i++)
                {
                    uint elementID = rIter-&gt;get(i);
                    if (elementID &gt; position)
                    {
                        rIter-&gt;set(i,elementID-1);
                    }
                }
            }
        }
        for (std::vector&lt;RSurface&gt;::reverse_iterator rIter = this-&gt;surfaces.rbegin();rIter != this-&gt;surfaces.rend();++rIter)
        {
            if (R_ELEMENT_TYPE_IS_SURFACE(elementType))
            {
                if (rIter-&gt;findPosition (position, &amp;ePosition))
                {
                    rIter-&gt;remove(ePosition);
                }
            }
            // Check if element group is empty
            if (rIter-&gt;empty())
            {
                // Remove empty element group
                if (removedSurfaces)
                {
                    uint gPosition = uint(std::distance(this-&gt;surfaces.begin(),(rIter+1).base()));
                    removedSurfaces-&gt;push_back(gPosition);
                }
                this-&gt;surfaces.erase((rIter+1).base());
            }
            else
            {
                // Decrease all element IDs by one which element ID
                // is greater then position of remved element.
                for (uint i=0;i&lt;rIter-&gt;size();i++)
                {
                    uint elementID = rIter-&gt;get(i);
                    if (elementID &gt; position)
                    {
                        rIter-&gt;set(i,elementID-1);
                    }
                }
            }
        }
        for (std::vector&lt;RVolume&gt;::reverse_iterator rIter = this-&gt;volumes.rbegin();rIter != this-&gt;volumes.rend();++rIter)
        {
            if (R_ELEMENT_TYPE_IS_VOLUME(elementType))
            {
                if (rIter-&gt;findPosition(position,&amp;ePosition))
                {
                    rIter-&gt;remove(ePosition);
                }
            }
            // Check if element group is empty
            if (rIter-&gt;empty())
            {
                // Remove empty element group
                if (removedVolumes)
                {
                    uint gPosition = uint(std::distance(this-&gt;volumes.begin(),(rIter+1).base()));
                    removedVolumes-&gt;push_back(gPosition);
                }
                this-&gt;volumes.erase((rIter+1).base());
            }
            else
            {
                // Decrease all element IDs by one which element ID
                // is greater then position of remved element.
                for (uint i=0;i&lt;rIter-&gt;size();i++)
                {
                    uint elementID = rIter-&gt;get(i);
                    if (elementID &gt; position)
                    {
                        rIter-&gt;set(i,elementID-1);
                    }
                }
            }
        }
    }

    // Find which nodes should be removed.
    std::vector&lt;uint&gt; nodesToRemove;
    for (uint i=0;i&lt;this-&gt;getElement(position).size();i++)
    {
        uint nodeID = this-&gt;getElement(position).getNodeId(i);
        bool nodeIsUsed = false;
        for (uint j=0;j&lt;this-&gt;getNElements() &amp;&amp; !nodeIsUsed;j++)
        {
            if (j == position)
            {
                continue;
            }
            if (this-&gt;getElement(j).hasNodeId(nodeID))
            {
                nodeIsUsed = true;
            }
        }
        if (!nodeIsUsed)
        {
            nodesToRemove.push_back(nodeID);
        }
    }
    std::sort(nodesToRemove.begin(),nodesToRemove.end());

    // Remove element from elements vector
    std::vector&lt;RElement&gt;::iterator iter = this-&gt;elements.begin();
    std::advance (iter, position);

    this-&gt;elements.erase(iter);
    this-&gt;RResults::removeElement(position);

    // Remove node
    for (uint i=0;i&lt;nodesToRemove.size();i++)
    {
        uint pos = uint(nodesToRemove.size()) - i - 1;
        this-&gt;removeNode(nodesToRemove[pos]);
    }
} /* RModel::removeElement */


</t>
<t tx="leo.20201108101536.51">void RModel::removeElements(const QList&lt;uint&gt; &amp;elementIDs, bool closeHole)
{
    QList&lt;uint&gt; sortedElementIDs(elementIDs);

    std::sort(sortedElementIDs.begin(),sortedElementIDs.end());

    for (int i=sortedElementIDs.size()-1;i&gt;=0;i--)
    {
//        RLogger::info("Removing element #%u\n",sortedElementIDs[i]);

//        QList&lt;uint&gt; edgeNodeIds;
        if (closeHole)
        {
//            edgeNodeIds = this-&gt;findElementEdgeRing(sortedElementIDs[i]);
        }

//        for (int j=0;j&lt;edgeNodeIds.size();j++)
//        {
//            if (edgeNodeIds[j] &gt; sortedElementIDs[i])
//            {
//                edgeNodeIds[j]--;
//            }
//        }

        this-&gt;removeElement(sortedElementIDs[i],true);

//        if (closeHole)
//        {
//            std::vector&lt;RNode&gt; edgeNodes;
//            edgeNodes.resize(edgeNodeIds.size());
//            for (uint i=0;i&lt;edgeNodes.size();i++)
//            {
//                edgeNodes[i] = this-&gt;getNode(edgeNodeIds[i]);
//            }

//            if (edgeNodes.size() &gt; 0)
//            {
//                std::vector&lt;RElement&gt; patchEelements = RPolygon::triangulate(edgeNodes,true);
//                for (uint j=0;j&lt;patchEelements.size();j++)
//                {
//                    for (uint k=0;k&lt;patchEelements[j].size();k++)
//                    {
//                        patchEelements[j].setNodeId(k,edgeNodeIds[patchEelements[j].getNodeId(k)]);
//                    }
//                    this-&gt;addElement(patchEelements[j]);
//                }
//            }
//        }
    }
} /* RModel::removeElements */


std::vector&lt;uint&gt; RModel::findElementPositionsByNodeId(uint nodeID) const
{
    std::vector&lt;uint&gt; elementPositions;
    const RElement *pElement = nullptr;

    R_ERROR_ASSERT (nodeID &lt; this-&gt;getNNodes());

    for (uint i=0;i&lt;this-&gt;getNElements();i++)
    {
        pElement = this-&gt;getElementPtr (i);
        if (pElement-&gt;hasNodeId(nodeID))
        {
            elementPositions.push_back(i);
        }
    }
    return elementPositions;
} /* RModel::findElementPositionsByNodeId */


RStatistics RModel::findLineElementSizeStatistics() const
{
    RRVector elementSizes;
    return RStatistics(elementSizes,100,true);
} /* RModel::findLineElementSizeStatistics */


RStatistics RModel::findSurfaceElementSizeStatistics() const
{
    RRVector elementSizes;
    return RStatistics(elementSizes,100,true);
} /* RModel::findSurfaceElementSizeStatistics */


RStatistics RModel::findVolumeElementSizeStatistics() const
{
    RRVector elementSizes;
    return RStatistics(elementSizes,100,true);
} /* RModel::findVolumeElementSizeStatistics */


uint RModel::purgeUnusedElements()
{
    RLogger::info("Purging unused elements\n");
    RLogger::indent();

    uint nElementGroups = this-&gt;getNElementGroups();

    RLogger::info("Finding unused elements\n");
    // Find unused elements
    std::vector&lt;uint&gt; elementBook(this-&gt;getNElements(),RConstants::eod);

    uint ne = this-&gt;getNElements();

#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(nElementGroups);i++)
    {
        const RElementGroup *pElementGroup = this-&gt;getElementGroupPtr(uint(i));
        for (uint j=0;j&lt;pElementGroup-&gt;size();j++)
        {
            elementBook[pElementGroup-&gt;get(j)] = 0;
        }
    }

    RLogger::info("Removing unused elements\n");
    RLogger::indent();
    // Remove unused elements
    std::vector&lt;RElement&gt; elementsNew;
    elementsNew.reserve(ne);
    for (uint i=0;i&lt;ne;i++)
    {
        if (elementBook[i] != RConstants::eod)
        {
            elementsNew.push_back(this-&gt;elements[i]);
        }
    }
    this-&gt;elements = elementsNew;
    elementsNew.resize(0);
    this-&gt;RResults::removeElements(elementBook);
    RLogger::unindent();

    RLogger::info("Fixing element ID references in element groups\n");
    // Fix element ID references in element groups
    uint nElements = 0;
    for (uint i=0;i&lt;elementBook.size();i++)
    {
        if (elementBook[i] != RConstants::eod)
        {
            elementBook[i] = nElements++;
        }
    }

#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(nElementGroups);i++)
    {
        RElementGroup *pElementGroup = this-&gt;getElementGroupPtr(uint(i));
        for (uint j=0;j&lt;pElementGroup-&gt;size();j++)
        {
            pElementGroup-&gt;set(j,elementBook[pElementGroup-&gt;get(j)]);
        }
    }

    RLogger::info("Updating surface neighbors\n");
    // Update surface neighbors
    if (this-&gt;surfaceNeigs.size() == elementBook.size())
    {
        for (uint i=0;i&lt;this-&gt;surfaceNeigs.size();i++)
        {
            RUVector::reverse_iterator riter;
            for (riter=this-&gt;surfaceNeigs[i].rbegin();riter!=this-&gt;surfaceNeigs[i].rend();++riter)
            {
                uint neigborID = (*riter);
                if (elementBook[neigborID] == RConstants::eod)
                {
                    this-&gt;surfaceNeigs[i].erase(--riter.base());
                }
                else
                {
                    (*riter) = elementBook[neigborID];
                }
            }
        }

        std::vector&lt;RUVector&gt; surfaceNeigsNew;
        surfaceNeigsNew.reserve(elementBook.size());

        for (uint i=0;i&lt;uint(elementBook.size());i++)
        {
            if (elementBook[i] != RConstants::eod)
            {
                surfaceNeigsNew.push_back(surfaceNeigs[i]);
            }
        }
        this-&gt;surfaceNeigs = surfaceNeigsNew;
        surfaceNeigsNew.resize(0);
    }

    RLogger::info("Updating volume neighbors\n");
    // Update volume neighbors
    if (this-&gt;volumeNeigs.size() == elementBook.size())
    {
        for (uint i=0;i&lt;this-&gt;volumeNeigs.size();i++)
        {
            RUVector::reverse_iterator riter;
            for (riter=this-&gt;volumeNeigs[i].rbegin();riter!=this-&gt;volumeNeigs[i].rend();++riter)
            {
                uint neigborID = (*riter);
                if (elementBook[neigborID] == RConstants::eod)
                {
                    this-&gt;volumeNeigs[i].erase(--riter.base());
                }
                else
                {
                    (*riter) = elementBook[neigborID];
                }
            }
        }

        std::vector&lt;RUVector&gt; volumeNeigsNew;
        volumeNeigsNew.reserve(elementBook.size());

        for (uint i=0;i&lt;uint(elementBook.size());i++)
        {
            if (elementBook[i] != RConstants::eod)
            {
                volumeNeigsNew.push_back(volumeNeigs[i]);
            }
        }
        this-&gt;volumeNeigs = volumeNeigsNew;
        volumeNeigsNew.resize(0);
    }
    RLogger::unindent();

    return ne - this-&gt;getNElements();
} /* RModel::purgeUnusedElements */


/*********************************************************************
 * Interpolated element interface                                    *
 *********************************************************************/


</t>
<t tx="leo.20201108101536.52">const RInterpolatedElement *RModel::getInterpolatedElement(REntityGroupType type, uint entityID, uint elementID) const
{
    switch (type)
    {
        case R_ENTITY_GROUP_CUT:
        {
            return &amp;this-&gt;cuts[entityID].at(elementID);
        }
        case R_ENTITY_GROUP_ISO:
        {
            return &amp;this-&gt;isos[entityID].at(elementID);
        }
        case R_ENTITY_GROUP_STREAM_LINE:
        {
            return &amp;this-&gt;streamLines[entityID].at(elementID);
        }
        default:
        {
            return nullptr;
        }
    }
} /* RModel::purgeUnusedElements */


RInterpolatedElement *RModel::getInterpolatedElement(REntityGroupType type, uint entityID, uint elementID)
{
    switch (type)
    {
        case R_ENTITY_GROUP_CUT:
        {
            return &amp;this-&gt;cuts[entityID].at(elementID);
        }
        case R_ENTITY_GROUP_ISO:
        {
            return &amp;this-&gt;isos[entityID].at(elementID);
        }
        case R_ENTITY_GROUP_STREAM_LINE:
        {
            return &amp;this-&gt;streamLines[entityID].at(elementID);
        }
        default:
        {
            return nullptr;
        }
    }
} /* RModel::purgeUnusedElements */


/*********************************************************************
 * Element group interface                                           *
 *********************************************************************/


uint RModel::getNEntityElements(REntityGroupType entityType) const
{
    uint nElements = 0;

    if (R_ENTITY_GROUP_POINT &amp; entityType)
    {
        for (uint i=0;i&lt;this-&gt;getNPoints();i++)
        {
            nElements += this-&gt;getPoint(i).size();
        }
    }
    if (R_ENTITY_GROUP_LINE &amp; entityType)
    {
        for (uint i=0;i&lt;this-&gt;getNLines();i++)
        {
            nElements += this-&gt;getLine(i).size();
        }
    }
    if (R_ENTITY_GROUP_SURFACE &amp; entityType)
    {
        for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
        {
            nElements += this-&gt;getSurface(i).size();
        }
    }
    if (R_ENTITY_GROUP_VOLUME &amp; entityType)
    {
        for (uint i=0;i&lt;this-&gt;getNVolumes();i++)
        {
            nElements += this-&gt;getVolume(i).size();
        }
    }

    return nElements;
} /* RModel::getNEntityElements */


uint RModel::getNElementGroups() const
{
    return this-&gt;getNEntityGroups(true);
} /* RModel::getNElementGroups */


uint RModel::getNEntityGroups(bool onlyElements) const
{
    uint nEntityGroups = this-&gt;getNPoints() + this-&gt;getNLines() + this-&gt;getNSurfaces() + this-&gt;getNVolumes();;
    if (!onlyElements)
    {
        nEntityGroups += this-&gt;getNVectorFields() + this-&gt;getNScalarFields() + this-&gt;getNStreamLines() + this-&gt;getNCuts() + this-&gt;getNIsos();
    }
    return nEntityGroups;
} /* RModel::getNEntityGroups */


</t>
<t tx="leo.20201108101536.53">const RElementGroup *RModel::getElementGroupPtr(uint groupID) const
{
    R_ERROR_ASSERT(groupID &lt; this-&gt;getNElementGroups());

    return static_cast&lt;const RElementGroup*&gt;(this-&gt;getEntityGroupPtr(groupID,true));
} /* RModel::getElementGroupPtr */


RElementGroup *RModel::getElementGroupPtr(uint groupID)
{
    R_ERROR_ASSERT(groupID &lt; this-&gt;getNElementGroups());

    return static_cast&lt;RElementGroup*&gt;(this-&gt;getEntityGroupPtr(groupID,true));
} /* RModel::getElementGroupPtr */


</t>
<t tx="leo.20201108101536.54">const REntityGroup *RModel::getEntityGroupPtr(uint groupID, bool onlyElements) const
{
    R_ERROR_ASSERT(groupID &lt; this-&gt;getNEntityGroups());

    uint groupPossition = groupID;
    if (groupPossition &lt; this-&gt;getNPoints())
    {
        return this-&gt;getPointPtr(groupPossition);
    }

    groupPossition -= this-&gt;getNPoints();
    if (groupPossition &lt; this-&gt;getNLines())
    {
        return this-&gt;getLinePtr(groupPossition);
    }

    groupPossition -= this-&gt;getNLines();
    if (groupPossition &lt; this-&gt;getNSurfaces())
    {
        return this-&gt;getSurfacePtr(groupPossition);
    }

    groupPossition -= this-&gt;getNSurfaces();
    if (groupPossition &lt; this-&gt;getNVolumes())
    {
        return this-&gt;getVolumePtr(groupPossition);
    }

    if (!onlyElements)
    {
        groupPossition -= this-&gt;getNVolumes();
        if (groupPossition &lt; this-&gt;getNVectorFields())
        {
            return this-&gt;getVectorFieldPtr(groupPossition);
        }

        groupPossition -= this-&gt;getNVectorFields();
        if (groupPossition &lt; this-&gt;getNScalarFields())
        {
            return this-&gt;getScalarFieldPtr(groupPossition);
        }

        groupPossition -= this-&gt;getNScalarFields();
        if (groupPossition &lt; this-&gt;getNStreamLines())
        {
            return this-&gt;getStreamLinePtr(groupPossition);
        }

        groupPossition -= this-&gt;getNStreamLines();
        if (groupPossition &lt; this-&gt;getNCuts())
        {
            return this-&gt;getCutPtr(groupPossition);
        }

        groupPossition -= this-&gt;getNCuts();
        if (groupPossition &lt; this-&gt;getNIsos())
        {
            return this-&gt;getIsoPtr(groupPossition);
        }
    }

    return nullptr;
} /* RModel::getEntityGroupPtr */


REntityGroup *RModel::getEntityGroupPtr(uint groupID, bool onlyElements)
{
    R_ERROR_ASSERT(groupID &lt; this-&gt;getNEntityGroups());

    uint groupPossition = groupID;
    if (groupPossition &lt; this-&gt;getNPoints())
    {
        return this-&gt;getPointPtr(groupPossition);
    }

    groupPossition -= this-&gt;getNPoints();
    if (groupPossition &lt; this-&gt;getNLines())
    {
        return this-&gt;getLinePtr(groupPossition);
    }

    groupPossition -= this-&gt;getNLines();
    if (groupPossition &lt; this-&gt;getNSurfaces())
    {
        return this-&gt;getSurfacePtr(groupPossition);
    }

    groupPossition -= this-&gt;getNSurfaces();
    if (groupPossition &lt; this-&gt;getNVolumes())
    {
        return this-&gt;getVolumePtr(groupPossition);
    }

    if (!onlyElements)
    {
        groupPossition -= this-&gt;getNVolumes();
        if (groupPossition &lt; this-&gt;getNVectorFields())
        {
            return this-&gt;getVectorFieldPtr(groupPossition);
        }

        groupPossition -= this-&gt;getNVectorFields();
        if (groupPossition &lt; this-&gt;getNScalarFields())
        {
            return this-&gt;getScalarFieldPtr(groupPossition);
        }

        groupPossition -= this-&gt;getNScalarFields();
        if (groupPossition &lt; this-&gt;getNStreamLines())
        {
            return this-&gt;getStreamLinePtr(groupPossition);
        }

        groupPossition -= this-&gt;getNStreamLines();
        if (groupPossition &lt; this-&gt;getNCuts())
        {
            return this-&gt;getCutPtr(groupPossition);
        }

        groupPossition -= this-&gt;getNCuts();
        if (groupPossition &lt; this-&gt;getNIsos())
        {
            return this-&gt;getIsoPtr(groupPossition);
        }
    }

    return nullptr;
} /* RModel::getEntityGroupPtr */


REntityGroupType RModel::getEntityGroupType(uint groupID, bool onlyElements) const
{
    R_ERROR_ASSERT(groupID &lt; this-&gt;getNEntityGroups());

    uint groupPossition = groupID;
    if (groupPossition &lt; this-&gt;getNPoints())
    {
        return R_ENTITY_GROUP_POINT;
    }

    groupPossition -= this-&gt;getNPoints();
    if (groupPossition &lt; this-&gt;getNLines())
    {
        return R_ENTITY_GROUP_LINE;
    }

    groupPossition -= this-&gt;getNLines();
    if (groupPossition &lt; this-&gt;getNSurfaces())
    {
        return R_ENTITY_GROUP_SURFACE;
    }

    groupPossition -= this-&gt;getNSurfaces();
    if (groupPossition &lt; this-&gt;getNVolumes())
    {
        return R_ENTITY_GROUP_VOLUME;
    }

    if (!onlyElements)
    {
        groupPossition -= this-&gt;getNVolumes();
        if (groupPossition &lt; this-&gt;getNVectorFields())
        {
            return R_ENTITY_GROUP_VECTOR_FIELD;
        }

        groupPossition -= this-&gt;getNVectorFields();
        if (groupPossition &lt; this-&gt;getNScalarFields())
        {
            return R_ENTITY_GROUP_SCALAR_FIELD;
        }

        groupPossition -= this-&gt;getNScalarFields();
        if (groupPossition &lt; this-&gt;getNStreamLines())
        {
            return R_ENTITY_GROUP_STREAM_LINE;
        }

        groupPossition -= this-&gt;getNStreamLines();
        if (groupPossition &lt; this-&gt;getNCuts())
        {
            return R_ENTITY_GROUP_CUT;
        }

        groupPossition -= this-&gt;getNCuts();
        if (groupPossition &lt; this-&gt;getNIsos())
        {
            return R_ENTITY_GROUP_ISO;
        }
    }

    return R_ENTITY_GROUP_NONE;
} /* RModel::getEntityGroupType */


uint RModel::getEntityGroupPosition(uint groupID, bool onlyElements) const
{
    R_ERROR_ASSERT(groupID &lt; this-&gt;getNEntityGroups());

    uint groupPossition = groupID;
    if (groupPossition &lt; this-&gt;getNPoints())
    {
        return groupPossition;
    }

    groupPossition -= this-&gt;getNPoints();
    if (groupPossition &lt; this-&gt;getNLines())
    {
        return groupPossition;
    }

    groupPossition -= this-&gt;getNLines();
    if (groupPossition &lt; this-&gt;getNSurfaces())
    {
        return groupPossition;
    }

    groupPossition -= this-&gt;getNSurfaces();
    if (groupPossition &lt; this-&gt;getNVolumes())
    {
        return groupPossition;
    }

    if (!onlyElements)
    {
        groupPossition -= this-&gt;getNVolumes();
        if (groupPossition &lt; this-&gt;getNVectorFields())
        {
            return groupPossition;
        }

        groupPossition -= this-&gt;getNVectorFields();
        if (groupPossition &lt; this-&gt;getNScalarFields())
        {
            return groupPossition;
        }

        groupPossition -= this-&gt;getNScalarFields();
        if (groupPossition &lt; this-&gt;getNStreamLines())
        {
            return groupPossition;
        }

        groupPossition -= this-&gt;getNStreamLines();
        if (groupPossition &lt; this-&gt;getNCuts())
        {
            return groupPossition;
        }

        groupPossition -= this-&gt;getNCuts();
        if (groupPossition &lt; this-&gt;getNIsos())
        {
            return groupPossition;
        }
    }

    return RConstants::eod;
} /* RModel::getEntityGroupPosition */


uint RModel::getElementGroupID(REntityGroupType entityType, uint entityID) const
{
    return this-&gt;getEntityGroupID(entityType,entityID,true);
} /* RModel::getElementGroupID */


uint RModel::getEntityGroupID(REntityGroupType entityType, uint entityID, bool onlyElements) const
{
    uint elementGroupID = 0;
    switch (entityType)
    {
        case R_ENTITY_GROUP_POINT:
            if (entityID &gt; this-&gt;getNPoints())
            {
                return RConstants::eod;
            }
            break;
        case R_ENTITY_GROUP_LINE:
            if (entityID &gt; this-&gt;getNLines())
            {
                return RConstants::eod;
            }
            elementGroupID += this-&gt;getNPoints();
            break;
        case R_ENTITY_GROUP_SURFACE:
            if (entityID &gt; this-&gt;getNSurfaces())
            {
                return RConstants::eod;
            }
            elementGroupID += this-&gt;getNPoints();
            elementGroupID += this-&gt;getNLines();
            break;
        case R_ENTITY_GROUP_VOLUME:
            if (entityID &gt; this-&gt;getNVolumes())
            {
                return RConstants::eod;
            }
            elementGroupID += this-&gt;getNPoints();
            elementGroupID += this-&gt;getNLines();
            elementGroupID += this-&gt;getNSurfaces();
            break;
        case R_ENTITY_GROUP_VECTOR_FIELD:
            if (entityID &gt; this-&gt;getNVectorFields() || onlyElements)
            {
                return RConstants::eod;
            }
            elementGroupID += this-&gt;getNPoints();
            elementGroupID += this-&gt;getNLines();
            elementGroupID += this-&gt;getNSurfaces();
            elementGroupID += this-&gt;getNVolumes();
            break;
        case R_ENTITY_GROUP_SCALAR_FIELD:
            if (entityID &gt; this-&gt;getNScalarFields() || onlyElements)
            {
                return RConstants::eod;
            }
            elementGroupID += this-&gt;getNPoints();
            elementGroupID += this-&gt;getNLines();
            elementGroupID += this-&gt;getNSurfaces();
            elementGroupID += this-&gt;getNVolumes();
            elementGroupID += this-&gt;getNVectorFields();
            break;
        case R_ENTITY_GROUP_STREAM_LINE:
            if (entityID &gt; this-&gt;getNStreamLines() || onlyElements)
            {
                return RConstants::eod;
            }
            elementGroupID += this-&gt;getNPoints();
            elementGroupID += this-&gt;getNLines();
            elementGroupID += this-&gt;getNSurfaces();
            elementGroupID += this-&gt;getNVolumes();
            elementGroupID += this-&gt;getNVectorFields();
            elementGroupID += this-&gt;getNScalarFields();
            break;
        case R_ENTITY_GROUP_CUT:
            if (entityID &gt; this-&gt;getNCuts() || onlyElements)
            {
                return RConstants::eod;
            }
            elementGroupID += this-&gt;getNPoints();
            elementGroupID += this-&gt;getNLines();
            elementGroupID += this-&gt;getNSurfaces();
            elementGroupID += this-&gt;getNVolumes();
            elementGroupID += this-&gt;getNVectorFields();
            elementGroupID += this-&gt;getNScalarFields();
            elementGroupID += this-&gt;getNStreamLines();
            break;
        case R_ENTITY_GROUP_ISO:
            if (entityID &gt; this-&gt;getNIsos() || onlyElements)
            {
                return RConstants::eod;
            }
            elementGroupID += this-&gt;getNPoints();
            elementGroupID += this-&gt;getNLines();
            elementGroupID += this-&gt;getNSurfaces();
            elementGroupID += this-&gt;getNVolumes();
            elementGroupID += this-&gt;getNVectorFields();
            elementGroupID += this-&gt;getNScalarFields();
            elementGroupID += this-&gt;getNStreamLines();
            elementGroupID += this-&gt;getNCuts();
            break;
        default:
            return RConstants::eod;
    }

    elementGroupID += entityID;

    return elementGroupID;
} /* RModel::getEntityGroupID */


std::vector&lt;uint&gt; RModel::getEntityGroupIDs(REntityGroupType entityType) const
{
    uint nEntities = 0;

    switch (entityType)
    {
        case R_ENTITY_GROUP_POINT:
            nEntities = this-&gt;getNPoints();
            break;
        case R_ENTITY_GROUP_LINE:
            nEntities = this-&gt;getNLines();
            break;
        case R_ENTITY_GROUP_SURFACE:
            nEntities = this-&gt;getNSurfaces();
            break;
        case R_ENTITY_GROUP_VOLUME:
            nEntities = this-&gt;getNVolumes();
            break;
        case R_ENTITY_GROUP_VECTOR_FIELD:
            nEntities = this-&gt;getNVectorFields();
            break;
        case R_ENTITY_GROUP_SCALAR_FIELD:
            nEntities = this-&gt;getNScalarFields();
            break;
        case R_ENTITY_GROUP_STREAM_LINE:
            nEntities = this-&gt;getNStreamLines();
            break;
        case R_ENTITY_GROUP_CUT:
            nEntities = this-&gt;getNCuts();
            break;
        case R_ENTITY_GROUP_ISO:
            nEntities = this-&gt;getNIsos();
            break;
        default:
            nEntities = 0;
            break;
    }

    std::vector&lt;uint&gt; groupIDs;

    for (uint i=0;i&lt;nEntities;i++)
    {
        groupIDs.push_back(this-&gt;getEntityGroupID(entityType,i));
    }

    return groupIDs;
} /* RModel::getEntityGroupIDs */


QMap&lt;REntityGroupType,RUVector&gt; RModel::getEntityIDMap() const
{
    QMap&lt;REntityGroupType,RUVector&gt; entityIDMap;

    RUVector envIDs;

    uint grpID = 0;

    // Points
    envIDs.resize(this-&gt;getNPoints());
    for (uint i=0;i&lt;envIDs.size();i++)
    {
        envIDs[i] = grpID++;
    }
    entityIDMap[R_ENTITY_GROUP_POINT] = envIDs;

    // Lines
    envIDs.resize(this-&gt;getNLines());
    for (uint i=0;i&lt;envIDs.size();i++)
    {
        envIDs[i] = grpID++;
    }
    entityIDMap[R_ENTITY_GROUP_LINE] = envIDs;

    // Surfaces
    envIDs.resize(this-&gt;getNSurfaces());
    for (uint i=0;i&lt;envIDs.size();i++)
    {
        envIDs[i] = grpID++;
    }
    entityIDMap[R_ENTITY_GROUP_SURFACE] = envIDs;

    // Volumes
    envIDs.resize(this-&gt;getNVolumes());
    for (uint i=0;i&lt;envIDs.size();i++)
    {
        envIDs[i] = grpID++;
    }
    entityIDMap[R_ENTITY_GROUP_VOLUME] = envIDs;

    // Vector fields
    envIDs.resize(this-&gt;getNVectorFields());
    for (uint i=0;i&lt;envIDs.size();i++)
    {
        envIDs[i] = grpID++;
    }
    entityIDMap[R_ENTITY_GROUP_VECTOR_FIELD] = envIDs;

    // Scalar fields
    envIDs.resize(this-&gt;getNScalarFields());
    for (uint i=0;i&lt;envIDs.size();i++)
    {
        envIDs[i] = grpID++;
    }
    entityIDMap[R_ENTITY_GROUP_SCALAR_FIELD] = envIDs;

    // Stream lines
    envIDs.resize(this-&gt;getNStreamLines());
    for (uint i=0;i&lt;envIDs.size();i++)
    {
        envIDs[i] = grpID++;
    }
    entityIDMap[R_ENTITY_GROUP_STREAM_LINE] = envIDs;

    // Cuts
    envIDs.resize(this-&gt;getNCuts());
    for (uint i=0;i&lt;envIDs.size();i++)
    {
        envIDs[i] = grpID++;
    }
    entityIDMap[R_ENTITY_GROUP_CUT] = envIDs;

    // ISOs
    envIDs.resize(this-&gt;getNIsos());
    for (uint i=0;i&lt;envIDs.size();i++)
    {
        envIDs[i] = grpID++;
    }
    entityIDMap[R_ENTITY_GROUP_ISO] = envIDs;

    return entityIDMap;
} /* RModel::getEntityIDMap */


</t>
<t tx="leo.20201108101536.55">bool RModel::getEntityID(uint groupID, REntityGroupType &amp;entityType, uint &amp;entityID) const
{
    uint ceid = 0;
    uint cgid = this-&gt;getNPoints();
    if (groupID &lt; cgid)
    {
        entityType = R_ENTITY_GROUP_POINT;
        entityID = groupID - ceid;
        return true;
    }
    ceid = cgid;
    cgid += this-&gt;getNLines();
    if (groupID &lt; cgid)
    {
        entityType = R_ENTITY_GROUP_LINE;
        entityID = groupID - ceid;
        return true;
    }
    ceid = cgid;
    cgid += this-&gt;getNSurfaces();
    if (groupID &lt; cgid)
    {
        entityType = R_ENTITY_GROUP_SURFACE;
        entityID = groupID - ceid;
        return true;
    }
    ceid = cgid;
    cgid += this-&gt;getNVolumes();
    if (groupID &lt; cgid)
    {
        entityType = R_ENTITY_GROUP_VOLUME;
        entityID = groupID - ceid;
        return true;
    }
    ceid = cgid;
    cgid += this-&gt;getNVectorFields();
    if (groupID &lt; cgid)
    {
        entityType = R_ENTITY_GROUP_VECTOR_FIELD;
        entityID = groupID - ceid;
        return true;
    }
    ceid = cgid;
    cgid += this-&gt;getNScalarFields();
    if (groupID &lt; cgid)
    {
        entityType = R_ENTITY_GROUP_SCALAR_FIELD;
        entityID = groupID - ceid;
        return true;
    }
    ceid = cgid;
    cgid += this-&gt;getNStreamLines();
    if (groupID &lt; cgid)
    {
        entityType = R_ENTITY_GROUP_STREAM_LINE;
        entityID = groupID - ceid;
        return true;
    }
    ceid = cgid;
    cgid += this-&gt;getNCuts();
    if (groupID &lt; cgid)
    {
        entityType = R_ENTITY_GROUP_CUT;
        entityID = groupID - ceid;
        return true;
    }
    ceid = cgid;
    cgid += this-&gt;getNIsos();
    if (groupID &lt; cgid)
    {
        entityType = R_ENTITY_GROUP_ISO;
        entityID = groupID - ceid;
        return true;
    }
    return false;
} /* RModel::getEntityID */


uint RModel::findElementID(REntityGroupType entityType, uint entityID, uint elementPosition) const
{
    uint groupID = this-&gt;getElementGroupID(entityType,entityID);
    if (groupID == RConstants::eod)
    {
        return RConstants::eod;
    }
    const RElementGroup *pElementGroup = this-&gt;getElementGroupPtr(groupID);
    if (!pElementGroup)
    {
        return RConstants::eod;
    }
    return pElementGroup-&gt;get(elementPosition);
} /* RModel::findElementID */


uint RModel::findNodeID(REntityGroupType entityType, uint entityID, uint elementPosition, uint nodePosition) const
{
    uint elementID = this-&gt;findElementID(entityType,entityID,elementPosition);
    if (elementID == RConstants::eod)
    {
        return RConstants::eod;
    }
    const RElement &amp;rElement = this-&gt;getElement(elementID);
    if (nodePosition &gt;= rElement.size())
    {
        return RConstants::eod;
    }
    return rElement.getNodeId(nodePosition);
} /* RModel::findNodeID */


std::vector&lt;uint&gt; RModel::findElementIDs(REntityGroupType entityType, const std::vector&lt;uint&gt; entityIDs) const
{
    std::vector&lt;uint&gt; elementIDsSet;
    elementIDsSet.resize(this-&gt;getNElements(),RConstants::eod);
    uint nElementIDs = 0;

    for (uint i=0;i&lt;entityIDs.size();i++)
    {
        uint groupID = this-&gt;getElementGroupID(entityType,entityIDs[i]);
        if (groupID == RConstants::eod)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid entity ID.");
        }
        const RElementGroup *pElementGroup = this-&gt;getElementGroupPtr(groupID);
        if (!pElementGroup)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid entity ID. Element group was not found.");
        }
        for (uint j=0;j&lt;pElementGroup-&gt;size();j++)
        {
            if (elementIDsSet[pElementGroup-&gt;get(j)] == RConstants::eod)
            {
                elementIDsSet[pElementGroup-&gt;get(j)] = nElementIDs++;
            }
        }
    }

    std::vector&lt;uint&gt; elementIDs(nElementIDs);
    for (uint i=0;i&lt;elementIDsSet.size();i++)
    {
        if (elementIDsSet[i] != RConstants::eod)
        {
            elementIDs[elementIDsSet[i]] = i;
        }
    }

    return elementIDs;
} /* RModel::findElementIDs */


</t>
<t tx="leo.20201108101536.56">void RModel::mergeEntities(REntityGroupType entityType, const QList&lt;uint&gt; &amp;entityIDs)
{
    if (entityIDs.size() &lt; 2)
    {
        return;
    }

    switch (entityType)
    {
        case R_ENTITY_GROUP_POINT:
        {
            RLogger::info("Merging point entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;0;i--)
            {
                for (uint j=0;j&lt;this-&gt;getPoint(entityIDs[i]).size();j++)
                {
                    this-&gt;getPoint(entityIDs[0]).add(this-&gt;getPoint(entityIDs[i]).get(j));
                }
                this-&gt;removePoint(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_LINE:
        {
            RLogger::info("Merging line entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;0;i--)
            {
                for (uint j=0;j&lt;this-&gt;getLine(entityIDs[i]).size();j++)
                {
                    this-&gt;getLine(entityIDs[0]).add(this-&gt;getLine(entityIDs[i]).get(j));
                }
                this-&gt;removeLine(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_SURFACE:
        {
            RLogger::info("Merging surface entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;0;i--)
            {
                for (uint j=0;j&lt;this-&gt;getSurface(entityIDs[i]).size();j++)
                {
                    this-&gt;getSurface(entityIDs[0]).add(this-&gt;getSurface(entityIDs[i]).get(j));
                }
                this-&gt;removeSurface(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_VOLUME:
        {
            RLogger::info("Merging volume entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;0;i--)
            {
                for (uint j=0;j&lt;this-&gt;getVolume(entityIDs[i]).size();j++)
                {
                    this-&gt;getVolume(entityIDs[0]).add(this-&gt;getVolume(entityIDs[i]).get(j));
                }
                this-&gt;removeVolume(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        default:
        {
            break;
        }
    }
} /* RModel::mergeEntities */


</t>
<t tx="leo.20201108101536.57">void RModel::removeEntities(REntityGroupType entityType, const QList&lt;uint&gt; &amp;entityIDs)
{
    if (entityIDs.size() == 0)
    {
        return;
    }

    switch (entityType)
    {
        case R_ENTITY_GROUP_POINT:
        {
            RLogger::info("Removing point entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;=0;i--)
            {
                RLogger::info("Removing point \'%s\'\n",this-&gt;getPoint(entityIDs[i]).getName().toUtf8().constData());
                this-&gt;removePoint(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_LINE:
        {
            RLogger::info("Removing line entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;=0;i--)
            {
                RLogger::info("Removing line \'%s\'\n",this-&gt;getLine(entityIDs[i]).getName().toUtf8().constData());
                this-&gt;removeLine(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_SURFACE:
        {
            RLogger::info("Removing surface entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;=0;i--)
            {
                RLogger::info("Removing surface \'%s\'\n",this-&gt;getSurface(entityIDs[i]).getName().toUtf8().constData());
                this-&gt;removeSurface(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_VOLUME:
        {
            RLogger::info("Removing volume entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;=0;i--)
            {
                RLogger::info("Removing volume \'%s\'\n",this-&gt;getVolume(entityIDs[i]).getName().toUtf8().constData());
                this-&gt;removeVolume(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_VECTOR_FIELD:
        {
            RLogger::info("Removing vector field entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;=0;i--)
            {
                RLogger::info("Removing vector field \'%s\'\n",this-&gt;getVectorField(entityIDs[i]).getName().toUtf8().constData());
                this-&gt;removeVectorField(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_SCALAR_FIELD:
        {
            RLogger::info("Removing scalar field entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;=0;i--)
            {
                RLogger::info("Removing scalar field \'%s\'\n",this-&gt;getScalarField(entityIDs[i]).getName().toUtf8().constData());
                this-&gt;removeScalarField(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_STREAM_LINE:
        {
            RLogger::info("Removing stream line entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;=0;i--)
            {
                RLogger::info("Removing stream line \'%s\'\n",this-&gt;getStreamLine(entityIDs[i]).getName().toUtf8().constData());
                this-&gt;removeStreamLine(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_CUT:
        {
            RLogger::info("Removing cut entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;=0;i--)
            {
                RLogger::info("Removing cut \'%s\'\n",this-&gt;getCut(entityIDs[i]).getName().toUtf8().constData());
                this-&gt;removeCut(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        case R_ENTITY_GROUP_ISO:
        {
            RLogger::info("Removing iso entities\n");
            RLogger::indent();
            for (int i=entityIDs.size()-1;i&gt;=0;i--)
            {
                RLogger::info("Removing iso \'%s\'\n",this-&gt;getIso(entityIDs[i]).getName().toUtf8().constData());
                this-&gt;removeIso(entityIDs[i]);
            }
            RLogger::unindent();
            break;
        }
        default:
        {
            break;
        }
    }
} /* RModel::removeEntities */


/*********************************************************************
 * Point interface                                                   *
 *********************************************************************/


uint RModel::getNPoints () const
{
    return uint(this-&gt;points.size());
} /* RModel::getNPoints */


</t>
<t tx="leo.20201108101536.58">void RModel::setNPoints (uint npoints)
{
    uint oldSize=uint(this-&gt;points.size());
    this-&gt;points.resize(npoints);
    for (uint i=oldSize;i&lt;npoints;i++)
    {
        this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_POINT,oldSize));
    }
    for (uint i=npoints;i&lt;oldSize;i++)
    {
        this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_POINT,npoints));
    }
} /* RModel::setNPoints */


</t>
<t tx="leo.20201108101536.59">const RPoint * RModel::getPointPtr (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;points.size());
    return &amp;this-&gt;points[position];
} /* RModel::getPointPtr */


RPoint * RModel::getPointPtr (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;points.size());
    return &amp;this-&gt;points[position];
} /* RModel::getPointPtr */


</t>
<t tx="leo.20201108101536.6">void RMeshSetup::setMaxEdgeLength(double maxEdgeLength)
{
    this-&gt;maxEdgeLength = maxEdgeLength;
}
</t>
<t tx="leo.20201108101536.60">const RPoint &amp; RModel::getPoint (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;points.size());
    return this-&gt;points[position];
} /* RModel::getPoint */


RPoint &amp; RModel::getPoint (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;points.size());
    return this-&gt;points[position];
} /* RModel::getPoint */


</t>
<t tx="leo.20201108101536.61">void RModel::addPoint (const RPoint &amp;point)
{
    this-&gt;points.push_back (point);
    this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_POINT,uint(this-&gt;points.size()-1)));
} /* RModel::addPoint */


</t>
<t tx="leo.20201108101536.62">void RModel::setPoint (uint  position,
                        const RPoint &amp;point)
{
    R_ERROR_ASSERT (position &lt; this-&gt;points.size());
    this-&gt;points[position] = point;
} /* RModel::setPoint */


</t>
<t tx="leo.20201108101536.63">void RModel::removePoint (uint position)
{
    this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_POINT,position));

    std::vector&lt;RPoint&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;points.size());

    iter = this-&gt;points.begin();
    std::advance (iter, position);

    this-&gt;points.erase (iter);
} /* RModel::removePoint */


/*********************************************************************
 * Line interface                                                    *
 *********************************************************************/


uint RModel::getNLines () const
{
    return uint(this-&gt;lines.size());
} /* RModel::getNLines */


</t>
<t tx="leo.20201108101536.64">void RModel::setNLines (uint nlines)
{
    uint oldSize=uint(this-&gt;lines.size());
    this-&gt;lines.resize(nlines);
    for (uint i=oldSize;i&lt;nlines;i++)
    {
        this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_LINE,oldSize));
    }
    for (uint i=nlines;i&lt;oldSize;i++)
    {
        this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_LINE,nlines));
    }
} /* RModel::setNLines */


</t>
<t tx="leo.20201108101536.65">const RLine * RModel::getLinePtr (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;lines.size());
    return &amp;this-&gt;lines[position];
} /* RModel::getLinePtr */


RLine * RModel::getLinePtr (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;lines.size());
    return &amp;this-&gt;lines[position];
} /* RModel::getLinePtr */


</t>
<t tx="leo.20201108101536.66">const RLine &amp; RModel::getLine (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;lines.size());
    return this-&gt;lines[position];
} /* RModel::getLine */


RLine &amp; RModel::getLine (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;lines.size());
    return this-&gt;lines[position];
} /* RModel::getLine */


</t>
<t tx="leo.20201108101536.67">void RModel::addLine (const RLine &amp;line)
{
    this-&gt;lines.push_back (line);
    this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_LINE,uint(this-&gt;lines.size()-1)));
} /* RModel::addLine */


</t>
<t tx="leo.20201108101536.68">void RModel::setLine (uint  position,
                       const RLine  &amp;line)
{
    R_ERROR_ASSERT (position &lt; this-&gt;lines.size());
    this-&gt;lines[position] = line;
} /* RModel::setLine */


</t>
<t tx="leo.20201108101536.69">void RModel::removeLine (uint position)
{
    this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_LINE,position));

    std::vector&lt;RLine&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;lines.size());

    iter = this-&gt;lines.begin();
    std::advance (iter, position);

    this-&gt;lines.erase (iter);
} /* RModel::removeLine */


/*********************************************************************
 * Surface interface                                                    *
 *********************************************************************/


uint RModel::getNSurfaces () const
{
    return uint(this-&gt;surfaces.size());
} /* RModel::getNSurfaces */


</t>
<t tx="leo.20201108101536.7">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_modal_setup.cpp                                      *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   10-th May 2016                                           *
 *                                                                   *
 *  DESCRIPTION: Modal setup class definition                        *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "rml_modal_setup.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101536.70">void RModel::setNSurfaces (uint nsurfaces)
{
    uint oldSize=uint(this-&gt;surfaces.size());
    this-&gt;surfaces.resize(nsurfaces);
    for (uint i=oldSize;i&lt;nsurfaces;i++)
    {
        this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_SURFACE,oldSize));
    }
    for (uint i=nsurfaces;i&lt;oldSize;i++)
    {
        this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_SURFACE,nsurfaces));
    }
} /* RModel::setNSurfaces */


</t>
<t tx="leo.20201108101536.71">const RSurface * RModel::getSurfacePtr (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;surfaces.size());
    return &amp;this-&gt;surfaces[position];
} /* RModel::getSurfacePtr */


RSurface * RModel::getSurfacePtr (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;surfaces.size());
    return &amp;this-&gt;surfaces[position];
} /* RModel::getSurfacePtr */


</t>
<t tx="leo.20201108101536.72">const RSurface &amp; RModel::getSurface (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;surfaces.size());
    return this-&gt;surfaces[position];
} /* RModel::getSurface */


RSurface &amp; RModel::getSurface (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;surfaces.size());
    return this-&gt;surfaces[position];
} /* RModel::getSurface */


</t>
<t tx="leo.20201108101536.73">void RModel::addSurface (const RSurface &amp;surface)
{
    this-&gt;surfaces.push_back (surface);
    this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_SURFACE,uint(this-&gt;surfaces.size()-1)));
} /* RModel::add_surface */


</t>
<t tx="leo.20201108101536.74">void RModel::setSurface (uint    position,
                          const RSurface &amp;surface)
{
    R_ERROR_ASSERT (position &lt; this-&gt;surfaces.size());
    this-&gt;surfaces[position] = surface;
} /* RModel::addSurface */


</t>
<t tx="leo.20201108101536.75">void RModel::removeSurface (uint position)
{
    this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_SURFACE,position));

    std::vector&lt;RSurface&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;surfaces.size());

    iter = this-&gt;surfaces.begin();
    std::advance (iter, position);

    this-&gt;surfaces.erase (iter);
} /* RModel::removeSurface */


</t>
<t tx="leo.20201108101536.76">bool RModel::checkIfSurfaceIsClosed(uint surfaceID) const
{
    QList&lt;uint&gt; surfaceIDList;
    surfaceIDList.append(surfaceID);
    return this-&gt;checkIfSurfacesAreClosed(surfaceIDList);
} /* RModel::checkIfSurfaceIsClosed */


</t>
<t tx="leo.20201108101536.77">bool RModel::checkIfSurfacesAreClosed(const QList&lt;uint&gt; &amp;surfaceIDs) const
{
    // Build book of elements, which are part of the surface.
    std::vector&lt;bool&gt; elementBook;
    elementBook.resize(this-&gt;getNElements(),false);

    for (int i=0;i&lt;surfaceIDs.size();i++)
    {
        const RSurface &amp;rSurface = this-&gt;getSurface(surfaceIDs[i]);
        for (uint j=0;j&lt;rSurface.size();j++)
        {
            elementBook[rSurface.get(j)] = true;
        }
    }

    for (uint i=0;i&lt;elementBook.size();i++)
    {
        if (elementBook[i])
        {
            const std::vector&lt;uint&gt; *neighborIDs = this-&gt;getNeighborIDs(i);
            if (!neighborIDs)
            {
                return false;
            }
            if (neighborIDs-&gt;size() &lt; RElement::getNNeighbors(this-&gt;getElement(i).getType()))
            {
                return false;
            }
            for (uint j=0;j&lt;neighborIDs-&gt;size();j++)
            {
                if (!elementBook[neighborIDs-&gt;at(j)])
                {
                    return false;
                }
            }
        }
    }

    return true;
} /* RModel::checkIfSurfacesAreClosed */


</t>
<t tx="leo.20201108101536.78">void RModel::syncSurfaceNormals()
{
    if (this-&gt;getNElements() != this-&gt;surfaceNeigs.size())
    {
        this-&gt;setSurfaceNeighbors(this-&gt;findSurfaceNeighbors());
    }

    uint nSwapped = 0;
    for (uint i=0;i&lt;this-&gt;getNSurfaces();i++)
    {
        RBVector elementSurface(this-&gt;getNElements(),false);
        RBVector elementChecked(this-&gt;getNElements(),false);

        const RSurface &amp;rSurface = this-&gt;getSurface(i);

        for (uint j=0;j&lt;rSurface.size();j++)
        {
            elementSurface[rSurface.get(j)] = true;
        }

        for (uint j=0;j&lt;rSurface.size();j++)
        {
            uint elementID = rSurface.get(j);
            if (!elementChecked[elementID])
            {
                elementChecked[elementID] = true;

                std::stack&lt;uint&gt; elementStack;
                elementStack.push(elementID);

                while (elementStack.size() &gt; 0)
                {
                    elementID = elementStack.top();
                    for (uint k=0;k&lt;this-&gt;surfaceNeigs[elementID].size();k++)
                    {
                        uint neighbourID = surfaceNeigs[elementID][k];
                        if (elementSurface[neighbourID] &amp;&amp; !elementChecked[neighbourID])
                        {
                            // Check neighbor orientation.
                            if (!this-&gt;getElement(elementID).isNeighborNormalSync(this-&gt;getElement(neighbourID)))
                            {
                                this-&gt;getElement(neighbourID).swapNormal();
                                nSwapped++;
                            }
                            elementChecked[neighbourID] = true;
                            elementStack.push(neighbourID);
                            break;
                        }

                    }
                    if (elementID == elementStack.top())
                    {
                        elementStack.pop();
                    }
                }
            }
        }
    }
    RLogger::info("Number of swapped elements = %u\n",nSwapped);
} /* RModel::syncSurfaceNormals */


/*********************************************************************
 * Volume interface                                                  *
 *********************************************************************/


uint RModel::getNVolumes () const
{
    return uint(this-&gt;volumes.size());
} /* RModel::getNVolumes */


</t>
<t tx="leo.20201108101536.79">void RModel::setNVolumes (uint nvolumes)
{
    uint oldSize=uint(this-&gt;volumes.size());
    this-&gt;volumes.resize(nvolumes);
    for (uint i=oldSize;i&lt;nvolumes;i++)
    {
        this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_VOLUME,oldSize));
    }
    for (uint i=nvolumes;i&lt;oldSize;i++)
    {
        this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_VOLUME,nvolumes));
    }
} /* RModel::setNVolumes */


</t>
<t tx="leo.20201108101536.8">static QString modalMethodNames [R_MODAL_N_TYPES] =
{
    "Only most dominant mode",
    "Multiple modes"
};

</t>
<t tx="leo.20201108101536.80">const RVolume * RModel::getVolumePtr (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;volumes.size());
    return &amp;this-&gt;volumes[position];
} /* RModel::getVolumePtr */


RVolume * RModel::getVolumePtr (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;volumes.size());
    return &amp;this-&gt;volumes[position];
} /* RModel::getVolumePtr */


</t>
<t tx="leo.20201108101536.81">const RVolume &amp; RModel::getVolume (uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;volumes.size());
    return this-&gt;volumes[position];
} /* RModel::getVolume */


RVolume &amp; RModel::getVolume (uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;volumes.size());
    return this-&gt;volumes[position];
} /* RModel::getVolume */


</t>
<t tx="leo.20201108101536.82">void RModel::addVolume (const RVolume &amp;volume)
{
    this-&gt;volumes.push_back (volume);
    this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_VOLUME,uint(this-&gt;volumes.size()-1)));
} /* RModel::addVolume */


</t>
<t tx="leo.20201108101536.83">void RModel::setVolume (uint   position,
                         const RVolume &amp;volume)
{
    R_ERROR_ASSERT (position &lt; this-&gt;volumes.size());
    this-&gt;volumes[position] = volume;
} /* RModel::setVolume */


</t>
<t tx="leo.20201108101536.84">void RModel::removeVolume (uint position)
{
    this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_VOLUME,position));

    std::vector&lt;RVolume&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;volumes.size());

    iter = this-&gt;volumes.begin();
    std::advance (iter, position);

    this-&gt;volumes.erase (iter);
} /* RModel::removeVolume */


/*********************************************************************
 * Vector field interface                                            *
 *********************************************************************/


uint RModel::getNVectorFields() const
{
    return uint(this-&gt;vectorFields.size());
} /* RModel::getNVectorFields */


</t>
<t tx="leo.20201108101536.85">void RModel::setNVectorFields(uint nVectorFields)
{
    uint oldSize=uint(this-&gt;vectorFields.size());
    this-&gt;vectorFields.resize(nVectorFields);
    for (uint i=oldSize;i&lt;nVectorFields;i++)
    {
        this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_VECTOR_FIELD,oldSize));
    }
    for (uint i=nVectorFields;i&lt;oldSize;i++)
    {
        this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_VECTOR_FIELD,nVectorFields));
    }
} /* RModel::setNVectorFields */


</t>
<t tx="leo.20201108101536.86">const RVectorField *RModel::getVectorFieldPtr(uint position) const
{
    return &amp;this-&gt;vectorFields[position];
} /* RModel::getVectorFieldPtr */


RVectorField *RModel::getVectorFieldPtr(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;vectorFields.size());

    return &amp;this-&gt;vectorFields[position];
} /* RModel::getVectorFieldPtr */


</t>
<t tx="leo.20201108101536.87">const RVectorField &amp;RModel::getVectorField(uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;vectorFields.size());

    return this-&gt;vectorFields[position];
} /* RModel::getVectorField */


RVectorField &amp;RModel::getVectorField(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;vectorFields.size());

    return this-&gt;vectorFields[position];
} /* RModel::getVectorField */


</t>
<t tx="leo.20201108101536.88">void RModel::addVectorField(const RVectorField &amp;vectorField)
{
    this-&gt;vectorFields.push_back(vectorField);
    this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_VECTOR_FIELD,uint(this-&gt;vectorFields.size()-1)));
} /* RModel::addVectorField */


</t>
<t tx="leo.20201108101536.89">void RModel::setVectorField(uint position, const RVectorField &amp;vectorField)
{
    R_ERROR_ASSERT (position &lt; this-&gt;vectorFields.size());

    this-&gt;vectorFields[position] = vectorField;
} /* RModel::setVectorField */


</t>
<t tx="leo.20201108101536.9">void RModalSetup::_init(const RModalSetup *pModalSetup)
{
    if (pModalSetup)
    {
        this-&gt;method = pModalSetup-&gt;method;
        this-&gt;nIterations = pModalSetup-&gt;nIterations;
        this-&gt;nModesToExtract = pModalSetup-&gt;nModesToExtract;
        this-&gt;convergenceValue = pModalSetup-&gt;convergenceValue;
        this-&gt;mode = pModalSetup-&gt;mode;
        this-&gt;frequency = pModalSetup-&gt;frequency;
    }
}

RModalSetup::RModalSetup(void)
    : method(R_MODAL_MULTIPLE_MODES)
    , nIterations(R_MODAL_ITERATIONS_DEFAULT_NUMBER)
    , nModesToExtract(R_MODAL_ITERATIONS_DEFAULT_NUMBER)
    , convergenceValue(R_MODAL_CONVERGENCE_DEFAULT_VALUE)
    , mode(0)
    , frequency(0.0)
{
    this-&gt;_init();
}

RModalSetup::RModalSetup(const RModalSetup &amp;modalSetup)
{
    this-&gt;_init(&amp;modalSetup);
}

RModalSetup::~RModalSetup(void)
{

}

RModalSetup &amp;RModalSetup::operator =(const RModalSetup &amp;modalSetup)
{
    this-&gt;_init(&amp;modalSetup);
    return (*this);
}

RModalMethod RModalSetup::getMethod(void) const
{
    return this-&gt;method;
}

</t>
<t tx="leo.20201108101536.90">void RModel::removeVectorField(uint position)
{
    this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_VECTOR_FIELD,position));

    std::vector&lt;RVectorField&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;vectorFields.size());

    iter = this-&gt;vectorFields.begin();
    std::advance (iter, position);

    this-&gt;vectorFields.erase (iter);
} /* RModel::removeVectorField */


/*********************************************************************
 * Scalar field interface                                          *
 *********************************************************************/


uint RModel::getNScalarFields() const
{
    return uint(this-&gt;scalarFields.size());
} /* RModel::getNScalarFields */


</t>
<t tx="leo.20201108101536.91">void RModel::setNScalarFields(uint nScalarFields)
{
    uint oldSize=uint(this-&gt;scalarFields.size());
    this-&gt;scalarFields.resize(nScalarFields);
    for (uint i=oldSize;i&lt;nScalarFields;i++)
    {
        this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_SCALAR_FIELD,oldSize));
    }
    for (uint i=nScalarFields;i&lt;oldSize;i++)
    {
        this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_SCALAR_FIELD,nScalarFields));
    }
} /* RModel::setNScalarFields */


</t>
<t tx="leo.20201108101536.92">const RScalarField *RModel::getScalarFieldPtr(uint position) const
{
    return &amp;this-&gt;scalarFields[position];
} /* RModel::getScalarFieldPtr */


RScalarField *RModel::getScalarFieldPtr(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;scalarFields.size());

    return &amp;this-&gt;scalarFields[position];
} /* RModel::getScalarFieldPtr */


</t>
<t tx="leo.20201108101536.93">const RScalarField &amp;RModel::getScalarField(uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;scalarFields.size());

    return this-&gt;scalarFields[position];
} /* RModel::getScalarField */


RScalarField &amp;RModel::getScalarField(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;scalarFields.size());

    return this-&gt;scalarFields[position];
} /* RModel::getScalarField */


</t>
<t tx="leo.20201108101536.94">void RModel::addScalarField(const RScalarField &amp;scalarField)
{
    this-&gt;scalarFields.push_back(scalarField);
    this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_SCALAR_FIELD,uint(this-&gt;scalarFields.size()-1)));
} /* RModel::addScalarField */


</t>
<t tx="leo.20201108101536.95">void RModel::setScalarField(uint position, const RScalarField &amp;scalarField)
{
    R_ERROR_ASSERT (position &lt; this-&gt;scalarFields.size());

    this-&gt;scalarFields[position] = scalarField;
} /* RModel::setScalarField */


</t>
<t tx="leo.20201108101536.96">void RModel::removeScalarField(uint position)
{
    this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_SCALAR_FIELD,position));

    std::vector&lt;RScalarField&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;scalarFields.size());

    iter = this-&gt;scalarFields.begin();
    std::advance (iter, position);

    this-&gt;scalarFields.erase (iter);
} /* RModel::removeScalarField */


/*********************************************************************
 * Stream line interface                                             *
 *********************************************************************/


uint RModel::getNStreamLines() const
{
    return uint(this-&gt;streamLines.size());
} /* RModel::getNStreamLines */


</t>
<t tx="leo.20201108101536.97">void RModel::setNStreamLines(uint nStreamLines)
{
    uint oldSize=uint(this-&gt;streamLines.size());
    this-&gt;streamLines.resize(nStreamLines);
    for (uint i=oldSize;i&lt;nStreamLines;i++)
    {
        this-&gt;addEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_STREAM_LINE,oldSize));
    }
    for (uint i=nStreamLines;i&lt;oldSize;i++)
    {
        this-&gt;removeEntityGroupIdReference(this-&gt;getEntityGroupID(R_ENTITY_GROUP_STREAM_LINE,nStreamLines));
    }
} /* RModel::setNStreamLines */


</t>
<t tx="leo.20201108101536.98">const RStreamLine *RModel::getStreamLinePtr(uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;streamLines.size());
    return &amp;this-&gt;streamLines[position];
} /* RModel::getStreamLinePtr */


RStreamLine *RModel::getStreamLinePtr(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;streamLines.size());
    return &amp;this-&gt;streamLines[position];
} /* RModel::getStreamLinePtr */


</t>
<t tx="leo.20201108101536.99">const RStreamLine &amp;RModel::getStreamLine(uint position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;streamLines.size());
    return this-&gt;streamLines[position];
} /* RModel::getStreamLine */


RStreamLine &amp;RModel::getStreamLine(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;streamLines.size());
    return this-&gt;streamLines[position];
} /* RModel::getStreamLine */


</t>
<t tx="leo.20201108101537.1">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_model_raw.cpp                                        *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   10-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: RAW model class definition                          *
 *********************************************************************/

#include &lt;QFile&gt;
#include &lt;QTextStream&gt;

#include &lt;rblib.h&gt;

#include "rml_model_raw.h"
#include "rml_polygon.h"


RModelRaw::RModelRaw ()
{
    this-&gt;_init();
} /* RModelRaw::RModelRaw */


RModelRaw::RModelRaw (const RModelRaw &amp;modelRaw)
{
    this-&gt;_init(&amp;modelRaw);
} /* RModelRaw::RModelRaw (copy) */


RModelRaw::~RModelRaw ()
{
} /* RModelRaw::~RModelRaw */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.10">void RModelRaw::addQuadrilateral(const RNode &amp;node1, const RNode &amp;node2, const RNode &amp;node3, const RNode &amp;node4, bool mergeNodes, double tolerance)
{
    RElement element;
    unsigned int nId1, nId2, nId3, nId4;

    std::vector&lt;RNode&gt; nodeList;
    nodeList.push_back(node1);
    nodeList.push_back(node2);
    nodeList.push_back(node3);
    nodeList.push_back(node4);

    RPolygon::sortNodes(nodeList);

    if (mergeNodes)
    {
        nId1 = this-&gt;findNearNode(nodeList[0],tolerance);
        if (nId1 == RConstants::eod)
        {
            this-&gt;nodes.push_back(nodeList[0]);
            nId1 = (unsigned int)this-&gt;nodes.size() - 1;
        }

        nId2 = this-&gt;findNearNode(nodeList[1],tolerance);
        if (nId2 == RConstants::eod)
        {
            this-&gt;nodes.push_back(nodeList[1]);
            nId2 = (unsigned int)this-&gt;nodes.size() - 1;
        }

        nId3 = this-&gt;findNearNode(nodeList[2],tolerance);
        if (nId3 == RConstants::eod)
        {
            this-&gt;nodes.push_back(nodeList[2]);
            nId3 = (unsigned int)this-&gt;nodes.size() - 1;
        }

        nId4 = this-&gt;findNearNode(nodeList[3],tolerance);
        if (nId4 == RConstants::eod)
        {
            this-&gt;nodes.push_back(nodeList[3]);
            nId4 = (unsigned int)this-&gt;nodes.size() - 1;
        }
    }
    else
    {
        this-&gt;nodes.push_back(nodeList[0]);
        nId1 = (unsigned int)this-&gt;nodes.size() - 1;
        this-&gt;nodes.push_back(nodeList[1]);
        nId2 = (unsigned int)this-&gt;nodes.size() - 1;
        this-&gt;nodes.push_back(nodeList[2]);
        nId3 = (unsigned int)this-&gt;nodes.size() - 1;
        this-&gt;nodes.push_back(nodeList[3]);
        nId4 = (unsigned int)this-&gt;nodes.size() - 1;
    }

    element.setType(R_ELEMENT_QUAD1);
    element.setNodeId(0,nId1);
    element.setNodeId(1,nId2);
    element.setNodeId(2,nId3);
    element.setNodeId(3,nId4);

    this-&gt;elements.push_back(element);
} /* RModelRaw::addQuadrilateral */


</t>
<t tx="leo.20201108101537.100">bool RProblem::getTimeSolverEnabled(RProblemTypeMask typeMask)
{
    unsigned int i = 0;

    if (typeMask == R_PROBLEM_MESH)
    {
        return false;
    }

    while (problemDesc[i].type != R_PROBLEM_NONE)
    {
        if (problemDesc[i].type &amp; typeMask &amp;&amp; problemDesc[i].type != R_PROBLEM_MESH)
        {
            if (!problemDesc[i].timeSolverEnabled)
            {
                return false;
            }
        }
        i++;
    }
    return true;
} /* RProblemMask::getTimeSolverTypeMask */


RProblemTypeMask RProblem::getRequiredProblemTypeMask(RProblemTypeMask typeMask)
{
    RProblemTypeMask reqTypeMask = R_PROBLEM_NONE;
    unsigned int i = 0;
    while (problemDesc[i].type != R_PROBLEM_NONE)
    {
        if (problemDesc[i].type &amp; typeMask)
        {
            reqTypeMask |= problemDesc[i].requiredProblemTypeMask;
        }
        i++;
    }
    return reqTypeMask;
} /* RProblemMask::getRequiredProblemTypeMask */


RProblemTypeMask RProblem::getExcludedProblemTypeMask(RProblemTypeMask typeMask)
{
    RProblemTypeMask excTypeMask = R_PROBLEM_NONE;
    unsigned int i = 0;
    while (problemDesc[i].type != R_PROBLEM_NONE)
    {
        if (problemDesc[i].type &amp; typeMask)
        {
            excTypeMask |= problemDesc[i].excludedProblemTypeMask;
        }
        i++;
    }
    return excTypeMask;
} /* RProblemMask::getTimeSolverTypeMask */


std::vector&lt;RProblemType&gt; RProblem::getTypes(RProblemTypeMask typeMask)
{
    R_ERROR_ASSERT (R_PROBLEM_TYPE_MASK_IS_VALID (typeMask));

    std::vector&lt;RProblemType&gt; types;
    unsigned int i = 0;
    while (problemDesc[i].type != R_PROBLEM_NONE)
    {
        if (problemDesc[i].type &amp; typeMask)
        {
            types.push_back (problemDesc[i].type);
        }
        i++;
    }

    return types;
} /* RProblemMask::getTypes */


std::vector&lt;RVariableType&gt; RProblem::getVariableTypes(RProblemTypeMask typeMask)
{
    std::vector&lt;RVariableType&gt; variableTypes;
    std::vector&lt;RProblemType&gt; problemTypes = RProblem::getTypes(typeMask);

    for (int i=R_VARIABLE_NONE;i&lt;R_VARIABLE_N_TYPES;i++)
    {
        RProblemTypeMask variableProblemTypeMask = RVariable::getResultsProblemTypeMask(RVariableType(i));
        for (unsigned int j=0;j&lt;problemTypes.size();j++)
        {
            if (variableProblemTypeMask &amp; problemTypes[j])
            {
                variableTypes.push_back(RVariableType(i));
                break;
            }
        }
    }

    return variableTypes;
} /* RProblemMask::getVariableTypes */

</t>
<t tx="leo.20201108101537.101">void RProblem::sortTypesByDependency(std::vector&lt;RProblemType&gt; &amp;problemTypes)
{
    if (problemTypes.size() == 0)
    {
        return;
    }

    bool orderChanged = false;

    do
    {
        orderChanged = false;
        for (uint i=0;i&lt;problemTypes.size()-1;i++)
        {
            RProblemTypeMask requiredProblemTypes = RProblem::getRequiredProblemTypeMask(problemTypes[i]);
            for (uint j=i+1;j&lt;problemTypes.size();j++)
            {
                if (requiredProblemTypes &amp; problemTypes[j])
                {
                    problemTypes.insert(problemTypes.begin()+i,problemTypes.at(j));
                    problemTypes.erase(problemTypes.begin()+j+1);
                    orderChanged = true;
                    break;
                }
            }
            if (orderChanged)
            {
                break;
            }
        }
    } while (orderChanged);
} /* RProblemMask::sortTypesByDependency */
</t>
<t tx="leo.20201108101537.11">unsigned int RModelRaw::findNearNode (const RNode &amp;node,
                                      double       tolerance) const
{
    unsigned int nn = this-&gt;getNNodes();

    for (unsigned int i=0;i&lt;nn;i++)
    {
        if (tolerance == 0.0)
        {
            if (this-&gt;getNode(i) == node)
            {
                return i;
            }
        }
        else
        {
            if (this-&gt;getNode(i).getDistance(node) &lt;= tolerance)
            {
                return i;
            }
        }
    }

    return RConstants::eod;
} /* RModelRaw::findNearNode */


</t>
<t tx="leo.20201108101537.12">unsigned int RModelRaw::mergeNearNodes (double tolerance)
{
    unsigned int nMerged = 0;
    std::vector&lt;unsigned int&gt; nodeBook;
    nodeBook.resize(this-&gt;getNNodes());

    RLogger::info("Finding near nodes\n");
    RProgressInitialize("Finfing near nodes");
    unsigned int nn = this-&gt;getNNodes();
    for (unsigned int i=0;i&lt;nn;i++)
    {
        nodeBook[i] = i;
    }
    for (unsigned int i=0;i&lt;nn;i++)
    {
        RProgressPrint(i,nn);
        if (nodeBook[i] != i)
        {
            continue;
        }
#pragma omp parallel for default(shared)
        for (int64_t j=int64_t(i)+1;j&lt;int64_t(nn);j++)
        {
            if (nodeBook[j] != j)
            {
                continue;
            }
            if (tolerance == 0.0)
            {
                if (this-&gt;getNode(i) != this-&gt;getNode(j))
                {
                    continue;
                }
            }
            else
            {
                if (this-&gt;getNode(i).getDistance(this-&gt;getNode(j)) &gt; tolerance)
                {
                    continue;
                }
            }
            nodeBook[j] = i;
        }
    }
    RProgressFinalize("Done");

    RLogger::info("Merging near nodes\n");
    RProgressInitialize("Merging near nodes");
    for (unsigned int i=0;i&lt;nn;i++)
    {
        RProgressPrint(i,nn);
        unsigned int nID = nn-i-1;
        if (nodeBook[nID] != nID)
        {
            // Remove node from node vector.
            std::vector&lt;RNode&gt;::iterator iter = this-&gt;nodes.begin();
            std::advance(iter, nID);
            this-&gt;nodes.erase(iter);
            nMerged ++;
        }
    }
    RProgressFinalize("Done");

    RLogger::info("Renumbering merged nodes nodes\n");
    nn = 0;
    for (unsigned int i=0;i&lt;nodeBook.size();i++)
    {

        if (nodeBook[i] == i)
        {
            nodeBook[i] = nn;
            nn++;
        }
        else
        {
            nodeBook[i] = nodeBook[nodeBook[i]];
        }
    }

    RProgressInitialize("Renumbering merged nodes nodes");
    // Renumber all higher node IDs in element vector.
    unsigned int ne = this-&gt;getNElements();
    for (unsigned int i=0;i&lt;ne;i++)
    {
        RProgressPrint(i,ne);
        for (unsigned int j=0;j&lt;this-&gt;getElement(i).size();j++)
        {
            this-&gt;getElement(i).setNodeId(j,nodeBook[this-&gt;getElement(i).getNodeId(j)]);
        }
    }
    RProgressFinalize("Done");

    return nMerged;
} /* RModelRaw::mergeNearNodes */


</t>
<t tx="leo.20201108101537.13">void RModelRaw::clear (void)
{
    this-&gt;nodes.clear();
    this-&gt;elements.clear();
} /* RModelRaw::clear */


</t>
<t tx="leo.20201108101537.14">void RModelRaw::read(const QString &amp;fileName,
                     double         tolerance)
{
    RProgressInitialize("Reading RAW file", true);

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QFile file(fileName);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    QTextStream in(&amp;file);

    try
    {
        this-&gt;readTextStream(in,tolerance);
    }
    catch (const RError &amp;rError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read the file \'%s\'. %s",fileName.toUtf8().constData(),rError.getMessage().toUtf8().constData());
    }

    file.close ();

    RProgressFinalize("Done");
} /* RModelRaw::read */

</t>
<t tx="leo.20201108101537.15">void RModelRaw::write(const QString &amp;fileName) const
{
    RProgressInitialize("Writing RAW file", true);

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QFile file(fileName);

    if (!file.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    QTextStream out(&amp;file);

    for (unsigned int i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (this-&gt;getElement(i).getType() == R_ELEMENT_POINT ||
            this-&gt;getElement(i).getType() == R_ELEMENT_TRUSS1 ||
            this-&gt;getElement(i).getType() == R_ELEMENT_TRI1 ||
            this-&gt;getElement(i).getType() == R_ELEMENT_QUAD1)
        {
            for (unsigned int j=0;j&lt;this-&gt;getElement(i).size();j++)
            {
                int nId = this-&gt;getElement(i).getNodeId(j);
                out &lt;&lt; this-&gt;getNode(nId).getX() &lt;&lt; " "
                    &lt;&lt; this-&gt;getNode(nId).getY() &lt;&lt; " "
                    &lt;&lt; this-&gt;getNode(nId).getZ() &lt;&lt; " ";
                if (out.status() != QTextStream::Ok)
                {
                    throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
                }
            }
            out &lt;&lt; "\n";
            if (out.status() != QTextStream::Ok)
            {
                throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
            }
        }
    }

    file.close ();

    RProgressFinalize("Done");
} /* RModelRaw::write */

</t>
<t tx="leo.20201108101537.16">void RModelRaw::readTextStream(QTextStream &amp;textSTream, double tolerance)
{
    RNode node1;
    RNode node2;
    RNode node3;
    RNode node4;

    uint lineNumber = 0;

    while (!textSTream.atEnd())
    {
        QString line = textSTream.readLine();
        lineNumber++;

        int hashPos = line.indexOf('#');
        if (hashPos &gt;= 0)
        {
            line.remove(hashPos,line.size());
        }

        if (!line.isEmpty())
        {
            QRegExp rx("[,; ]");// match a comma or semicolon or a space
            QStringList list = line.split(rx, QString::SkipEmptyParts);

            RRVector coordinates(list.size(),0.0);

            QString invalidRecordMessage;

            if (list.size() % 3 != 0)
            {
                invalidRecordMessage = "Invalid number of coordinates = " + QString::number(list.size());
            }
            else
            {
                for (int i=0;i&lt;list.size();i++)
                {
                    bool isDouble = true;
                    coordinates[i] = list[i].toDouble(&amp;isDouble);
                    if (!isDouble)
                    {
                        invalidRecordMessage = "Record can contain only numbers";
                        break;
                    }
                }
            }

            if (invalidRecordMessage.isEmpty())
            {
                if (coordinates.size() == 3)
                {
                    node1.set(coordinates[0],coordinates[1],coordinates[2]);
                    this-&gt;addPoint(node1,true,tolerance);
                }
                else if (coordinates.size() == 6)
                {
                    node1.set(coordinates[0],coordinates[1],coordinates[2]);
                    node2.set(coordinates[3],coordinates[4],coordinates[5]);
                    this-&gt;addSegment(node1,node2,true,tolerance);
                }
                else if (coordinates.size() == 9)
                {
                    node1.set(coordinates[0],coordinates[1],coordinates[2]);
                    node2.set(coordinates[3],coordinates[4],coordinates[5]);
                    node3.set(coordinates[6],coordinates[7],coordinates[8]);
                    this-&gt;addTriangle(node1,node2,node3,true,tolerance);
                }
                else if (coordinates.size() == 12)
                {
                    node1.set(coordinates[0],coordinates[1],coordinates[2]);
                    node2.set(coordinates[3],coordinates[4],coordinates[5]);
                    node3.set(coordinates[6],coordinates[7],coordinates[8]);
                    node4.set(coordinates[9],coordinates[10],coordinates[11]);
                    this-&gt;addQuadrilateral(node1,node2,node3,node4,true,tolerance);
                }
                else
                {
                    invalidRecordMessage = "Invalid number of nodes = " + QString::number(coordinates.size() / 3);
                }
            }
            if (!invalidRecordMessage.isEmpty())
            {
                RLogger::warning("Invalid RAW element record @ line %u (%s). %s.\n", lineNumber, line.toUtf8().constData(), invalidRecordMessage.toUtf8().constData());
            }
        }

        if (textSTream.status() != QTextStream::Ok &amp;&amp; !textSTream.atEnd())
        {
            throw RError(R_ERROR_INVALID_INPUT,R_ERROR_REF,"Failed to read the text stream.");
        }
    }
} /* RModelRaw::readTextStream */

</t>
<t tx="leo.20201108101537.17">bool RModelRaw::getNormal(unsigned int elementID, double &amp;nx, double &amp;ny, double &amp;nz) const
{
    const RElement &amp;element = this-&gt;getElement(elementID);
    if (element.getType() == R_ELEMENT_TRI1)
    {
        nx = ny = nz = 0.0;
        return true;
    }
    return false;
} /* RModelRaw::getNormal */
</t>
<t tx="leo.20201108101537.18">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_model_stl.cpp                                        *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   10-th January 2012                                       *
 *                                                                   *
 *  DESCRIPTION: STL model class definition                          *
 *********************************************************************/

#include &lt;QFile&gt;
#include &lt;QFileInfo&gt;
#include &lt;QTextStream&gt;

#include &lt;rblib.h&gt;

#include "rml_model_stl.h"
#include "rml_model_raw.h"


RModelStl::RModelStl ()
{
    this-&gt;_init();
} /* RModelStl::RModelStl */


RModelStl::RModelStl (const RModelStl &amp;modelStl) : RModelRaw(modelStl)
{
    this-&gt;_init(&amp;modelStl);
} /* RModelStl::RModelStl (copy) */


RModelStl::~RModelStl ()
{
} /* RModelStl::~RModelStl */


RModelStl &amp; RModelStl::operator = (const RModelStl &amp;modelStl)
{
    this-&gt;RModelRaw::operator = (modelStl);
    this-&gt;_init(&amp;modelStl);
    return (*this);
} /* RModelStl::operator = */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.19">void RModelStl::_init(const RModelStl *pModelStl)
{
    if (pModelStl)
    {
        this-&gt;setName(pModelStl-&gt;getName());
        this-&gt;setDescription(pModelStl-&gt;getDescription());
    }
} /* RModelStl::_init */


QString RModelStl::getName (void) const
{
    return this-&gt;name;
} /* RModelStl::getName */


</t>
<t tx="leo.20201108101537.2">void RModelRaw::_init(const RModelRaw *pModelRaw)
{
    if (pModelRaw)
    {
        this-&gt;nodes = pModelRaw-&gt;nodes;
        this-&gt;elements = pModelRaw-&gt;elements;
    }
} /* RModelRaw::_init */


RModelRaw &amp; RModelRaw::operator = (const RModelRaw &amp;modelRaw)
{
    this-&gt;_init(&amp;modelRaw);
    return (*this);
} /* RModelRaw::operator = */


</t>
<t tx="leo.20201108101537.20">void RModelStl::setName (const QString &amp;name)
{
    this-&gt;name = name;
} /* RModelStl::setName */


QString RModelStl::getDescription (void) const
{
    return this-&gt;description;
} /* RModelStl::getDescription */


</t>
<t tx="leo.20201108101537.21">void RModelStl::setDescription (const QString &amp;description)
{
    this-&gt;description = description;
} /* RModelStl::setDescription */


</t>
<t tx="leo.20201108101537.22">void RModelStl::clear (void)
{
    this-&gt;RModelRaw::clear();
    this-&gt;name.clear();
    this-&gt;description.clear();
} /* RModelStl::clear */


</t>
<t tx="leo.20201108101537.23">void RModelStl::read (const QString &amp;fileName,
                      double         tolerance)
{
    if (this-&gt;checkIfBinary(fileName))
    {
        RLogger::info("Reading binary STL file \'%s\'\n",fileName.toUtf8().constData());
        this-&gt;readBinary(fileName,tolerance);
    }
    else
    {
        RLogger::info("Reading ASCII STL file \'%s\'\n",fileName.toUtf8().constData());
        this-&gt;readAscii(fileName,tolerance);
    }
} /* RModelStl::read */


</t>
<t tx="leo.20201108101537.24">void RModelStl::write (const QString &amp;fileName, bool binary) const
{
    if (binary)
    {
        this-&gt;writeBinary(fileName);
    }
    else
    {
        this-&gt;writeAscii(fileName);
    }
} /* RModelStl::write */


</t>
<t tx="leo.20201108101537.25">void RModelStl::readBinary(const QString &amp;fileName, double tolerance)
{
    RNode node1;
    RNode node2;
    RNode node3;
    float xyz[3];
    double x1, y1, z1;
    double x2, y2, z2;
    double x3, y3, z3;

    RProgressInitialize("Reading STL binary file");

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QFile stlFile(fileName);

    if (!stlFile.open(QIODevice::ReadOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    QString line(stlFile.read(80));
    if (stlFile.error() != QFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read from file \'%s\'.",fileName.toUtf8().constData());
    }

    this-&gt;name = QFileInfo(stlFile).baseName();

    QStringList query = line.split(QRegExp("(\\ |\\t)"));
    for (int i=0;i&lt;query.size();i++)
    {
        this-&gt;description += query.at(i);
        if (i &lt; query.size()-1)
        {
            this-&gt;description += " ";
        }
    }

    unsigned int nf;
    stlFile.read((char*)&amp;nf,sizeof(unsigned int));
    if (stlFile.error() != QFile::NoError)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read from file \'%s\'.",fileName.toUtf8().constData());
    }

    char dummy[2];

    for (unsigned int i=0;i&lt;nf;i++)
    {
        RProgressPrint(i+1,nf);

        stlFile.read((char*)xyz,3*sizeof(float));
        if (stlFile.error() != QFile::NoError)
        {
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read from file \'%s\'.",fileName.toUtf8().constData());
        }

        stlFile.read((char*)xyz,3*sizeof(float));
        if (stlFile.error() != QFile::NoError)
        {
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read from file \'%s\'.",fileName.toUtf8().constData());
        }
        x1 = (double) xyz[0];
        y1 = (double) xyz[1];
        z1 = (double) xyz[2];

        stlFile.read((char*)xyz,3*sizeof(float));
        if (stlFile.error() != QFile::NoError)
        {
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read from file \'%s\'.",fileName.toUtf8().constData());
        }
        x2 = (double) xyz[0];
        y2 = (double) xyz[1];
        z2 = (double) xyz[2];

        stlFile.read((char*)xyz,3*sizeof(float));
        if (stlFile.error() != QFile::NoError)
        {
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read from file \'%s\'.",fileName.toUtf8().constData());
        }
        x3 = (double) xyz[0];
        y3 = (double) xyz[1];
        z3 = (double) xyz[2];

        node1.set(x1,y1,z1);
        node2.set(x2,y2,z2);
        node3.set(x3,y3,z3);
        this-&gt;addTriangle(node1,node2,node3,false,tolerance);

        stlFile.read(dummy,2);
        if (stlFile.error() != QFile::NoError)
        {
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF,"Failed to read from file \'%s\'.",fileName.toUtf8().constData());
        }
    }

    stlFile.close ();

    RProgressFinalize("Done");

    this-&gt;mergeNearNodes(tolerance);
} /* RModelStl::readBinary */


</t>
<t tx="leo.20201108101537.26">void RModelStl::writeBinary (const QString &amp;fileName) const
{
    RProgressInitialize("Writing STL binary file", true);

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QFile stlFile(fileName);

    if (!stlFile.open(QIODevice::WriteOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    char dummy[2] = { '\0', '\0' };
    char buffer[80];
    snprintf (buffer, 80, "%s %s", this-&gt;getName().toUtf8().constData(), this-&gt;getDescription().toUtf8().constData());
    stlFile.write(buffer,80);
    if (stlFile.error() != QFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
    }

    unsigned int nf = this-&gt;getNElements();
    stlFile.write((char*)&amp;nf,sizeof(unsigned int));
    if (stlFile.error() != QFile::NoError)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
    }

    double dxyz[3];
    float  fxyz[3];
    for (unsigned int i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (this-&gt;getElement(i).getType() != R_ELEMENT_TRI1)
        {
            continue;
        }

        this-&gt;getNormal(i,dxyz[0],dxyz[1],dxyz[2]);
        fxyz[0] = float(dxyz[0]);
        fxyz[1] = float(dxyz[1]);
        fxyz[2] = float(dxyz[2]);

        stlFile.write((char*)fxyz,3*sizeof(float));
        if (stlFile.error() != QFile::NoError)
        {
            throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
        }
        for (unsigned int j=0;j&lt;this-&gt;getElement(i).size();j++)
        {
            int nId = this-&gt;getElement(i).getNodeId(j);
            fxyz[0] = float(this-&gt;getNode(nId).getX());
            fxyz[1] = float(this-&gt;getNode(nId).getY());
            fxyz[2] = float(this-&gt;getNode(nId).getZ());
            stlFile.write((char*)fxyz,3*sizeof(float));
            if (stlFile.error() != QFile::NoError)
            {
                throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
            }
        }

        stlFile.write(dummy,2); // Attribute byte count UINT16
        if (stlFile.error() != QFile::NoError)
        {
            throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
        }
    }

    stlFile.close ();

    RProgressFinalize("Done");
} /* RModelStl::writeBinary */


</t>
<t tx="leo.20201108101537.27">void RModelStl::readAscii (const QString &amp;fileName,
                           double             tolerance)
{
    RNode node1;
    RNode node2;
    RNode node3;
    double nx, ny, nz;
    double x1, y1, z1;
    double x2, y2, z2;
    double x3, y3, z3;
    QString flag;

    RProgressInitialize("Reading STL ASCII file");

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QFile file(fileName);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    QTextStream in(&amp;file);

    QString line;
    line = in.readLine();
    if (in.status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read first line (1).");
    }

    this-&gt;name = QFileInfo(fileName).baseName();

    QStringList query = line.split(QRegExp("(\\ |\\t)"));
    for (int i=0;i&lt;query.size();i++)
    {
        this-&gt;description += query.at(i);
        if (i &lt; query.size()-1)
        {
            this-&gt;description += " ";
        }
    }

    unsigned int nf = 0;
    while (!in.atEnd() &amp;&amp; in.status() == QTextStream::Ok)
    {
        in &gt;&gt; flag;
        if (flag == "normal" || flag == "NORMAL")
        {
            nf++;
        }
    }
    in.resetStatus();

    in.seek(0);
    if (in.status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to set position.");
    }

    line = in.readLine();
    if (in.status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_READ_FILE,R_ERROR_REF, "Failed to read first line (2).");
    }

    for (unsigned int i=0;i&lt;nf;i++)
    {
        RProgressPrint(i+1,nf);

        in &gt;&gt; flag &gt;&gt; flag &gt;&gt; nx &gt;&gt; ny &gt;&gt; nz;
        if (in.status() != QTextStream::Ok)
        {
            QString errorStr("Failed to read normal (Facet: " + QString::number(i+1) + " of " + QString::number(nf) + ").");
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF, errorStr);
        }
        in &gt;&gt; flag &gt;&gt; flag;
        if (in.status() != QTextStream::Ok)
        {
            QString errorStr("Failed to read outer loop (Facet: " + QString::number(i+1) + " of " + QString::number(nf) + ").");
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF, errorStr);
        }
        in &gt;&gt; flag &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1;
        if (in.status() != QTextStream::Ok)
        {
            QString errorStr("Failed to read vertex 1 (Facet: " + QString::number(i+1) + " of " + QString::number(nf) + ").");
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF, errorStr);
        }
        in &gt;&gt; flag &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; z2;
        if (in.status() != QTextStream::Ok)
        {
            QString errorStr("Failed to read vertex 2 (Facet: " + QString::number(i+1) + " of " + QString::number(nf) + ").");
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF, errorStr);
        }
        in &gt;&gt; flag &gt;&gt; x3 &gt;&gt; y3 &gt;&gt; z3;
        if (in.status() != QTextStream::Ok)
        {
            QString errorStr("Failed to read vertex 3 (Facet: " + QString::number(i+1) + " of " + QString::number(nf) + ").");
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF, errorStr);
        }
        in &gt;&gt; flag;
        if (in.status() != QTextStream::Ok)
        {
            QString errorStr("Failed to read endloop (Facet: " + QString::number(i+1) + " of " + QString::number(nf) + ").");
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF, errorStr);
        }
        in &gt;&gt; flag;
        if (in.status() != QTextStream::Ok)
        {
            QString errorStr("Failed to read endfacet (Facet: " + QString::number(i+1) + " of " + QString::number(nf) + ").");
            throw RError(R_ERROR_READ_FILE,R_ERROR_REF, errorStr);
        }

        node1.set(x1,y1,z1);
        node2.set(x2,y2,z2);
        node3.set(x3,y3,z3);
        this-&gt;addTriangle(node1,node2,node3,false,tolerance);
    }

    file.close ();

    RProgressFinalize("Done");

    this-&gt;mergeNearNodes(tolerance);
} /* RModelStl::readAscii */


</t>
<t tx="leo.20201108101537.28">void RModelStl::writeAscii (const QString &amp;fileName) const
{
    RProgressInitialize("Writing STL ASCII file", true);

    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QFile file(fileName);

    if (!file.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    QTextStream out(&amp;file);

    out.setRealNumberNotation(QTextStream::ScientificNotation);
    out.setFieldAlignment(QTextStream::AlignRight);

    out &lt;&lt; "solid " &lt;&lt; this-&gt;getName().toUtf8().constData() &lt;&lt; " " &lt;&lt; this-&gt;getDescription().toUtf8().constData();
    endl(out);
    if (out.status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
    }

    double xyz[3];
    for (unsigned int i=0;i&lt;this-&gt;getNElements();i++)
    {
        if (this-&gt;getElement(i).getType() != R_ELEMENT_TRI1)
        {
            continue;
        }

        this-&gt;getNormal(i,xyz[0],xyz[1],xyz[2]);

        out &lt;&lt; "  facet normal " &lt;&lt; xyz[0] &lt;&lt; " " &lt;&lt; xyz[1] &lt;&lt; " " &lt;&lt; xyz[2];
        endl(out);
        if (out.status() != QTextStream::Ok)
        {
            throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
        }
        out &lt;&lt; "    outer loop ";
        endl(out);
        if (out.status() != QTextStream::Ok)
        {
            throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
        }
        for (unsigned int j=0;j&lt;this-&gt;getElement(i).size();j++)
        {
            int nId = this-&gt;getElement(i).getNodeId(j);
            out &lt;&lt; "      vertex "
                    &lt;&lt; this-&gt;getNode(nId).getX() &lt;&lt; " "
                    &lt;&lt; this-&gt;getNode(nId).getY() &lt;&lt; " "
                    &lt;&lt; this-&gt;getNode(nId).getZ();
            endl(out);
            if (out.status() != QTextStream::Ok)
            {
                throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
            }
        }
        out &lt;&lt; "    endloop";
        endl(out);
        if (out.status() != QTextStream::Ok)
        {
            throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
        }
        out &lt;&lt; "  endfacet";
        endl(out);
        if (out.status() != QTextStream::Ok)
        {
            throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
        }
    }

    out &lt;&lt; "endsolid";
    endl(out);
    if (out.status() != QTextStream::Ok)
    {
        throw RError(R_ERROR_WRITE_FILE,R_ERROR_REF,"Failed to write to file \'%s\'.",fileName.toUtf8().constData());
    }

    file.close ();

    RProgressFinalize("Done");
} /* RModelStl::writeAscii */


</t>
<t tx="leo.20201108101537.29">bool RModelStl::checkIfBinary (const QString &amp;fileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QFile file(fileName);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    QTextStream in(&amp;file);

    bool isBinary = true;
    bool solidFound = false;
    bool faceFound = false;
    bool normalFound = false;
    bool outerFound = false;
    bool loopFound = false;
    qint64 maxPos = 10240; // Max. 10 Kb
    QString strVal;

    while (!in.atEnd())
    {
        in &gt;&gt; strVal;
        if (strVal == "solid")
        {
            solidFound = true;
        }
        else if (strVal == "facet")
        {
            faceFound = true;
        }
        else if (strVal == "normal")
        {
            normalFound = true;
        }
        else if (strVal == "outer")
        {
            outerFound = true;
        }
        else if (strVal == "loop")
        {
            loopFound = true;
        }
        if (solidFound &amp;&amp; faceFound &amp;&amp; normalFound &amp;&amp; outerFound &amp;&amp; loopFound)
        {
            isBinary = false;
            break;
        }
        if (in.pos() &gt; maxPos)
        {
            break;
        }
    }

    file.close();

    return isBinary;
} /* RModelStl::checkIfBinary */
</t>
<t tx="leo.20201108101537.3">unsigned int RModelRaw::getNNodes(void) const
{
    return (unsigned int)this-&gt;nodes.size();
} /* RModelRaw::getNNodes */


</t>
<t tx="leo.20201108101537.30">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_monitoring_point.cpp                                 *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th March 2014                                         *
 *                                                                   *
 *  DESCRIPTION: Monitoring point class definition                   *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rml_monitoring_point.h"
#include "rml_file_io.h"
#include "rml_save_file.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.31">void RMonitoringPoint::_init(const RMonitoringPoint *pMonitoringPoint)
{
    if (pMonitoringPoint)
    {
        this-&gt;variableType = pMonitoringPoint-&gt;variableType;
        this-&gt;position = pMonitoringPoint-&gt;position;
        this-&gt;outputFileName = pMonitoringPoint-&gt;outputFileName;
    }
}

RMonitoringPoint::RMonitoringPoint()
    : variableType(R_VARIABLE_NONE)
{
    this-&gt;_init();
}

RMonitoringPoint::RMonitoringPoint(RVariableType variableType, const RR3Vector &amp;position)
    : variableType(variableType)
    , position(position)
{
}

RMonitoringPoint::RMonitoringPoint(const RMonitoringPoint &amp;monitoringPoint)
{
    this-&gt;_init(&amp;monitoringPoint);
}

RMonitoringPoint::~RMonitoringPoint()
{

}

RMonitoringPoint &amp;RMonitoringPoint::operator =(const RMonitoringPoint &amp;monitoringPoint)
{
    this-&gt;_init(&amp;monitoringPoint);
    return (*this);
}

</t>
<t tx="leo.20201108101537.32">bool RMonitoringPoint::operator ==(const RMonitoringPoint &amp;monitoringPoint) const
{
    if (this-&gt;variableType != monitoringPoint.variableType)
    {
        return false;
    }
    if (std::fabs(this-&gt;position[0]-monitoringPoint.position[0]) &gt; RConstants::eps)
    {
        return false;
    }
    if (std::fabs(this-&gt;position[1]-monitoringPoint.position[1]) &gt; RConstants::eps)
    {
        return false;
    }
    if (std::fabs(this-&gt;position[2]-monitoringPoint.position[2]) &gt; RConstants::eps)
    {
        return false;
    }
    return true;
}

</t>
<t tx="leo.20201108101537.33">bool RMonitoringPoint::operator &lt;(const RMonitoringPoint &amp;monitoringPoint) const
{
    if (this-&gt;variableType &lt; monitoringPoint.variableType)
    {
        return true;
    }
    if (this-&gt;position[0] &lt; monitoringPoint.position[0] - RConstants::eps)
    {
        return true;
    }
    if (this-&gt;position[1] &lt; monitoringPoint.position[1] - RConstants::eps)
    {
        return true;
    }
    if (this-&gt;position[2] &lt; monitoringPoint.position[2] - RConstants::eps)
    {
        return true;
    }
    return false;
}

RVariableType RMonitoringPoint::getVariableType(void) const
{
    return this-&gt;variableType;
}

</t>
<t tx="leo.20201108101537.34">void RMonitoringPoint::setVariableType(RVariableType variableType)
{
    this-&gt;variableType = variableType;
}

</t>
<t tx="leo.20201108101537.35">const RR3Vector &amp;RMonitoringPoint::getPosition(void) const
{
    return this-&gt;position;
}

</t>
<t tx="leo.20201108101537.36">void RMonitoringPoint::setPosition(const RR3Vector &amp;position)
{
    this-&gt;position = position;
}

</t>
<t tx="leo.20201108101537.37">const QString &amp;RMonitoringPoint::getOutputFileName(void) const
{
    return this-&gt;outputFileName;
}

</t>
<t tx="leo.20201108101537.38">void RMonitoringPoint::setOutputFileName(const QString &amp;outputFileName)
{
    this-&gt;outputFileName = outputFileName;
}

</t>
<t tx="leo.20201108101537.39">void RMonitoringPoint::writeValueVectorToFile(unsigned int iteration, const RValueVector &amp;valueVector) const
{
    if (this-&gt;outputFileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"Empty file name was provided");
    }

    RFile file(this-&gt;outputFileName,RFile::ASCII);

    if (!file.open(QIODevice::Append | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",this-&gt;outputFileName.toUtf8().constData());
    }

    RFileIO::writeAscii(file,(*this),false);
    RFileIO::writeAscii(file,' ',false);
    RFileIO::writeAscii(file,iteration+1,false);
    RFileIO::writeAscii(file,' ',false);
    RFileIO::writeAscii(file,valueVector.getDataVector(),true,false);
    RFileIO::writeNewLineAscii(file);
}

</t>
<t tx="leo.20201108101537.4">const RNode &amp; RModelRaw::getNode(unsigned int position) const
{
    R_ERROR_ASSERT(position &lt; this-&gt;nodes.size());
    return this-&gt;nodes[position];
} /* RModelRaw::getNode */


RNode &amp; RModelRaw::getNode(unsigned int position)
{
    R_ERROR_ASSERT(position &lt; this-&gt;nodes.size());
    return this-&gt;nodes[position];
} /* RModelRaw::getNode */


</t>
<t tx="leo.20201108101537.40">void RMonitoringPoint::readRecordFromFile(RFile &amp;in, unsigned int &amp;iteration, RRVector &amp;valueVector)
{
    RFileIO::readAscii(in,(*this));
    RFileIO::readAscii(in,iteration);
    RFileIO::readAscii(in,valueVector,true);
}
</t>
<t tx="leo.20201108101537.41">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_monitoring_point_manager.cpp                         *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th March 2014                                         *
 *                                                                   *
 *  DESCRIPTION: Monitoring point manager class definition           *
 *********************************************************************/

#include "rml_monitoring_point.h"
#include "rml_monitoring_point_manager.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.42">void RMonitoringPointManager::_init(const RMonitoringPointManager *pMonitoringPointManager)
{
    if (pMonitoringPointManager)
    {

    }
}

RMonitoringPointManager::RMonitoringPointManager()
{
    this-&gt;_init();
}

RMonitoringPointManager::RMonitoringPointManager(const RMonitoringPointManager &amp;monitoringPointManager)
    : std::vector&lt;RMonitoringPoint&gt;(monitoringPointManager)
{
    this-&gt;_init(&amp;monitoringPointManager);
}

RMonitoringPointManager::~RMonitoringPointManager()
{

}

RMonitoringPointManager &amp;RMonitoringPointManager::operator =(const RMonitoringPointManager &amp;monitoringPointManager)
{
    this-&gt;std::vector&lt;RMonitoringPoint&gt;::operator = (monitoringPointManager);
    this-&gt;_init(&amp;monitoringPointManager);
    return (*this);
}

</t>
<t tx="leo.20201108101537.43">void RMonitoringPointManager::setOutputFileName(const QString &amp;fileName)
{
    for (unsigned int i=0;i&lt;this-&gt;size();i++)
    {
        this-&gt;at(i).setOutputFileName(fileName);
    }
}
</t>
<t tx="leo.20201108101537.44">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_node.source                                          *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th December 2011                                       *
 *                                                                   *
 *  DESCRIPTION: Node class definition                               *
 *********************************************************************/

#include &lt;cmath&gt;
#include &lt;rblib.h&gt;

#include "rml_node.h"


RNode::RNode ()
    : x(0.0)
    , y(0.0)
    , z(0.0)
{
    this-&gt;_init ();
} /* RNode::RNode */


RNode::RNode (double x,
              @others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.45">              double y,
              double z)
    : x(x)
    , y(y)
    , z(z)
{
    this-&gt;_init ();
}

RNode::RNode (const RR3Vector &amp;vector)
    : x(vector[0])
    , y(vector[1])
    , z(vector[2])
{
    this-&gt;_init ();
} /* RNode::RNode */


RNode::RNode (const RNode &amp;node)
{
    this-&gt;_init (&amp;node);
} /* RNode::RNode - copy */


RNode::~RNode ()
{
} /* RNode::~RNode */


</t>
<t tx="leo.20201108101537.46">void RNode::_init (const RNode *pNode)
{
    if (pNode)
    {
        this-&gt;x = pNode-&gt;x;
        this-&gt;y = pNode-&gt;y;
        this-&gt;z = pNode-&gt;z;
    }
} /* RNode::_init */


double RNode::getDistance (const RNode &amp;node) const
{
    double x, y, z;
    double dx, dy, dz;
    double dl;

    x = this-&gt;getX();
    y = this-&gt;getY();
    z = this-&gt;getZ();

    dx = x - node.getX();
    dy = y - node.getY();
    dz = z - node.getZ();

    dl = sqrt (dx*dx + dy*dy + dz*dz);

    return dl;
} /* RNode::getDistance */


</t>
<t tx="leo.20201108101537.47">void RNode::transform(const RRMatrix &amp;R, const RR3Vector &amp;t, bool translateFirst)
{
    if (translateFirst)
    {
        this-&gt;translate(t);
    }
    double xt = R[0][0] * this-&gt;getX() + R[0][1] * this-&gt;getY() + R[0][2] * this-&gt;getZ();
    double yt = R[1][0] * this-&gt;getX() + R[1][1] * this-&gt;getY() + R[1][2] * this-&gt;getZ();
    double zt = R[2][0] * this-&gt;getX() + R[2][1] * this-&gt;getY() + R[2][2] * this-&gt;getZ();

    this-&gt;set(xt,yt,zt);
    if (!translateFirst)
    {
        this-&gt;translate(t);
    }
} /* RNode::transform */


</t>
<t tx="leo.20201108101537.48">void RNode::translate(const RR3Vector &amp;t)
{
    this-&gt;set(this-&gt;getX()+t[0],this-&gt;getY()+t[1],this-&gt;getZ()+t[2]);
} /* RNode::translate */


</t>
<t tx="leo.20201108101537.49">void RNode::scale(double scale)
{
    this-&gt;set(this-&gt;getX()*scale,this-&gt;getY()*scale,this-&gt;getZ()*scale);
} /* RNode::scale */


</t>
<t tx="leo.20201108101537.5">unsigned int RModelRaw::getNElements(void) const
{
    return (unsigned int)this-&gt;elements.size();
} /* RModelRaw::getNElements */


</t>
<t tx="leo.20201108101537.50">void RNode::scale(const RR3Vector &amp;scaleVector)
{
    this-&gt;set(this-&gt;getX()*scaleVector[0],this-&gt;getY()*scaleVector[1],this-&gt;getZ()*scaleVector[2]);
} /* RNode::scale */


RNode &amp; RNode::operator = (const RNode &amp;node)
{
    this-&gt;_init (&amp;node);
    return (*this);
} /* RNode::operator = */


</t>
<t tx="leo.20201108101537.51">bool RNode::operator == (const RNode &amp;node) const
{
    if (this-&gt;getX() == node.getX() &amp;&amp;
        this-&gt;getY() == node.getY() &amp;&amp;
        this-&gt;getZ() == node.getZ())
    {
        return true;
    }
    else
    {
        return false;
    }
} /*RNode::operator == */


</t>
<t tx="leo.20201108101537.52">bool RNode::operator != (const RNode &amp;node) const
{
    return !((*this) == node);
} /*RNode::operator == */


</t>
<t tx="leo.20201108101537.53">bool RNode::operator &lt;(const RNode &amp;node) const
{
    if (this-&gt;x &lt; node.x)
    {
        return true;
    }
    if (this-&gt;y &lt; node.y)
    {
        return true;
    }
    if (this-&gt;z &lt; node.z)
    {
        return true;
    }
    return false;
} /*RNode::operator &lt; */


RR3Vector RNode::toVector(void) const
{
    RR3Vector vector;
    vector.at(0) = this-&gt;getX();
    vector.at(1) = this-&gt;getY();
    vector.at(2) = this-&gt;getZ();
    return vector;
} /*RNode::toVector */


</t>
<t tx="leo.20201108101537.54">void RNode::toVector (RR3Vector &amp;vector) const
{
    vector.at(0) = this-&gt;getX();
    vector.at(1) = this-&gt;getY();
    vector.at(2) = this-&gt;getZ();
} /*RNode::toVector */


</t>
<t tx="leo.20201108101537.55">void RNode::print(void) const
{
    this-&gt;toVector().print(true,true);
} /*RNode::print */
</t>
<t tx="leo.20201108101537.56">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_patch.cpp                                            *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th August 2014                                         *
 *                                                                   *
 *  DESCRIPTION: Patch class definition                              *
 *********************************************************************/

#include &lt;algorithm&gt;

#include "rml_patch.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.57">void RPatch::_init(const RPatch *pPatch)
{
    if (pPatch)
    {
        this-&gt;surfaceID = pPatch-&gt;surfaceID;
        this-&gt;elementIDs = pPatch-&gt;elementIDs;
    }
}

RPatch::RPatch(uint surfaceID)
    : surfaceID(surfaceID)
{
    this-&gt;_init();
}

RPatch::RPatch(const RPatch &amp;patch)
{
    this-&gt;_init(&amp;patch);
}

RPatch::~RPatch()
{

}

RPatch &amp;RPatch::operator =(const RPatch &amp;patch)
{
    this-&gt;_init(&amp;patch);
    return (*this);
}

uint RPatch::getSurfaceID(void) const
{
    return this-&gt;surfaceID;
}

</t>
<t tx="leo.20201108101537.58">const RUVector &amp;RPatch::getElementIDs(void) const
{
    return this-&gt;elementIDs;
}

</t>
<t tx="leo.20201108101537.59">bool RPatch::addElementID(uint elementID)
{
    if (this-&gt;hasElementID(elementID))
    {
        return false;
    }
    this-&gt;elementIDs.push_back(elementID);
    std::sort(this-&gt;elementIDs.begin(),this-&gt;elementIDs.end());
    return false;
}

</t>
<t tx="leo.20201108101537.6">const RElement &amp; RModelRaw::getElement(unsigned int position) const
{
    R_ERROR_ASSERT(position &lt; this-&gt;elements.size());
    return this-&gt;elements[position];
} /* RModelRaw::getElement */


RElement &amp; RModelRaw::getElement(unsigned int position)
{
    R_ERROR_ASSERT(position &lt; this-&gt;elements.size());
    return this-&gt;elements[position];
} /* RModelRaw::getElement */


</t>
<t tx="leo.20201108101537.60">bool RPatch::removeElementID(uint elementID)
{
    std::vector&lt;unsigned int&gt;::iterator iter = std::find(this-&gt;elementIDs.begin(),this-&gt;elementIDs.end(),elementID);
    if (iter == this-&gt;elementIDs.end())
    {
        return false;
    }
    this-&gt;elementIDs.erase(iter);
    return true;
}

</t>
<t tx="leo.20201108101537.61">bool RPatch::hasElementID(uint elementID) const
{
    return std::binary_search(this-&gt;elementIDs.begin(),this-&gt;elementIDs.end(),elementID);
}
</t>
<t tx="leo.20201108101537.62">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_patch_book.cpp                                       *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th August 2014                                         *
 *                                                                   *
 *  DESCRIPTION: Patch book class definition                         *
 *********************************************************************/

#include "rml_patch_book.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.63">void RPatchBook::_init(const RPatchBook *pPatchBook)
{
    if (pPatchBook)
    {
        this-&gt;patches = pPatchBook-&gt;patches;
        this-&gt;elementPatchMap = pPatchBook-&gt;elementPatchMap;
    }
}

RPatchBook::RPatchBook()
{
    this-&gt;_init();
}

RPatchBook::RPatchBook(const RPatchBook &amp;patchBook)
{
    this-&gt;_init(&amp;patchBook);
}

RPatchBook::~RPatchBook()
{

}

RPatchBook &amp;RPatchBook::operator =(const RPatchBook &amp;patchBook)
{
    this-&gt;_init(&amp;patchBook);
    return (*this);
}

uint RPatchBook::getNPatches(void) const
{
    return (unsigned int)this-&gt;patches.size();
}

</t>
<t tx="leo.20201108101537.64">const RPatch &amp;RPatchBook::getPatch(uint patchID) const
{
    R_ERROR_ASSERT(patchID &lt; this-&gt;patches.size());

    return this-&gt;patches[patchID];
}

uint RPatchBook::findPatchID(uint elementID) const
{
    std::map&lt;uint,uint&gt;::const_iterator iter = this-&gt;elementPatchMap.find(elementID);
    if (iter == this-&gt;elementPatchMap.end())
    {
        return RConstants::eod;
    }
    return iter-&gt;second;
}

</t>
<t tx="leo.20201108101537.65">void RPatchBook::clear(void)
{
    this-&gt;patches.clear();
    this-&gt;elementPatchMap.clear();
}

uint RPatchBook::createNewPatch(uint surfaceID)
{
    this-&gt;patches.push_back(RPatch(surfaceID));
    return (unsigned int)this-&gt;patches.size() - 1;
}

</t>
<t tx="leo.20201108101537.66">void RPatchBook::registerElementID(uint patchID, uint elementID)
{
    R_ERROR_ASSERT(patchID &lt; this-&gt;patches.size());

    this-&gt;patches[patchID].addElementID(elementID);
    this-&gt;elementPatchMap[elementID] = patchID;
}
</t>
<t tx="leo.20201108101537.67">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_patch_input.cpp                                      *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th August 2014                                         *
 *                                                                   *
 *  DESCRIPTION: Patch input class definition                        *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "rml_patch_input.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.68">void RPatchInput::_init(const RPatchInput *pPatchInput)
{
    if (pPatchInput)
    {
        this-&gt;patchArea = pPatchInput-&gt;patchArea;
        this-&gt;patchSize = pPatchInput-&gt;patchSize;
        this-&gt;separationAngle = pPatchInput-&gt;separationAngle;
        this-&gt;emitter = pPatchInput-&gt;emitter;
        this-&gt;receiver = pPatchInput-&gt;receiver;
    }
}

RPatchInput::RPatchInput()
    : patchArea(0.0)
    , patchSize(0)
    , separationAngle(RConstants::pi/4.0)
    , emitter(false)
    , receiver(false)
{
    this-&gt;_init();
}

RPatchInput::RPatchInput(const RPatchInput &amp;patchInput)
{
    this-&gt;_init(&amp;patchInput);
}

RPatchInput::~RPatchInput()
{

}

RPatchInput &amp;RPatchInput::operator =(const RPatchInput &amp;patchInput)
{
    this-&gt;_init(&amp;patchInput);
    return (*this);
}

</t>
<t tx="leo.20201108101537.69">bool RPatchInput::operator ==(const RPatchInput &amp;patchInput) const
{
    if (this-&gt;patchArea != patchInput.patchArea)
    {
        return false;
    }
    if (this-&gt;patchSize != patchInput.patchSize)
    {
        return false;
    }
    if (this-&gt;separationAngle != patchInput.separationAngle)
    {
        return false;
    }
    if (this-&gt;emitter != patchInput.emitter)
    {
        return false;
    }
    if (this-&gt;receiver != patchInput.receiver)
    {
        return false;
    }
    return true;
}

</t>
<t tx="leo.20201108101537.7">void RModelRaw::addPoint(const RNode &amp;node, bool mergeNodes, double tolerance)
{
    RElement element;
    unsigned int nId;

    if (mergeNodes)
    {
        nId = this-&gt;findNearNode(node,tolerance);
        if (nId == RConstants::eod)
        {
            this-&gt;nodes.push_back(node);
            nId = (unsigned int)this-&gt;nodes.size() - 1;
        }
    }
    else
    {
        this-&gt;nodes.push_back(node);
        nId = (unsigned int)this-&gt;nodes.size() - 1;
    }

    element.setType(R_ELEMENT_POINT);
    element.setNodeId(0,nId);

    this-&gt;elements.push_back(element);
} /* RModelRaw::addPoint */


</t>
<t tx="leo.20201108101537.70">bool RPatchInput::operator !=(const RPatchInput &amp;patchInput) const
{
    return !this-&gt;operator ==(patchInput);
}

double RPatchInput::getPatchArea(void) const
{
    return this-&gt;patchArea;
}

</t>
<t tx="leo.20201108101537.71">void RPatchInput::setPatchArea(double patchArea)
{
    this-&gt;patchArea = patchArea;
}

</t>
<t tx="leo.20201108101537.72">unsigned int RPatchInput::getPatchSize(void) const
{
    return this-&gt;patchSize;
}

</t>
<t tx="leo.20201108101537.73">void RPatchInput::setPatchSize(unsigned int patchSize)
{
    this-&gt;patchSize = patchSize;
}

double RPatchInput::getSeparationAngle(void) const
{
    return this-&gt;separationAngle;
}

</t>
<t tx="leo.20201108101537.74">void RPatchInput::setSeparationAngle(double separationAngle)
{
    this-&gt;separationAngle = separationAngle;
}

</t>
<t tx="leo.20201108101537.75">bool RPatchInput::getEmitter(void) const
{
    return this-&gt;emitter;
}

</t>
<t tx="leo.20201108101537.76">void RPatchInput::setEmitter(bool emitter)
{
    this-&gt;emitter = emitter;
}

</t>
<t tx="leo.20201108101537.77">bool RPatchInput::getReceiver(void) const
{
    return this-&gt;receiver;
}

</t>
<t tx="leo.20201108101537.78">void RPatchInput::setReceiver(bool receiver)
{
    this-&gt;receiver = receiver;
}
</t>
<t tx="leo.20201108101537.79">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_point.cpp                                            *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th December 2011                                       *
 *                                                                   *
 *  DESCRIPTION: Point class definition                              *
 *********************************************************************/

#include "rml_element.h"
#include "rml_point.h"

const QString RPoint::defaultName("Point");

RPoint::RPoint () : volume(0.0)
{
    this-&gt;name = RPoint::defaultName;
    this-&gt;_init ();
} /* RPoint::RPoint */


RPoint::RPoint (const RPoint &amp;point) : RElementGroup (point)
{
    this-&gt;_init (&amp;point);
} /* RPoint::RPoint */


RPoint::~RPoint ()
{
} /* RPoint::~RPoint */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.8">void RModelRaw::addSegment(const RNode &amp;node1,
                           const RNode &amp;node2,
                           bool         mergeNodes,
                           double       tolerance)
{
    RElement element;
    unsigned int nId1, nId2;

    if (mergeNodes)
    {
        nId1 = this-&gt;findNearNode(node1,tolerance);
        if (nId1 == RConstants::eod)
        {
            this-&gt;nodes.push_back(node1);
            nId1 = (unsigned int)this-&gt;nodes.size() - 1;
        }

        nId2 = this-&gt;findNearNode(node2,tolerance);
        if (nId2 == RConstants::eod)
        {
            this-&gt;nodes.push_back(node2);
            nId2 = (unsigned int)this-&gt;nodes.size() - 1;
        }
    }
    else
    {
        this-&gt;nodes.push_back(node1);
        nId1 = (unsigned int)this-&gt;nodes.size() - 1;
        this-&gt;nodes.push_back(node2);
        nId2 = (unsigned int)this-&gt;nodes.size() - 1;
    }

    element.setType(R_ELEMENT_TRUSS1);
    element.setNodeId(0,nId1);
    element.setNodeId(1,nId2);

    this-&gt;elements.push_back(element);
} /* RModelRaw::addSegment */


</t>
<t tx="leo.20201108101537.80">void RPoint::_init (const RPoint *pPoint)
{
    if (pPoint)
    {
        this-&gt;setVolume (pPoint-&gt;getVolume());
    }
} /* RPoint::_init */


double RPoint::getVolume (void) const
{
    return this-&gt;volume;
} /* RPoint::get_volume */


</t>
<t tx="leo.20201108101537.81">void RPoint::setVolume (double volume)
{
    this-&gt;volume = volume;
} /* RPoint::set_volume */


RPoint &amp; RPoint::operator = (const RPoint &amp;point)
{
    this-&gt;RElementGroup::operator = (point);
    this-&gt;_init (&amp;point);
    return (*this);
} /* RPoint::operator = */

</t>
<t tx="leo.20201108101537.82">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_polygon.cpp                                          *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   24-th October 2014                                       *
 *                                                                   *
 *  DESCRIPTION: Polygon class definition                            *
 *********************************************************************/

#include "rml_polygon.h"
#include "rml_triangle.h"
#include "rml_element.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.83">void RPolygon::_init(const RPolygon *pPolygon)
{
    if (pPolygon)
    {
        this-&gt;nodes = pPolygon-&gt;nodes;
        this-&gt;normal = pPolygon-&gt;normal;
    }
}

RPolygon::RPolygon(const std::vector&lt;RNode&gt; &amp;nodes)
    : nodes(nodes)
{
    this-&gt;_init();
    this-&gt;computeNormal();
}

RPolygon::RPolygon(const std::vector&lt;RR3Vector&gt; &amp;nodes)
{
    this-&gt;nodes.resize(nodes.size());
    for (uint i=0;i&lt;nodes.size();i++)
    {
        this-&gt;nodes[i].setX(nodes[i][0]);
        this-&gt;nodes[i].setY(nodes[i][1]);
        this-&gt;nodes[i].setZ(nodes[i][2]);
    }

    this-&gt;_init();
    this-&gt;computeNormal();
}

RPolygon::RPolygon(const RPolygon &amp;polygon)
{
    this-&gt;_init(&amp;polygon);
}

RPolygon::~RPolygon()
{

}

RPolygon &amp;RPolygon::operator =(const RPolygon &amp;polygon)
{
    this-&gt;_init(&amp;polygon);
    return (*this);
}

</t>
<t tx="leo.20201108101537.84">void RPolygon::setNodes(const std::vector&lt;RNode&gt; &amp;nodes)
{
    this-&gt;nodes = nodes;
    RPolygon::sortNodes(this-&gt;nodes);
    this-&gt;computeNormal();
}

</t>
<t tx="leo.20201108101537.85">void RPolygon::removeNode(uint nodePosition, bool updateNormal)
{
    R_ERROR_ASSERT (nodePosition &lt; this-&gt;nodes.size());
    this-&gt;nodes.erase(this-&gt;nodes.begin()+nodePosition);
    if (updateNormal)
    {
        this-&gt;computeNormal();
    }
}

double RPolygon::findArea(void) const
{
    double area = 0.0;

    return area;
}

uint RPolygon::getNNodes(void) const
{
    return uint(this-&gt;nodes.size());
}

struct NodeAngleItem
{
    uint id;
    RNode node;
    double angle;
};

</t>
<t tx="leo.20201108101537.86">bool nodeAngleItemCompare(const NodeAngleItem &amp;a, const NodeAngleItem &amp;b)
{
    return a.angle &lt; b.angle;
}

std::vector&lt;uint&gt; RPolygon::sortNodes(std::vector&lt;RNode&gt; &amp;nodes)
{
    std::vector&lt;uint&gt; nodeIDs;
    nodeIDs.resize(nodes.size());
    for (uint i=0;i&lt;nodeIDs.size();i++)
    {
        nodeIDs[i] = i;
    }

    if (nodes.size() &lt; 4)
    {
        return nodeIDs;
    }

    std::vector&lt;NodeAngleItem&gt; nodeAngleList;

    RR3Vector v1(nodes[1].getX()-nodes[0].getX(),nodes[1].getY()-nodes[0].getY(),nodes[1].getZ()-nodes[0].getZ());

    RTriangle t(nodes[0],nodes[1],nodes[2]);
    RR3Vector firstNormal(t.getNormal());

    nodeAngleList.push_back(NodeAngleItem());
    nodeAngleList.back().id = nodeIDs[1];
    nodeAngleList.back().node = nodes[1];
    nodeAngleList.back().angle = 0.0;
    for (uint i=2;i&lt;nodes.size();i++)
    {
        nodeAngleList.push_back(NodeAngleItem());
        nodeAngleList.back().id = nodeIDs[i];
        nodeAngleList.back().node = nodes[i];
        RR3Vector v2(nodes[i].getX()-nodes[0].getX(),nodes[i].getY()-nodes[0].getY(),nodes[i].getZ()-nodes[0].getZ());
        nodeAngleList.back().angle = RR3Vector::angle(v1,v2);

        if (i &gt; 2)
        {
            RTriangle t(nodes[0],nodes[1],nodes[i]);
            if (RR3Vector::angle(firstNormal,t.getNormal()) &gt; RConstants::pi/2.0)
            {
                nodeAngleList.back().angle *= -1.0;
            }
        }
    }

    std::sort(nodeAngleList.begin(), nodeAngleList.end(), nodeAngleItemCompare);

    for (uint i=0;i&lt;nodeAngleList.size();i++)
    {
        nodeIDs[i+1] = nodeAngleList[i].id;
        nodes[i+1] = nodeAngleList[i].node;
    }

    return nodeIDs;
}

std::vector&lt;RElement&gt; RPolygon::triangulate(const std::vector&lt;RNode&gt; &amp;nodes, bool nodesSorted)
{
    if (nodes.size() &lt; 3)
    {
        return std::vector&lt;RElement&gt;();
    }
    else if (nodes.size() == 3)
    {
        RElement element;
        element.setType(R_ELEMENT_TRI1);
        element.setNodeId(0,0);
        element.setNodeId(1,1);
        element.setNodeId(2,2);
        std::vector&lt;RElement&gt; elements;
        elements.push_back(element);
        return elements;
    }

    std::vector&lt;RNode&gt; sortedNodes(nodes);
    std::vector&lt;uint&gt; nodeIDs;

    nodeIDs.resize(sortedNodes.size());
    for (uint i=0;i&lt;nodeIDs.size();i++)
    {
        nodeIDs[i] = i;
    }

    if (!nodesSorted)
    {
        nodeIDs = RPolygon::sortNodes(sortedNodes);
    }

    RPolygon p(sortedNodes);
    RUVector book(p.getNNodes());

    for (uint i=0;i&lt;book.size();i++)
    {
        book[i] = i;
    }

    std::vector&lt;RElement&gt; elements;

    while (true)
    {
        uint n2 = p.findEarNode();
        if (n2 == RConstants::eod)
        {
            break;
        }
        uint n1 = (n2 &gt; 0) ? n2 - 1 : p.getNNodes() - 1;
        uint n3 = (n2 &lt; p.getNNodes() - 1) ? n2 + 1 : 0;

        RElement element(R_ELEMENT_TRI1);
        element.setNodeId(0,nodeIDs[book[n1]]);
        element.setNodeId(1,nodeIDs[book[n2]]);
        element.setNodeId(2,nodeIDs[book[n3]]);

        elements.push_back(element);

        p.removeNode(n2,false);
        book.erase(book.begin()+n2);
    }

    return elements;
}

</t>
<t tx="leo.20201108101537.87">void RPolygon::computeNormal(void)
{
    this-&gt;normal[0] = this-&gt;normal[1] = this-&gt;normal[2] = 0.0;

    if (this-&gt;nodes.size() &lt; 3)
    {
        return;
    }
    if (this-&gt;nodes.size() == 3)
    {
        RTriangle t(this-&gt;nodes[0],this-&gt;nodes[1],this-&gt;nodes[2]);
        this-&gt;normal = t.getNormal();
        return;
    }

    for (uint i=0;i&lt;this-&gt;nodes.size();i++)
    {
        uint n1 = (i==0) ? this-&gt;getNNodes()-1 : i-1;
        uint n2 = i;
        uint n3 = (i==this-&gt;getNNodes()-1) ? 0 : i+1;

        RR3Vector n(RTriangle::computeNormal(this-&gt;nodes[n1],this-&gt;nodes[n2],this-&gt;nodes[n3],false));
        this-&gt;normal[0] += n[0];
        this-&gt;normal[1] += n[1];
        this-&gt;normal[2] += n[2];
    }

    this-&gt;normal.normalize();
}

uint RPolygon::findEarNode(void) const
{
    if (this-&gt;getNNodes() &lt; 3)
    {
        return RConstants::eod;
    }
    if (this-&gt;getNNodes() == 3)
    {
        return 0;
    }

    uint earNode = RConstants::eod;
    double earAngle = RConstants::pi;

    for (uint i=0;i&lt;this-&gt;getNNodes();i++)
    {
        uint n1 = (i==0) ? this-&gt;getNNodes()-1 : i-1;
        uint n2 = i;
        uint n3 = (i==this-&gt;getNNodes()-1) ? 0 : i+1;

        RR3Vector v12(this-&gt;nodes[n1].getX()-this-&gt;nodes[n2].getX(),
                      this-&gt;nodes[n1].getY()-this-&gt;nodes[n2].getY(),
                      this-&gt;nodes[n1].getZ()-this-&gt;nodes[n2].getZ());

        RR3Vector v23(this-&gt;nodes[n2].getX()-this-&gt;nodes[n3].getX(),
                      this-&gt;nodes[n2].getY()-this-&gt;nodes[n3].getY(),
                      this-&gt;nodes[n2].getZ()-this-&gt;nodes[n3].getZ());

        RR3Vector vn;

        RR3Vector::cross(v12,v23,vn);

        if (RR3Vector::angle(vn,this-&gt;normal) &lt; RConstants::pi / 2.0)
        {

            RTriangle t(this-&gt;nodes[n1],this-&gt;nodes[n2],this-&gt;nodes[n3]);
            for (uint j=0;j&lt;this-&gt;getNNodes();j++)
            {
                if (j == n1 || j == n2 || j == n3)
                {
                    continue;
                }

                if (!t.isPointInside(this-&gt;nodes[j].toVector(),false))
                {
                    double angle = RR3Vector::angle(v12,v23);
                    if (angle &lt; earAngle)
                    {
                        earAngle = angle;
                        earNode = n2;
                    }
                }
            }
        }
    }

    return earNode;
}
</t>
<t tx="leo.20201108101537.88">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_problem.cpp                                          *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   23-rd December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Problem class definition                            *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "rml_problem.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101537.89">typedef struct _RProblemDesc
{
    RProblemType        type;
    QString             id;
    QString             name;
    QString             desc;
    bool                timeSolverEnabled;
    RProblemTypeMask    requiredProblemTypeMask;
    RProblemTypeMask    excludedProblemTypeMask;
} RProblemDesc;

</t>
<t tx="leo.20201108101537.9">void RModelRaw::addTriangle(const RNode &amp;node1,
                            const RNode &amp;node2,
                            const RNode &amp;node3,
                            bool         mergeNodes,
                            double       tolerance)
{
    RElement element;
    unsigned int nId1, nId2, nId3;

    if (mergeNodes)
    {
        nId1 = this-&gt;findNearNode(node1,tolerance);
        if (nId1 == RConstants::eod)
        {
            this-&gt;nodes.push_back(node1);
            nId1 = (unsigned int)this-&gt;nodes.size() - 1;
        }

        nId2 = this-&gt;findNearNode(node2,tolerance);
        if (nId2 == RConstants::eod)
        {
            this-&gt;nodes.push_back(node2);
            nId2 = (unsigned int)this-&gt;nodes.size() - 1;
        }

        nId3 = this-&gt;findNearNode(node3,tolerance);
        if (nId3 == RConstants::eod)
        {
            this-&gt;nodes.push_back(node3);
            nId3 = (unsigned int)this-&gt;nodes.size() - 1;
        }
    }
    else
    {
        this-&gt;nodes.push_back(node1);
        nId1 = (unsigned int)this-&gt;nodes.size() - 1;
        this-&gt;nodes.push_back(node2);
        nId2 = (unsigned int)this-&gt;nodes.size() - 1;
        this-&gt;nodes.push_back(node3);
        nId3 = (unsigned int)this-&gt;nodes.size() - 1;
    }

    element.setType(R_ELEMENT_TRI1);
    element.setNodeId(0,nId1);
    element.setNodeId(1,nId2);
    element.setNodeId(2,nId3);

    this-&gt;elements.push_back(element);
} /* RModelRaw::addTriangle */


</t>
<t tx="leo.20201108101537.90">const RProblemDesc problemDesc [] =
{
    {
        R_PROBLEM_ACOUSTICS,
        "prb-acoustics",
        "Acoustics",
        "Customized wave equation for solving acoustic problems.",
        true,
        R_PROBLEM_NONE,
        R_PROBLEM_WAVE | R_PROBLEM_STRESS_MODAL
    },
    {
        R_PROBLEM_FLUID_PARTICLE,
        "prb-contaminant",
        "Contaminant dispersion",
        "Calculate distribution of contaminant in the flow field.",
        true,
        R_PROBLEM_FLUID,
        R_PROBLEM_STRESS_MODAL
    },
    {
        R_PROBLEM_ELECTROSTATICS,
        "prb-electrostatics",
        "Electro-statics",
        "Calculate electric field, current density and generated Joule\'s heat.",
        false,
        R_PROBLEM_NONE,
        R_PROBLEM_STRESS_MODAL
    },
    {
        R_PROBLEM_MAGNETOSTATICS,
        "prb-magnetostatics",
        "Magneto-statics",
        "Calculate magnetic field.",
        false,
        R_PROBLEM_ELECTROSTATICS,
        R_PROBLEM_STRESS_MODAL
    },
    {
        R_PROBLEM_FLUID,
        "prb-fluid",
        "Incompressible viscous flow",
        "Steady-state and transient flow of newtonian fluids.",
        true,
        R_PROBLEM_NONE,
        R_PROBLEM_POTENTIAL | R_PROBLEM_STRESS_MODAL
    },
    {
        R_PROBLEM_FLUID_HEAT,
        "prb-fluid-heat",
        "Heat transfer in fluids",
        "Heat transfer in fluids.",
        true,
        R_PROBLEM_FLUID,
        R_PROBLEM_STRESS_MODAL
    },
    {
        R_PROBLEM_HEAT,
        "prb-heat",
        "Heat transfer",
        "Steady-state and transient Heat-transfer.",
        true,
        R_PROBLEM_NONE,
        R_PROBLEM_STRESS_MODAL
    },
    {
        R_PROBLEM_RADIATIVE_HEAT,
        "prb-radiative_heat",
        "Radiative heat transfer",
        "Steady-state and transient radiative heat-transfer.",
        true,
        R_PROBLEM_HEAT,
        R_PROBLEM_STRESS_MODAL
    },
    {
        R_PROBLEM_STRESS,
        "prb-stress",
        "Stress analysis",
        "Stress and linear elasto-dynamics analysis including modal analysis.",
        true,
        R_PROBLEM_NONE,
        R_PROBLEM_NONE
    },
    {
        R_PROBLEM_STRESS_MODAL,
        "prb-stress-modal",
        "Modal analysis",
        "Stress modal analysis.",
        false,
        R_PROBLEM_NONE,
        R_PROBLEM_ACOUSTICS | R_PROBLEM_FLUID_PARTICLE | R_PROBLEM_ELECTROSTATICS | R_PROBLEM_MAGNETOSTATICS | R_PROBLEM_FLUID | R_PROBLEM_FLUID_HEAT | R_PROBLEM_HEAT | R_PROBLEM_RADIATIVE_HEAT | R_PROBLEM_POTENTIAL | R_PROBLEM_WAVE
    },
    {
        R_PROBLEM_POTENTIAL,
        "prb-potential",
        "Flow through porous media",
        "Flow through porous media.",
        true,
        R_PROBLEM_NONE,
        R_PROBLEM_FLUID | R_PROBLEM_STRESS_MODAL
    },
    {
        R_PROBLEM_WAVE,
        "prb-wave",
        "Wave - general",
        "Solve general wave equation for wave displacements.",
        true,
        R_PROBLEM_NONE,
        R_PROBLEM_ACOUSTICS | R_PROBLEM_STRESS_MODAL
    },
    {
        R_PROBLEM_MESH,
        "prb-mesh",
        "Mesh reconstruction",
        "Reconstruct mesh based on provided criteria.",
        false,
        R_PROBLEM_NONE,
        R_PROBLEM_NONE
    },
    {
        R_PROBLEM_NONE,
        "prb-none",
        "",
        "",
        false,
        R_PROBLEM_NONE,
        R_PROBLEM_NONE
    }
};

RProblem::RProblem()
{
    this-&gt;_init();
} /* RProblem::RProblem */


RProblem::RProblem(const RProblem &amp; problem)
{
    this-&gt;_init(&amp;problem);
} /* RProblem::RProblem (copy) */


RProblem::~RProblem()
{
} /* RProblem::~RProblem */


</t>
<t tx="leo.20201108101537.91">void RProblem::_init(const RProblem *pProblem)
{
    this-&gt;matrixSolverConfs.insert(RMatrixSolverConf::CG,RMatrixSolverConf(RMatrixSolverConf::CG));
    this-&gt;matrixSolverConfs.insert(RMatrixSolverConf::GMRES,RMatrixSolverConf(RMatrixSolverConf::GMRES));
    if (pProblem)
    {
        this-&gt;taskTree = pProblem-&gt;taskTree;
        this-&gt;timeSolver = pProblem-&gt;timeSolver;
        this-&gt;matrixSolverConfs = pProblem-&gt;matrixSolverConfs;
        this-&gt;monitoringPointManager = pProblem-&gt;monitoringPointManager;
        this-&gt;problemSetup = pProblem-&gt;problemSetup;
    }
} /* RProblem::_init */


</t>
<t tx="leo.20201108101537.92">const RProblemTaskItem &amp;RProblem::getProblemTaskTree(void) const
{
    return this-&gt;taskTree;
} /* RProblem::getProblemTaskTree */


RProblemTaskItem &amp;RProblem::getProblemTaskTree(void)
{
    return this-&gt;taskTree;
} /* RProblem::getProblemTaskTree */


</t>
<t tx="leo.20201108101537.93">void RProblem::setProblemTaskTree(const RProblemTaskItem &amp;taskTree)
{
    this-&gt;taskTree = taskTree;
} /* RProblem::setProblemTaskTree */


</t>
<t tx="leo.20201108101537.94">const RTimeSolver &amp;RProblem::getTimeSolver(void) const
{
    return this-&gt;timeSolver;
} /* RProblem::getTimeSolver */


RTimeSolver &amp;RProblem::getTimeSolver(void)
{
    return this-&gt;timeSolver;
} /* RProblem::getTimeSolver */


</t>
<t tx="leo.20201108101537.95">void RProblem::setTimeSolver(const RTimeSolver &amp;timeSolver)
{
    this-&gt;timeSolver = timeSolver;
} /* RProblem::setTimeSolver */


RMatrixSolverConf RProblem::getMatrixSolverConf(RMatrixSolverType matrixSolverType) const
{
    if (!this-&gt;matrixSolverConfs.contains(matrixSolverType))
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid matrix solver type \'%d\'",matrixSolverType);
    }
    return this-&gt;matrixSolverConfs[matrixSolverType];
} /* RProblem::getMatrixSolver */


RMatrixSolverConf &amp;RProblem::getMatrixSolverConf(RMatrixSolverType matrixSolverType)
{
    if (!this-&gt;matrixSolverConfs.contains(matrixSolverType))
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid matrix solver type \'%d\'",matrixSolverType);
    }
    this-&gt;matrixSolverConfs[matrixSolverType].setType(matrixSolverType);
    return this-&gt;matrixSolverConfs[matrixSolverType];
} /* RProblem::getMatrixSolver */


</t>
<t tx="leo.20201108101537.96">const RMonitoringPointManager &amp;RProblem::getMonitoringPointManager(void) const
{
    return this-&gt;monitoringPointManager;
} /* RProblem::getMonitoringPointManager */


RMonitoringPointManager &amp;RProblem::getMonitoringPointManager(void)
{
    return this-&gt;monitoringPointManager;
} /* RProblem::getMonitoringPointManager */


</t>
<t tx="leo.20201108101537.97">void RProblem::setMonitoringPointManager(const RMonitoringPointManager &amp;monitoringPointManager)
{
    this-&gt;monitoringPointManager = monitoringPointManager;
} /* RProblem::setMonitoringPointManager */


</t>
<t tx="leo.20201108101537.98">const RProblemSetup &amp;RProblem::getProblemSetup(void) const
{
    return this-&gt;problemSetup;
} /* RProblem::getProblemSetup */


RProblemSetup &amp;RProblem::getProblemSetup(void)
{
    return this-&gt;problemSetup;
} /* RProblem::getProblemSetup */


</t>
<t tx="leo.20201108101537.99">void RProblem::setProblemSetup(const RProblemSetup &amp;problemSetup)
{
    this-&gt;problemSetup = problemSetup;
} /* RProblem::setProblemSetup */


RProblem &amp; RProblem::operator = (const RProblem &amp; problem)
{
    this-&gt;_init(&amp;problem);
    return (*this);
} /* RProblem::operator */


RProblemType RProblem::getTypeFromId(const QString &amp;problemId)
{
    RProblemType problemType(R_PROBLEM_NONE);


    unsigned int i = 0;
    while (problemDesc[i].type != R_PROBLEM_NONE)
    {
        if (problemDesc[i].id == problemId)
        {
            problemType = problemDesc[i].type;
            break;
        }
        i++;
    }

    return problemType;
} /* RProblem::getTypeFromId */


QString RProblem::getId(RProblemType type)
{
    R_ERROR_ASSERT (R_PROBLEM_TYPE_IS_VALID (type));
    QString id;
    unsigned int i = 0;
    while (problemDesc[i].type != R_PROBLEM_NONE)
    {
        if (problemDesc[i].type == type)
        {
            id = problemDesc[i].id;
            break;
        }
        i++;
    }
    return id;
} /* RProblem::getId */


QString RProblem::getName(RProblemType type)
{
    R_ERROR_ASSERT (R_PROBLEM_TYPE_IS_VALID (type));
    QString name;
    unsigned int i = 0;
    while (problemDesc[i].type != R_PROBLEM_NONE)
    {
        if (problemDesc[i].type == type)
        {
            name = problemDesc[i].name;
            break;
        }
        i++;
    }
    return name;
} /* RProblem::getName */


QString RProblem::getDesc(RProblemType type)
{
    R_ERROR_ASSERT (R_PROBLEM_TYPE_IS_VALID (type));

    QString desc;
    unsigned int i = 0;
    while (problemDesc[i].type != R_PROBLEM_NONE)
    {
        if (problemDesc[i].type == type)
        {
            desc = problemDesc[i].desc;
            break;
        }
        i++;
    }
    return desc;
} /* RProblem::getDesc */


</t>
<t tx="leo.20201108101538.1">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_problem_setup.cpp                                    *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th July 2014                                           *
 *                                                                   *
 *  DESCRIPTION: Problem setup class definition                      *
 *********************************************************************/

#include "rml_problem_setup.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.10">void RProblemSetup::setMeshSetup(const RMeshSetup &amp;meshSetup)
{
    this-&gt;meshSetup = meshSetup;
}
</t>
<t tx="leo.20201108101538.11">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_problem_task_item.cpp                                *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th November 2015                                       *
 *                                                                   *
 *  DESCRIPTION: Problem task item class definition                  *
 *********************************************************************/

#include &lt;list&gt;

#include &lt;rblib.h&gt;

#include "rml_problem.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.12">void RProblemTaskItem::_init(const RProblemTaskItem *pSolverTaskItem)
{
    if (pSolverTaskItem)
    {
        this-&gt;problemType = pSolverTaskItem-&gt;problemType;
        this-&gt;nIterations = pSolverTaskItem-&gt;nIterations;
        this-&gt;children = pSolverTaskItem-&gt;children;
    }
}

RProblemTaskItem::RProblemTaskItem(RProblemType problemType)
    : problemType(problemType)
    , nIterations(1)
{
    this-&gt;_init();
}

RProblemTaskItem::RProblemTaskItem(const RProblemTaskItem &amp;solverTaskItem)
{
    this-&gt;_init(&amp;solverTaskItem);
}

RProblemTaskItem::~RProblemTaskItem()
{

}

RProblemTaskItem &amp;RProblemTaskItem::operator =(const RProblemTaskItem &amp;solverTaskItem)
{
    this-&gt;_init(&amp;solverTaskItem);
    return (*this);
}

RProblemTypeMask RProblemTaskItem::getProblemTypeMask(void) const
{
    RProblemTypeMask problemTypeMask = this-&gt;getProblemType();

    for (uint i=0;i&lt;this-&gt;getNChildren();i++)
    {
        problemTypeMask |= this-&gt;getChild(i).getProblemTypeMask();
    }

    return problemTypeMask;
}

RProblemType RProblemTaskItem::getProblemType(void) const
{
    return this-&gt;problemType;
}

</t>
<t tx="leo.20201108101538.13">void RProblemTaskItem::setProblemType(RProblemType problemType)
{
    this-&gt;problemType = problemType;
    if (this-&gt;problemType != R_PROBLEM_NONE)
    {
        this-&gt;nIterations = 0;
        this-&gt;children.resize(0);
    }
}

</t>
<t tx="leo.20201108101538.14">unsigned int RProblemTaskItem::getNIterations(void) const
{
    return this-&gt;nIterations;
}

</t>
<t tx="leo.20201108101538.15">void RProblemTaskItem::setNIterations(unsigned int nIterations)
{
    this-&gt;nIterations = nIterations;
}

</t>
<t tx="leo.20201108101538.16">unsigned int RProblemTaskItem::getNChildren(void) const
{
    return (unsigned int)this-&gt;children.size();
}

</t>
<t tx="leo.20201108101538.17">const RProblemTaskItem &amp;RProblemTaskItem::getChild(unsigned int position) const
{
    return this-&gt;children.at(position);
}

RProblemTaskItem &amp;RProblemTaskItem::getChild(unsigned int position)
{
    return this-&gt;children.at(position);
}

</t>
<t tx="leo.20201108101538.18">void RProblemTaskItem::addChild(const RProblemTaskItem &amp;solverTaskItem)
{
    this-&gt;children.push_back(solverTaskItem);
}

</t>
<t tx="leo.20201108101538.19">void RProblemTaskItem::insertChild(unsigned int position, const RProblemTaskItem &amp;solverTaskItem)
{
    this-&gt;children.insert(this-&gt;children.begin()+position,1,solverTaskItem);
}

</t>
<t tx="leo.20201108101538.2">void RProblemSetup::_init(const RProblemSetup *pProblemSetup)
{
    if (pProblemSetup)
    {
        this-&gt;restart = pProblemSetup-&gt;restart;
        this-&gt;radiationSetup = pProblemSetup-&gt;radiationSetup;
        this-&gt;modalSetup = pProblemSetup-&gt;modalSetup;
        this-&gt;meshSetup = pProblemSetup-&gt;meshSetup;
    }
}

RProblemSetup::RProblemSetup()
    : restart(false)
{
    this-&gt;_init();
}

RProblemSetup::RProblemSetup(const RProblemSetup &amp;problemSetup)
{
    this-&gt;_init(&amp;problemSetup);
}

RProblemSetup::~RProblemSetup()
{

}

RProblemSetup &amp;RProblemSetup::operator =(const RProblemSetup &amp;problemSetup)
{
    this-&gt;_init(&amp;problemSetup);
    return (*this);
}

</t>
<t tx="leo.20201108101538.20">void RProblemTaskItem::removeChild(unsigned int position)
{
    this-&gt;children.erase(this-&gt;children.begin()+position);
}

</t>
<t tx="leo.20201108101538.21">void RProblemTaskItem::print(bool printTitle) const
{
    if (printTitle)
    {
        RLogger::info("Task-tree to be executed:\n");
        RLogger::indent();
    }
    if (this-&gt;getProblemType() == R_PROBLEM_NONE)
    {
        RLogger::info("Number of iterations: %u\n",this-&gt;getNIterations());
        RLogger::indent();
        for (unsigned int i=0;i&lt;this-&gt;getNChildren();i++)
        {
            this-&gt;getChild(i).print(false);
        }
        RLogger::unindent(false);
    }
    else
    {
        RLogger::info("Problem type: %s\n",RProblem::getName(this-&gt;getProblemType()).toUtf8().constData());
    }
    if (printTitle)
    {
        RLogger::unindent(false);
    }
}

RProblemTaskItem RProblemTaskItem::generateDefaultTree(RProblemTypeMask problemTypeMask)
{
    RProblemTaskItem root;
    unsigned int nTypes = 0;
    unsigned int nNonlinearIterations = 5;

    bool isNonlinear = false;

    if (problemTypeMask &amp; R_PROBLEM_RADIATIVE_HEAT &amp;&amp; problemTypeMask &amp; R_PROBLEM_HEAT)
    {
        isNonlinear = true;
    }

    if (problemTypeMask &amp; R_PROBLEM_RADIATIVE_HEAT)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_RADIATIVE_HEAT));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_HEAT)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_HEAT));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_ACOUSTICS)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_ACOUSTICS));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_FLUID_PARTICLE)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_FLUID_PARTICLE));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_FLUID)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_FLUID));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_ELECTROSTATICS)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_ELECTROSTATICS));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_MAGNETOSTATICS)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_MAGNETOSTATICS));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_STRESS)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_STRESS));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_STRESS_MODAL)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_STRESS_MODAL));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_POTENTIAL)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_POTENTIAL));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_WAVE)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_WAVE));
        nTypes ++;
    }
    if (problemTypeMask &amp; R_PROBLEM_MESH)
    {
        root.addChild(RProblemTaskItem(R_PROBLEM_MESH));
        nTypes ++;
    }

    root.setNIterations(nTypes &gt; 1 &amp;&amp; isNonlinear ? nNonlinearIterations : 1);

    return root;
}
</t>
<t tx="leo.20201108101538.22">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_radiation_setup.cpp                                  *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th July 2014                                           *
 *                                                                   *
 *  DESCRIPTION: Radiation setup class definition                    *
 *********************************************************************/

#include &lt;QFileInfo&gt;

#include "rml_file_manager.h"
#include "rml_radiation_setup.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.23">void RRadiationSetup::_init(const RRadiationSetup *pRadiationSetup)
{
    if (pRadiationSetup)
    {
        this-&gt;resolution = pRadiationSetup-&gt;resolution;
        this-&gt;viewFactorMatrixFile = pRadiationSetup-&gt;viewFactorMatrixFile;
    }
}

RRadiationSetup::RRadiationSetup()
    : resolution(R_RADIATION_RESOLUTION_MEDIUM)
{
    this-&gt;_init();
}

RRadiationSetup::RRadiationSetup(const RRadiationSetup &amp;radiationSetup)
{
    this-&gt;_init(&amp;radiationSetup);
}

RRadiationSetup::~RRadiationSetup()
{

}

RRadiationSetup &amp;RRadiationSetup::operator =(const RRadiationSetup &amp;radiationSetup)
{
    this-&gt;_init(&amp;radiationSetup);
    return (*this);
}

RRadiationResolution RRadiationSetup::getResolution(void) const
{
    return this-&gt;resolution;
}

</t>
<t tx="leo.20201108101538.24">void RRadiationSetup::setResolution(const RRadiationResolution &amp;value)
{
    this-&gt;resolution = value;
}

</t>
<t tx="leo.20201108101538.25">const QString &amp;RRadiationSetup::getViewFactorMatrixFile(void) const
{
    return this-&gt;viewFactorMatrixFile;
}

</t>
<t tx="leo.20201108101538.26">void RRadiationSetup::setViewFactorMatrixFile(const QString &amp;viewFactorMatrixFile)
{
    this-&gt;viewFactorMatrixFile = viewFactorMatrixFile;
}

QString RRadiationSetup::findRecentViewFactorMatrixFile(const QString &amp;viewFactorMatrixFile, uint timeStep)
{
    if (viewFactorMatrixFile.isEmpty())
    {
        return QString();
    }

    for (uint i=0;i&lt;=timeStep;i++)
    {
        QString fileNameWithTimeStamp = RFileManager::getFileNameWithTimeStep(viewFactorMatrixFile,timeStep-i);

        if (QFileInfo::exists(fileNameWithTimeStamp))
        {
            return fileNameWithTimeStamp;
        }
    }

    if (QFileInfo::exists(viewFactorMatrixFile))
    {
        return viewFactorMatrixFile;
    }

    return QString();
}

QString RRadiationSetup::getResolutionText(RRadiationResolution resolution)
{
    if (resolution &lt;= R_RADIATION_RESOLUTION_LOW)
    {
        return "Low";
    }
    if (resolution &gt; R_RADIATION_RESOLUTION_LOW &amp;&amp; resolution &lt; R_RADIATION_RESOLUTION_HIGH)
    {
        return "Medium";
    }
    if (resolution &gt;= R_RADIATION_RESOLUTION_HIGH)
    {
        return "High";
    }
    return "Unknown";
}

</t>
<t tx="leo.20201108101538.27">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_results.cpp                                          *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   14-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Results class definition                            *
 *********************************************************************/

#include &lt;string&gt;
#include &lt;vector&gt;

#include "rml_results.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.28">void RResults::_init (const RResults *pResults)
{
    this-&gt;nnodes = 0;
    this-&gt;nelements = 0;

    if (pResults)
    {
//        this-&gt;compTime = compTime;
        this-&gt;setNVariables (pResults-&gt;getNVariables());
        this-&gt;setNNodes (pResults-&gt;getNNodes());
        this-&gt;setNElements (pResults-&gt;getNElements());
        for (unsigned int i=0;i&lt;this-&gt;getNVariables();i++)
        {
            this-&gt;setVariable(i, pResults-&gt;getVariable(i));
        }
    }
} /* RResults::_init */

RResults::RResults ()
//    : compTime(0.0)
{
    this-&gt;_init ();
} /* RResults::RResults */

RResults::RResults (const RResults &amp;results)
{
    this-&gt;_init (&amp;results);
} /* RResults::RResults (copy) */


RResults::~RResults ()
{
} /* RResults::~RResults */


RResults &amp; RResults::operator = (const RResults &amp;results)
{
    this-&gt;_init (&amp;results);
    return (*this);
} /* RResults::operator = */


</t>
<t tx="leo.20201108101538.29">void RResults::clearResults(void)
{
    for (unsigned int i=0;i&lt;this-&gt;variables.size();i++)
    {
        this-&gt;variables[i].clearValues();
    }
    this-&gt;variables.clear();
} /* RResults::clearResults */


//double RResults::getCompTime(void) const
//{
//    return this-&gt;compTime;
//} /* RResults::getCompTime */


//void RResults::setCompTime(double compTime)
//{
//    this-&gt;compTime = compTime;
//} /* RResults::setCompTime */


</t>
<t tx="leo.20201108101538.3">bool RProblemSetup::getRestart(void) const
{
    return this-&gt;restart;
}

</t>
<t tx="leo.20201108101538.30">unsigned int RResults::getNVariables (void) const
{
    return uint(this-&gt;variables.size());
} /* RResults::getNVariables */


</t>
<t tx="leo.20201108101538.31">void RResults::setNVariables (unsigned int nvariables)
{
    this-&gt;variables.resize(nvariables);
} /* RResults::set_n_variables */


</t>
<t tx="leo.20201108101538.32">const RVariable &amp; RResults::getVariable (unsigned int position) const
{
    R_ERROR_ASSERT (position &lt; this-&gt;getNVariables());
    return this-&gt;variables[position];
} /* RResults::getVariable */


RVariable &amp; RResults::getVariable (unsigned int position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;getNVariables());
    return this-&gt;variables[position];
} /* RResults::getVariable */


</t>
<t tx="leo.20201108101538.33">unsigned int RResults::findVariable(RVariableType variableType) const
{
    for (unsigned int i=0;i&lt;this-&gt;getNVariables();i++)
    {
        if (this-&gt;getVariable(i).getType() == variableType)
        {
            return i;
        }
    }
    return RConstants::eod;
} /* RResults::findVariable */


//unsigned int RResults::findVariable(RVariableType variableType, bool create)
//{
//    for (unsigned int i=0;i&lt;this-&gt;getNVariables();i++)
//    {
//        if (this-&gt;getVariable(i).getType() == variableType)
//        {
//            return i;
//        }
//    }
//    if (create)
//    {
//        this-&gt;addVariable(RVariable(variableType));
//        return this-&gt;getNVariables()-1;
//    }
//    return RConstants::eod;
//} /* RResults::findVariable */


</t>
<t tx="leo.20201108101538.34">unsigned int RResults::addVariable(const RVariable &amp;variable)
{
    unsigned int variablePosition = this-&gt;findVariable(variable.getType());
    if (variablePosition == RConstants::eod)
    {
        this-&gt;variables.push_back(variable);
        variablePosition = uint(this-&gt;variables.size()-1);
    }
    else
    {
        this-&gt;setVariable(variablePosition,variable);
    }
    return variablePosition;
} /* RResults::addVariable */


</t>
<t tx="leo.20201108101538.35">void RResults::setVariable (unsigned int     position,
                            const RVariable &amp;variable)
{
    R_ERROR_ASSERT (position &lt; this-&gt;getNVariables());
    this-&gt;variables[position] = variable;
} /* RResults::setVariable */


</t>
<t tx="leo.20201108101538.36">void RResults::removeVariable(uint position)
{
    R_ERROR_ASSERT (position &lt; this-&gt;getNVariables());
    this-&gt;variables.erase(this-&gt;variables.begin() + position);
} /* RResults::removeVariable */


</t>
<t tx="leo.20201108101538.37">void RResults::removeAllVariables(void)
{
    this-&gt;variables.clear();
} /* RResults::removeAllVariables */


</t>
<t tx="leo.20201108101538.38">unsigned int RResults::getNNodes (void) const
{
    return this-&gt;nnodes;
} /* RResults::getNNodes */


</t>
<t tx="leo.20201108101538.39">void RResults::setNNodes (unsigned int nnodes)
{
    std::vector&lt;RVariable&gt;::iterator iter;

    this-&gt;nnodes = nnodes;

    for (iter = this-&gt;variables.begin();
         iter != this-&gt;variables.end();
         ++iter)
    {
        if (iter-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            iter-&gt;resize (iter-&gt;getNVectors(), this-&gt;nnodes);
        }
    }
} /* RResults::setNNodes */


</t>
<t tx="leo.20201108101538.4">void RProblemSetup::setRestart(bool restart)
{
    this-&gt;restart = restart;
}

</t>
<t tx="leo.20201108101538.40">void RResults::addNode (double value)
{
    std::vector&lt;RVariable&gt;::iterator iter;

    for (iter = this-&gt;variables.begin();
         iter != this-&gt;variables.end();
         ++iter)
    {
        if (iter-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            iter-&gt;addValue (value);
        }
    }

    this-&gt;nnodes ++;
} /* RResults::addNode */


</t>
<t tx="leo.20201108101538.41">void RResults::removeNode (unsigned int position)
{
    std::vector&lt;RVariable&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNNodes());

    for (iter = this-&gt;variables.begin();
         iter != this-&gt;variables.end();
         ++iter)
    {
        if (iter-&gt;getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            iter-&gt;removeValue (position);
        }
    }

    this-&gt;nnodes --;
} /* RResults::removeNode */


</t>
<t tx="leo.20201108101538.42">unsigned int RResults::getNElements (void) const
{
    return this-&gt;nelements;
} /* RResults::getNElements */


</t>
<t tx="leo.20201108101538.43">void RResults::setNElements (unsigned int nelements)
{
    std::vector&lt;RVariable&gt;::iterator iter;

    this-&gt;nelements = nelements;

    for (iter = this-&gt;variables.begin();
         iter != this-&gt;variables.end();
         ++iter)
    {
        if (iter-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            iter-&gt;resize (iter-&gt;getNVectors(), this-&gt;nelements);
        }
    }
} /* RResults::setNElements */


</t>
<t tx="leo.20201108101538.44">void RResults::addElement (double value)
{
    std::vector&lt;RVariable&gt;::iterator iter;

    for (iter = this-&gt;variables.begin();
         iter != this-&gt;variables.end();
         ++iter)
    {
        if (iter-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            iter-&gt;addValue (value);
        }
    }

    this-&gt;nelements ++;
} /* RResults::addElement */


</t>
<t tx="leo.20201108101538.45">void RResults::removeElement (unsigned int position)
{
    std::vector&lt;RVariable&gt;::iterator iter;

    R_ERROR_ASSERT (position &lt; this-&gt;getNElements());

    for (iter = this-&gt;variables.begin();
         iter != this-&gt;variables.end();
         ++iter)
    {
        if (iter-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            iter-&gt;removeValue(position);
        }
    }

    this-&gt;nelements--;
}

</t>
<t tx="leo.20201108101538.46">void RResults::removeElements(const std::vector&lt;uint&gt; &amp;elementBook)
{
    std::vector&lt;RVariable&gt;::iterator iter;

    for (iter = this-&gt;variables.begin();
         iter != this-&gt;variables.end();
         ++iter)
    {
        if (iter-&gt;getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            iter-&gt;removeValues(elementBook);
        }
    }

    this-&gt;nelements = 0;
    for (uint i=0;i&lt;uint(elementBook.size());i++)
    {
        if (elementBook[i] != RConstants::eod)
        {
            this-&gt;nelements++;
        }
    }
} /* RResults::removeElements */
</t>
<t tx="leo.20201108101538.47">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_save_file.cpp                                        *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   1-st January 2017                                        *
 *                                                                   *
 *  DESCRIPTION: Save file class definition                          *
 *********************************************************************/

#include "rml_save_file.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.48">void RSaveFile::_init(const RSaveFile *pFile)
{
    if (pFile)
    {
        this-&gt;fileName = pFile-&gt;fileName;
        this-&gt;type = pFile-&gt;type;
        this-&gt;fileVersion = pFile-&gt;fileVersion;
//        this-&gt;textStream = pFile-&gt;textStream;
    }
    if (this-&gt;type == RSaveFile::ASCII)
    {
        this-&gt;textStream.setDevice(this);
    }
}

RSaveFile::RSaveFile(const QString &amp;fileName, RSaveFile::Type type)
    : QSaveFile(fileName)
    , fileName(fileName)
    , type(type)
    , fileVersion(RVersion(0,0,0))
{
    this-&gt;_init();
}

RSaveFile::RSaveFile(const RSaveFile &amp;file)
    : QSaveFile(fileName)
{
    this-&gt;_init(&amp;file);
}

RSaveFile::~RSaveFile()
{

}

RSaveFile &amp;RSaveFile::operator =(const RSaveFile &amp;file)
{
    this-&gt;_init(&amp;file);
    return (*this);
}

</t>
<t tx="leo.20201108101538.49">const RVersion &amp;RSaveFile::getVersion(void) const
{
    return this-&gt;fileVersion;
}

</t>
<t tx="leo.20201108101538.5">const RRadiationSetup &amp;RProblemSetup::getRadiationSetup(void) const
{
    return this-&gt;radiationSetup;
}

RRadiationSetup &amp;RProblemSetup::getRadiationSetup(void)
{
    return this-&gt;radiationSetup;
}

</t>
<t tx="leo.20201108101538.50">void RSaveFile::setVersion(const RVersion &amp;fileVersion)
{
    this-&gt;fileVersion = fileVersion;
}

QTextStream &amp;RSaveFile::getTextStream(void)
{
    return this-&gt;textStream;
}

QString RSaveFile::getTextStreamStatusStringt(QTextStream::Status status)
{
    switch (status)
    {
        case QTextStream::Ok:
            return "ok";
        case QTextStream::ReadPastEnd:
            return "read past end";
        case QTextStream::ReadCorruptData:
            return "read corrupt data";
        case QTextStream::WriteFailed:
            return "write failed";
        default:
            return "unknown";
    }
}
</t>
<t tx="leo.20201108101538.51">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_scalar_field.cpp                                     *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th February 2014                                      *
 *                                                                   *
 *  DESCRIPTION: Scalar field class definition                       *
 *********************************************************************/

#include "rml_scalar_field.h"

const QString RScalarField::defaultName("Scalar field");

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.52">void RScalarField::_init(const RScalarField *pScalarField)
{
    if (pScalarField)
    {
        this-&gt;minPointSize = pScalarField-&gt;minPointSize;
        this-&gt;maxPointSize = pScalarField-&gt;maxPointSize;
    }
}

RScalarField::RScalarField()
    : minPointSize(0.0)
    , maxPointSize(RScalarField::getDefaultMaxPointSize())
{
    this-&gt;name = RScalarField::defaultName;
    this-&gt;_init();
}

RScalarField::RScalarField(const RScalarField &amp;scalarField)
    : RVectorField(scalarField)
{
    this-&gt;_init(&amp;scalarField);
}

RScalarField::~RScalarField()
{

}

RScalarField &amp;RScalarField::operator =(const RScalarField &amp;scalarField)
{
    this-&gt;RVectorField::operator =(scalarField);
    this-&gt;_init(&amp;scalarField);
    return (*this);
}

double RScalarField::getMaxPointSize(void) const
{
    return this-&gt;maxPointSize;
}

</t>
<t tx="leo.20201108101538.53">void RScalarField::setMaxPointSize(double maxPointSize)
{
    this-&gt;maxPointSize = maxPointSize;
}

double RScalarField::getDefaultMaxPointSize(void)
{
    return 10.0;
}
</t>
<t tx="leo.20201108101538.54">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_segment.cpp                                          *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Segment class definition                            *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rml_segment.h"
#include "rml_triangle.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.55">void RSegment::_init(const RSegment *pSegment)
{
    if (pSegment)
    {
        this-&gt;node1ID = pSegment-&gt;node1ID;
        this-&gt;node2ID = pSegment-&gt;node2ID;
        this-&gt;node1 = pSegment-&gt;node1;
        this-&gt;node2 = pSegment-&gt;node2;
    }
}

RSegment::RSegment(const RNode &amp;node1, const RNode &amp;node2)
    : node1ID(RConstants::eod)
    , node2ID(RConstants::eod)
    , node1(node1)
    , node2(node2)
{
    this-&gt;_init();
}

RSegment::RSegment(const RSegment &amp;segment)
{
    this-&gt;_init(&amp;segment);
}

RSegment::~RSegment()
{
}

RSegment &amp;RSegment::operator =(const RSegment &amp;segment)
{
    this-&gt;_init(&amp;segment);
    return (*this);
}

</t>
<t tx="leo.20201108101538.56">bool RSegment::operator &lt;(const RSegment &amp;segment) const
{
    if (this-&gt;node1 &lt; segment.node1 || this-&gt;node1 &lt; segment.node2)
    {
        return true;
    }
    if (this-&gt;node2 &lt; segment.node1 || this-&gt;node2 &lt; segment.node2)
    {
        return true;
    }
    return false;
}

</t>
<t tx="leo.20201108101538.57">void RSegment::setNodeIDs(uint node1ID, uint node2ID)
{
    this-&gt;node1ID = node1ID;
    this-&gt;node2ID = node2ID;
}

</t>
<t tx="leo.20201108101538.58">bool RSegment::hasNodeID(uint nodeID) const
{
    if (nodeID == RConstants::eod)
    {
        return false;
    }
    return (this-&gt;node1ID == nodeID || this-&gt;node2ID == nodeID);
}

</t>
<t tx="leo.20201108101538.59">void RSegment::setNodes(const RNode &amp;node1, const RNode &amp;node2)
{
    this-&gt;node1 = node1;
    this-&gt;node2 = node2;
}

</t>
<t tx="leo.20201108101538.6">void RProblemSetup::setRadiationSetup(const RRadiationSetup &amp;radiationSetup)
{
    this-&gt;radiationSetup = radiationSetup;
}

</t>
<t tx="leo.20201108101538.60">void RSegment::findRotationMatrix(RRMatrix &amp;R) const
{
    RR3Vector vec;

    vec[0] = this-&gt;node2.getX() - this-&gt;node1.getX();
    vec[1] = this-&gt;node2.getY() - this-&gt;node1.getY();
    vec[2] = this-&gt;node2.getZ() - this-&gt;node1.getZ();

    vec.findRotationMatrix(R);
}

double RSegment::findLineDistance(const RR3Vector &amp;position, const RR3Vector &amp;direction) const
{
    RR3Vector segmentDirection(this-&gt;node2.getX()-this-&gt;node1.getX(),this-&gt;node2.getY()-this-&gt;node1.getY(),this-&gt;node2.getZ()-this-&gt;node1.getZ());

    RR3Vector vp;
    RR3Vector::cross(segmentDirection,direction,vp);

    double norm = RR3Vector::norm(vp);

    if (norm &lt; RConstants::eps)
    {
        // Parallel lines
        return this-&gt;findPointDistance(position);
    }

    vp *= 1.0 / norm;

    RR3Vector startDistance;
    RR3Vector::subtract(position,this-&gt;node1.toVector(),startDistance);
    return std::fabs(RR3Vector::dot(vp,startDistance));
}

double RSegment::findSegmentDistance(const RR3Vector &amp;position, const RR3Vector &amp;direction) const
{
    RR3Vector c1 = this-&gt;findLineNearestPoint(position,direction,true);

    RSegment line(RNode(position),RNode(position[0]+direction[0],position[1]+direction[1],position[2]+direction[2]));

    if (this-&gt;isPointInside(c1))
    {
        return line.findPointDistance(c1);
    }
    else
    {
        double d1 = line.findPointDistance(this-&gt;node1.toVector());
        double d2 = line.findPointDistance(this-&gt;node2.toVector());

        return d1 &lt; d2 ? d1 : d2;
    }
}

RR3Vector RSegment::findLineNearestPoint(const RR3Vector &amp;position, const RR3Vector &amp;direction, bool onSegment) const
{
    RR3Vector p1(this-&gt;node1.toVector());
    RR3Vector d1(this-&gt;node2.getX()-this-&gt;node1.getX(),this-&gt;node2.getY()-this-&gt;node1.getY(),this-&gt;node2.getZ()-this-&gt;node1.getZ());
    const RR3Vector &amp;p2 = position;
    const RR3Vector &amp;d2 = direction;
    RR3Vector n;

    RR3Vector::cross(d1,d2,n);

    if (RR3Vector::norm(n) &lt; RConstants::eps)
    {
        // Parallel lines
        return position;
    }

    if (onSegment)
    {
        RR3Vector n2;
        RR3Vector::cross(d2,n,n2);

        // c1 = p1 + (((p2-p1).n2)/(d1.n2))d1

        // p21 = p2-p1
        RR3Vector p21;
        RR3Vector::subtract(p2,p1,p21);

        d1 *= RR3Vector::dot(p21,n2) / RR3Vector::dot(d1,n2);

        RR3Vector c1;

        RR3Vector::add(p1,d1,c1);

        return c1;
    }
    else
    {
        RR3Vector n1;
        RR3Vector::cross(d1,n,n1);

        // c2 = p2 + (((p1-p2).n1)/(d2.n1))d2

        // p12 = p1-p2
        RR3Vector p12;
        RR3Vector::subtract(p1,p2,p12);

        RR3Vector sd2(d2);
        sd2 *= RR3Vector::dot(p12,n1) / RR3Vector::dot(d2,n1);

        RR3Vector c2;

        RR3Vector::add(p2,sd2,c2);

        return c2;
    }
}

</t>
<t tx="leo.20201108101538.61">bool RSegment::findLineIntersection(const RR3Vector &amp;position, const RR3Vector &amp;direction, RR3Vector &amp;x, double &amp;u) const
{
    RR3Vector n1 = this-&gt;getNode1().toVector();
    RR3Vector n2 = this-&gt;getNode2().toVector();
    const RR3Vector &amp;n3(position);
    RR3Vector n4(position[0]+direction[0],position[1]+direction[1],position[2]+direction[2]);

    double u2;
    if (!RSegment::findLineLineIntersection(n1,n2,n3,n4,x,u,u2))
    {
        return false;
    }

    return R_IS_IN_CLOSED_INTERVAL(0.0,1.0,u);
}

</t>
<t tx="leo.20201108101538.62">bool RSegment::findPointIntersection(const RNode &amp;node, std::set&lt;RR3Vector&gt; &amp;x) const
{
    bool intersectionFound = false;
    RR3Vector point(node.toVector());

    if (this-&gt;isPointInside(point))
    {
        @others
}

</t>
<t tx="leo.20201108101538.63">    intersectionFound = (RR3Vector::findDistance(this-&gt;getNode1().toVector(),point) &gt; RConstants::eps &amp;&amp;
                         RR3Vector::findDistance(this-&gt;getNode2().toVector(),point) &gt; RConstants::eps);
}

if (intersectionFound)
{
    x.insert(point);
}

return intersectionFound;
</t>
<t tx="leo.20201108101538.64">bool RSegment::findSegmentIntersection(const RSegment &amp;segment, std::set&lt;RR3Vector&gt; &amp;x) const
{
    double tollerance = 1.0e-5;

    RPlane plane(this-&gt;getNode1().toVector(),
                 this-&gt;getNode2().toVector(),
                 segment.getNode1().toVector());

    double pointPlaneDistance = std::fabs(plane.findPointDistance(segment.getNode2().toVector()));
    if (pointPlaneDistance &gt; tollerance)
    {
        return false;
    }

    std::set&lt;RR3Vector&gt; xTemp;

    if (RR3Vector::areParallel(this-&gt;findDirection(),segment.findDirection()))
    {
        if (this-&gt;isPointInside(segment.getNode1().toVector()))
        {
            xTemp.insert(segment.getNode1().toVector());
        }
        if (this-&gt;isPointInside(segment.getNode2().toVector()))
        {
            xTemp.insert(segment.getNode2().toVector());
        }
        if (segment.isPointInside(this-&gt;getNode1().toVector()))
        {
            xTemp.insert(this-&gt;getNode1().toVector());
        }
        if (segment.isPointInside(this-&gt;getNode2().toVector()))
        {
            xTemp.insert(this-&gt;getNode2().toVector());
        }
    }
    else
    {
        RR3Vector xVec;
        double u1 = 0.0;
        double u2 = 0.0;

        if (RSegment::findLineLineIntersection(this-&gt;getNode1().toVector(),
                                               this-&gt;getNode2().toVector(),
                                               segment.getNode1().toVector(),
                                               segment.getNode2().toVector(),
                                               xVec,u1,u2))
        {
            if (R_IS_IN_CLOSED_INTERVAL(0.0,1.0,u1) &amp;&amp; R_IS_IN_CLOSED_INTERVAL(0.0,1.0,u2))
            {
                xTemp.insert(xVec);
            }
        }
    }

    bool intersectionFound = false;

    // Delete intersections at nodes.

    std::set&lt;RR3Vector&gt;::reverse_iterator it;
    for (it=xTemp.rbegin();it!=xTemp.rend();++it)
    {
        @others
}

</t>
<t tx="leo.20201108101538.65">    bool isNode1 = (RR3Vector::findDistance(this-&gt;getNode1().toVector(),*it) &lt; RConstants::eps ||
                    RR3Vector::findDistance(this-&gt;getNode2().toVector(),*it) &lt; RConstants::eps);
    bool isNode2 = (RR3Vector::findDistance(segment.getNode1().toVector(),*it) &lt; RConstants::eps ||
                    RR3Vector::findDistance(segment.getNode2().toVector(),*it) &lt; RConstants::eps);
    if (isNode1 &amp;&amp; isNode2)
    {
        continue;
    }
    // Intersection is not in node.
    x.insert(*it);
    intersectionFound = true;
}

return intersectionFound;
</t>
<t tx="leo.20201108101538.66">bool RSegment::findSegmentIntersection(const RSegment &amp;segment, RR3Vector &amp;x, double &amp;u) const
{
    RR3Vector position;
    RR3Vector direction;

    position[0] = segment.getNode1().getX();
    position[1] = segment.getNode1().getY();
    position[2] = segment.getNode1().getZ();

    direction[0] = segment.getNode2().getX() - segment.getNode1().getX();
    direction[1] = segment.getNode2().getY() - segment.getNode1().getY();
    direction[2] = segment.getNode2().getZ() - segment.getNode1().getZ();

    return this-&gt;findLineIntersection(position,direction,x,u);
}

double RSegment::findPointDistance(const RR3Vector &amp;point) const
{
    const RR3Vector &amp;p = point;
    RR3Vector a(this-&gt;getNode1().toVector());
    RR3Vector n(this-&gt;getNode2().getX()-this-&gt;getNode1().getX(),
                this-&gt;getNode2().getY()-this-&gt;getNode1().getY(),
                this-&gt;getNode2().getZ()-this-&gt;getNode1().getZ());
    RR3Vector ap;
    RR3Vector::subtract(a,p,ap);

    RR3Vector apn(n);
    apn *= RR3Vector::dot(ap,n);

    RR3Vector d;
    RR3Vector::subtract(ap,apn,d);
    return d.length();
}

</t>
<t tx="leo.20201108101538.67">bool RSegment::isPointInside(const RR3Vector &amp;point, bool includeNodes) const
{
    if (this-&gt;isPointAtNode(point) != RConstants::eod)
    {
        return includeNodes;
    }

    RNode np(point);

    return (std::fabs(np.getDistance(this-&gt;node1) + np.getDistance(this-&gt;node2) - this-&gt;findLength()) &lt; RConstants::eps);
}

uint RSegment::isPointAtNode(const RR3Vector &amp;point) const
{
    RNode pointNode(point);

    if (this-&gt;getNode1().getDistance(pointNode) &lt; RConstants::eps)
    {
        return 0;
    }
    if (this-&gt;getNode2().getDistance(pointNode) &lt; RConstants::eps)
    {
        return 1;
    }

    return RConstants::eod;
}

RR3Vector RSegment::findDirection() const
{
    RR3Vector direction;
    this-&gt;findDirection(direction);
    return direction;
}

</t>
<t tx="leo.20201108101538.68">void RSegment::findDirection(RR3Vector &amp;direction) const
{
    direction[0] = this-&gt;node2.getX() - this-&gt;node1.getX();
    direction[1] = this-&gt;node2.getY() - this-&gt;node1.getY();
    direction[2] = this-&gt;node2.getZ() - this-&gt;node1.getZ();
}

double RSegment::findLength() const
{
    return this-&gt;node1.getDistance(this-&gt;node2);
}

double RSegment::findLength(const RNode &amp;node1, const RNode &amp;node2)
{
    return node1.getDistance(node2);
}

</t>
<t tx="leo.20201108101538.69">void RSegment::findPerpendicularVectors(RR3Vector &amp;d1, RR3Vector &amp;d2, RR3Vector &amp;d3) const
{
    d1 = this-&gt;findDirection();
    d1.normalize();

    if (std::abs(d1[0]-1.0) &lt; 0.5)
    {
        d3[0]=0.0; d3[1]=1.0; d3[2]=0.0;
    }
    else
    {
        d3[0]=1.0; d3[1]=0.0; d3[2]=0.0;
    }

    RR3Vector::cross(d1,d3,d2);
    RR3Vector::cross(d1,d2,d3);
}

</t>
<t tx="leo.20201108101538.7">const RModalSetup &amp;RProblemSetup::getModalSetup(void) const
{
    return this-&gt;modalSetup;
}

RModalSetup &amp;RProblemSetup::getModalSetup(void)
{
    return this-&gt;modalSetup;
}

</t>
<t tx="leo.20201108101538.70">void RSegment::print() const
{
    RLogger::info("Segment:\n");
    this-&gt;node1.print();
    this-&gt;node2.print();
}

</t>
<t tx="leo.20201108101538.71">bool RSegment::findLineLineIntersection(const RR3Vector &amp;n1, const RR3Vector &amp;n2, const RR3Vector &amp;n3, const RR3Vector &amp;n4, RR3Vector &amp;nx, double &amp;u1, double &amp;u2)
{
    // http://mathforum.org/library/drmath/view/62814.html
    double tolerance = 1.0e-5;

    RR3Vector v1;
    RR3Vector v2;
    const RR3Vector &amp;p1 = n1;
    const RR3Vector &amp;p2 = n3;

    RR3Vector::subtract(n2,n1,v1);
    RR3Vector::subtract(n4,n3,v2);

    RR3Vector v1v2;

    RR3Vector::cross(v1,v2,v1v2);

    double dv1v2 = RR3Vector::norm(v1v2);
    if (dv1v2 &lt; tolerance)
    {
        return false;
    }

    RR3Vector p21;
    RR3Vector p21v2;

    RR3Vector::subtract(p2,p1,p21);
    RR3Vector::cross(p21,v2,p21v2);

    RR3Vector vx;
    RR3Vector::cross(v1v2,p21v2,vx);

    if (RR3Vector::norm(vx) &gt; tolerance)
    {
        return false;
    }

    u1 = RR3Vector::norm(p21v2) / dv1v2;

    if (RR3Vector::dot(v1v2,p21v2) &lt; 0.0)
    {
        u1 *= -1.0;
    }

    nx[0] = p1[0] + u1*v1[0];
    nx[1] = p1[1] + u1*v1[1];
    nx[2] = p1[2] + u1*v1[2];

    RR3Vector::subtract(nx,p2,vx);
    u2 = RR3Vector::norm(vx) / RR3Vector::norm(v2);

    if (RR3Vector::dot(vx,v2) &lt; 0.0)
    {
        u2 *= -1.0;
    }
    return true;
}
</t>
<t tx="leo.20201108101538.72">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_shape_generator.cpp                                  *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   17-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Shape generator class definition                    *
 *********************************************************************/

#include "rml_shape_generator.h"
#include "rml_segment.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.73">void RShapeGenerator::_init(const RShapeGenerator *pShapeGenerator)
{
    if (pShapeGenerator)
    {

    }
}

RShapeGenerator::RShapeGenerator()
{
    this-&gt;_init();
}

RShapeGenerator::RShapeGenerator(const RShapeGenerator &amp;shapeGenerator)
{
    this-&gt;_init(&amp;shapeGenerator);
}

RShapeGenerator::~RShapeGenerator()
{
}

RShapeGenerator &amp;RShapeGenerator::operator =(const RShapeGenerator &amp;shapeGenerator)
{
    this-&gt;_init(&amp;shapeGenerator);
    return (*this);
}

RModelRaw RShapeGenerator::generateArrow(const RR3Vector &amp;v1, const RR3Vector &amp;v2, double scale)
{
    RModelRaw arrow;

    RNode r1(  0.0,                0.0,          0.0         );
    RNode r2(  1.0/scale,          0.0,          0.0         );
    RNode r3(  1.0/scale-1.0/2.0,  1.0/6.0,      0.0         );
    RNode r4(  1.0/scale-1.0/2.0,  0.70711/6.0,  0.70711/6.0 );
    RNode r5(  1.0/scale-1.0/2.0,  0.0,          1.0/6.0     );
    RNode r6(  1.0/scale-1.0/2.0, -0.70711/6.0,  0.70711/6.0 );
    RNode r7(  1.0/scale-1.0/2.0, -1.0/6.0,      0.0         );
    RNode r8(  1.0/scale-1.0/2.0, -0.70711/6.0, -0.70711/6.0 );
    RNode r9(  1.0/scale-1.0/2.0,  0.0,         -1.0/6.0     );
    RNode r10( 1.0/scale-1.0/2.0,  0.70711/6.0, -0.70711/6.0 );
//    RNode r11( 1.0/2.0, 0.0,         0.0         );

    r1.scale(scale);
    r2.scale(scale);
    r3.scale(scale);
    r4.scale(scale);
    r5.scale(scale);
    r6.scale(scale);
    r7.scale(scale);
    r8.scale(scale);
    r9.scale(scale);
    r10.scale(scale);

    RSegment segment(RNode(v1[0],v1[1],v1[2]),RNode(v2[0],v2[1],v2[2]));

    RRMatrix R;
    segment.findRotationMatrix(R);

    R *= segment.findLength();

    r1.transform(R,v1);
    r2.transform(R,v1);
    r3.transform(R,v1);
    r4.transform(R,v1);
    r5.transform(R,v1);
    r6.transform(R,v1);
    r7.transform(R,v1);
    r8.transform(R,v1);
    r9.transform(R,v1);
    r10.transform(R,v1);
//    r11.transform(R,v1);

    arrow.addSegment(r1,r2);
    arrow.addTriangle(r2,r4,r3);
    arrow.addTriangle(r2,r5,r4);
    arrow.addTriangle(r2,r6,r5);
    arrow.addTriangle(r2,r7,r6);
    arrow.addTriangle(r2,r8,r7);
    arrow.addTriangle(r2,r9,r8);
    arrow.addTriangle(r2,r10,r9);
    arrow.addTriangle(r2,r3,r10);
//    arrow.addTriangle(r11,r3,r4);
//    arrow.addTriangle(r11,r4,r5);
//    arrow.addTriangle(r11,r5,r6);
//    arrow.addTriangle(r11,r6,r7);
//    arrow.addTriangle(r11,r7,r8);
//    arrow.addTriangle(r11,r8,r9);
//    arrow.addTriangle(r11,r9,r10);
//    arrow.addTriangle(r11,r10,r3);

    return arrow;
}
</t>
<t tx="leo.20201108101538.74">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_sparse_matrix.cpp                                    *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   11-th December 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Range sparse matrix class definition                *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "rml_sparse_matrix.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.75">void RSparseMatrix::_init(const RSparseMatrix *pMatrix)
{
    if (pMatrix)
    {
        this-&gt;data = pMatrix-&gt;data;
    }
}

RSparseMatrix::RSparseMatrix()
{
    this-&gt;_init();
}

RSparseMatrix::RSparseMatrix(const RSparseMatrix &amp;matrix)
{
    this-&gt;_init(&amp;matrix);
}

RSparseMatrix::~RSparseMatrix()
{
}

RSparseMatrix &amp;RSparseMatrix::operator =(const RSparseMatrix &amp;matrix)
{
    this-&gt;_init(&amp;matrix);
    return (*this);
}

</t>
<t tx="leo.20201108101538.76">const RSparseVector&lt;double&gt; &amp;RSparseMatrix::getVector(uint rowIndex) const
{
    return this-&gt;data.at(rowIndex);
}

RSparseVector&lt;double&gt; &amp;RSparseMatrix::getVector(uint rowIndex)
{
    return this-&gt;data.at(rowIndex);
}

</t>
<t tx="leo.20201108101538.77">void RSparseMatrix::addMatrix(const RSparseMatrix &amp;A)
{
    R_ERROR_ASSERT(this-&gt;getNRows() == A.getNRows());

    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        this-&gt;data.at(i).addVector(A.getVector(i));
    }
}

uint RSparseMatrix::getNRows(void) const
{
    return uint(this-&gt;data.size());
}

</t>
<t tx="leo.20201108101538.78">void RSparseMatrix::setNRows(uint nRows)
{
    this-&gt;data.resize(nRows);
}

uint RSparseMatrix::getNColumns(uint rowIndex) const
{
    return uint(this-&gt;data[rowIndex].size());
}

</t>
<t tx="leo.20201108101538.79">void RSparseMatrix::reserveNColumns(uint nColumns)
{
    for (uint i=0;i&lt;this-&gt;data.size();i++)
    {
        this-&gt;data[i].reserve(nColumns);
    }
}

double RSparseMatrix::getValue(uint rowIndex, uint columnPosition) const
{
    return this-&gt;data[rowIndex].getValue(columnPosition);
}

std::vector&lt;uint&gt; RSparseMatrix::getRowIndexes(uint rowIndex) const
{
    return this-&gt;data[rowIndex].getIndexes();
}

</t>
<t tx="leo.20201108101538.8">void RProblemSetup::setModalSetup(const RModalSetup &amp;modalSetup)
{
    this-&gt;modalSetup = modalSetup;
}

</t>
<t tx="leo.20201108101538.80">void RSparseMatrix::addValue(uint rowIndex, uint columnIndex, double value)
{
    if (rowIndex &gt;= this-&gt;data.size())
    {
        this-&gt;data.resize(rowIndex + 1);
    }
    this-&gt;data[rowIndex].addValue(columnIndex,value);
}

double RSparseMatrix::findValue(uint rowIndex, uint columnIndex) const
{
    uint pos = 0;
    if (this-&gt;findColumnPosition(rowIndex,columnIndex,pos))
    {
        return this-&gt;getValue(rowIndex,pos);
    }
    return 0.0;
}

</t>
<t tx="leo.20201108101538.81">void RSparseMatrix::clear(void)
{
    for (uint i=0;i&lt;this-&gt;data.size();i++)
    {
        this-&gt;data[i].clear();
    }
}

</t>
<t tx="leo.20201108101538.82">bool RSparseMatrix::findColumnPosition(uint rowIndex, uint columnIndex, uint &amp;rowPosition) const
{
    std::vector&lt;uint&gt; columnIndexes = this-&gt;getRowIndexes(rowIndex);
    for (uint i=0;i&lt;columnIndexes.size();i++)
    {
        if (columnIndexes[i] == columnIndex)
        {
            rowPosition = i;
            return true;
        }
    }
    return false;
}

uint RSparseMatrix::findMaxColumnIndex(void) const
{
    uint maxColumnIndex = 0;

    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        for (uint j=0;j&lt;this-&gt;data[i].size();j++)
        {
            maxColumnIndex = std::max(maxColumnIndex,this-&gt;data[i].getIndex(j));
        }
    }

    return maxColumnIndex;
}

double RSparseMatrix::findNorm(void) const
{
    RRVector v(this-&gt;getNRows());
    v.fill(0.0);

    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        for (uint j=0;j&lt;this-&gt;getNColumns(i);j++)
        {
            v[i] += this-&gt;getValue(i,j);
        }
    }

    return RRVector::norm(v);
}

double RSparseMatrix::findTrace(void) const
{
    double traceValue = 0.0;
    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        uint position = 0;
        if (this-&gt;findColumnPosition(i,i,position))
        {
            traceValue += this-&gt;getValue(i,position);
        }
    }
    return traceValue;
}

</t>
<t tx="leo.20201108101538.83">void RSparseMatrix::print(void) const
{
    uint nc = this-&gt;findMaxColumnIndex() + 1;

    RLogger::info("Matrix - sparse: [%ux%u]\n",this-&gt;getNRows(),nc);
    for (uint i=0;i&lt;this-&gt;getNRows();i++)
    {
        for (uint j=0;j&lt;nc;j++)
        {
            double value = 0.0;
            unsigned rp = 0;
            if (this-&gt;findColumnPosition(i,j,rp))
            {
                value = this-&gt;getValue(i,rp);
            }
            RLogger::info("%15.6e",value);
        }
        RLogger::info("\n");
    }
}

</t>
<t tx="leo.20201108101538.84">void RSparseMatrix::mlt(const RSparseMatrix &amp;A, const RRVector &amp;x, RRVector &amp;y)
{
    y.resize(A.getNRows(),0.0);

    for (uint i=0;i&lt;A.getNRows();i++)
    {
        std::vector&lt;uint&gt; index = A.getRowIndexes(i);
        for (uint j=0;j&lt;index.size();j++)
        {
            y[i] += A.getValue(i,j) * x[j];
        }
    }
}
</t>
<t tx="leo.20201108101538.85">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_stream_line.cpp                                      *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Stream line class definition                        *
 *********************************************************************/

#include "rml_stream_line.h"

const QString RStreamLine::defaultName("Stream line");

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.86">void RStreamLine::_init(const RStreamLine *pStreamLine)
{
    if (pStreamLine)
    {
        this-&gt;variableType = pStreamLine-&gt;variableType;
        this-&gt;position = pStreamLine-&gt;position;
    }
}

RStreamLine::RStreamLine()
    : variableType(R_VARIABLE_NONE)
{
    this-&gt;name = RStreamLine::defaultName;
    this-&gt;_init();
}

RStreamLine::RStreamLine(const RStreamLine &amp;streamLine) :
    RInterpolatedEntity(streamLine)
{
    this-&gt;_init(&amp;streamLine);
}

RStreamLine::~RStreamLine()
{
}

RStreamLine &amp;RStreamLine::operator =(const RStreamLine &amp;streamLine)
{
    this-&gt;RInterpolatedEntity::operator = (streamLine);
    this-&gt;_init(&amp;streamLine);
    return (*this);
}

RVariableType RStreamLine::getVariableType(void) const
{
    return this-&gt;variableType;
}

</t>
<t tx="leo.20201108101538.87">void RStreamLine::setVariableType(RVariableType variableType)
{
    this-&gt;variableType = variableType;
}

</t>
<t tx="leo.20201108101538.88">const RR3Vector &amp;RStreamLine::getPosition(void) const
{
    return this-&gt;position;
}

</t>
<t tx="leo.20201108101538.89">void RStreamLine::setPosition(const RR3Vector &amp;position)
{
    this-&gt;position = position;
}
</t>
<t tx="leo.20201108101538.9">const RMeshSetup &amp;RProblemSetup::getMeshSetup() const
{
    return this-&gt;meshSetup;
}

RMeshSetup &amp;RProblemSetup::getMeshSetup()
{
    return this-&gt;meshSetup;
}

</t>
<t tx="leo.20201108101538.90">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_surface.cpp                                          *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th December 2011                                       *
 *                                                                   *
 *  DESCRIPTION: Surface class definition                            *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rml_element.h"
#include "rml_surface.h"
#include "rml_mesh_generator.h"

const QString RSurface::defaultName("Surface");


RSurface::RSurface () : thickness(0.0)
{
    this-&gt;name = RSurface::defaultName;
    this-&gt;_init ();
} /* RSurface::RSurface */


RSurface::RSurface (const RSurface &amp;surface) : RElementGroup (surface)
{
    this-&gt;_init (&amp;surface);
} /* RSurface::RSurface */


RSurface::~RSurface ()
{
} /* RSurface::~RSurface */


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101538.91">void RSurface::_init (const RSurface *pSurface)
{
    if (pSurface)
    {
        this-&gt;setThickness (pSurface-&gt;getThickness());
    }
} /* RSurface::_init */


double RSurface::getThickness (void) const
{
    return this-&gt;thickness;
} /* RSurface::getThickness */


</t>
<t tx="leo.20201108101538.92">void RSurface::setThickness (double thickness)
{
    this-&gt;thickness = thickness;
} /* RSurface::setThickness */


</t>
<t tx="leo.20201108101538.93">bool RSurface::pointInside(const std::vector&lt;RNode&gt; &amp;nodes, const std::vector&lt;RElement&gt; &amp;elements, const RR3Vector &amp;point, bool includeSurface) const
{
    std::vector&lt;RR3Vector&gt; points;
    points.push_back(point);
    std::vector&lt;bool&gt; isInside = this-&gt;pointsInside(nodes,elements,points,includeSurface);
    if (isInside.size() != 1)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Unexpected error, size of the array = \'%u\'",isInside.size());
    }
    return isInside[0];
} /* RSurface::pointInside */


std::vector&lt;bool&gt; RSurface::pointsInside(const std::vector&lt;RNode&gt; &amp;nodes, const std::vector&lt;RElement&gt; &amp;elements, const std::vector&lt;RR3Vector&gt; &amp;points, bool includeSurface) const
{
    std::vector&lt;RNode&gt; steinerNodes;
    std::vector&lt;RNode&gt; volumeNodes(nodes);
    std::vector&lt;RElement&gt; volumeElements;

    try
    {
        this-&gt;tetrahedralize(nodes,elements,steinerNodes,volumeElements);
    }
    catch (const RError &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to tetrahedralize surface \'%s\'. %s",
                     this-&gt;getName().toUtf8().constData(), error.getMessage().toUtf8().constData());
    }

    if (steinerNodes.size() &gt; 0)
    {
        uint nVolumeNodes = uint(volumeNodes.size());
        volumeNodes.resize(nVolumeNodes + steinerNodes.size());
        for (uint i=0;i&lt;steinerNodes.size();i++)
        {
            volumeNodes[nVolumeNodes+i] = steinerNodes[i];
        }
    }

    std::vector&lt;bool&gt; areInside;
    areInside.resize(points.size(),false);

    for (uint i=0;i&lt;points.size();i++)
    {
        RNode node(points[i]);
        bool isInside = false;

#pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(volumeElements.size());j++)
        {
#pragma omp flush (isInside)
            if (!isInside)
            {
                if (volumeElements[j].isInside(volumeNodes,node))
                {
                    isInside = true;
#pragma omp flush (isInside)
                }
            }
        }

        if (!includeSurface)
        {
            // Check that point is not on the surface.
            for (uint j=0;j&lt;this-&gt;size();j++)
            {
                if (elements[this-&gt;get(j)].isInside(nodes,node))
                {
                    isInside = false;
                    break;
                }
            }
        }

        areInside[i] = isInside;
    }

    return areInside;
} /* RSurface::pointsInside */


</t>
<t tx="leo.20201108101538.94">void RSurface::tetrahedralize(const std::vector&lt;RNode&gt; &amp;nodes, const std::vector&lt;RElement&gt; &amp;elements, std::vector&lt;RNode&gt; &amp;steinerNodes, std::vector&lt;RElement&gt; &amp;volumeElements) const
{
    std::vector&lt;RNode&gt; surfaceNodes;
    std::vector&lt;RElement&gt; surfaceElements;

    std::vector&lt;uint&gt; nodeBook;
    nodeBook.resize(nodes.size(),RConstants::eod);

    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        const RElement &amp;rElement = elements[this-&gt;get(i)];
        surfaceElements.push_back(rElement);

        for (uint j=0;j&lt;rElement.size();j++)
        {
            nodeBook[rElement.getNodeId(j)] = 0;
        }
    }
    uint nSurfaceNodes = 0;
    for (uint i=0;i&lt;nodes.size();i++)
    {
        if (nodeBook[i] != RConstants::eod)
        {
            nodeBook[i] = nSurfaceNodes++;
            surfaceNodes.push_back(nodes[i]);
        }
    }
    for (uint i=0;i&lt;surfaceElements.size();i++)
    {
        RElement &amp;rElement = surfaceElements[i];
        for (uint j=0;j&lt;rElement.size();j++)
        {
            rElement.setNodeId(j,nodeBook[rElement.getNodeId(j)]);
        }
    }

    std::vector&lt;uint&gt; sNodeBook;
    sNodeBook.resize(surfaceNodes.size(),RConstants::eod);
    for (uint i=0;i&lt;nodeBook.size();i++)
    {
        if (nodeBook[i] != RConstants::eod)
        {
            sNodeBook[nodeBook[i]] = i;
        }
    }

    try
    {
        RMeshGenerator::generate(surfaceNodes,surfaceElements,steinerNodes,volumeElements);
    }
    catch (const RError &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to generate volume mesh. %s", error.getMessage().toUtf8().constData());
    }

    if (steinerNodes.size() &gt; 0)
    {
        uint nSurfaceNodes = uint(sNodeBook.size());
        uint nSteinerNodes = uint(steinerNodes.size());

        sNodeBook.resize(nSurfaceNodes + nSteinerNodes);

        for (uint i=0;i&lt;nSteinerNodes;i++)
        {
            sNodeBook[nSurfaceNodes+i] = uint(nodes.size()) + i;
        }
    }

    for (uint i=0;i&lt;volumeElements.size();i++)
    {
        RElement &amp;rElement = volumeElements[i];
        for (uint j=0;j&lt;rElement.size();j++)
        {
            uint nodeId = rElement.getNodeId(j);
            rElement.setNodeId(j,sNodeBook[nodeId]);
        }
    }
} /* RSurface::tetrahedralize */


double RSurface::findArea(const std::vector&lt;RNode&gt; &amp;nodes, const std::vector&lt;RElement&gt; &amp;elements) const
{
    double surfaceArea = 0.0;

    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        const RElement &amp;rElement = elements[this-&gt;get(i)];

        double elementArea = 0.0;
        if (rElement.findArea(nodes,elementArea))
        {
            surfaceArea += elementArea;
        }
    }

    return surfaceArea;
} /* RSurface::findArea */


</t>
<t tx="leo.20201108101538.95">void RSurface::findAverageNormal(const std::vector&lt;RNode&gt; &amp;nodes, const std::vector&lt;RElement&gt; &amp;elements, RR3Vector &amp;normal) const
{
    normal[0] = normal[1] = normal[2] = 0.0;
    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        const RElement &amp;rElement = elements[this-&gt;get(i)];

        RR3Vector elementNormal;
        if (rElement.findNormal(nodes,elementNormal[0],elementNormal[1],elementNormal[2]))
        {
            normal[0] += elementNormal[0];
            normal[1] += elementNormal[1];
            normal[2] += elementNormal[2];
        }
    }
    normal.normalize();
} /* RSurface::findAverageNormal */


RSurface &amp; RSurface::operator = (const RSurface &amp;surface)
{
    this-&gt;RElementGroup::operator = (surface);
    this-&gt;_init (&amp;surface);
    return (*this);
} /* RSurface::operator = */
</t>
<t tx="leo.20201108101539.1">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_tetgen.cpp                                           *
 *  GROUP:  RModel                                                   *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th August 2012                                         *
 *                                                                   *
 *  DESCRIPTION: RTetGen class definition                            *
 *********************************************************************/

#include &lt;sstream&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

#include &lt;rmlib.h&gt;
#include &lt;rblib.h&gt;

#include "rml_tetgen.h"

RTetGen::RTetGen(const RModel &amp;model)
{
    this-&gt;importModel(model,false);
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101539.10">void RTimeSolver::sort(void)
{
    std::sort(this-&gt;times.begin(),this-&gt;times.end());
} /* RTimeSolver::sort */

RTimeSolver::RTimeSolver()
    : enabled(false)
    , timeMarchApproximation(R_TIME_MARCH_CENTRAL)
    , inputNTimeSteps(R_TIME_STEP_DEFAULT_NUMBER)
    , inputStartTime(0.0)
    , inputTimeStepSize(R_TIME_STEP_DEFAULT_SIZE)
    , currentTimeStep(0)
    , computedTime(0.0)
    , outputFrequency(R_TIME_DEFAULT_OUTPUT_FREQUENCY)
{
    this-&gt;times.resize(R_TIME_STEP_DEFAULT_NUMBER,R_TIME_STEP_DEFAULT_START + R_TIME_STEP_DEFAULT_SIZE);
    this-&gt;_init();
} /* RTimeSolver::RTimeSolver */

RTimeSolver::RTimeSolver(const RTimeSolver &amp;timeSolver)
{
    this-&gt;_init(&amp;timeSolver);
} /* RTimeSolver::RTimeSolver (copy) */

RTimeSolver::~RTimeSolver()
{
} /* RTimeSolver::~RTimeSolver */

RTimeSolver &amp;RTimeSolver::operator =(const RTimeSolver &amp;timeSolver)
{
    this-&gt;_init(&amp;timeSolver);
    return (*this);
} /* RTimeSolver::operator = */

</t>
<t tx="leo.20201108101539.100">void RVectorField::setType3D(bool type3d)
{
    this-&gt;type3d = type3d;
}

</t>
<t tx="leo.20201108101539.101">const std::vector&lt;uint&gt; &amp;RVectorField::getElementGroupIDs(void) const
{
    return this-&gt;elementGroupIDs;
}

std::vector&lt;uint&gt; &amp;RVectorField::getElementGroupIDs(void)
{
    return this-&gt;elementGroupIDs;
}

</t>
<t tx="leo.20201108101539.102">bool RVectorField::addElementGroupID(uint elementGroupID)
{
    if (std::find(this-&gt;elementGroupIDs.begin(),this-&gt;elementGroupIDs.end(),elementGroupID) != this-&gt;elementGroupIDs.end())
    {
        return false;
    }

    this-&gt;elementGroupIDs.push_back(elementGroupID);

    std::sort(this-&gt;elementGroupIDs.begin(),this-&gt;elementGroupIDs.end());

    return true;
}

</t>
<t tx="leo.20201108101539.103">bool RVectorField::removeElementGroupID(uint elementGroupID, bool decrement)
{
    bool removed = false;
    std::vector&lt;uint&gt;::iterator iter = std::find(this-&gt;elementGroupIDs.begin(),this-&gt;elementGroupIDs.end(),elementGroupID);
    if (iter != this-&gt;elementGroupIDs.end())
    {
        this-&gt;elementGroupIDs.erase(iter);
        removed = true;
    }
    if (decrement)
    {
        for (uint i=0;i&lt;this-&gt;elementGroupIDs.size();i++)
        {
            if (this-&gt;elementGroupIDs[i] &gt; elementGroupID)
            {
                this-&gt;elementGroupIDs[i]--;
            }
        }
    }
    return removed;
}

</t>
<t tx="leo.20201108101539.104">void RVectorField::clearElementGroupIDs(void)
{
    this-&gt;elementGroupIDs.clear();
}
</t>
<t tx="leo.20201108101539.105">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_view_factor_matrix.cpp                               *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th July 2014                                          *
 *                                                                   *
 *  DESCRIPTION: View-Factor matrix class definition                 *
 *********************************************************************/

#include "rml_view_factor_matrix.h"
#include "rml_file_manager.h"
#include "rml_file_io.h"


static const RVersion _version = RVersion(FILE_MAJOR_VERSION,FILE_MINOR_VERSION,FILE_RELEASE_VERSION);

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101539.106">void RViewFactorMatrix::_init(const RViewFactorMatrix *pViewFactorMatrix)
{
    if (pViewFactorMatrix)
    {
        this-&gt;header = pViewFactorMatrix-&gt;header;
        this-&gt;patchBook = pViewFactorMatrix-&gt;patchBook;
        this-&gt;rows = pViewFactorMatrix-&gt;rows;
    }
}

RViewFactorMatrix::RViewFactorMatrix()
{
    this-&gt;_init();
}

RViewFactorMatrix::RViewFactorMatrix(const RViewFactorMatrix &amp;viewFactorMatrix)
{
    this-&gt;_init(&amp;viewFactorMatrix);
}

RViewFactorMatrix::~RViewFactorMatrix()
{

}

RViewFactorMatrix &amp;RViewFactorMatrix::operator =(const RViewFactorMatrix &amp;viewFactorMatrix)
{
    this-&gt;_init(&amp;viewFactorMatrix);
    return (*this);
}

</t>
<t tx="leo.20201108101539.107">const RViewFactorMatrixHeader &amp;RViewFactorMatrix::getHeader(void) const
{
    return this-&gt;header;
}

RViewFactorMatrixHeader &amp;RViewFactorMatrix::getHeader(void)
{
    return this-&gt;header;
}

</t>
<t tx="leo.20201108101539.108">void RViewFactorMatrix::setHeader(const RViewFactorMatrixHeader &amp;header)
{
    this-&gt;header = header;
}

</t>
<t tx="leo.20201108101539.109">const RPatchBook &amp;RViewFactorMatrix::getPatchBook(void) const
{
    return this-&gt;patchBook;
}

RPatchBook &amp;RViewFactorMatrix::getPatchBook(void)
{
    return this-&gt;patchBook;
}

uint RViewFactorMatrix::size(void) const
{
    return uint(this-&gt;rows.size());
}

</t>
<t tx="leo.20201108101539.11">bool RTimeSolver::getEnabled(void) const
{
    return this-&gt;enabled;
} /* RTimeSolver::getEnabled */

</t>
<t tx="leo.20201108101539.110">void RViewFactorMatrix::resize(uint nRows)
{
    this-&gt;rows.resize(nRows);
}

</t>
<t tx="leo.20201108101539.111">const RViewFactorRow &amp;RViewFactorMatrix::getRow(uint rowID) const
{
    return this-&gt;rows[rowID];
}

RViewFactorRow &amp;RViewFactorMatrix::getRow(uint rowID)
{
    return this-&gt;rows[rowID];
}

</t>
<t tx="leo.20201108101539.112">void RViewFactorMatrix::clear(void)
{
    this-&gt;header.clear();
    this-&gt;patchBook.clear();
    this-&gt;rows.clear();
}

</t>
<t tx="leo.20201108101539.113">void RViewFactorMatrix::read(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QString targetFileName(fileName);

    while (!targetFileName.isEmpty())
    {
        QString ext = RFileManager::getExtension(targetFileName);

        try
        {
            if (ext == RViewFactorMatrix::getDefaultFileExtension(false))
            {
                targetFileName = this-&gt;readAscii(targetFileName);
            }
            else if (ext == RViewFactorMatrix::getDefaultFileExtension(true))
            {
                targetFileName = this-&gt;readBinary(targetFileName);
            }
            else
            {
                throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
            }
        }
        catch (RError &amp;error)
        {
            throw error;
        }
        catch (std::bad_alloc&amp;)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Memory allocation failed.");
        }
        catch (const std::exception&amp; x)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "%s.", typeid(x).name());
        }
        catch (...)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Unknown exception.");
        }
    }
}

</t>
<t tx="leo.20201108101539.114">void RViewFactorMatrix::write(const QString &amp;fileName, const QString &amp;linkFileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QString ext = RFileManager::getExtension(fileName);

    try
    {
        if (!linkFileName.isEmpty())
        {
            RViewFactorMatrix::writeLink(linkFileName,fileName);
        }

        if (ext == RViewFactorMatrix::getDefaultFileExtension(false))
        {
            this-&gt;writeAscii(fileName);
        }
        else if (ext == RViewFactorMatrix::getDefaultFileExtension(true))
        {
            this-&gt;writeBinary(fileName);
        }
        else
        {
            throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
        }
    }
    catch (RError &amp;error)
    {
        throw error;
    }
    catch (std::bad_alloc&amp;)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Memory allocation failed.");
    }
    catch (const std::exception&amp; x)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "%s.", typeid(x).name());
    }
    catch (...)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Unknown exception.");
    }
}

</t>
<t tx="leo.20201108101539.115">void RViewFactorMatrix::readHeader(const QString &amp;fileName, RViewFactorMatrixHeader &amp;header)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    QString targetFileName(fileName);


    while (!targetFileName.isEmpty())
    {
        QString ext = RFileManager::getExtension(targetFileName);

        try
        {
            if (ext == RViewFactorMatrix::getDefaultFileExtension(false))
            {
                targetFileName = RViewFactorMatrix::readAsciiHeader(targetFileName,header);
            }
            else if (ext == RViewFactorMatrix::getDefaultFileExtension(true))
            {
                targetFileName = RViewFactorMatrix::readBinaryHeader(targetFileName,header);
            }
            else
            {
                throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
            }
        }
        catch (RError &amp;error)
        {
            throw error;
        }
        catch (std::bad_alloc&amp;)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Memory allocation failed.");
        }
        catch (const std::exception&amp; x)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "%s.", typeid(x).name());
        }
        catch (...)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF, "Unknown exception.");
        }
    }
}

QString RViewFactorMatrix::getDefaultFileExtension(bool binary)
{
    return binary ? "rbv" : "rtv";
}

</t>
<t tx="leo.20201108101539.116">void RViewFactorMatrix::writeLink(const QString &amp;linkFileName, const QString &amp;targetFileName)
{
    if (linkFileName.isEmpty() || targetFileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    bool binary = true;
    QString ext = RFileManager::getExtension(linkFileName);

    if (ext == RViewFactorMatrix::getDefaultFileExtension(false))
    {
        binary = false;
    }
    else if (ext == RViewFactorMatrix::getDefaultFileExtension(true))
    {
        binary = true;
    }
    else
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF, "Unknown extension \"" + ext + "\".");
    }

    RFileManager::writeLink(linkFileName,targetFileName,_version,binary);
}

QString RViewFactorMatrix::readAscii(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Reading ascii file \'%s\'\n",fileName.toUtf8().constData());

    RFile file(fileName,RFile::ASCII);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileHeader fileHeader;

    RFileIO::readAscii(file,fileHeader);
    if (fileHeader.getType() == R_FILE_TYPE_LINK)
    {
        QString targetFileName(RFileManager::findLinkTargetFileName(fileName,fileHeader.getInformation()));
        RLogger::info("File \'%s\' is a link file pointing to \'%s\'\n",fileName.toUtf8().constData(),targetFileName.toUtf8().constData());
        return targetFileName;
    }
    if (fileHeader.getType() != R_FILE_TYPE_VIEW_FACTOR_MATRIX)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF,"File type of the file \'" + fileName + "\' is not VIEW FACTOR MATRIX.");
    }

    // Set file version
    file.setVersion(fileHeader.getVersion());

    RFileIO::readAscii(file,this-&gt;header);
    RFileIO::readAscii(file,this-&gt;patchBook);

    uint nRows = 0;
    RFileIO::readAscii(file,nRows);
    this-&gt;rows.resize(nRows);
    for (uint i=0;i&lt;this-&gt;rows.size();i++)
    {
        RFileIO::readAscii(file,this-&gt;rows[i]);
    }

    file.close();

    return QString();
}

QString RViewFactorMatrix::readBinary(const QString &amp;fileName)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Reading binary file \'%s\'\n",fileName.toUtf8().constData());

    RFile file(fileName,RFile::BINARY);

    if (!file.open(QIODevice::ReadOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileHeader fileHeader;

    RFileIO::readBinary(file,fileHeader);
    if (fileHeader.getType() == R_FILE_TYPE_LINK)
    {
        QString targetFileName(RFileManager::findLinkTargetFileName(fileName,fileHeader.getInformation()));
        RLogger::info("File \'%s\' is a link file pointing to \'%s\'\n",fileName.toUtf8().constData(),targetFileName.toUtf8().constData());
        return targetFileName;
    }
    if (fileHeader.getType() != R_FILE_TYPE_VIEW_FACTOR_MATRIX)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF,"File type of the file \'" + fileName + "\' is not VIEW FACTOR MATRIX.");
    }

    // Set file version
    file.setVersion(fileHeader.getVersion());

    RFileIO::readBinary(file,this-&gt;header);
    RFileIO::readBinary(file,this-&gt;patchBook);

    uint nRows = 0;
    RFileIO::readBinary(file,nRows);
    this-&gt;rows.resize(nRows);
    for (uint i=0;i&lt;this-&gt;rows.size();i++)
    {
        RFileIO::readBinary(file,this-&gt;rows[i]);
    }

    file.close();

    return QString();
}

</t>
<t tx="leo.20201108101539.117">void RViewFactorMatrix::writeAscii(const QString &amp;fileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Writing ascii file \'%s\'\n",fileName.toUtf8().constData());

    RSaveFile file(fileName,RSaveFile::ASCII);

    if (!file.open(QIODevice::WriteOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileIO::writeAscii(file,RFileHeader(R_FILE_TYPE_VIEW_FACTOR_MATRIX,_version));
    RFileIO::writeAscii(file,this-&gt;header);
    RFileIO::writeAscii(file,this-&gt;patchBook);
    RFileIO::writeAscii(file,uint(this-&gt;rows.size()));
    for (uint i=0;i&lt;this-&gt;rows.size();i++)
    {
        RFileIO::writeAscii(file,this-&gt;rows[i],false);
        RFileIO::writeNewLineAscii(file);
    }

    file.commit();
}

</t>
<t tx="leo.20201108101539.118">void RViewFactorMatrix::writeBinary(const QString &amp;fileName) const
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Writing binary file \'%s\'\n",fileName.toUtf8().constData());

    RSaveFile file(fileName,RSaveFile::BINARY);

    if (!file.open(QIODevice::WriteOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileIO::writeBinary(file,RFileHeader(R_FILE_TYPE_VIEW_FACTOR_MATRIX,_version));
    RFileIO::writeBinary(file,this-&gt;header);
    RFileIO::writeBinary(file,this-&gt;patchBook);
    RFileIO::writeBinary(file,uint(this-&gt;rows.size()));
    for (uint i=0;i&lt;this-&gt;rows.size();i++)
    {
        RFileIO::writeBinary(file,this-&gt;rows[i]);
    }

    file.commit();
}

QString RViewFactorMatrix::readAsciiHeader(const QString &amp;fileName, RViewFactorMatrixHeader &amp;header)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Reading ascii file \'%s\'\n",fileName.toUtf8().constData());

    RFile file(fileName,RFile::ASCII);

    if (!file.open(QIODevice::ReadOnly | QIODevice::Text))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileHeader fileHeader;

    RFileIO::readAscii(file,fileHeader);
    if (fileHeader.getType() == R_FILE_TYPE_LINK)
    {
        QString targetFileName(RFileManager::findLinkTargetFileName(fileName,fileHeader.getInformation()));
        RLogger::info("File \'%s\' is a link file pointing to \'%s\'\n",fileName.toUtf8().constData(),targetFileName.toUtf8().constData());
        return targetFileName;
    }
    if (fileHeader.getType() != R_FILE_TYPE_VIEW_FACTOR_MATRIX)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF,"File type of the file \'" + fileName + "\' is not VIEW FACTOR MATRIX.");
    }

    // Set file version
    file.setVersion(fileHeader.getVersion());

    RFileIO::readAscii(file,header);

    file.close();

    return QString();
}

QString RViewFactorMatrix::readBinaryHeader(const QString &amp;fileName, RViewFactorMatrixHeader &amp;header)
{
    if (fileName.isEmpty())
    {
        throw RError(R_ERROR_INVALID_FILE_NAME,R_ERROR_REF,"No file name was provided.");
    }

    RLogger::info("Reading binary file \'%s\'\n",fileName.toUtf8().constData());

    RFile file(fileName,RFile::BINARY);

    if (!file.open(QIODevice::ReadOnly))
    {
        throw RError(R_ERROR_OPEN_FILE,R_ERROR_REF,"Failed to open the file \'%s\'.",fileName.toUtf8().constData());
    }

    RFileHeader fileHeader;

    RFileIO::readBinary(file,fileHeader);
    if (fileHeader.getType() == R_FILE_TYPE_LINK)
    {
        QString targetFileName(RFileManager::findLinkTargetFileName(fileName,fileHeader.getInformation()));
        RLogger::info("File \'%s\' is a link file pointing to \'%s\'\n",fileName.toUtf8().constData(),targetFileName.toUtf8().constData());
        return targetFileName;
    }
    if (fileHeader.getType() != R_FILE_TYPE_VIEW_FACTOR_MATRIX)
    {
        throw RError(R_ERROR_INVALID_FILE_FORMAT,R_ERROR_REF,"File type of the file \'" + fileName + "\' is not VIEW FACTOR MATRIX.");
    }

    // Set file version
    file.setVersion(fileHeader.getVersion());

    RFileIO::readBinary(file,header);

    file.close();

    return QString();
}
</t>
<t tx="leo.20201108101539.119">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_view_factor_matrix_header.cpp                        *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th August 2014                                         *
 *                                                                   *
 *  DESCRIPTION: View-Factor matrix header class definition          *
 *********************************************************************/

#include "rml_view_factor_matrix_header.h"
#include "rml_radiation_setup.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101539.12">void RTimeSolver::setEnabled(bool enabled)
{
    this-&gt;enabled = enabled;
} /* RTimeSolver::setEnabled */

RTimeMarchApproximation RTimeSolver::getTimeMarchApproximation(void) const
{
    return this-&gt;timeMarchApproximation;
} /* RTimeSolver::getTimeMarchApproximation */

double RTimeSolver::getTimeMarchApproximationCoefficient(void) const
{
    switch (this-&gt;timeMarchApproximation)
    {
        case R_TIME_MARCH_CENTRAL:
            return 0.5;
        case R_TIME_MARCH_BACKWARD:
            return 0.0;
        case R_TIME_MARCH_FORWARD:
            return 1.0;
        default:
            return 0.0;
    }
} /* RTimeSolver::getTimeMarchApproximationCoefficient */

</t>
<t tx="leo.20201108101539.120">void RViewFactorMatrixHeader::_init(const RViewFactorMatrixHeader *pViewFactorMatrixHeader)
{
    if (pViewFactorMatrixHeader)
    {
        this-&gt;patchInput = pViewFactorMatrixHeader-&gt;patchInput;
        this-&gt;hemicubeResolution = pViewFactorMatrixHeader-&gt;hemicubeResolution;
        this-&gt;nElements = pViewFactorMatrixHeader-&gt;nElements;
    }
}

RViewFactorMatrixHeader::RViewFactorMatrixHeader()
    : hemicubeResolution(R_RADIATION_RESOLUTION_MEDIUM)
    , nElements(0)
{
    this-&gt;_init();
}

RViewFactorMatrixHeader::RViewFactorMatrixHeader(const RViewFactorMatrixHeader &amp;viewFactorMatrixHeader)
{
    this-&gt;_init(&amp;viewFactorMatrixHeader);
}

RViewFactorMatrixHeader::~RViewFactorMatrixHeader()
{

}

RViewFactorMatrixHeader &amp;RViewFactorMatrixHeader::operator =(const RViewFactorMatrixHeader &amp;viewFactorMatrixHeader)
{
    this-&gt;_init(&amp;viewFactorMatrixHeader);
    return (*this);
}

</t>
<t tx="leo.20201108101539.121">bool RViewFactorMatrixHeader::operator ==(const RViewFactorMatrixHeader &amp;viewFactorMatrixHeader)
{
    if (this-&gt;patchInput.size() != viewFactorMatrixHeader.patchInput.size())
    {
        return false;
    }
    for (unsigned int i=0;i&lt;this-&gt;patchInput.size();i++)
    {
        if (this-&gt;patchInput[i] != viewFactorMatrixHeader.patchInput[i])
        {
            return false;
        }
    }
    if (this-&gt;hemicubeResolution != viewFactorMatrixHeader.hemicubeResolution)
    {
        return false;
    }
    if (this-&gt;nElements != viewFactorMatrixHeader.nElements)
    {
        return false;
    }
    return true;
}

</t>
<t tx="leo.20201108101539.122">bool RViewFactorMatrixHeader::operator !=(const RViewFactorMatrixHeader &amp;viewFactorMatrixHeader)
{
    return !this-&gt;operator ==(viewFactorMatrixHeader);
}

</t>
<t tx="leo.20201108101539.123">const std::vector&lt;RPatchInput&gt; &amp;RViewFactorMatrixHeader::getPatchInput(void) const
{
    return this-&gt;patchInput;
}

std::vector&lt;RPatchInput&gt; &amp;RViewFactorMatrixHeader::getPatchInput(void)
{
    return this-&gt;patchInput;
}

</t>
<t tx="leo.20201108101539.124">unsigned int RViewFactorMatrixHeader::getHemicubeResolution(void) const
{
    return this-&gt;hemicubeResolution;
}

</t>
<t tx="leo.20201108101539.125">void RViewFactorMatrixHeader::setHemicubeResolution(unsigned int hemicubeResolution)
{
    this-&gt;hemicubeResolution = hemicubeResolution;
}

</t>
<t tx="leo.20201108101539.126">unsigned int RViewFactorMatrixHeader::getNElements(void) const
{
    return this-&gt;nElements;
}

</t>
<t tx="leo.20201108101539.127">void RViewFactorMatrixHeader::setNElements(unsigned int nElements)
{
    this-&gt;nElements = nElements;
}

</t>
<t tx="leo.20201108101539.128">void RViewFactorMatrixHeader::clear(void)
{
    this-&gt;hemicubeResolution = 0;
    this-&gt;patchInput.clear();
}
</t>
<t tx="leo.20201108101539.13">void RTimeSolver::setTimeMarchApproximation(RTimeMarchApproximation timeMarchApproximation)
{
    R_ERROR_ASSERT(R_TIME_MARCH_APPROXIMATION_TYPE_IS_VALID(timeMarchApproximation));
    this-&gt;timeMarchApproximation = timeMarchApproximation;
} /* RTimeSolver::setTimeMarchApproximation */

</t>
<t tx="leo.20201108101539.14">const std::vector&lt;double&gt; &amp;RTimeSolver::getTimes(void) const
{
    return this-&gt;times;
} /* RTimeSolver::getTimes */

std::vector&lt;double&gt; &amp;RTimeSolver::getTimes(void)
{
    return this-&gt;times;
} /* RTimeSolver::getTimes */

</t>
<t tx="leo.20201108101539.15">void RTimeSolver::setTimes(const std::vector&lt;double&gt; &amp;times)
{
    this-&gt;times = times;
//    this-&gt;setCurrentTimeStep(0);
    this-&gt;sort();
} /* RTimeSolver::setTimes */

</t>
<t tx="leo.20201108101539.16">void RTimeSolver::addTimes(unsigned int startTimeStep, unsigned int nTimeSteps, double timeStepSize)
{
    if (startTimeStep &lt; this-&gt;getNTimeSteps())
    {
        this-&gt;times.erase(this-&gt;times.begin()+startTimeStep,this-&gt;times.end());
    }
    std::vector&lt;double&gt; newTimes = RTimeSolver::findTimesVector(nTimeSteps,this-&gt;times.back(),timeStepSize);
    this-&gt;times.insert(this-&gt;times.end(),newTimes.begin(),newTimes.end());
} /* RTimeSolver::addTimes */

</t>
<t tx="leo.20201108101539.17">unsigned int RTimeSolver::getInputNTimeSteps(void) const
{
    return this-&gt;inputNTimeSteps;
} /* RTimeSolver::getInputNTimeSteps */

</t>
<t tx="leo.20201108101539.18">void RTimeSolver::setInputNTimeSteps(unsigned int inputNTimeSteps)
{
    this-&gt;inputNTimeSteps = inputNTimeSteps;
} /* RTimeSolver::setInputNTimeSteps */

double RTimeSolver::getInputStartTime(void) const
{
    return this-&gt;inputStartTime;
} /* RTimeSolver::getInputStartTime */

</t>
<t tx="leo.20201108101539.19">void RTimeSolver::setInputStartTime(double inputStartTime)
{
    this-&gt;inputStartTime = inputStartTime;
} /* RTimeSolver::setInputStartTime */

double RTimeSolver::getInputTimeStepSize(void) const
{
    return this-&gt;inputTimeStepSize;
} /* RTimeSolver::getInputTimeStepSize */

</t>
<t tx="leo.20201108101539.2">void RTetGen::importModel(const RModel &amp;model, bool reconstruct, const RRVector &amp;nodeMeshSizeValues)
{
    this-&gt;firstnumber = 0;

    // Set nodes

    this-&gt;numberofpoints = int(model.getNNodes());
    this-&gt;numberofpointattributes = 0;
    this-&gt;numberofpointmtrs = nodeMeshSizeValues.size() == model.getNNodes() ? 1 : 0;

    if (this-&gt;numberofpoints)
    {
        this-&gt;pointlist = new REAL [uint(this-&gt;numberofpoints)*3];
//        if (this-&gt;numberofpointattributes)
//        {
//            this-&gt;pointattributelist = new REAL [this-&gt;numberofpoints*this-&gt;numberofpointattributes];
//        }
        if (this-&gt;numberofpointmtrs)
        {
            this-&gt;pointmtrlist = new REAL [uint(this-&gt;numberofpoints)*uint(this-&gt;numberofpointmtrs)];
        }
        this-&gt;pointmarkerlist = new int [uint(this-&gt;numberofpoints)];

        for (uint i=0;i&lt;uint(this-&gt;numberofpoints);i++)
        {
            this-&gt;pointlist[3*i+0] = REAL(model.getNode(i).getX());
            this-&gt;pointlist[3*i+1] = REAL(model.getNode(i).getY());
            this-&gt;pointlist[3*i+2] = REAL(model.getNode(i).getZ());
//            if (this-&gt;numberofpointattributes)
//            {
//                this-&gt;pointattributelist[this-&gt;numberofpointattributes*i+0] = REAL(i);
//                for (int j=1;j&lt;this-&gt;numberofpointattributes;j++)
//                {
//                    this-&gt;pointattributelist[this-&gt;numberofpointattributes*i+j] = 0.0;
//                }
//            }
            if (this-&gt;numberofpointmtrs)
            {
                this-&gt;pointmtrlist[uint(this-&gt;numberofpointmtrs)*i+0] = nodeMeshSizeValues[i];
                for (uint j=1;j&lt;uint(this-&gt;numberofpointmtrs);j++)
                {
                    this-&gt;pointmtrlist[uint(this-&gt;numberofpointmtrs)*i+j] = 0.0;
                }
            }
            this-&gt;pointmarkerlist[i] = 0;
        }
    }

    for (uint i=0;i&lt;model.getNPoints();i++)
    {
        int marker = int(i)+1;
        const RPoint &amp;rPoint = model.getPoint(i);
        for (uint j=0;j&lt;rPoint.size();j++)
        {
            this-&gt;pointmarkerlist[model.getElement(rPoint.get(j)).getNodeId(0)] = -marker;
        }
    }

    this-&gt;numberofedges = int(model.getNEntityElements(R_ENTITY_GROUP_LINE));
    if (this-&gt;numberofedges &gt; 0)
    {
        this-&gt;edgelist = new int [uint(this-&gt;numberofedges)*2];
        this-&gt;edgemarkerlist = new int [uint(this-&gt;numberofedges)];
        uint edgeNumber = 0;
        for (uint i=0;i&lt;model.getNLines();i++)
        {
            int marker = int(i)+1;
            const RLine &amp;rLine = model.getLine(i);
            for (uint j=0;j&lt;rLine.size();j++)
            {
                uint elementID = rLine.get(j);
                const RElement &amp;rElement = model.getElement(elementID);
                this-&gt;edgelist[2*edgeNumber+0] = int(rElement.getNodeId(0)) + this-&gt;firstnumber;
                this-&gt;edgelist[2*edgeNumber+1] = int(rElement.getNodeId(1)) + this-&gt;firstnumber;
                this-&gt;edgemarkerlist[edgeNumber] = -marker;
                edgeNumber++;
            }
        }
    }

    if (reconstruct)
    {
        // Set trifacets

        this-&gt;numberoftrifaces = int(model.getNElements(R_ELEMENT_TRI1) + model.getNElements(R_ELEMENT_TRI2));

        if (this-&gt;numberoftrifaces)
        {
            this-&gt;trifacelist = new int[uint(this-&gt;numberoftrifaces)*3];
            this-&gt;trifacemarkerlist = new int[uint(this-&gt;numberoftrifaces)];

            RUVector surfaceBook(model.getNElements());
            std::fill(surfaceBook.begin(),surfaceBook.end(),RConstants::eod);

            uint ce = 0;
            for (uint i=0;i&lt;model.getNElements();i++)
            {
                if (model.getElement(i).getType() != R_ELEMENT_TRI1 &amp;&amp;
                    model.getElement(i).getType() != R_ELEMENT_TRI2)
                {
                    continue;
                }
                this-&gt;trifacelist[3*ce+0] = int(model.getElement(i).getNodeId(0)) + this-&gt;firstnumber;
                this-&gt;trifacelist[3*ce+1] = int(model.getElement(i).getNodeId(1)) + this-&gt;firstnumber;
                this-&gt;trifacelist[3*ce+2] = int(model.getElement(i).getNodeId(2)) + this-&gt;firstnumber;

                this-&gt;trifacemarkerlist[ce] = -1;

                surfaceBook[i] = ce;

                ce++;
            }

            for (uint i=0;i&lt;model.getNSurfaces();i++)
            {
                int marker = int(i+1);
                for (uint j=0;j&lt;model.getSurface(i).size();j++)
                {
                    uint elementPosition = surfaceBook[model.getSurface(i).get(j)];
                    if (elementPosition != RConstants::eod)
                    {
                        this-&gt;trifacemarkerlist[elementPosition] = -marker;
                    }
                }
            }
        }

        // Set tetrahedras

        this-&gt;numberoftetrahedra = int(model.getNElements(R_ELEMENT_TETRA1));

        if (this-&gt;numberoftetrahedra)
        {
            this-&gt;numberofcorners = 4;
            this-&gt;numberoftetrahedronattributes = 1;
            this-&gt;tetrahedronlist = new int[uint(this-&gt;numberoftetrahedra)*4];
            this-&gt;tetrahedronattributelist = new REAL[uint(this-&gt;numberoftetrahedra)*uint(this-&gt;numberoftetrahedronattributes)];
            this-&gt;tetrahedronvolumelist = new REAL[uint(this-&gt;numberoftetrahedra)];

            RUVector volumeBook(model.getNElements());
            std::fill(volumeBook.begin(),volumeBook.end(),RConstants::eod);

            uint ce = 0;
            for (uint i=0;i&lt;model.getNElements();i++)
            {
                if (model.getElement(i).getType() != R_ELEMENT_TETRA1)
                {
                    continue;
                }
                this-&gt;tetrahedronlist[4*ce+0] = int(model.getElement(i).getNodeId(0)) + this-&gt;firstnumber;
                this-&gt;tetrahedronlist[4*ce+1] = int(model.getElement(i).getNodeId(1)) + this-&gt;firstnumber;
                this-&gt;tetrahedronlist[4*ce+2] = int(model.getElement(i).getNodeId(2)) + this-&gt;firstnumber;
                this-&gt;tetrahedronlist[4*ce+3] = int(model.getElement(i).getNodeId(3)) + this-&gt;firstnumber;

                this-&gt;tetrahedronattributelist[uint(this-&gt;numberoftetrahedronattributes)*ce+0] = 0.0;

                this-&gt;tetrahedronvolumelist[ce] = -1.0;

                volumeBook[i] = ce;

                ce++;
            }

            // Set volume marker for each tetrahedra
            for (uint i=0;i&lt;model.getNVolumes();i++)
            {
                int marker = int(i+1);
                for (uint j=0;j&lt;model.getVolume(i).size();j++)
                {
                    uint elementPosition = volumeBook[model.getVolume(i).get(j)];
                    if (elementPosition != RConstants::eod)
                    {
                        this-&gt;tetrahedronattributelist[uint(this-&gt;numberoftetrahedronattributes)*elementPosition+0] = -marker;
                    }
                }
            }
        }
    }
    else
    {
        // Set facets
        this-&gt;numberoffacets = int(  model.getNElements(R_ELEMENT_TRI1)
                                   + model.getNElements(R_ELEMENT_TRI2)
                                   + model.getNElements(R_ELEMENT_QUAD1)
                                   + model.getNElements(R_ELEMENT_QUAD2));

        if (this-&gt;numberoffacets &gt; 0)
        {
            this-&gt;facetlist = new tetgenio::facet[uint(this-&gt;numberoffacets)];
            this-&gt;facetmarkerlist = new int[uint(this-&gt;numberoffacets)];

            RUVector faceBook(model.getNElements());
            std::fill(faceBook.begin(),faceBook.end(),RConstants::eod);

            uint ce = 0;
            for (uint i=0;i&lt;model.getNElements();i++)
            {
                uint nne = 0;
                if (model.getElement(i).getType() == R_ELEMENT_TRI1 ||
                    model.getElement(i).getType() == R_ELEMENT_TRI2)
                {
                    nne = 3;
                }
                else if (model.getElement(i).getType() == R_ELEMENT_QUAD1 ||
                         model.getElement(i).getType() == R_ELEMENT_QUAD2)
                {
                    nne = 4;
                }
                else
                {
                    continue;
                }
                this-&gt;facetlist[ce].numberofholes = 0;
                this-&gt;facetlist[ce].holelist = nullptr;
                this-&gt;facetlist[ce].numberofpolygons = 1;
                this-&gt;facetlist[ce].polygonlist = new tetgenio::polygon[1];
                this-&gt;facetlist[ce].polygonlist[0].numberofvertices = int(nne);
                this-&gt;facetlist[ce].polygonlist[0].vertexlist = new int[nne];
                for (uint j=0;j&lt;nne;j++)
                {
                    this-&gt;facetlist[ce].polygonlist[0].vertexlist[j] = int(model.getElement(i).getNodeId(j)) + this-&gt;firstnumber;
                }

                this-&gt;facetmarkerlist[ce] = 0;

                faceBook[i] = ce;

                ce++;
            }

            for (uint i=0;i&lt;model.getNSurfaces();i++)
            {
                int marker = int(i+1);
                for (uint j=0;j&lt;model.getSurface(i).size();j++)
                {
                    uint elementPosition = faceBook[model.getSurface(i).get(j)];
                    if (elementPosition != RConstants::eod)
                    {
                        this-&gt;facetmarkerlist[elementPosition] = -marker;
                    }
                }
            }
        }
    }
}

</t>
<t tx="leo.20201108101539.20">void RTimeSolver::setInputTimeStepSize(double inputTimeStepSize)
{
    this-&gt;inputTimeStepSize = inputTimeStepSize;
} /* RTimeSolver::setInputTimeStepSize */

</t>
<t tx="leo.20201108101539.21">unsigned int RTimeSolver::getCurrentTimeStep(void) const
{
    return this-&gt;currentTimeStep;
} /* RTimeSolver::getCurrentTimeStep */

</t>
<t tx="leo.20201108101539.22">void RTimeSolver::setCurrentTimeStep(unsigned int timeStep)
{
    R_ERROR_ASSERT(timeStep &lt; this-&gt;getNTimeSteps());
    this-&gt;currentTimeStep = timeStep;
} /* RTimeSolver::setCurrentTimeStep */

</t>
<t tx="leo.20201108101539.23">unsigned int RTimeSolver::getOutputFrequency(void) const
{
    return this-&gt;outputFrequency;
} /* RTimeSolver::getOutputFrequency */

</t>
<t tx="leo.20201108101539.24">void RTimeSolver::setOutputFrequency(unsigned int outputFrequency)
{
    this-&gt;outputFrequency = outputFrequency;
} /* RTimeSolver::setOutputFrequency */

</t>
<t tx="leo.20201108101539.25">unsigned int RTimeSolver::setNextTimeStep(void)
{
    if (this-&gt;currentTimeStep + 1 &gt;= this-&gt;getNTimeSteps())
    {
        return RConstants::eod;
    }
    return ++this-&gt;currentTimeStep;
} /* RTimeSolver::setNextTimeStep */

double RTimeSolver::getCurrentTimeStepSize(void) const
{
    if (this-&gt;enabled)
    {
        return (this-&gt;getCurrentTime() - this-&gt;getPreviousTime());
    }
    else
    {
        return 0.0;
    }
} /* RTimeSolver::getCurrentTimeStepSize */

double RTimeSolver::getComputedTime(void) const
{
    return this-&gt;computedTime;
} /* RTimeSolver::getComputedTime */

</t>
<t tx="leo.20201108101539.26">void RTimeSolver::setComputedTime(double computedTime)
{
    this-&gt;computedTime = computedTime;
} /* RTimeSolver::setComputedTime */

double RTimeSolver::getCurrentTime(void) const
{
    R_ERROR_ASSERT(this-&gt;getCurrentTimeStep() &lt; this-&gt;getNTimeSteps());
    return this-&gt;times[this-&gt;getCurrentTimeStep()];
} /* RTimeSolver::getCurrentTime */

double RTimeSolver::getPreviousTime(void) const
{
    R_ERROR_ASSERT(this-&gt;getCurrentTimeStep() &lt; this-&gt;getNTimeSteps());
    if (this-&gt;getCurrentTimeStep() &gt; 0)
    {
        return this-&gt;times[this-&gt;getCurrentTimeStep() - 1];
    }
    else
    {
        return this-&gt;times[this-&gt;getCurrentTimeStep()] - this-&gt;getInputTimeStepSize();
    }
} /* RTimeSolver::getPreviousTime */

double RTimeSolver::getTime(unsigned int timeStep) const
{
    R_ERROR_ASSERT(timeStep &lt; this-&gt;getNTimeSteps());
    return this-&gt;times[timeStep];
} /* RTimeSolver::getTime */

double RTimeSolver::getFirstTime(void) const
{
    return this-&gt;getTime(0);
} /* RTimeSolver::getFirstTime */

double RTimeSolver::getLastTime(void) const
{
    return this-&gt;getTime(this-&gt;getNTimeSteps()-1);
} /* RTimeSolver::getLastTime */

</t>
<t tx="leo.20201108101539.27">unsigned int RTimeSolver::getNTimeSteps(void) const
{
    return (unsigned int)this-&gt;times.size();
} /* RTimeSolver::getNTimeSteps */

</t>
<t tx="leo.20201108101539.28">bool RTimeSolver::hasTime(double timeValue) const
{
    return (timeValue &gt;= this-&gt;getFirstTime() &amp;&amp; timeValue &lt;= this-&gt;getLastTime());
} /* RTimeSolver::hasTime */

</t>
<t tx="leo.20201108101539.29">void RTimeSolver::harmonizeTimesWithInput(bool restart)
{
    if (this-&gt;enabled)
    {
        if (restart)
        {
            if (this-&gt;getCurrentTimeStep() &gt;= this-&gt;getNTimeSteps())
            {
                this-&gt;setCurrentTimeStep(this-&gt;getNTimeSteps()-1);
            }
            this-&gt;addTimes(this-&gt;getCurrentTimeStep()+1,
                           this-&gt;getInputNTimeSteps(),
                           this-&gt;getInputTimeStepSize());
        }
        else
        {
            this-&gt;setCurrentTimeStep(0);
            this-&gt;setComputedTime(0.0);
            this-&gt;setTimes(RTimeSolver::findTimesVector(this-&gt;getInputNTimeSteps(),
                                                        this-&gt;getInputStartTime(),
                                                        this-&gt;getInputTimeStepSize()));
        }
    }
    else
    {
        this-&gt;times.resize(R_TIME_STEP_DEFAULT_NUMBER,R_TIME_STEP_DEFAULT_START + R_TIME_STEP_DEFAULT_SIZE);
    }
} /* RTimeSolver::harmonizeTimesWithInput */

</t>
<t tx="leo.20201108101539.3">void RTetGen::exportMesh(RModel &amp;model, bool keepResults) const
{
    // Find number of point elements.
    uint numberOfPointElements = 0;
    if (this-&gt;pointmarkerlist)
    {
        for (int i=0;i&lt;this-&gt;numberofpoints;i++)
        {
            if (this-&gt;pointmarkerlist[i] &gt; 0)
            {
                numberOfPointElements++;
            }
        }
    }

    // Find number of line elements.
    uint numberOfLineElements = 0;
    if (this-&gt;edgemarkerlist)
    {
        for (int i=0;i&lt;this-&gt;numberofedges;i++)
        {
            if (this-&gt;edgemarkerlist[i] &gt; 0)
            {
                numberOfLineElements++;
            }
        }
    }

    // Interpolate element results.
    std::vector&lt;RVariable&gt; variables;

    if (keepResults &amp;&amp; model.getNVariables() &gt; 0)
    {
        RLogger::info("Interpolating results\n");
        RLogger::indent();

        RProgressInitialize("Interpolating results");
        for (uint i=0;i&lt;model.getNVariables();i++)
        {
            RProgressPrint(i,model.getNVariables());
            RVariable variable = model.getVariable(i);
            RLogger::info("Interpolating %s\n",variable.getName().toUtf8().constData());
            RLogger::indent();
            if (model.getVariable(i).getApplyType() == R_VARIABLE_APPLY_NODE)
            {
                variable.resize(variable.getNVectors(),uint(this-&gt;numberofpoints));
#pragma omp parallel for default(shared)
                for (int64_t j=0;j&lt;this-&gt;numberofpoints;j++)
                {
                    RNode node(this-&gt;pointlist[3*j+0],this-&gt;pointlist[3*j+1],this-&gt;pointlist[3*j+2]);
                    RRVector values = model.getInterpolatedResultsValues(variable.getType(),node);
                    for (uint k=0;k&lt;values.size();k++)
                    {
                        variable.setValue(k,uint(j),values[k]);
                    }
                }
                variables.push_back(variable);
            }
            else if (model.getVariable(i).getApplyType() == R_VARIABLE_APPLY_ELEMENT)
            {
                variable.resize(variable.getNVectors(),  numberOfPointElements
                                                       + numberOfLineElements
                                                       + uint(this-&gt;numberoftrifaces)
                                                       + uint(this-&gt;numberoftetrahedra));
#pragma omp parallel for default(shared)
                for (int64_t j=0;j&lt;this-&gt;numberoftetrahedra;j++)
                {
                    int n1 = this-&gt;tetrahedronlist[4*j+0] - this-&gt;firstnumber;
                    int n2 = this-&gt;tetrahedronlist[4*j+1] - this-&gt;firstnumber;
                    int n3 = this-&gt;tetrahedronlist[4*j+2] - this-&gt;firstnumber;
                    int n4 = this-&gt;tetrahedronlist[4*j+3] - this-&gt;firstnumber;

                    RNode node1(this-&gt;pointlist[3*n1+0],this-&gt;pointlist[3*n1+1],this-&gt;pointlist[3*n1+2]);
                    RNode node2(this-&gt;pointlist[3*n2+0],this-&gt;pointlist[3*n2+1],this-&gt;pointlist[3*n2+2]);
                    RNode node3(this-&gt;pointlist[3*n3+0],this-&gt;pointlist[3*n3+1],this-&gt;pointlist[3*n3+2]);
                    RNode node4(this-&gt;pointlist[3*n4+0],this-&gt;pointlist[3*n4+1],this-&gt;pointlist[3*n4+2]);

                    RNode node((node1.getX()+node2.getX()+node3.getX()+node4.getX())/4.0,
                               (node1.getY()+node2.getY()+node3.getY()+node4.getY())/4.0,
                               (node1.getZ()+node2.getZ()+node3.getZ()+node4.getZ())/4.0);

                    RRVector values = model.getInterpolatedResultsValues(variable.getType(),node);

                    uint offset = numberOfPointElements + numberOfLineElements + uint(this-&gt;numberoftrifaces);

                    for (uint k=0;k&lt;values.size();k++)
                    {
                        variable.setValue(k,offset+uint(j),values[k]);
                    }
                }
                variables.push_back(variable);
            }
            RLogger::unindent();
        }
        RProgressFinalize();
        RLogger::unindent();
    }

    // NODES
    model.setNNodes(uint(this-&gt;numberofpoints));

    for (uint i=0;i&lt;uint(this-&gt;numberofpoints);i++)
    {
        model.getNode(i).set(this-&gt;pointlist[3*i+0],
                             this-&gt;pointlist[3*i+1],
                             this-&gt;pointlist[3*i+2]);
    }

    model.setNVariables(uint(variables.size()));

    model.setNElements(numberOfPointElements + numberOfLineElements + uint(this-&gt;numberoftrifaces) + uint(this-&gt;numberoftetrahedra));

    std::vector&lt;RUVector&gt; volumeNeigs;

    model.clearSurfaceNeighbors();
    model.clearVolumeNeighbors();

    volumeNeigs.resize(numberOfPointElements + numberOfLineElements + uint(this-&gt;numberoftrifaces) + uint(this-&gt;numberoftetrahedra));

    uint nElements = 0;

    // POINTS
    for (uint i=0;i&lt;model.getNPoints();i++)
    {
        model.getPoint(i).resize(0);
    }
    if (this-&gt;pointmarkerlist)
    {
        for (uint i=0;i&lt;uint(this-&gt;numberofpoints);i++)
        {
            if (this-&gt;pointmarkerlist[i] &gt; 0)
            {
                RElement element(R_ELEMENT_POINT);

                element.setNodeId(0,i);

                model.setElement(nElements,element,false);

                uint marker = uint(std::abs(this-&gt;pointmarkerlist[i])) - 1;
                if (model.getNPoints() &lt; marker + 1)
                {
                    model.setNPoints(marker+1);
                }
                model.getPoint(marker).add(nElements);
                nElements++;
            }
        }
    }

    //LINES
    for (uint i=0;i&lt;model.getNLines();i++)
    {
        model.getLine(i).resize(0);
    }
    if (this-&gt;edgemarkerlist)
    {
        for (uint i=0;i&lt;uint(this-&gt;numberofedges);i++)
        {
            if (this-&gt;edgemarkerlist[i] &gt; 0)
            {
                RElement element(R_ELEMENT_TRUSS1);

                // Line element normals are swapped
                element.setNodeId(0,uint(this-&gt;edgelist[2*i+0] - this-&gt;firstnumber));
                element.setNodeId(1,uint(this-&gt;edgelist[2*i+1] - this-&gt;firstnumber));

                model.setElement(nElements,element,false);

                uint marker = uint(std::abs(this-&gt;edgemarkerlist[i])) - 1;
                if (model.getNLines() &lt; marker + 1)
                {
                    model.setNLines(marker+1);
                }
                model.getLine(marker).add(nElements);
                nElements++;
            }
        }
    }

    // SURFACES
    for (uint i=0;i&lt;model.getNSurfaces();i++)
    {
        model.getSurface(i).resize(0);
    }
    for (uint i=0;i&lt;uint(this-&gt;numberoftrifaces);i++)
    {
        RElement element(R_ELEMENT_TRI1);

        // Triangle element normals are swapped
        element.setNodeId(0,uint(this-&gt;trifacelist[3*i+0] - this-&gt;firstnumber));
        element.setNodeId(1,uint(this-&gt;trifacelist[3*i+2] - this-&gt;firstnumber));
        element.setNodeId(2,uint(this-&gt;trifacelist[3*i+1] - this-&gt;firstnumber));

        model.setElement(nElements,element,false);
        uint marker = this-&gt;trifacemarkerlist ? uint(std::abs(this-&gt;trifacemarkerlist[i])) - 1 : 0;
        if (model.getNSurfaces() &lt; marker + 1)
        {
            model.setNSurfaces(marker+1);
        }
        model.getSurface(marker).add(nElements);
        nElements++;
    }

    // VOLUMES
    RUVector tetrahedraVolumeMarker(uint(this-&gt;numberoftetrahedra),0);
    if (this-&gt;numberoftetrahedronattributes &gt; 0)
    {
        uint minTetrahedraVolumeMarker = 0;
        uint maxTetrahedraVolumeMarker = 0;
        for (uint i=0;i&lt;uint(this-&gt;numberoftetrahedra);i++)
        {
            tetrahedraVolumeMarker[i] = uint(std::abs(this-&gt;tetrahedronattributelist[uint(this-&gt;numberoftetrahedronattributes)*i + 0]) - 1);
            minTetrahedraVolumeMarker = std::min(minTetrahedraVolumeMarker,tetrahedraVolumeMarker[i]);
            maxTetrahedraVolumeMarker = std::max(maxTetrahedraVolumeMarker,tetrahedraVolumeMarker[i]);
        }
        RUVector tetrahedraVolumeMarkerBook(maxTetrahedraVolumeMarker+1,RConstants::eod);
        for (uint i=0;i&lt;uint(this-&gt;numberoftetrahedra);i++)
        {
            tetrahedraVolumeMarkerBook[tetrahedraVolumeMarker[i]] = 0;
        }
        uint tetrahedraVolumeMarkerBookCnt = 0;
        for (uint i=0;i&lt;tetrahedraVolumeMarkerBook.size();i++)
        {
            if (tetrahedraVolumeMarkerBook[i] == 0)
            {
                tetrahedraVolumeMarkerBook[i] = tetrahedraVolumeMarkerBookCnt++;
            }
        }
        for (uint i=0;i&lt;tetrahedraVolumeMarkerBook.size();i++)
        {
            if (tetrahedraVolumeMarkerBook[i] == RConstants::eod)
            {
                tetrahedraVolumeMarkerBook[i] = tetrahedraVolumeMarkerBookCnt++;
            }
        }
        for (uint i=0;i&lt;uint(this-&gt;numberoftetrahedra);i++)
        {
            tetrahedraVolumeMarker[i] = tetrahedraVolumeMarkerBook[tetrahedraVolumeMarker[i]];
        }

        // Resize number of volumes
        model.setNVolumes(tetrahedraVolumeMarkerBookCnt);
    }
    else
    {
        model.setNVolumes(1);
    }

    // VOLUME NEIGHBORS
    for (uint i=0;i&lt;uint(this-&gt;numberoftetrahedra);i++)
    {
        RElement element(R_ELEMENT_TETRA1);

        element.setNodeId(0,uint(this-&gt;tetrahedronlist[4*i+0] - this-&gt;firstnumber));
        element.setNodeId(1,uint(this-&gt;tetrahedronlist[4*i+1] - this-&gt;firstnumber));
        element.setNodeId(2,uint(this-&gt;tetrahedronlist[4*i+2] - this-&gt;firstnumber));
        element.setNodeId(3,uint(this-&gt;tetrahedronlist[4*i+3] - this-&gt;firstnumber));

        model.setElement(nElements,element,false);
        model.getVolume(tetrahedraVolumeMarker[i]).add(nElements);
        for (uint j=0;j&lt;4;j++)
        {
            if (this-&gt;neighborlist[4*i+j] &gt;= this-&gt;firstnumber)
            {
                volumeNeigs[nElements].push_back(uint(this-&gt;neighborlist[4*i+j]) - uint(this-&gt;firstnumber) + numberOfPointElements + numberOfLineElements + uint(this-&gt;numberoftrifaces));
            }
        }
        nElements++;
    }

    model.setVolumeNeighbors(volumeNeigs);

    for (uint i=model.getNPoints();i&gt;0;i--)
    {
        if (model.getPoint(i-1).size() == 0)
        {
            model.removePoint(i-1);
        }
    }
    for (uint i=model.getNLines();i&gt;0;i--)
    {
        if (model.getLine(i-1).size() == 0)
        {
            model.removeLine(i-1);
        }
    }
    for (uint i=model.getNSurfaces();i&gt;0;i--)
    {
        if (model.getSurface(i-1).size() == 0)
        {
            model.removeSurface(i-1);
        }
    }
    for (uint i=model.getNVolumes();i&gt;0;i--)
    {
        if (model.getVolume(i-1).size() == 0)
        {
            model.removeVolume(i-1);
        }
    }
    for (uint i=0;i&lt;model.getNVolumes();i++)
    {
        if (model.getVolume(i).getName().isEmpty() || model.getVolume(i).getName() == RVolume::defaultName)
        {
            model.getVolume(i).setName(RVolume::defaultName + " " + QString::number(i+1));
        }
    }

    if (keepResults)
    {
        for (uint i=0;i&lt;model.getNVariables();i++)
        {
            model.setVariable(i,variables[i]);
        }
    }

    if (model.checkMesh() != R_MODEL_PROBLEM_NONE)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid mesh was generated.");
    }

    // Synchronize normals.
    model.syncSurfaceNormals();
}
</t>
<t tx="leo.20201108101539.30">const QString &amp;RTimeSolver::getTimeMarchApproximationName(RTimeMarchApproximation timeApproximation)
{
    R_ERROR_ASSERT(R_TIME_MARCH_APPROXIMATION_TYPE_IS_VALID(timeApproximation));
    return timeApproximationNames[timeApproximation];
} /* RTimeSolver::getTimeMarchApproximationName */

std::vector&lt;double&gt; RTimeSolver::findTimesVector(unsigned int nTimeSteps, double startTime, double timeStepSize)
{
    std::vector&lt;double&gt; timesVector;

    timesVector.resize(nTimeSteps);
    for (uint i=0;i&lt;nTimeSteps;i++)
    {
        timesVector[i] = startTime + (i+1)*timeStepSize;
    }

    return timesVector;
} /* RTimeSolver::findTimesVector */
</t>
<t tx="leo.20201108101539.31">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_triangle.cpp                                         *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th September 2012                                     *
 *                                                                   *
 *  DESCRIPTION: Triangle class definition                           *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rml_triangle.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101539.32">void RTriangle::_init(const RTriangle *pTriangle)
{
    if (pTriangle)
    {
        this-&gt;node1ID = pTriangle-&gt;node1ID;
        this-&gt;node2ID = pTriangle-&gt;node2ID;
        this-&gt;node3ID = pTriangle-&gt;node3ID;
        this-&gt;node1 = pTriangle-&gt;node1;
        this-&gt;node2 = pTriangle-&gt;node2;
        this-&gt;node3 = pTriangle-&gt;node3;
        this-&gt;normal = pTriangle-&gt;normal;
    }
}

RTriangle::RTriangle(const RNode &amp;node1, const RNode &amp;node2, const RNode &amp;node3)
    : node1ID(RConstants::eod)
    , node2ID(RConstants::eod)
    , node3ID(RConstants::eod)
    , node1(node1)
    , node2(node2)
    , node3(node3)
{
    this-&gt;_init();
    this-&gt;computeNormal();
}

RTriangle::RTriangle(const RR3Vector &amp;node1, const RR3Vector &amp;node2, const RR3Vector &amp;node3) :
    node1(RNode(node1)),
    node2(RNode(node2)),
    node3(RNode(node3))
{
    this-&gt;_init();
    this-&gt;computeNormal();
}

RTriangle::RTriangle(const RTriangle &amp;triangle)
{
    this-&gt;_init(&amp;triangle);
}

RTriangle::~RTriangle()
{
}

RTriangle &amp;RTriangle::operator =(const RTriangle &amp;triangle)
{
    this-&gt;_init(&amp;triangle);
    return (*this);
}

</t>
<t tx="leo.20201108101539.33">void RTriangle::setNodeIDs(uint node1ID, uint node2ID, uint node3ID)
{
    this-&gt;node1ID = node1ID;
    this-&gt;node2ID = node2ID;
    this-&gt;node3ID = node3ID;
}

</t>
<t tx="leo.20201108101539.34">bool RTriangle::hasNodeID(uint nodeID) const
{
    if (nodeID == RConstants::eod)
    {
        return false;
    }
    return (this-&gt;node1ID == nodeID || this-&gt;node2ID == nodeID || this-&gt;node3ID == nodeID);
}

</t>
<t tx="leo.20201108101539.35">void RTriangle::setNodes(const RNode &amp;node1, const RNode &amp;node2, const RNode &amp;node3)
{
    this-&gt;node1 = node1;
    this-&gt;node2 = node2;
    this-&gt;node3 = node3;
    this-&gt;computeNormal();
}

</t>
<t tx="leo.20201108101539.36">void RTriangle::findRotationMatrix(RRMatrix &amp;R) const
{
    R.setIdentity(3);

    RR3Vector lx;
    RR3Vector ly;
    RR3Vector lz;

    lx[0] = this-&gt;node2.getX() - this-&gt;node1.getX();
    lx[1] = this-&gt;node2.getY() - this-&gt;node1.getY();
    lx[2] = this-&gt;node2.getZ() - this-&gt;node1.getZ();

    ly[0] = this-&gt;node3.getX() - this-&gt;node1.getX();
    ly[1] = this-&gt;node3.getY() - this-&gt;node1.getY();
    ly[2] = this-&gt;node3.getZ() - this-&gt;node1.getZ();

    RR3Vector::cross(lx,ly,lz);

    lx.normalize();
    lz.normalize();

    RR3Vector::cross(lz,lx,ly);

    ly.normalize();

    for (unsigned int i=0;i&lt;3;i++)
    {
        R[i][0] = lx[i];
        R[i][1] = ly[i];
        R[i][2] = lz[i];
    }
}

</t>
<t tx="leo.20201108101539.37">bool RTriangle::findLineIntersection(const RR3Vector &amp;position, const RR3Vector &amp;direction, RR3Vector &amp;x, double &amp;u) const
{
    RPlane plane(this-&gt;node1.toVector(),this-&gt;node2.toVector(),this-&gt;node3.toVector());
    if (!plane.findLineIntersection(position,direction,x,u))
    {
        return false;
    }

    return this-&gt;isPointInside(x);
}

</t>
<t tx="leo.20201108101539.38">bool RTriangle::findSegmentIntersection(const RSegment &amp;segment, RR3Vector &amp;x, double &amp;u) const
{
    if (this-&gt;hasNodeID(segment.getNode1ID()))
    {
        u = 1.0;
        return this-&gt;findPointIntersection(segment.getNode2(),x);
    }
    if (this-&gt;hasNodeID(segment.getNode2ID()))
    {
        u = 0.0;
        return this-&gt;findPointIntersection(segment.getNode1(),x);
    }

    RR3Vector position;
    RR3Vector direction;

    position[0] = segment.getNode1().getX();
    position[1] = segment.getNode1().getY();
    position[2] = segment.getNode1().getZ();

    direction[0] = segment.getNode2().getX() - segment.getNode1().getX();
    direction[1] = segment.getNode2().getY() - segment.getNode1().getY();
    direction[2] = segment.getNode2().getZ() - segment.getNode1().getZ();

    return this-&gt;findLineIntersection(position,direction,x,u);
}

</t>
<t tx="leo.20201108101539.39">bool RTriangle::findPointIntersection(const RNode &amp;node, RR3Vector &amp;x) const
{
    bool intersectionFound = false;
    x = node.toVector();

    if (this-&gt;isPointInside(x))
    {
        @others
}

</t>
<t tx="leo.20201108101539.4">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_tetrahedron.cpp                                      *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   11-th June 2013                                          *
 *                                                                   *
 *  DESCRIPTION: Tetrahedron class definition                        *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rml_tetrahedron.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101539.40">        intersectionFound = (RR3Vector::findDistance(this-&gt;getNode1().toVector(),x) &gt; RConstants::eps &amp;&amp;
                             RR3Vector::findDistance(this-&gt;getNode2().toVector(),x) &gt; RConstants::eps &amp;&amp;
                             RR3Vector::findDistance(this-&gt;getNode3().toVector(),x) &gt; RConstants::eps);
    }

    return intersectionFound;
}

bool RTriangle::findPointIntersection(const RNode &amp;node, std::set&lt;RR3Vector&gt; &amp;x) const
{
    bool intersectionFound = false;
    RR3Vector point(node.toVector());

    if (this-&gt;isPointInside(point))
    {
</t>
<t tx="leo.20201108101539.41">    intersectionFound = (RR3Vector::findDistance(this-&gt;getNode1().toVector(),point) &gt; RConstants::eps &amp;&amp;
                         RR3Vector::findDistance(this-&gt;getNode2().toVector(),point) &gt; RConstants::eps &amp;&amp;
                         RR3Vector::findDistance(this-&gt;getNode3().toVector(),point) &gt; RConstants::eps);
}

if (intersectionFound)
{
    x.insert(point);
}

return intersectionFound;
</t>
<t tx="leo.20201108101539.42">bool RTriangle::findSegmentIntersection(const RSegment &amp;segment, std::set&lt;RR3Vector&gt; &amp;x) const
{
    RPlane plane(this-&gt;getNode1().toVector(),this-&gt;getNode2().toVector(),this-&gt;getNode3().toVector());
    double d1 = plane.findPointDistance(segment.getNode1().toVector());
    double d2 = plane.findPointDistance(segment.getNode2().toVector());

    std::set&lt;RR3Vector&gt; xTemp;

    bool intersectionFound = false;
    if (std::fabs(d1-d2) &lt; RConstants::eps)
    {
        // Segment is parallel to triangle.
        intersectionFound = this-&gt;findParallelSegmentIntersection(segment,xTemp);
    }
    else
    {
        // Segment is not parallel to triangle.
        intersectionFound = this-&gt;findSkewedSegmentIntersection(segment,xTemp);
    }

    if (intersectionFound)
    {
        intersectionFound = false;

        // Delete intersections at corner nodes.

        std::set&lt;RR3Vector&gt;::reverse_iterator it;
        for (it=xTemp.rbegin();it!=xTemp.rend();++it)
        {
            @others
}

</t>
<t tx="leo.20201108101539.43">        bool isNode1 = (RR3Vector::findDistance(this-&gt;getNode1().toVector(),*it) &lt; RConstants::eps ||
                        RR3Vector::findDistance(this-&gt;getNode2().toVector(),*it) &lt; RConstants::eps ||
                        RR3Vector::findDistance(this-&gt;getNode3().toVector(),*it) &lt; RConstants::eps);
        bool isNode2 = (RR3Vector::findDistance(segment.getNode1().toVector(),*it) &lt; RConstants::eps ||
                        RR3Vector::findDistance(segment.getNode2().toVector(),*it) &lt; RConstants::eps);
        if (isNode1 &amp;&amp; isNode2)
        {
            continue;
        }
        // Intersection is not in node.
        x.insert(*it);
        intersectionFound = true;
    }
}

return intersectionFound;
</t>
<t tx="leo.20201108101539.44">bool RTriangle::findTriangleIntersection(const RTriangle &amp;triangle, std::set&lt;RR3Vector&gt; &amp;x) const
{
    double tolerance = 1.0e-5;

    bool intersectionFound = false;
    std::set&lt;RR3Vector&gt; xTemp;
    RR3Vector nv;
    RR3Vector::cross(this-&gt;getNormal(),triangle.getNormal(),nv);
    if (RR3Vector::norm(nv) &lt; tolerance)
    {
        // Triangles are parallel.
        intersectionFound = this-&gt;findParallelTriangleIntersection(triangle,xTemp);
    }
    else
    {
        // Triangles are skewed.
        intersectionFound = this-&gt;findSkewedTriangleIntersection(triangle,xTemp);
    }

    tolerance = RConstants::eps * 100.0;

    if (intersectionFound)
    {
        intersectionFound = false;

        // Delete intersections at corner nodes.

        std::set&lt;RR3Vector&gt;::reverse_iterator it;
        for (it=xTemp.rbegin();it!=xTemp.rend();++it)
        {
            @others
}

</t>
<t tx="leo.20201108101539.45">        bool isNode1 = (RR3Vector::findDistance(this-&gt;getNode1().toVector(),*it) &lt; tolerance ||
                        RR3Vector::findDistance(this-&gt;getNode2().toVector(),*it) &lt; tolerance ||
                        RR3Vector::findDistance(this-&gt;getNode3().toVector(),*it) &lt; tolerance);
        bool isNode2 = (RR3Vector::findDistance(triangle.getNode1().toVector(),*it) &lt; tolerance ||
                        RR3Vector::findDistance(triangle.getNode2().toVector(),*it) &lt; tolerance ||
                        RR3Vector::findDistance(triangle.getNode3().toVector(),*it) &lt; tolerance);
        if (isNode1 &amp;&amp; isNode2)
        {
            continue;
        }
        if (this-&gt;isPointInside(*it,false) || triangle.isPointInside(*it,false))
        {
            // Intersection is not in node.
            x.insert(*it);
            intersectionFound = true;
        }
    }
}

return intersectionFound;
</t>
<t tx="leo.20201108101539.46">bool RTriangle::isPointInside(const RR3Vector &amp;point, bool includeNodes) const
{
    if (this-&gt;isPointAtNode(point) != RConstants::eod)
    {
        return includeNodes;
    }

    RNode pointNode(point);

    RTriangle t1(this-&gt;node1,this-&gt;node2,pointNode);
    RTriangle t2(this-&gt;node2,this-&gt;node3,pointNode);
    RTriangle t3(this-&gt;node3,this-&gt;node1,pointNode);

    double tArea = this-&gt;findArea();
    double pArea = t1.findArea() + t2.findArea() + t3.findArea();

    // EPS (tolerance) is multiplied by factor 100 due to cumulative error when calculating an area
    return !(std::fabs(pArea-tArea) &gt; 100*RConstants::eps);
}

uint RTriangle::isPointAtNode(const RR3Vector &amp;point) const
{
    RNode pointNode(point);

    if (this-&gt;getNode1().getDistance(pointNode) &lt; RConstants::eps)
    {
        return 0;
    }
    if (this-&gt;getNode2().getDistance(pointNode) &lt; RConstants::eps)
    {
        return 1;
    }
    if (this-&gt;getNode3().getDistance(pointNode) &lt; RConstants::eps)
    {
        return 2;
    }

    return RConstants::eod;
}

double RTriangle::findLongestEdgeLength(void) const
{
    double l1 = this-&gt;node2.getDistance(this-&gt;node3);
    double l2 = this-&gt;node3.getDistance(this-&gt;node1);
    double l3 = this-&gt;node1.getDistance(this-&gt;node2);

    if (l1 &lt; l2)
    {
        if (l1 &lt; l3)
        {
            return l1;
        }
        else
        {
            return l3;
        }
    }
    else
    {
        if (l2 &lt; l3)
        {
            return l2;
        }
        else
        {
            return l3;
        }
    }
}

double RTriangle::findArea(void) const
{
    return RTriangle::findArea(this-&gt;node1.getX(),this-&gt;node1.getY(),this-&gt;node1.getZ(),
                               this-&gt;node2.getX(),this-&gt;node2.getY(),this-&gt;node2.getZ(),
                               this-&gt;node3.getX(),this-&gt;node3.getY(),this-&gt;node3.getZ());
}

double RTriangle::findArea(const RNode &amp;node1, const RNode &amp;node2, const RNode &amp;node3)
{
    return RTriangle::findArea(node1.getX(),node1.getY(),node1.getZ(),
                               node2.getX(),node2.getY(),node2.getZ(),
                               node3.getX(),node3.getY(),node3.getZ());
}

double RTriangle::findArea(double xi, double yi, double zi, double xj, double yj, double zj, double xk, double yk, double zk)
{
    double Lij = sqrt((xj-xi)*(xj-xi) + (yj-yi)*(yj-yi) + (zj-zi)*(zj-zi));
    double Ljk = sqrt((xk-xj)*(xk-xj) + (yk-yj)*(yk-yj) + (zk-zj)*(zk-zj));
    double Lki = sqrt((xi-xk)*(xi-xk) + (yi-yk)*(yi-yk) + (zi-zk)*(zi-zk));

    double s = (Lij + Ljk + Lki)/2.0;
    return std::sqrt(std::abs(s*(s-Lij)*(s-Ljk)*(s-Lki)));
}

</t>
<t tx="leo.20201108101539.47">void RTriangle::findCenter(RR3Vector &amp;center) const
{
    center[0] = (this-&gt;getNode1().getX() + this-&gt;getNode2().getX() + this-&gt;getNode3().getX()) / 3.0;
    center[1] = (this-&gt;getNode1().getY() + this-&gt;getNode2().getY() + this-&gt;getNode3().getY()) / 3.0;
    center[2] = (this-&gt;getNode1().getZ() + this-&gt;getNode2().getZ() + this-&gt;getNode3().getZ()) / 3.0;
}

RR3Vector RTriangle::computeNormal(const RNode &amp;node1, const RNode &amp;node2, const RNode &amp;node3, bool normalize)
{
    return RTriangle::computeNormal(node1.toVector(),node2.toVector(),node3.toVector(),normalize);
}

RR3Vector RTriangle::computeNormal(const RR3Vector &amp;node1, const RR3Vector &amp;node2, const RR3Vector &amp;node3, bool normalize)
{
    RR3Vector v1;
    RR3Vector v2;
    RR3Vector::subtract(node2,node1,v1);
    RR3Vector::subtract(node3,node1,v2);

    RR3Vector n;
    RR3Vector::cross(v1,v2,n);

    if (normalize)
    {
        n.normalize();
    }
    return n;
}

</t>
<t tx="leo.20201108101539.48">void RTriangle::computeNormal(void)
{
    this-&gt;normal = RTriangle::computeNormal(this-&gt;node1,this-&gt;node2,this-&gt;node3);
}

</t>
<t tx="leo.20201108101539.49">bool RTriangle::findParallelSegmentIntersection(const RSegment &amp;segment, std::set&lt;RR3Vector&gt; &amp;x) const
{
    bool intersectionFound = false;
    uint nNFound = 0;

    // Check if segment's points are inside this triangle.
    if (this-&gt;isPointInside(segment.getNode1().toVector()))
    {
        x.insert(segment.getNode1().toVector());
        intersectionFound = true;
        nNFound++;
    }
    if (this-&gt;isPointInside(segment.getNode2().toVector()))
    {
        x.insert(segment.getNode2().toVector());
        intersectionFound = true;
        nNFound++;
    }

    if (nNFound == 2)
    {
        return true;
    }

    RSegment s12(this-&gt;getNode1(),this-&gt;getNode2());
    RSegment s23(this-&gt;getNode2(),this-&gt;getNode3());
    RSegment s31(this-&gt;getNode3(),this-&gt;getNode1());

    if (s12.findSegmentIntersection(segment,x))
    {
        intersectionFound = true;
    }
    if (s23.findSegmentIntersection(segment,x))
    {
        intersectionFound = true;
    }
    if (s31.findSegmentIntersection(segment,x))
    {
        intersectionFound = true;
    }

    return intersectionFound;
}

</t>
<t tx="leo.20201108101539.5">void RTetrahedron::_init(const RTetrahedron *pTetrahedron)
{
    if (pTetrahedron)
    {
        this-&gt;node1 = pTetrahedron-&gt;node1;
        this-&gt;node2 = pTetrahedron-&gt;node2;
        this-&gt;node3 = pTetrahedron-&gt;node3;
        this-&gt;node4 = pTetrahedron-&gt;node4;
    }
}

RTetrahedron::RTetrahedron(const RNode &amp;node1, const RNode &amp;node2, const RNode &amp;node3, const RNode &amp;node4) :
    node1(node1),
    node2(node2),
    node3(node3),
    node4(node4)
{
    this-&gt;_init();
}

RTetrahedron::RTetrahedron(const RTetrahedron &amp;tetrahedron)
{
    this-&gt;_init(&amp;tetrahedron);
}

RTetrahedron::~RTetrahedron()
{
}

RTetrahedron &amp;RTetrahedron::operator =(const RTetrahedron &amp;tetrahedron)
{
    this-&gt;_init(&amp;tetrahedron);
    return (*this);
}

</t>
<t tx="leo.20201108101539.50">bool RTriangle::findSkewedSegmentIntersection(const RSegment &amp;segment, std::set&lt;RR3Vector&gt; &amp;x) const
{
    RR3Vector xVec;
    double u = 0.0;
    if (this-&gt;findSegmentIntersection(segment,xVec,u))
    {
        if (R_IS_IN_CLOSED_INTERVAL(0.0,1.0,u))
        {
            x.insert(xVec);
            return true;
        }
    }
    return false;
}

</t>
<t tx="leo.20201108101539.51">bool RTriangle::findParallelTriangleIntersection(const RTriangle &amp;triangle, std::set&lt;RR3Vector&gt; &amp;x) const
{
    bool intersectionFound = false;
    uint nNFound = 0;

    bool hasNode11 = this-&gt;hasNodeID(triangle.getNode1ID());
    bool hasNode12 = this-&gt;hasNodeID(triangle.getNode2ID());
    bool hasNode13 = this-&gt;hasNodeID(triangle.getNode3ID());

    // Check if triangle's points are inside this triangle.
    if (hasNode11 || this-&gt;isPointInside(triangle.getNode1().toVector()))
    {
        if (!hasNode11)
        {
            x.insert(triangle.getNode1().toVector());
            intersectionFound = true;
        }
        nNFound++;
    }
    if (hasNode12 || this-&gt;isPointInside(triangle.getNode2().toVector()))
    {
        if (!hasNode12)
        {
            x.insert(triangle.getNode2().toVector());
            intersectionFound = true;
        }
        nNFound++;
    }
    if (hasNode13 || this-&gt;isPointInside(triangle.getNode3().toVector()))
    {
        if (!hasNode13)
        {
            x.insert(triangle.getNode3().toVector());
            intersectionFound = true;
        }
        nNFound++;
    }
    if (nNFound == 3)
    {
        return intersectionFound;
    }

    bool hasNode21 = triangle.hasNodeID(this-&gt;getNode1ID());
    bool hasNode22 = triangle.hasNodeID(this-&gt;getNode2ID());
    bool hasNode23 = triangle.hasNodeID(this-&gt;getNode3ID());

    // Check if this triangle's points are inside triangle.
    nNFound = 0;
    if (hasNode21 || triangle.isPointInside(this-&gt;getNode1().toVector()))
    {
        if (!hasNode21)
        {
            x.insert(this-&gt;getNode1().toVector());
            intersectionFound = true;
        }
        nNFound++;
    }
    if (hasNode22 || triangle.isPointInside(this-&gt;getNode2().toVector()))
    {
        if (!hasNode22)
        {
            x.insert(this-&gt;getNode2().toVector());
            intersectionFound = true;
        }
        nNFound++;
    }
    if (hasNode23 || triangle.isPointInside(this-&gt;getNode3().toVector()))
    {
        if (!hasNode23)
        {
            x.insert(this-&gt;getNode3().toVector());
            intersectionFound = true;
            nNFound++;
        }
    }
    if (nNFound == 3)
    {
        return intersectionFound;
    }

    // Check edge intersections.
    RSegment s11(this-&gt;getNode1(),this-&gt;getNode2());
    RSegment s12(this-&gt;getNode2(),this-&gt;getNode3());
    RSegment s13(this-&gt;getNode3(),this-&gt;getNode1());

    RSegment s21(triangle.getNode1(),triangle.getNode2());
    RSegment s22(triangle.getNode2(),triangle.getNode3());
    RSegment s23(triangle.getNode3(),triangle.getNode1());

    if (!hasNode11 &amp;&amp; s11.findSegmentIntersection(s21,x))
    {
        intersectionFound = true;
    }
    if (!hasNode12 &amp;&amp; s11.findSegmentIntersection(s22,x))
    {
        intersectionFound = true;
    }
    if (!hasNode13 &amp;&amp; s11.findSegmentIntersection(s23,x))
    {
        intersectionFound = true;
    }

    if (!hasNode11 &amp;&amp; s12.findSegmentIntersection(s21,x))
    {
        intersectionFound = true;
    }
    if (!hasNode12 &amp;&amp; s12.findSegmentIntersection(s22,x))
    {
        intersectionFound = true;
    }
    if (!hasNode13 &amp;&amp; s12.findSegmentIntersection(s23,x))
    {
        intersectionFound = true;
    }

    if (!hasNode11 &amp;&amp; s13.findSegmentIntersection(s21,x))
    {
        intersectionFound = true;
    }
    if (!hasNode12 &amp;&amp; s13.findSegmentIntersection(s22,x))
    {
        intersectionFound = true;
    }
    if (!hasNode13 &amp;&amp; s13.findSegmentIntersection(s23,x))
    {
        intersectionFound = true;
    }

    return intersectionFound;
}


</t>
<t tx="leo.20201108101539.52">bool RTriangle::findSkewedTriangleIntersection(const RTriangle &amp;triangle, std::set&lt;RR3Vector&gt; &amp;x) const
{
    bool intersectionFound = false;

    RR3Vector vx;
    double u = 0.0;

    // Check if triangle's edges are intersecting this triangle.
    RSegment s11(triangle.getNode1(),triangle.getNode2());
    s11.setNodeIDs(triangle.getNode1ID(),triangle.getNode2ID());
    RSegment s12(triangle.getNode2(),triangle.getNode3());
    s12.setNodeIDs(triangle.getNode2ID(),triangle.getNode3ID());
    RSegment s13(triangle.getNode3(),triangle.getNode1());
    s13.setNodeIDs(triangle.getNode3ID(),triangle.getNode1ID());

    if (this-&gt;findSegmentIntersection(s11,vx,u))
    {
        if (R_IS_IN_CLOSED_INTERVAL(0.0,1.0,u))
        {
            x.insert(vx);
            intersectionFound = true;
        }
    }
    if (this-&gt;findSegmentIntersection(s12,vx,u))
    {
        if (R_IS_IN_CLOSED_INTERVAL(0.0,1.0,u))
        {
            x.insert(vx);
            intersectionFound = true;
        }
    }
    if (this-&gt;findSegmentIntersection(s13,vx,u))
    {
        if (R_IS_IN_CLOSED_INTERVAL(0.0,1.0,u))
        {
            x.insert(vx);
            intersectionFound = true;
        }
    }

    // Check if this triangle's edges are intersecting triangle.
    RSegment s21(this-&gt;getNode1(),this-&gt;getNode2());
    s21.setNodeIDs(this-&gt;getNode1ID(),this-&gt;getNode2ID());
    RSegment s22(this-&gt;getNode2(),this-&gt;getNode3());
    s22.setNodeIDs(this-&gt;getNode2ID(),this-&gt;getNode3ID());
    RSegment s23(this-&gt;getNode3(),this-&gt;getNode1());
    s23.setNodeIDs(this-&gt;getNode3ID(),this-&gt;getNode1ID());

    if (triangle.findSegmentIntersection(s21,vx,u))
    {
        if (R_IS_IN_CLOSED_INTERVAL(0.0,1.0,u))
        {
            x.insert(vx);
            intersectionFound = true;
        }
    }
    if (triangle.findSegmentIntersection(s22,vx,u))
    {
        if (R_IS_IN_CLOSED_INTERVAL(0.0,1.0,u))
        {
            x.insert(vx);
            intersectionFound = true;
        }
    }
    if (triangle.findSegmentIntersection(s23,vx,u))
    {
        if (R_IS_IN_CLOSED_INTERVAL(0.0,1.0,u))
        {
            x.insert(vx);
            intersectionFound = true;
        }
    }

    return intersectionFound;
}
</t>
<t tx="leo.20201108101539.53">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_triangulate.cpp                                      *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   4-th May 2015                                            *
 *                                                                   *
 *  DESCRIPTION: Triangulate functions                               *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rml_triangulate.h"

/*********************************************************************
 * TYPE DEFINITIONS ================================================ *
 *********************************************************************/

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101539.54">typedef struct _TRIANGLE
{
    int p1;
    int p2;
    int p3;
} TRIANGLE;

</t>
<t tx="leo.20201108101539.55">typedef struct _EDGE
{
    int p1;
    int p2;
} EDGE;

</t>
<t tx="leo.20201108101539.56">typedef struct _XYZ
{
    uint id;
    double x;
    double y;
    double z;
} XYZ;

/*********************************************************************
 * STATIC FUNCTIONS DECLARATIONS =================================== *
 *********************************************************************/

static std::vector&lt;TRIANGLE&gt; triangulate(std::vector&lt;XYZ&gt; &amp;pxyz, bool removeZeroSized, double zeroSize);

</t>
<t tx="leo.20201108101539.57">static bool CircumCircle( double  xp, double  yp,
                          double  x1, double  y1,
                          double  x2, double  y2,
                          double  x3, double  y3,
                          double *xc, double *yc, double *r );

struct less_than_key
{
    inline bool operator() (const XYZ&amp; pxyz1, const XYZ&amp; pxyz2)
    {
        return ((pxyz1.x &lt; pxyz2.x) || (pxyz1.x == pxyz2.x &amp;&amp; pxyz1.y &lt; pxyz2.y));
    }
};


/*********************************************************************
 * PUBLIC FUNCTIONS DEFINITIONS ==================================== *
 *********************************************************************/


/*********************************************************************
 * NAME:        RTriangulateNodes                                    *
 * DESCRIPTION: Triangulate set of nodes                             *
 *********************************************************************/
std::vector&lt;RElement&gt; RTriangulateNodes(const std::vector&lt;RNode&gt; &amp;nodes, bool removeZeroSized, double zeroSize)
{
    // Convert nodes to XYZ
    std::vector&lt;XYZ&gt; pxyz;
    pxyz.resize(nodes.size());

    for (uint i=0;i&lt;nodes.size();i++)
    {
        pxyz[i].id = i;
        pxyz[i].x = nodes[i].getX();
        pxyz[i].y = nodes[i].getY();
        pxyz[i].z = nodes[i].getZ();
    }
    std::sort(pxyz.begin(), pxyz.end(), less_than_key());

    std::vector&lt;TRIANGLE&gt;v = triangulate(pxyz,removeZeroSized,zeroSize);

    std::vector&lt;RElement&gt; elements;
    elements.resize(v.size(),RElement(R_ELEMENT_TRI1));

    for (uint i=0;i&lt;elements.size();i++)
    {
        elements[i].setNodeId(0,pxyz[v[i].p1].id);
        elements[i].setNodeId(1,pxyz[v[i].p2].id);
        elements[i].setNodeId(2,pxyz[v[i].p3].id);
    }

    return elements;
} /* RTriangulateNodes */


/*********************************************************************
 * STATIC FUNCTIONS DEFINITIONS ==================================== *
 *********************************************************************/


/*********************************************************************
 * NAME:        triangulate                                          *
 * DESCRIPTION: Triangulation subroutine                             *
 *              Takes as input NV vertices in array pxyz. Returned   *
 *              is a list of ntri triangular faces in the array v.   *
 *              These triangles are arranged in a consistent         *
 *              clockwise order. The triangle array 'v' should be    *
 *              malloced to 3 * nv. The vertex array pxyz must be    *
 *              big enough to hold 3 more points. The vertex array   *
 *              must be sorted in increasing x values say.           *
 *********************************************************************/
</t>
<t tx="leo.20201108101539.58">static std::vector&lt;TRIANGLE&gt; triangulate (std::vector&lt;XYZ&gt; &amp;pxyz, bool removeZeroSized, double zeroSize)
{
    std::vector&lt;int&gt; complete;
    std::vector&lt;EDGE&gt; edges;
    std::vector&lt;TRIANGLE&gt; v;

    uint nv = uint(pxyz.size());
    uint ntri = 0;

    uint nedge = 0;
    uint emax = 1000;

    double xp=0.0,yp=0.0,x1=0.0,y1=0.0,x2=0.0,y2=0.0,x3=0.0,y3=0.0,xc=0.0,yc=0.0,r=0.0;
    double xmin=0.0,xmax=0.0,ymin=0.0,ymax=0.0;
    double dx=0.0,dy=0.0,dmax=0.0;

    /* Allocate memory for the completeness list, flag for each triangle */
    uint trimax = 4 * nv;
    complete.resize(trimax);
    v.resize(trimax);

    /* Allocate memory for the edge list */
    edges.resize(emax);

    /* Find the maximum and minimum vertex bounds.
       This is to allow calculation of the bounding triangle */

    xmin = pxyz[0].x;
    ymin = pxyz[0].y;
    xmax = xmin;
    ymax = ymin;
    for (uint i=1;i&lt;nv;i++)
    {
        if (pxyz[i].x &lt; xmin) xmin = pxyz[i].x;
        if (pxyz[i].x &gt; xmax) xmax = pxyz[i].x;
        if (pxyz[i].y &lt; ymin) ymin = pxyz[i].y;
        if (pxyz[i].y &gt; ymax) ymax = pxyz[i].y;
    }
    dx = xmax - xmin;
    dy = ymax - ymin;
    dmax = (dx &gt; dy) ? dx : dy;

    /* Set up the supertriangle
       This is a triangle which encompasses all the sample points.
       The supertriangle coordinates are added to the end of the
       vertex list. The supertriangle is the first triangle in
       the triangle list. */

    double dfactor = 20.0;

    pxyz.resize(pxyz.size()+4);
    pxyz[nv+0].x = xmin - dfactor*dmax;
    pxyz[nv+0].y = ymin - dfactor*dmax;
    pxyz[nv+0].z = 0.0;
    pxyz[nv+1].x = xmin - dfactor*dmax;
    pxyz[nv+1].y = ymax + dfactor*dmax;
    pxyz[nv+1].z = 0.0;
    pxyz[nv+2].x = xmax + dfactor*dmax;
    pxyz[nv+2].y = ymin - dfactor*dmax;
    pxyz[nv+2].z = 0.0;
    pxyz[nv+3].x = xmax + dfactor*dmax;
    pxyz[nv+3].y = ymax + dfactor*dmax;
    pxyz[nv+3].z = 0.0;
    v[0].p1 = nv;
    v[0].p2 = nv+1;
    v[0].p3 = nv+2;
    v[1].p1 = nv+2;
    v[1].p2 = nv+1;
    v[1].p3 = nv+3;
    complete[0] = 0;
    complete[1] = 0;
    ntri = 2;

    /* Include each point one at a time into the existing mesh */
    for (uint i=0;i&lt;nv;i++)
    {
        xp = pxyz[i].x;
        yp = pxyz[i].y;
        nedge = 0;

        /* Set up the edge buffer.
           If the point (xp,yp) lies inside the circumcircle then the
           three edges of that triangle are added to the edge buffer
           and that triangle is removed. */
        for (uint j=0;j&lt;ntri;j++)
        {
            if (complete[j] == 1)
            {
                continue;
            }
            x1 = pxyz[v[j].p1].x;
            y1 = pxyz[v[j].p1].y;
            x2 = pxyz[v[j].p2].x;
            y2 = pxyz[v[j].p2].y;
            x3 = pxyz[v[j].p3].x;
            y3 = pxyz[v[j].p3].y;
            @others
} /* triangulate */


/*********************************************************************
 * NAME:        CircumCircle                                         *
 * DESCRIPTION: Return '1' if a point (xp,yp) is inside the          *
 *              circumcircle made up of the points (x1,y1), (x2,y2), *
 *              (x3,y3).                                             *
 *              The circumcircle centre is returned in (xc,yc) and   *
 *              the radius r.                                        *
 *              NOTE: A point on the edge is inside the circumcircle *
 *********************************************************************/
</t>
<t tx="leo.20201108101539.59">        bool inside = CircumCircle (xp, yp,
                                    x1, y1,
                                    x2, y2,
                                    x3, y3,
                                    &amp;xc, &amp;yc, &amp;r);
        if (xc + r &lt; xp)
        {
            complete[j] = 1;
        }
        if (inside)
        {
            /* Check that we haven't exceeded the edge list size */
            if (nedge+3 &gt;= emax)
            {
                emax += 100;
                edges.resize(emax);
            }
            edges[nedge+0].p1 = v[j].p1;
            edges[nedge+0].p2 = v[j].p2;
            edges[nedge+1].p1 = v[j].p2;
            edges[nedge+1].p2 = v[j].p3;
            edges[nedge+2].p1 = v[j].p3;
            edges[nedge+2].p2 = v[j].p1;
            nedge += 3;
            v[j] = v[ntri-1];
            complete[j] = complete[ntri-1];
            ntri--;
            j--;
        }
    }

    if (nedge &gt; 0)
    {
        /* Tag multiple edges
           Note: if all triangles are specified anticlockwise then all
                 interior edges are opposite pointing in direction. */
        for (uint j=0;j&lt;nedge-1;j++)
        {
            for (uint k=j+1;k&lt;nedge;k++)
            {
                if ((edges[j].p1 == edges[k].p2) &amp;&amp;
                    (edges[j].p2 == edges[k].p1))
                {
                    edges[j].p1 = -1;
                    edges[j].p2 = -1;
                    edges[k].p1 = -1;
                    edges[k].p2 = -1;
                }
                /* Shouldn't need the following, see note above */
                if ((edges[j].p1 == edges[k].p1) &amp;&amp;
                    (edges[j].p2 == edges[k].p2))
                {
                    edges[j].p1 = -1;
                    edges[j].p2 = -1;
                    edges[k].p1 = -1;
                    edges[k].p2 = -1;
                }
            }
        }
    }

    /* Form new triangles for the current point
       Skipping over any tagged edges.
       All edges are arranged in clockwise order. */
    for (uint j=0;j&lt;nedge;j++)
    {
        if (edges[j].p1 &lt; 0 || edges[j].p2 &lt; 0)
        {
            continue;
        }
        if (ntri &gt;= trimax)
        {
            trimax += 100;
            complete.resize(trimax);
            v.resize(trimax);
        }
        v[ntri].p1 = edges[j].p1;
        v[ntri].p2 = edges[j].p2;
        v[ntri].p3 = i;
        complete[ntri] = 0;
        ntri++;
    }
}

/* Remove triangles with supertriangle vertices
   These are triangles which have a vertex number greater than nv */
for (uint i=0;i&lt;ntri;i++)
{
    if (v[i].p1 &gt;= int(nv) || v[i].p2 &gt;= int(nv) || v[i].p3 &gt;= int(nv))
    {
        v[i] = v[ntri-1];
        ntri--;
        i--;
    }
}

/* Remove zero-sized triangles */
if (removeZeroSized)
{
    uint n = 0;
    for (uint i=0;i&lt;ntri;i++)
    {
        RTriangle t(RNode(pxyz[v[i].p1].x,pxyz[v[i].p1].y,pxyz[v[i].p1].z),
                    RNode(pxyz[v[i].p2].x,pxyz[v[i].p2].y,pxyz[v[i].p2].z),
                    RNode(pxyz[v[i].p3].x,pxyz[v[i].p3].y,pxyz[v[i].p3].z));
        if (t.findArea() &gt; zeroSize)
        {
            v[n]=v[i];
            n++;
        }
    }
    ntri = n;
}
v.resize(ntri);

for (uint i=0;i&lt;ntri;i++)
{
    std::swap(v[i].p2,v[i].p3);
}

return v;
</t>
<t tx="leo.20201108101539.6">void RTetrahedron::setNodes(const RNode &amp;node1, const RNode &amp;node2, const RNode &amp;node3, const RNode &amp;node4)
{
    this-&gt;node1 = node1;
    this-&gt;node2 = node2;
    this-&gt;node3 = node3;
    this-&gt;node4 = node4;
}

double RTetrahedron::findVolume(void) const
{
    return RTetrahedron::findVolume(this-&gt;node1.getX(),this-&gt;node1.getY(),this-&gt;node1.getZ(),
                                    this-&gt;node2.getX(),this-&gt;node2.getY(),this-&gt;node2.getZ(),
                                    this-&gt;node3.getX(),this-&gt;node3.getY(),this-&gt;node3.getZ(),
                                    this-&gt;node4.getX(),this-&gt;node4.getY(),this-&gt;node4.getZ());
}

double RTetrahedron::findVolume(const RNode &amp;node1, const RNode &amp;node2, const RNode &amp;node3, const RNode &amp;node4)
{
    return RTetrahedron::findVolume(node1.getX(),node1.getY(),node1.getZ(),
                                    node2.getX(),node2.getY(),node2.getZ(),
                                    node3.getX(),node3.getY(),node3.getZ(),
                                    node4.getX(),node4.getY(),node4.getZ());
}

double RTetrahedron::findVolume(double xi, double yi, double zi, double xj, double yj, double zj, double xk, double yk, double zk, double xl, double yl, double zl)
{
    RRMatrix mV(4,4);

    mV[0][0] = xi;
    mV[0][1] = yi;
    mV[0][2] = zi;
    mV[0][3] = 1.0;

    mV[1][0] = xj;
    mV[1][1] = yj;
    mV[1][2] = zj;
    mV[1][3] = 1.0;

    mV[2][0] = xk;
    mV[2][1] = yk;
    mV[2][2] = zk;
    mV[2][3] = 1.0;

    mV[3][0] = xl;
    mV[3][1] = yl;
    mV[3][2] = zl;
    mV[3][3] = 1.0;

    return std::abs(mV.getDeterminant() / 6.0);
}

</t>
<t tx="leo.20201108101539.60">static bool CircumCircle(double  xp, double  yp,
                         double  x1, double  y1,
                         double  x2, double  y2,
                         double  x3, double  y3,
                         double *xc, double *yc, double *r)
{
    double m1,m2,mx1,mx2,my1,my2;
    double dx,dy,rsqr,drsqr;
    double tolerance = 0.0;

    tolerance = RConstants::eps;
    tolerance = 0.0;

   /* Check for coincident points */
    if (std::fabs(y1-y2) &lt;= tolerance &amp;&amp;
        std::fabs(y2-y3) &lt;= tolerance)
    {
        return (0);
    }

    if (std::fabs(y2-y1) &lt;= tolerance)
    {
        m2 = - (x3-x2) / (y3-y2);
        mx2 = (x2 + x3) / 2.0;
        my2 = (y2 + y3) / 2.0;
        *xc = (x2 + x1) / 2.0;
        *yc = m2 * (*xc - mx2) + my2;
    }
    else if (std::fabs(y3-y2) &lt;= tolerance)
    {
        m1 = - (x2-x1) / (y2-y1);
        mx1 = (x1 + x2) / 2.0;
        my1 = (y1 + y2) / 2.0;
        *xc = (x3 + x2) / 2.0;
        *yc = m1 * (*xc - mx1) + my1;
    }
    else
    {
        m1 = - (x2-x1) / (y2-y1);
        m2 = - (x3-x2) / (y3-y2);
        mx1 = (x1 + x2) / 2.0;
        mx2 = (x2 + x3) / 2.0;
        my1 = (y1 + y2) / 2.0;
        my2 = (y2 + y3) / 2.0;
        *xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);
        *yc = m1 * (*xc - mx1) + my1;
    }

    dx = x2 - *xc;
    dy = y2 - *yc;
    rsqr = dx*dx + dy*dy;
    *r = sqrt(rsqr);

    dx = xp - *xc;
    dy = yp - *yc;
    drsqr = dx*dx + dy*dy;

    return (drsqr &lt;= rsqr);
} /* CircumCircle */
</t>
<t tx="leo.20201108101539.61">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_variable.cpp                                         *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th December 2011                                      *
 *                                                                   *
 *  DESCRIPTION: Variable class definition                           *
 *********************************************************************/

#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

#include &lt;rblib.h&gt;

#include "rml_problem_type.h"
#include "rml_variable.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101539.62">typedef struct _RVariableDesc
{
    QString           id;
    QString           name;
    QString           units;
    double            value;
    RVariableDataType dataType;
    RProblemTypeMask  problemTypeMask;
} RVariableDesc;

</t>
<t tx="leo.20201108101539.63">const RVariableDesc variableDesc [R_VARIABLE_N_TYPES] =
{
    { "var-none"                         , "None",                                      "N/A",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-acceleration"                 , "Acceleration",                              "m/s^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_STRESS | R_PROBLEM_FLUID },
    { "var-acceleration_x"               , "Acceleration in X direction",               "m/s^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-acceleration_y"               , "Acceleration in Y direction",               "m/s^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-acceleration_z"               , "Acceleration in Z direction",               "m/s^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-acoustic_particle_velocitty"  , "Acoustic particle velocity",                "m/s",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ACOUSTICS },
    { "var-acoustic_pressure"            , "Acoustic pressure",                         "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ACOUSTICS },
    { "var-charge_density"               , "Charge density",                            "C",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ELECTROSTATICS },
    { "var-convection_coefficient"       , "Convection coefficient",                    "W/(m^2*K)",  100.0,   R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_FLUID },
    { "var-current_density"              , "Current density",                           "A/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ELECTROSTATICS },
    { "var-current_density_x"            , "Current density in X direction",            "A/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-current_density_y"            , "Current density in Y direction",            "A/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-current_density_z"            , "Current density in Z direction",            "A/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-density"                      , "Density",                                   "kg/m^3",     0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_FLUID },
    { "var-displacement"                 , "Displacement",                              "m",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "var-displacement_x"               , "Displacement in X direction",               "m",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-displacement_y"               , "Displacement in Y direction",               "m",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-displacement_z"               , "Displacement in Z direction",               "m",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-dynamic_viscosity"            , "Dynamic viscosity",                         "kg/(m*s)",   0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_FLUID },
    { "var-electric_energy"              , "Electric energy",                           "J",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ELECTROSTATICS },
    { "var-electric_field"               , "Electric field",                            "V/m",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ELECTROSTATICS },
    { "var-electric_field_x"             , "Electric field in X direction",             "V/m",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-electric_field_y"             , "Electric field in Y direction",             "V/m",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-electric_field_z"             , "Electric field in Z direction",             "V/m",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-electric_potential"           , "Electric potential",                        "V",          1.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ELECTROSTATICS },
    { "var-electrical_conductivity"      , "Electrical conductivity",                   "S/m",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-electrical_resistivity"       , "Electrical resistivity",                    "V*m/A",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ELECTROSTATICS },
    { "var-emissivity"                   , "Emissivity",                                "N/A",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-fluid_temperature"            , "Fluid temperature",                         "K",          293.15,  R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-frequency"                    , "Frequency",                                 "Hz",         100.0,   R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL | R_PROBLEM_ACOUSTICS | R_PROBLEM_WAVE },
    { "var-force"                        , "Force",                                     "N",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_STRESS_MODAL },
    { "var-force_x"                      , "Force in X direction",                      "N",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-force_y"                      , "Force in Y direction",                      "N",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-force_z"                      , "Force in Z direction",                      "N",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-force_unit_area"              , "Force per unit area",                       "N/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-force_unit_area_x"            , "Force per unit area in X direction",        "N/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-force_unit_area_y"            , "Force per unit area in Y direction",        "N/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-force_unit_area_z"            , "Force per unit area in Z direction",        "N/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-g_acceleration"               , "Gravitational acceleration",                "m/s^2",      9.80665, R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-g_acceleration_x"             , "Gravitational acceleration in X direction", "m/s^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-g_acceleration_y"             , "Gravitational acceleration in Y direction", "m/s^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-g_acceleration_z"             , "Gravitational acceleration in Z direction", "m/s^2",     -9.80665, R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-heat_capacity"                , "Heat capacity",                             "J/(kg*K)",   0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-heat"                         , "Heat",                                      "W",          1000.0,  R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-heat_flux"                    , "Heat flux",                                 "W/m^2",      1000.0,  R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_HEAT },
    { "var-heat_flux_x"                  , "Heat flux in X direction",                  "W/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-heat_flux_y"                  , "Heat flux in Y direction",                  "W/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-heat_flux_z"                  , "Heat flux in Z direction",                  "W/m^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-heat_radiation"               , "Heat - radiation part",                     "W",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-heat_rate_area"               , "Heat per unit area",                        "W/m^2",      10.0,    R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-heat_rate_volume"             , "Heat per unit volume",                      "W/m^3",      10.0,    R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-heat_transfer_coefficientt"   , "Heat transfer coefficient",                 "W/(m^2*K)",  100.0,   R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_HEAT },
    { "var-hydraulic_diameter"           , "Hydraulic diameter",                        "m",          1.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-iteration"                    , "Iteration",                                 "#",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-joule_heat"                   , "Joule heat",                                "W",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ELECTROSTATICS },
    { "var-magnetic_field"               , "Magnetic field",                            "T",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ELECTROSTATICS },
    { "var-magnetic_field_x"             , "Magnetic field in X direction",             "T",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-magnetic_field_y"             , "Magnetic field in Y direction",             "T",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-magnetic_field_z"             , "Magnetic field in Z direction",             "T",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-mass_flow_rate"               , "Mass flow rate",                            "kg/s",       0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_FLUID | R_PROBLEM_POTENTIAL },
    { "var-mass_flow_rate_x"             , "Mass flow rate in X direction",             "kg/s",       0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-mass_flow_rate_y"             , "Mass flow rate in Y direction",             "kg/s",       0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-mass_flow_rate_z"             , "Mass flow rate in Z direction",             "kg/s",       0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-modulus_of_elasticity"        , "Modulus of elasticity",                     "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-particle_concentration"       , "Particle concentration",                    "kg/m^3",     0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_FLUID },
    { "var-particle_flux"                , "Particle flux",                             "kg/(m^3*s)", 0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-particle_rate"                , "Particle rate",                             "kg/(m^3*s)", 0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_FLUID },
    { "var-patch_area"                   , "Patch area",                                "m^2",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-patch_size"                   , "Patch size",                                "#",          0.0,     R_VARIABLE_DATA_UNSIGNED_INTEGER, R_PROBLEM_NONE },
    { "var-permeability_to_fluids"       , "Permeability to fluids",                    "m^2",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-pressure"                     , "Pressure",                                  "Pa",         1000.0,  R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_FLUID },
    { "var-poisson_ratio"                , "Poisson ratio",                             "N/A",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-potential"                    , "Potential",                                 "",           0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ACOUSTICS },
    { "var-potential_velocity"           , "Potential / s",                             "1/s",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ACOUSTICS },
    { "var-potential_acceleration"       , "Potential / s^2",                           "1/s^2",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_ACOUSTICS },
    { "var-radiation_emitter"            , "Radiation emitter",                         "N/A",        1.0,     R_VARIABLE_DATA_BOOLEAN, R_PROBLEM_NONE },
    { "var-radiation_receiver"           , "Radiation receiver",                        "N/A",        1.0,     R_VARIABLE_DATA_BOOLEAN, R_PROBLEM_NONE },
    { "var-relative_permittivity"        , "Relative permittivity",                     "C^2",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-separation_angle"             , "Separation angle",                          "Deg",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-sound_speed"                  , "Speed of sound",                            "m/s",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-stress"                       , "Stress",                                    "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-stress_x"                     , "Normal stress in X direction",              "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-stress_y"                     , "Normal stress in Y direction",              "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-stress_z"                     , "Normal stress in Z direction",              "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-stress_xy"                    , "Shear stress in XY plane",                  "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-stress_xz"                    , "Shear stress in XZ plane",                  "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-stress_yz"                    , "Shear stress in YZ plane",                  "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-stress_von_mises"             , "Von Mises stress",                          "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "var-stress_normal"                , "Normal stress",                             "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "var-stress_shear"                 , "Shear stress",                              "Pa",         0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_STRESS | R_PROBLEM_STRESS_MODAL },
    { "var-temperature"                  , "Temperature",                               "K",          293.15,  R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_HEAT | R_PROBLEM_FLUID },
    { "var-thermal_conductivity"         , "Thermal conductivity",                      "W/(m*K)",    0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-thermal_expansion_coefficient", "Thermal expansion coefficient",             "1/K",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-time"                         , "Time",                                      "s",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-velocity"                     , "Velocity",                                  "m/s",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_FLUID | R_PROBLEM_STRESS },
    { "var-velocity_x"                   , "Velocity in X direction",                   "m/s",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-velocity_y"                   , "Velocity in Y direction",                   "m/s",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-velocity_z"                   , "Velocity in Z direction",                   "m/s",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-vof"                          , "Volume of fraction",                        "%",          0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_FLUID },
    { "var-volume_flow_rate"             , "Volumetric flow rate",                      "m^3/s",      0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_FLUID },
    { "var-wave_displacement"            , "Wave displacement",                         "N/A",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_WAVE },
    { "var-weight"                       , "Weight",                                    "kg",         1.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-length"                       , "Length",                                    "m",          1.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-area"                         , "Area",                                      "m^2",        1.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-volume"                       , "Volume",                                    "m^3",        1.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE },
    { "var-custom"                       , "Custom",                                    "N/A",        0.0,     R_VARIABLE_DATA_DOUBLE,  R_PROBLEM_NONE }
};


RVariable::RVariable (RVariableType type, RVariableApplyType applyType)
{
    this-&gt;setType(type);
    this-&gt;setApplyType(applyType);
    this-&gt;_init();
} /* RVariable::RVariable */


RVariable::RVariable (const RVariable &amp;variable)
{
    this-&gt;_init (&amp;variable);
} /* RVariable::RVariable (copy) */


RVariable::~RVariable ()
{
} /* RVariable::~RVariable */


</t>
<t tx="leo.20201108101539.64">void RVariable::_init (const RVariable *pVariable)
{
    if (pVariable)
    {

        this-&gt;type = pVariable-&gt;type;
        this-&gt;applyType = pVariable-&gt;applyType;
        this-&gt;name = pVariable-&gt;name;
        this-&gt;units = pVariable-&gt;units;
        this-&gt;values = pVariable-&gt;values;
        this-&gt;variableData = pVariable-&gt;variableData;
    }
} /* RVariable::_init */


RVariableType RVariable::getType (void) const
{
    return this-&gt;type;
} /* RVariable::get_type */


</t>
<t tx="leo.20201108101539.65">void RVariable::setType (RVariableType type)
{
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type));
    this-&gt;type = type;
    this-&gt;setName(RVariable::getName(type));
    this-&gt;setUnits(RVariable::getUnits(type));
} /* RVariable::set_type */


RVariableApplyType RVariable::getApplyType (void) const
{
    return this-&gt;applyType;
} /* RVariable::get_apply_type */


</t>
<t tx="leo.20201108101539.66">void RVariable::setApplyType (RVariableApplyType type)
{
    R_ERROR_ASSERT (R_VARIABLE_APPLY_TYPE_IS_VALID (type));
    this-&gt;applyType = type;
} /* RVariable::set_apply_type */


</t>
<t tx="leo.20201108101539.67">const QString &amp;RVariable::getName(void) const
{
    return this-&gt;name;
} /* RVariable::get_name */


</t>
<t tx="leo.20201108101539.68">void RVariable::setName (const QString &amp;name)
{
    this-&gt;name = name;
} /* RVariable::set_name */


</t>
<t tx="leo.20201108101539.69">const QString &amp;RVariable::getUnits(void) const
{
    return this-&gt;units;
} /* RVariable::get_units */


</t>
<t tx="leo.20201108101539.7">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_time_solver.cpp                                      *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th June 2012                                          *
 *                                                                   *
 *  DESCRIPTION: Time-Solver class definition                        *
 *********************************************************************/

#include &lt;algorithm&gt;

#include &lt;rblib.h&gt;

#include "rml_time_solver.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101539.70">void RVariable::setUnits (const QString &amp;units)
{
    this-&gt;units = units;
} /* RVariable::set_units */


</t>
<t tx="leo.20201108101539.71">unsigned int RVariable::getNVectors (void) const
{
    return (unsigned int)this-&gt;values.size();
} /* RVariable::getNVectors */


</t>
<t tx="leo.20201108101539.72">unsigned int RVariable::getNValues (void) const
{
    if (this-&gt;getNVectors() &gt; 0)
    {
        return this-&gt;values[0].size();
    }
    else
    {
        return 0;
    }
} /* RVariable::getNValues */


</t>
<t tx="leo.20201108101539.73">void RVariable::clearValues(void)
{
    for (unsigned int i=0;i&lt;this-&gt;values.size();i++)
    {
        this-&gt;values[i].fill(0.0);
    }
} /* RVariable::clearValues */


</t>
<t tx="leo.20201108101539.74">void RVariable::resize (unsigned int nvectors,
                        unsigned int nvalues,
                        bool fillInitValues)
{
    this-&gt;values.resize (nvectors);
    for (unsigned int i=0;i&lt;nvectors;i++)
    {
        this-&gt;values[i].resize(nvalues);
        if (fillInitValues)
        {
            this-&gt;values[i].fill(RVariable::getInitValue(this-&gt;type));
        }
    }
} /* RVariable::resize */


double RVariable::getValue(unsigned int valpos) const
{
    R_ERROR_ASSERT (this-&gt;getNVectors() &gt; 0);
    R_ERROR_ASSERT (valpos &lt; this-&gt;getNValues());

    if (this-&gt;getNVectors() == 1)
    {
        return this-&gt;values[0][valpos];
    }
    else
    {
        double tmpValue = 0.0;
        for (unsigned int i=0;i&lt;this-&gt;getNVectors();i++)
        {
            tmpValue += this-&gt;getValue(i,valpos)*this-&gt;getValue(i,valpos);
        }
        return std::sqrt(tmpValue);
    }
} /* RVariable::getValue */


double RVariable::getValue (unsigned int vecpos,
</t>
<t tx="leo.20201108101539.75">                            unsigned int valpos) const
{
    R_ERROR_ASSERT (vecpos &lt; this-&gt;getNVectors ());
    R_ERROR_ASSERT (valpos &lt; this-&gt;getNValues ());
    return this-&gt;values[vecpos][valpos];
} /* RVariable::getValue */


RRVector RVariable::getValueVector(unsigned int valpos) const
{
    R_ERROR_ASSERT (valpos &lt; this-&gt;getNValues ());

    RRVector valueVector(this-&gt;getNVectors());

    for (unsigned int i=0;i&lt;this-&gt;getNVectors();i++)
    {
        valueVector[i] = this-&gt;getValue(i,valpos);
    }

    return valueVector;
} /* RVariable::getValueVector */


RRVector RVariable::getValues(void) const
{
    RRVector values(this-&gt;getNValues());

    for (unsigned int i=0;i&lt;this-&gt;getNValues();i++)
    {
        values[i] = this-&gt;getValue(i);
    }

    return values;
} /* RVariable::getValues */


RRVector RVariable::getValues(unsigned int vecpos) const
{
    R_ERROR_ASSERT (vecpos &lt; this-&gt;getNVectors());

    RRVector values(this-&gt;getNValues());

    for (unsigned int i=0;i&lt;this-&gt;getNValues();i++)
    {
        values[i] = this-&gt;getValue(vecpos,i);
    }

    return values;
}  /* RVariable::getValues */


double RVariable::getMinValue(void) const
{
    double minValue = 0.0;
    bool firstValue = true;

    for (unsigned int i=0;i&lt;this-&gt;getNValues();i++)
    {
        if (firstValue)
        {
            minValue = this-&gt;getValue(i);
            firstValue = false;
        }
        else
        {
            minValue = std::min(minValue,this-&gt;getValue(i));
        }
    }

    return minValue;
} /* RVariable::getMinValue */


double RVariable::getMinValue(unsigned int vecpos) const
{
    double minValue = 0.0;
    bool firstValue = true;

    for (unsigned int i=0;i&lt;this-&gt;getNValues();i++)
    {
        if (firstValue)
        {
            minValue = this-&gt;getValue(vecpos,i);
            firstValue = false;
        }
        else
        {
            minValue = std::min(minValue,this-&gt;getValue(vecpos,i));
        }
    }

    return minValue;
} /* RVariable::getMinValue */


double RVariable::getMaxValue(void) const
{
    double maxValue = 0.0;
    bool firstValue = true;

    for (unsigned int i=0;i&lt;this-&gt;getNValues();i++)
    {
        if (firstValue)
        {
            maxValue = this-&gt;getValue(i);
            firstValue = false;
        }
        else
        {
            maxValue = std::max(maxValue,this-&gt;getValue(i));
        }
    }

    return maxValue;
} /* RVariable::getMaxValue */


double RVariable::getMaxValue(unsigned int vecpos) const
{
    double maxValue = 0.0;
    bool firstValue = true;

    for (unsigned int i=0;i&lt;this-&gt;getNValues();i++)
    {
        if (firstValue)
        {
            maxValue = this-&gt;getValue(vecpos,i);
            firstValue = false;
        }
        else
        {
            maxValue = std::max(maxValue,this-&gt;getValue(vecpos,i));
        }
    }

    return maxValue;
} /* RVariable::getMaxValue */


</t>
<t tx="leo.20201108101539.76">void RVariable::setValue (unsigned int vecpos,
                          unsigned int valpos,
                          double       value)
{
    R_ERROR_ASSERT (vecpos &lt; this-&gt;getNVectors ());
    R_ERROR_ASSERT (valpos &lt; this-&gt;getNValues ());
    this-&gt;values[vecpos][valpos] = value;
} /* RVariable::setValue */


</t>
<t tx="leo.20201108101539.77">void RVariable::addValue (double value)
{
    std::vector&lt;RValueVector&gt;::iterator iter;

    for (iter = this-&gt;values.begin();
         iter != this-&gt;values.end();
         ++iter)
    {
        iter-&gt;add (value);
    }
} /* RVariable::addValue */


</t>
<t tx="leo.20201108101539.78">void RVariable::removeValue (unsigned int valpos)
{
    std::vector&lt;RValueVector&gt;::iterator iter;

    for (iter = this-&gt;values.begin();
         iter != this-&gt;values.end();
         ++iter)
    {
        iter-&gt;remove(valpos);
    }
} /* RVariable::removeValue */


</t>
<t tx="leo.20201108101539.79">void RVariable::removeValues(const std::vector&lt;uint&gt; &amp;valueBook)
{    std::vector&lt;RValueVector&gt;::iterator iter;

     for (iter = this-&gt;values.begin();
          iter != this-&gt;values.end();
          ++iter)
     {
         iter-&gt;remove(valueBook);
     }

} /* RVariable::removeValues */


</t>
<t tx="leo.20201108101539.8">static QString timeApproximationNames [R_TIME_MARCH_N_TYPES] =
{
    "Central difference (accurate)",
    "Backward difference (stable)",
    "Forward difference (fast)"
};

</t>
<t tx="leo.20201108101539.80">const RVariableData &amp;RVariable::getVariableData(void) const
{
    return this-&gt;variableData;
} /* RVariable::getVariableData */


RVariableData &amp;RVariable::getVariableData(void)
{
    return this-&gt;variableData;
} /* RVariable::getVariableData */


</t>
<t tx="leo.20201108101539.81">void RVariable::setVariableData(RVariableData &amp;variableData)
{
    this-&gt;variableData = variableData;
} /* RVariable::setVariableData */


RVariable &amp; RVariable::operator = (const RVariable &amp;variable)
{
    this-&gt;_init (&amp;variable);
    return (*this);
} /* RVariable::operator = */


</t>
<t tx="leo.20201108101539.82">const RValueVector &amp; RVariable::operator [] (unsigned int vecpos) const
{
    R_ERROR_ASSERT (vecpos &lt; this-&gt;getNVectors ());
    return this-&gt;values[vecpos];
} /* RVariable::operator [] */


RValueVector &amp; RVariable::operator [] (unsigned int vecpos)
{
    R_ERROR_ASSERT (vecpos &lt; this-&gt;getNVectors ());
    return this-&gt;values[vecpos];
} /* RVariable::operator [] */


RVariableType RVariable::getTypeFromId(const QString &amp;variableId)
{
    for (uint type=uint(R_VARIABLE_NONE);type&lt;uint(R_VARIABLE_N_TYPES);type++)
    {
        if (variableDesc[type].id == variableId)
        {
            return RVariableType(type);
        }
    }

    return R_VARIABLE_NONE;
} /* RVariable::getTypeFromId */


QString RVariable::getId(RVariableType type)
{
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type));
    return variableDesc[type].id;
} /* RVariable::getId */


</t>
<t tx="leo.20201108101539.83">const QString &amp;RVariable::getName(RVariableType type)
{
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type));
    return variableDesc[type].name;
} /* RVariable::getName */


</t>
<t tx="leo.20201108101539.84">const QString &amp;RVariable::getUnits(RVariableType type)
{
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type));
    return variableDesc[type].units;
} /* RVariable::getUnits */


double RVariable::getInitValue (RVariableType type)
{
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type));
    return variableDesc[type].value;
} /* RVariable::getInitValue */


RVariableDataType RVariable::getDataType(RVariableType type)
{
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type));
    return variableDesc[type].dataType;
} /* RVariable::getDataType */


RProblemTypeMask RVariable::getResultsProblemTypeMask(RVariableType type)
{
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type));
    return variableDesc[type].problemTypeMask;
} /* RVariable::getResultsProblemTypeMask */


</t>
<t tx="leo.20201108101539.85">const QString RVariable::guessVectorName(RVariableType type1,
                                              RVariableType type2,
                                              RVariableType type3)
{
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type1));
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type2));
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type3));

   if (RVariable::checkVectorTypes (type1,type2,type3,
                                    R_VARIABLE_ACCELERATION_X,
                                    R_VARIABLE_ACCELERATION_Y,
                                    R_VARIABLE_ACCELERATION_Z))
   {
       return RVariable::getName (R_VARIABLE_ACCELERATION);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_CURRENT_DENSITY_X,
                                         R_VARIABLE_CURRENT_DENSITY_Y,
                                         R_VARIABLE_CURRENT_DENSITY_Z))
   {
       return RVariable::getName (R_VARIABLE_CURRENT_DENSITY);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_DISPLACEMENT_X,
                                         R_VARIABLE_DISPLACEMENT_Y,
                                         R_VARIABLE_DISPLACEMENT_Z))
   {
       return RVariable::getName (R_VARIABLE_DISPLACEMENT);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_ELECTRIC_FIELD_X,
                                         R_VARIABLE_ELECTRIC_FIELD_Y,
                                         R_VARIABLE_ELECTRIC_FIELD_Z))
   {
       return RVariable::getName (R_VARIABLE_ELECTRIC_FIELD);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_FORCE_X,
                                         R_VARIABLE_FORCE_Y,
                                         R_VARIABLE_FORCE_Z))
   {
       return RVariable::getName (R_VARIABLE_FORCE);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_FORCE_UNIT_AREA_X,
                                         R_VARIABLE_FORCE_UNIT_AREA_Y,
                                         R_VARIABLE_FORCE_UNIT_AREA_Z))
   {
       return RVariable::getName (R_VARIABLE_FORCE_UNIT_AREA);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_G_ACCELERATION_X,
                                         R_VARIABLE_G_ACCELERATION_Y,
                                         R_VARIABLE_G_ACCELERATION_Z))
   {
       return RVariable::getName (R_VARIABLE_G_ACCELERATION);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_HEAT_FLUX_X,
                                         R_VARIABLE_HEAT_FLUX_Y,
                                         R_VARIABLE_HEAT_FLUX_Z))
   {
       return RVariable::getName (R_VARIABLE_HEAT_FLUX);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_MAGNETIC_FIELD_X,
                                         R_VARIABLE_MAGNETIC_FIELD_Y,
                                         R_VARIABLE_MAGNETIC_FIELD_Z))
   {
       return RVariable::getName (R_VARIABLE_MAGNETIC_FIELD);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_MASS_FLOW_RATE_X,
                                         R_VARIABLE_MASS_FLOW_RATE_Y,
                                         R_VARIABLE_MASS_FLOW_RATE_Z))
   {
       return RVariable::getName (R_VARIABLE_MASS_FLOW_RATE);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_STRESS_X,
                                         R_VARIABLE_STRESS_Y,
                                         R_VARIABLE_STRESS_Z))
   {
       return RVariable::getName (R_VARIABLE_STRESS_NORMAL);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_STRESS_XY,
                                         R_VARIABLE_STRESS_XZ,
                                         R_VARIABLE_STRESS_YZ))
   {
       return RVariable::getName (R_VARIABLE_STRESS_SHEAR);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_VELOCITY_X,
                                         R_VARIABLE_VELOCITY_Y,
                                         R_VARIABLE_VELOCITY_Z))
   {
       return RVariable::getName (R_VARIABLE_VELOCITY);
   }
   else
   {
       return "Vector";
   }
} /* RVariable::guessVectorName */

</t>
<t tx="leo.20201108101539.86">const QString RVariable::guessVectorUnits(RVariableType type1,
                                              RVariableType type2,
                                              RVariableType type3)
{
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type1));
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type2));
    R_ERROR_ASSERT (R_VARIABLE_TYPE_IS_VALID (type3));

   if (RVariable::checkVectorTypes (type1,type2,type3,
                                    R_VARIABLE_ACCELERATION_X,
                                    R_VARIABLE_ACCELERATION_Y,
                                    R_VARIABLE_ACCELERATION_Z))
   {
       return RVariable::getUnits (R_VARIABLE_ACCELERATION);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_CURRENT_DENSITY_X,
                                         R_VARIABLE_CURRENT_DENSITY_Y,
                                         R_VARIABLE_CURRENT_DENSITY_Z))
   {
       return RVariable::getUnits (R_VARIABLE_CURRENT_DENSITY);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_DISPLACEMENT_X,
                                         R_VARIABLE_DISPLACEMENT_Y,
                                         R_VARIABLE_DISPLACEMENT_Z))
   {
       return RVariable::getUnits (R_VARIABLE_DISPLACEMENT);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_ELECTRIC_FIELD_X,
                                         R_VARIABLE_ELECTRIC_FIELD_Y,
                                         R_VARIABLE_ELECTRIC_FIELD_Z))
   {
       return RVariable::getUnits (R_VARIABLE_ELECTRIC_FIELD);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_FORCE_X,
                                         R_VARIABLE_FORCE_Y,
                                         R_VARIABLE_FORCE_Z))
   {
       return RVariable::getUnits (R_VARIABLE_FORCE);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_FORCE_UNIT_AREA_X,
                                         R_VARIABLE_FORCE_UNIT_AREA_Y,
                                         R_VARIABLE_FORCE_UNIT_AREA_Z))
   {
       return RVariable::getUnits (R_VARIABLE_FORCE_UNIT_AREA);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_G_ACCELERATION_X,
                                         R_VARIABLE_G_ACCELERATION_Y,
                                         R_VARIABLE_G_ACCELERATION_Z))
   {
       return RVariable::getUnits (R_VARIABLE_G_ACCELERATION);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_HEAT_FLUX_X,
                                         R_VARIABLE_HEAT_FLUX_Y,
                                         R_VARIABLE_HEAT_FLUX_Z))
   {
       return RVariable::getUnits (R_VARIABLE_HEAT_FLUX);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_MAGNETIC_FIELD_X,
                                         R_VARIABLE_MAGNETIC_FIELD_Y,
                                         R_VARIABLE_MAGNETIC_FIELD_Z))
   {
       return RVariable::getUnits (R_VARIABLE_MAGNETIC_FIELD);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_MASS_FLOW_RATE_X,
                                         R_VARIABLE_MASS_FLOW_RATE_Y,
                                         R_VARIABLE_MASS_FLOW_RATE_Z))
   {
       return RVariable::getUnits (R_VARIABLE_MASS_FLOW_RATE);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_STRESS_X,
                                         R_VARIABLE_STRESS_Y,
                                         R_VARIABLE_STRESS_Z))
   {
       return RVariable::getUnits (R_VARIABLE_STRESS_NORMAL);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_STRESS_XY,
                                         R_VARIABLE_STRESS_XZ,
                                         R_VARIABLE_STRESS_YZ))
   {
       return RVariable::getUnits (R_VARIABLE_STRESS_SHEAR);
   }
   else if (RVariable::checkVectorTypes (type1,type2,type3,
                                         R_VARIABLE_VELOCITY_X,
                                         R_VARIABLE_VELOCITY_Y,
                                         R_VARIABLE_VELOCITY_Z))
   {
       return RVariable::getUnits (R_VARIABLE_VELOCITY);
   }
   else
   {
       return "Unknown";
   }
} /* RVariable::guessVectorUnits */


</t>
<t tx="leo.20201108101539.87">bool RVariable::checkVectorTypes(RVariableType typeA1,
                                 RVariableType typeA2,
                                 RVariableType typeA3,
                                 RVariableType typeB1,
                                 RVariableType typeB2,
                                 RVariableType typeB3)
{
    if ((typeA1 == typeB1 || typeA1 == typeB2 || typeA1 == typeB3) &amp;&amp;
        (typeA2 == typeB1 || typeA2 == typeB2 || typeA2 == typeB3)   )
    {
        if (typeA3 == R_VARIABLE_NONE)
        {
            return true;
        }
        else
        {
            if (typeA3 == typeB1 || typeA3 == typeB2 || typeA3 == typeB3)
            {
                return true;
            }
        }
    }
    return false;
} /* RVariable::checkVectorTypes */
</t>
<t tx="leo.20201108101539.88">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_variable_data.cpp                                    *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   18-th February 2013                                      *
 *                                                                   *
 *  DESCRIPTION: Variable data class definition                      *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "rml_variable_data.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101539.89">void RVariableData::_init(const RVariableData *pVariableData)
{
    if (pVariableData)
    {
        this-&gt;minDisplayValue = pVariableData-&gt;minDisplayValue;
        this-&gt;maxDisplayValue = pVariableData-&gt;maxDisplayValue;
        this-&gt;displayValueRange = pVariableData-&gt;displayValueRange;
        this-&gt;valueRangeName = pVariableData-&gt;valueRangeName;
        this-&gt;scale = pVariableData-&gt;scale;
    }
} /* RVariableData::_init */

RVariableData::RVariableData()
    : minDisplayValue(0.0)
    , maxDisplayValue(0.0)
    , displayValueRange(false)
    , scale(1.0)
{
    this-&gt;_init();
} /* RVariableData::RVariableData */


RVariableData::RVariableData(const RVariableData &amp;variableData)
{
    this-&gt;_init(&amp;variableData);
} /* RVariableData::RVariableData (copy) */


RVariableData::~RVariableData()
{
} /* RVariableData::~RVariableData */


RVariableData &amp;RVariableData::operator =(const RVariableData &amp;variableData)
{
    this-&gt;_init(&amp;variableData);
    return (*this);
} /* RVariableData::operator = */


double RVariableData::getMinDisplayValue(void) const
{
    return this-&gt;minDisplayValue;
} /* RVariableData::getMinDisplayValue */


double RVariableData::getMaxDisplayValue(void) const
{
    return this-&gt;maxDisplayValue;
} /* RVariableData::getMaxDisplayValue */


</t>
<t tx="leo.20201108101539.9">void RTimeSolver::_init(const RTimeSolver *pTimeSolver)
{
    if (pTimeSolver)
    {
        this-&gt;enabled = pTimeSolver-&gt;enabled;
        this-&gt;timeMarchApproximation = pTimeSolver-&gt;timeMarchApproximation;
        this-&gt;times = pTimeSolver-&gt;times;
        this-&gt;inputStartTime = pTimeSolver-&gt;inputStartTime;
        this-&gt;inputTimeStepSize = pTimeSolver-&gt;inputTimeStepSize;
        this-&gt;inputNTimeSteps = pTimeSolver-&gt;inputNTimeSteps;
        this-&gt;currentTimeStep = pTimeSolver-&gt;currentTimeStep;
        this-&gt;outputFrequency = pTimeSolver-&gt;outputFrequency;
        this-&gt;computedTime = pTimeSolver-&gt;computedTime;
    }
} /* RTimeSolver::_init */

</t>
<t tx="leo.20201108101539.90">void RVariableData::setMinMaxDisplayValue(double minDisplayValue, double maxDisplayValue)
{
    R_ERROR_ASSERT(minDisplayValue &lt;= maxDisplayValue);
    this-&gt;minDisplayValue = minDisplayValue;
    this-&gt;maxDisplayValue = maxDisplayValue;
} /* RVariableData::setMinMaxDisplayValue */


</t>
<t tx="leo.20201108101539.91">bool RVariableData::getDisplayValueRange(void) const
{
    return this-&gt;displayValueRange;
} /* RVariableData::getDisplayValueRange */


</t>
<t tx="leo.20201108101539.92">void RVariableData::setDisplayValueRange(bool displayValueRange)
{
    this-&gt;displayValueRange = displayValueRange;
} /* RVariableData::setDisplayValueRange */


</t>
<t tx="leo.20201108101539.93">const QString &amp;RVariableData::getValueRangeName(void) const
{
    return this-&gt;valueRangeName;
} /* RVariableData::getValueRangeName */


</t>
<t tx="leo.20201108101539.94">void RVariableData::setValueRangeName(const QString &amp;valueRangeName)
{
    this-&gt;valueRangeName = valueRangeName;
} /* RVariableData::setValueRangeName */


double RVariableData::getScale(void) const
{
    return this-&gt;scale;
} /* RVariableData::getScale */


</t>
<t tx="leo.20201108101539.95">void RVariableData::setScale(double scale)
{
    this-&gt;scale = scale;
} /* RVariableData::setScale */
</t>
<t tx="leo.20201108101539.96">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_vector_field.cpp                                     *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   13-th May 2013                                           *
 *                                                                   *
 *  DESCRIPTION: Vector field class definition                       *
 *********************************************************************/

#include "rml_vector_field.h"

const QString RVectorField::defaultName("Vector field");

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101539.97">void RVectorField::_init(const RVectorField *pVectorField)
{
    if (pVectorField)
    {
        this-&gt;variableType = pVectorField-&gt;variableType;
        this-&gt;type3d = pVectorField-&gt;type3d;
        this-&gt;elementGroupIDs = pVectorField-&gt;elementGroupIDs;
    }
}

RVectorField::RVectorField()
    : variableType(R_VARIABLE_NONE)
    , type3d(true)
{
    this-&gt;name = RVectorField::defaultName;
    this-&gt;_init();
}

RVectorField::RVectorField(const RVectorField &amp;vectorField) :
    REntityGroup(vectorField)
{
    this-&gt;_init(&amp;vectorField);
}

RVectorField::~RVectorField()
{
}

RVectorField &amp;RVectorField::operator =(const RVectorField &amp;vectorField)
{
    this-&gt;REntityGroup::operator = (vectorField);
    this-&gt;_init(&amp;vectorField);
    return (*this);
}

RVariableType RVectorField::getVariableType(void) const
{
    return this-&gt;variableType;
}

</t>
<t tx="leo.20201108101539.98">void RVectorField::setVariableType(RVariableType variableType)
{
    this-&gt;variableType = variableType;
}

</t>
<t tx="leo.20201108101539.99">bool RVectorField::getType3D(void) const
{
    return this-&gt;type3d;
}

</t>
<t tx="leo.20201108101540.1">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_view_factor_row.cpp                                  *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   15-th July 2014                                          *
 *                                                                   *
 *  DESCRIPTION: View-Factor row class definition                    *
 *********************************************************************/

#include "rml_view_factor_row.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101540.10">@path ./RangeSolver/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   command_processor.cpp                                    *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th August 2013                                        *
 *                                                                   *
 *  DESCRIPTION: Command processor class definition                  *
 *********************************************************************/

#include &lt;QDataStream&gt;

#include &lt;rblib.h&gt;

#include "command_processor.h"

CommandProcessor::CommandProcessor(const QString &amp;taskServer, const QString &amp;taskID, QCoreApplication *application)
    : QObject(application)
    , localSocket(new QLocalSocket(this))
    , taskServer(taskServer)
    , taskID(taskID)
{
    if (!this-&gt;taskServer.isEmpty() &amp;&amp; !this-&gt;taskID.isEmpty())
    {
        this-&gt;start();
    }
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101540.11">void CommandProcessor::start(void)
{
    this-&gt;localSocket-&gt;connectToServer(taskServer);
    if (!this-&gt;localSocket-&gt;waitForConnected())
    {
        RLogger::error("Failed to connect to: %s\n",taskServer.toUtf8().constData());
    }
    RLogger::info("Connected to: %s\n",this-&gt;localSocket-&gt;serverName().toUtf8().constData());
    QObject::connect(this-&gt;localSocket, &amp;QLocalSocket::readyRead, this, &amp;CommandProcessor::readSocket);
}

</t>
<t tx="leo.20201108101540.12">void CommandProcessor::stop(void)
{
    this-&gt;localSocket-&gt;disconnectFromServer();
}

</t>
<t tx="leo.20201108101540.13">void CommandProcessor::readSocket(void)
{
    if (this-&gt;localSocket-&gt;bytesAvailable() &lt; (int)sizeof(quint32))
    {
        return;
    }
    QDataStream in;
    in.setDevice(this-&gt;localSocket);
    in.setVersion(QDataStream::Qt_5_6);
    quint32 blockSize;
    in &gt;&gt; blockSize;
    if (this-&gt;localSocket-&gt;bytesAvailable() &lt; blockSize || in.atEnd())
    {
        return;
    }
    QString message;
    in &gt;&gt; message;
    RLogger::info("Received command: \'%s\'\n",message.toUtf8().constData());
    if (message.contains(this-&gt;taskID + ":STOP"))
    {
        RApplicationState::getInstance().setStateType(R_APPLICATION_STATE_STOP);
    }
}
</t>
<t tx="leo.20201108101540.14">@path ./RangeSolver/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   main.cpp                                                 *
 *  GROUP:  RangeSolver                                              *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th July 2013                                          *
 *                                                                   *
 *  DESCRIPTION: Main function                                       *
 *********************************************************************/

#include &lt;QLocale&gt;

#include &lt;rblib.h&gt;

#include "application.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101540.15">int main(int argc, char *argv[])
{
    RArgumentsParser::printHeader("Solver");

    QLocale::setDefault(QLocale::c());

    int exitValue = 0;
    if ((exitValue = Application(argc, argv).exec()) != 0)
    {
        RLogger::info("Application has terminated with error code (%d).\n", exitValue);
    }

    RArgumentsParser::printFooter();
    return exitValue;
} /* main */
</t>
<t tx="leo.20201108101540.16">@path ./RangeSolver/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   main_task.cpp                                            *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th August 2013                                        *
 *                                                                   *
 *  DESCRIPTION: Main task class definition                          *
 *********************************************************************/

#include &lt;QCoreApplication&gt;
#include &lt;QSettings&gt;

#include &lt;rblib.h&gt;

#include "main_task.h"
#include "solver_task.h"
#include "command_processor.h"

MainTask::MainTask(QObject *parent) :
    QObject(parent)
{
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101540.17">void MainTask::run(void)
{
    QCoreApplication *application = (QCoreApplication*)this-&gt;parent();

    QSettings settings(RVendor::name, RVendor::shortName);

    try
    {
        QString rangeAccount = settings.value("application/rangeAccount").toString();
        QString rangePassword = settings.value("application/rangePassword").toString();

        // Process command line arguments.
        QList&lt;RArgumentOption&gt; validOptions;
        validOptions.append(RArgumentOption("file",RArgumentOption::Path,QVariant(),"File name",true,false));
        validOptions.append(RArgumentOption("log-file",RArgumentOption::Path,QVariant(),"Log file name",false,false));
        validOptions.append(RArgumentOption("convergence-file",RArgumentOption::Path,QVariant(),"Convergence file name",false,false));
        validOptions.append(RArgumentOption("monitoring-file",RArgumentOption::Path,QVariant(),"Monitoring file name",false,false));
        validOptions.append(RArgumentOption("nthreads",RArgumentOption::Integer,QVariant(1),"Number of threads to use",false,false));
        validOptions.append(RArgumentOption("restart",RArgumentOption::Switch,QVariant(),"Restart solver",false,false));
        validOptions.append(RArgumentOption("task-id",RArgumentOption::Path,QVariant(),"Task ID for inter process communication",false,false));
        validOptions.append(RArgumentOption("task-server",RArgumentOption::Path,QVariant(),"Task server for inter process communication",false,false));

        RArgumentsParser argumentsParser(QCoreApplication::arguments(),validOptions,false);

        if (argumentsParser.isSet("help"))
        {
            argumentsParser.printHelp();
            application-&gt;exit(0);
            return;
        }

        if (argumentsParser.isSet("version"))
        {
            argumentsParser.printVersion();
            application-&gt;exit(0);
            return;
        }

        if (argumentsParser.isSet("log-file"))
        {
            RLogger::getInstance().setFile(argumentsParser.getValue("log-file").toString());
        }

        // Command processor.
        new CommandProcessor(argumentsParser.getValue("task-server").toString(),
                             argumentsParser.getValue("task-id").toString(),
                             application);

        SolverInput solverInput(argumentsParser.getValue("file").toString());
        if (argumentsParser.isSet("convergence-file"))
        {
            solverInput.setConvergenceFileName(argumentsParser.getValue("convergence-file").toString());
        }
        if (argumentsParser.isSet("monitoring-file"))
        {
            solverInput.setMonitoringFileName(argumentsParser.getValue("monitoring-file").toString());
        }
        if (argumentsParser.isSet("nthreads"))
        {
            solverInput.setNThreads(argumentsParser.getValue("nthreads").toUInt());
        }
        if (argumentsParser.isSet("restart"))
        {
            solverInput.setRestart(true);
        }

        // Start solver.
        QThread* thread = new QThread;
        SolverTask *solverTask = new SolverTask(solverInput, application);

        solverTask-&gt;moveToThread(thread);

        QObject::connect(thread, &amp;QThread::started, solverTask, &amp;SolverTask::run);
        QObject::connect(solverTask, &amp;SolverTask::finished, solverTask, &amp;SolverTask::deleteLater);
        QObject::connect(solverTask, &amp;SolverTask::destroyed, thread, &amp;QThread::quit);
        QObject::connect(thread, &amp;QThread::finished, thread, &amp;QThread::deleteLater);
        QObject::connect(thread, &amp;QThread::finished, application, &amp;QCoreApplication::quit);

        thread-&gt;start();
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to start solver. %s\n",error.getMessage().toUtf8().constData());
        application-&gt;exit(1);
    }
}
</t>
<t tx="leo.20201108101540.18">@path ./RangeSolver/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   solver_input.cpp                                         *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   5-th February 2014                                       *
 *                                                                   *
 *  DESCRIPTION: Solver input class definition                       *
 *********************************************************************/

#include "solver_input.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101540.19">void SolverInput::_init(const SolverInput *pSolverInput)
{
    if (pSolverInput)
    {
        this-&gt;modelFileName = pSolverInput-&gt;modelFileName;
        this-&gt;convergenceFileName = pSolverInput-&gt;convergenceFileName;
        this-&gt;restart = pSolverInput-&gt;restart;
    }
}

SolverInput::SolverInput(const QString &amp;modelFileName)
    : modelFileName(modelFileName)
    , restart(false)
{
    this-&gt;_init();
}

SolverInput::SolverInput(const SolverInput &amp;solverInput)
{
    this-&gt;_init(&amp;solverInput);
}

SolverInput::~SolverInput()
{

}

SolverInput &amp;SolverInput::operator =(const SolverInput &amp;solverInput)
{
    this-&gt;_init(&amp;solverInput);
    return (*this);
}

</t>
<t tx="leo.20201108101540.2">void RViewFactorRow::_init(const RViewFactorRow *pViewFactorRow)
{
    if (pViewFactorRow)
    {
        this-&gt;viewFactors = pViewFactorRow-&gt;viewFactors;
    }
}

RViewFactorRow::RViewFactorRow()
{
    this-&gt;_init();
}

RViewFactorRow::RViewFactorRow(const RViewFactorRow &amp;viewFactorRow)
{
    this-&gt;_init(&amp;viewFactorRow);
}

RViewFactorRow::~RViewFactorRow()
{

}

RViewFactorRow &amp;RViewFactorRow::operator =(const RViewFactorRow &amp;viewFactorRow)
{
    this-&gt;_init(&amp;viewFactorRow);
    return (*this);
}

</t>
<t tx="leo.20201108101540.20">void SolverInput::setConvergenceFileName(const QString &amp;convergenceFileName)
{
    this-&gt;convergenceFileName = convergenceFileName;
}

</t>
<t tx="leo.20201108101540.21">void SolverInput::setMonitoringFileName(const QString &amp;monitoringFileName)
{
    this-&gt;monitoringFileName = monitoringFileName;
}

</t>
<t tx="leo.20201108101540.22">void SolverInput::setNThreads(uint nThreads)
{
    this-&gt;nThreads = nThreads;
}

</t>
<t tx="leo.20201108101540.23">void SolverInput::setRestart(bool restart)
{
    this-&gt;restart = restart;
}
</t>
<t tx="leo.20201108101540.24">@path ./RangeSolver/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   solver_task.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   25-th August 2013                                        *
 *                                                                   *
 *  DESCRIPTION: Solver task class definition                        *
 *********************************************************************/

#include &lt;omp.h&gt;

#include &lt;algorithm&gt;

#include &lt;rmlib.h&gt;
#include &lt;rsolverlib.h&gt;

#include "solver_task.h"

SolverTask::SolverTask(const SolverInput &amp;solverInput, QCoreApplication *app, QObject *parent)
    : QObject(parent)
    , modelFileName(solverInput.modelFileName)
    , convergenceFileName(solverInput.convergenceFileName)
    , monitoringFileName(solverInput.monitoringFileName)
    , nThreads(solverInput.nThreads)
    , restart(solverInput.restart)
    , app(app)
{
    this-&gt;nThreads = std::max(this-&gt;nThreads,uint(1));
    this-&gt;nThreads = std::min(this-&gt;nThreads,uint(omp_get_max_threads()));
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101540.25">void SolverTask::run(void)
{
    RLogger::info("Threads = %u (max=%d)\n", this-&gt;nThreads, omp_get_max_threads());
    omp_set_num_threads(this-&gt;nThreads);

    RModel model;

    // Load model
    try
    {
        model.read(this-&gt;modelFileName);
        RLogger::info("Model has been successfully loaded from file \'%s\'.\n", this-&gt;modelFileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to load model from file \'%s\'. %s\n", this-&gt;modelFileName.toUtf8().constData(), error.getMessage().toUtf8().constData());

        emit this-&gt;finished();
        this-&gt;app-&gt;exit(1);
        return;
    }

    model.getMatrixSolverConf(RMatrixSolverConf::CG).setOutputFileName(RFileManager::getFileNameWithSuffix(this-&gt;convergenceFileName,RMatrixSolverConf::getId(RMatrixSolverConf::CG)));
    model.getMatrixSolverConf(RMatrixSolverConf::GMRES).setOutputFileName(RFileManager::getFileNameWithSuffix(this-&gt;convergenceFileName,RMatrixSolverConf::getId(RMatrixSolverConf::GMRES)));
    model.getMonitoringPointManager().setOutputFileName(this-&gt;monitoringFileName);
    if (this-&gt;restart)
    {
        model.getProblemSetup().setRestart(true);
    }

    // Solve model
    try
    {
        RLogger::info("\n");
        RLogger::info("********* SOLVER - BEGIN *********\n");
        RLogger::info("\n");
        RLogger::indent();
        RSolver solver(model,this-&gt;modelFileName,this-&gt;convergenceFileName);
        solver.run();
        RLogger::unindent();
        RLogger::info("\n");
        RLogger::info("********** SOLVER - END **********\n");
        RLogger::info("\n");
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        RLogger::error("Failed to solve model from file \'%s\'. %s\n", this-&gt;modelFileName.toUtf8().constData(), error.getMessage().toUtf8().constData());

        emit this-&gt;finished();
        this-&gt;app-&gt;exit(1);
        return;
    }

    // Save model
    try
    {
        this-&gt;modelFileName = model.write(this-&gt;modelFileName);
        RLogger::info("Model has been successfully saved to file \'%s\'.\n", this-&gt;modelFileName.toUtf8().constData());
    }
    catch (const RError &amp;error)
    {
        RLogger::error("Failed to save model to file \'%s\'. %s\n", this-&gt;modelFileName.toUtf8().constData(), error.getMessage().toUtf8().constData());

        emit this-&gt;finished();
        this-&gt;app-&gt;exit(1);
        return;
    }

    emit this-&gt;finished();
}
</t>
<t tx="leo.20201108101540.26"></t>
<t tx="leo.20201108101540.3">const RSparseVector&lt;double&gt; &amp;RViewFactorRow::getViewFactors(void) const
{
    return this-&gt;viewFactors;
}

RSparseVector&lt;double&gt; &amp;RViewFactorRow::getViewFactors(void)
{
    return this-&gt;viewFactors;
}
</t>
<t tx="leo.20201108101540.4">@path ./RangeModel/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rml_volume.cpp                                           *
 *  GROUP:  RML                                                      *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   8-th December 2011                                       *
 *                                                                   *
 *  DESCRIPTION: Volume class definition                             *
 *********************************************************************/

#include "rml_element.h"
#include "rml_volume.h"

const QString RVolume::defaultName("Volume");


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101540.5">void RVolume::_init (const RVolume *pVolume)
{
    if (pVolume)
    {
    }
} /* RVolume::_init */


RVolume::RVolume ()
{
    this-&gt;name = RVolume::defaultName;
    this-&gt;_init ();
} /* RVolume::RVolume */


RVolume::RVolume (const RVolume &amp;volume) : RElementGroup (volume)
{
    this-&gt;_init (&amp;volume);
} /* RVolume::RVolume */


RVolume::~RVolume ()
{
} /* RVolume::~RVolume */

double RVolume::findVolume(const std::vector&lt;RNode&gt; &amp;nodes, const std::vector&lt;RElement&gt; &amp;elements) const
{
    double totalVolume = 0.0;

    for (uint i=0;i&lt;this-&gt;size();i++)
    {
        const RElement &amp;rElement = elements[this-&gt;get(i)];

        double elementVolume = 0.0;
        if (rElement.findVolume(nodes,elementVolume))
        {
            totalVolume += elementVolume;
        }
    }

    return totalVolume;
} /* RVolume::findVolume */


RVolume &amp; RVolume::operator = (const RVolume &amp;volume)
{
    this-&gt;RElementGroup::operator = (volume);
    this-&gt;_init (&amp;volume);
    return (*this);
} /* RVolume::operator = */

</t>
<t tx="leo.20201108101540.6"></t>
<t tx="leo.20201108101540.7"></t>
<t tx="leo.20201108101540.8">@path ./RangeSolver/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   application.cpp                                          *
 *  GROUP:  Range                                                    *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th July 2013                                          *
 *                                                                   *
 *  DESCRIPTION: Application class definition                        *
 *********************************************************************/

#include &lt;QTimer&gt;

#include "application.h"
#include "main_task.h"

Application::Application(int &amp;argc, char **argv) :
    QCoreApplication(argc,argv)
{
    // Needed for printf functions family to work correctly.
    setlocale(LC_ALL,"C");

    QObject::connect(this,&amp;Application::started,this,&amp;Application::onStarted);

    QTimer::singleShot(0, this, SIGNAL(started()));
}

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101540.9">void Application::onStarted(void)
{
    MainTask *mainTask = new MainTask(this);
    QTimer::singleShot(0, mainTask, SLOT(run()));
}
</t>
<t tx="leo.20201108101541.1"></t>
<t tx="leo.20201108101541.10">void RConvection::setVelocity(double v)
{
    this-&gt;v = v;
}

</t>
<t tx="leo.20201108101541.11">void RConvection::setGravity(double g)
{
    this-&gt;g = g;
}

</t>
<t tx="leo.20201108101541.12">void RConvection::setSurfTemp(double Ts)
{
    this-&gt;Ts = Ts;
}

</t>
<t tx="leo.20201108101541.13">void RConvection::setFluidTemp(double Tf)
{
    this-&gt;Tf = Tf;
}

double RConvection::calculateGr(void) const
{
    if (this-&gt;mu == 0.0)
    {
        return 0.0;
    }
    return std::abs(pow(this-&gt;ro,2.0) * this-&gt;g * this-&gt;b * (this-&gt;Ts - this-&gt;Tf) * pow(this-&gt;d,3.0) / pow(this-&gt;mu,2.0));
}

double RConvection::calculateRa(void) const
{
    return this-&gt;calculateGr() * this-&gt;calculatePr();
}

double RConvection::calculateRe(void) const
{
    if (this-&gt;mu == 0.0)
    {
        return 0.0;
    }
    return this-&gt;ro * this-&gt;v * this-&gt;d / this-&gt;mu;
}

double RConvection::calculatePr(void) const
{
    if (this-&gt;k == 0.0)
    {
        return 0.0;
    }
    return this-&gt;c * this-&gt;mu / this-&gt;k;
}

double RConvection::calculateNu(void) const
{
    double Nu = 0.0;
    double Ra = 0.0;
    double Re = 0.0;
    double Pr = 0.0;

    if (RConvection::isNatural(this-&gt;type))
    {
        Ra = this-&gt;calculateRa();
        if (Ra &lt;= 0.0)
        {
            return 1.0;
        }
    }
    if (RConvection::isForced(this-&gt;type))
    {
        Re = this-&gt;calculateRe();
    }
    Pr = this-&gt;calculatePr();

    if (Pr == 0.0)
    {
        return 0.0;
    }

    if (RConvection::isForced(this-&gt;type))
    {
        if (Re == 0.0)
        {
            return 0.0;
        }
    }

    switch (this-&gt;type)
    {
        case R_CONVECTION_NATURAL_EXTERNAL_VERTICAL_PLANE:
        case R_CONVECTION_NATURAL_EXTERNAL_VERTICAL_CYLINDER:
            if (Ra &lt;= 1.0e-9)
            {
                Nu = 0.68 + (0.67*pow(Ra,1.0/4.0))/pow(1.0 + pow(0.492/Pr, 9.0/16.0),4.0/9.0);
            }
            else
            {
                Nu = pow (0.825 + (0.387*pow(Ra,1.0/6.0))/pow(1.0 + pow(0.492/Pr, 9.0/16.0),8.0/27.0), 2.0);
            }
            break;
        case R_CONVECTION_NATURAL_EXTERNAL_HORIZONTAL_PLATES:
            if (Ra &lt; 1.0e5)
            {
                /* Not really correct */
                Nu = 0.54*pow(Ra,1.0/4.0);
            }
            else if (1.0e5 &lt;= Ra &amp;&amp; Ra &lt; 2.0e7)
            {
                Nu = 0.54*pow(Ra,1.0/4.0);
            }
            else if (2.0e7 &lt;= Ra &amp;&amp; Ra &lt; 3.0e10)
            {
                Nu = 0.14*pow(Ra,1.0/3.0);
            }
            else if (3.0e5 &lt;= Ra &amp;&amp; Ra &lt; 1.0e10)
            {
                Nu = 0.27*pow(Ra,1.0/3.0);
            }
            else
            {
                /* Not really correct */
                Nu = 0.27*pow(Ra,1.0/3.0);
            }
            break;
        case R_CONVECTION_NATURAL_EXTERNAL_HORIZONTAL_CYLINDER:
            Nu = pow (0.6 + (0.387*pow(Ra,1.0/6.0))/pow(1.0 + pow(0.559/Pr, 9.0/16.0),8.0/27.0), 2.0);
            break;
        case R_CONVECTION_NATURAL_EXTERNAL_SPHERES:
            Nu = 2.0 + 0.43*pow(Ra,1.0/4.0);
            break;
        case R_CONVECTION_FORCED_INTERNAL_LAMINAR:
            Nu = 1.86 / pow(Re*Pr,2.0/3.0);
            break;
        case R_CONVECTION_FORCED_INTERNAL_TURBULENT:
            Nu = 0.023 * pow(Re,0.8) * pow(Pr,0.4);
            break;
        case R_CONVECTION_FORCED_EXTERNAL:
            Nu = 0.036 * pow(Re,4.0/5.0) * pow(Pr,1.0/3.0);
            break;
        default:
            Nu = 0.0;
            break;
    }

    return Nu;
}

double RConvection::calculateHtc(void) const
{
    if (this-&gt;d == 0.0)
    {
        return 0.0;
    }
    return this-&gt;calculateNu() * this-&gt;k / this-&gt;d;
}

</t>
<t tx="leo.20201108101541.14">const QString &amp;RConvection::getName(RConvectionType type)
{
    return convectionDesc[type].description;
}

</t>
<t tx="leo.20201108101541.15">bool RConvection::isNatural(RConvectionType type)
{
    return convectionDesc[type].natural;
}

</t>
<t tx="leo.20201108101541.16">bool RConvection::isForced(RConvectionType type)
{
    return !convectionDesc[type].natural;
}
</t>
<t tx="leo.20201108101541.17">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   reigenvaluesolver.cpp                                    *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   1-st July 2015                                           *
 *                                                                   *
 *  DESCRIPTION: Eigen value solver class definition                 *
 *********************************************************************/

#include &lt;cmath&gt;

#include "reigenvaluesolver.h"

#define R_EIS_PYTHAG(a,b) (std::sqrt (a*a + b*b))
#define R_ASSERT(_condition) { if (!(_condition)) { RLogger::unindent(); R_ERROR_ASSERT(_condition); } }

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.18">void REigenValueSolver::_init(const REigenValueSolver *pEigenValueSolver)
{
    if (pEigenValueSolver)
    {
        this-&gt;eigenValueSolverConf = pEigenValueSolver-&gt;eigenValueSolverConf;
        this-&gt;matrixSolverConf = pEigenValueSolver-&gt;matrixSolverConf;
    }
}

REigenValueSolver::REigenValueSolver(const REigenValueSolverConf &amp;eigenValueSolverConf, const RMatrixSolverConf &amp;matrixSolverConf)
    : eigenValueSolverConf(eigenValueSolverConf)
    , matrixSolverConf(matrixSolverConf)
{
    this-&gt;_init();
}

REigenValueSolver::REigenValueSolver(const REigenValueSolver &amp;eigenValueSolver)
{
    this-&gt;_init(&amp;eigenValueSolver);
}

REigenValueSolver::~REigenValueSolver()
{

}

REigenValueSolver &amp;REigenValueSolver::operator =(const REigenValueSolver &amp;eigenValueSolver)
{
    this-&gt;_init(&amp;eigenValueSolver);
    return (*this);
}

</t>
<t tx="leo.20201108101541.19">void REigenValueSolver::solve(const RSparseMatrix &amp;M, const RSparseMatrix &amp;K, RRVector &amp;d, RRMatrix &amp;ev)
{
    switch (this-&gt;eigenValueSolverConf.method)
    {
        case REigenValueSolverConf::Lanczos:
        {
            // Find multiple eigen values.
            try
            {
                this-&gt;solveLanczos(M,K,d);
            }
            catch (const RError &amp;error)
            {
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Lanczos method failed. %s",error.getMessage().toUtf8().constData());
            }
            break;
        }
        case REigenValueSolverConf::Arnoldi:
        {
            // Find multiple eigen values.
            try
            {
                this-&gt;solveArnoldi(M,K,d,ev);
            }
            catch (const RError &amp;error)
            {
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Arnoldi method failed. %s",error.getMessage().toUtf8().constData());
            }
            break;
        }
        case REigenValueSolverConf::Rayleigh:
        {
            // Find one (most dominant) eigen value.
            try
            {
                this-&gt;solveRayleigh(M,K,d,ev);
            }
            catch (const RError &amp;error)
            {
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Rayleigh method failed. %s",error.getMessage().toUtf8().constData());
            }
            break;
        }
        default:
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Unknown eigen-value solver method.");
        }
    }

    if (d.getNRows() &gt; 1)
    {
        try
        {
            for (uint i=0;i&lt;d.getNRows();i++)
            {
                d[i] = std::fabs(1.0/d[i]);
            }
            std::vector&lt;uint&gt; indexes;
            std::swap(d[0],d[1]);
            RUtil::qSort(d,indexes);

            for (uint i=0;i&lt;ev.getNRows();i++)
            {
                uint n1 = i;
                uint n2 = indexes[i];
                for (uint j=0;j&lt;ev.getNColumns();j++)
                {
                    std::swap(ev[n1][j],ev[n2][j]);
                }
                indexes[n2] = n2;
            }
        }
        catch (const RError &amp;error)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to reorder eigen values and vectors. %s",error.getMessage().toUtf8().constData());
        }
    }
}

</t>
<t tx="leo.20201108101541.2">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rconvection.cpp                                          *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   21-st January 2013                                       *
 *                                                                   *
 *  DESCRIPTION: Convection coefficient calculator class definition  *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rconvection.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.20">void REigenValueSolver::solveLanczos(const RSparseMatrix &amp;M, const RSparseMatrix &amp;K, RRVector &amp;d)
{
    RRVector e;
    RRVector v(M.getNRows(),0.0);
    RRVector vo(M.getNRows(),0.0);
    RRVector w(M.getNRows(),0.0);

    for (uint i=0;i&lt;M.getNRows();i++)
    {
        v[i] = double(std::rand()) / double(RAND_MAX);
    }
    v.normalize();

    RMatrixSolver solver(this-&gt;matrixSolverConf);

    uint ne = std::min(this-&gt;eigenValueSolverConf.getNEigenValues(),K.getNRows());

    d.resize(ne,0.0);
    e.resize(ne,0.0);

    // Lanczos iteration
    for (uint i=0;i&lt;ne;i++)
    {
        RLogger::info("Lanczos iteration %u of %u\n",i+1,ne);
        RLogger::indent();

        // w = A*v - e(i)*vo
        // w = (M/K)*v - e(i)*vo
        // K*w = M*v - K*e(i)*vo

        RRVector b;

        RSparseMatrix::mlt(M,v,b);

        if (i &gt; 0)
        {
            RRVector bTmp;
            RSparseMatrix::mlt(K,vo,bTmp);
            bTmp *= e[i];
            for (uint j=0;j&lt;b.size();j++)
            {
                b[j] -= bTmp[j];
            }
        }

        try
        {
            solver.solve(K,b,w,R_MATRIX_PRECONDITIONER_JACOBI);
        }
        catch (const RError &amp;error)
        {
            RLogger::unindent();
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to solve matrix system. %s", error.getMessage().toUtf8().constData());
        }

        // d(i) = w dot v
        d[i] = RRVector::dot(w,v);

        if (i+1 &lt; ne)
        {
            // w = w - d(i)*v
            for (uint j=0;j&lt;w.size();j++)
            {
                w[j] -= d[i] * v[j];
            }

            // e(i+1) = || w ||
            e[i+1] = RRVector::norm(w);
            R_ASSERT(e[i+1] != 0.0);

            // vo = v
            vo = v;

            // v = w / e(i+1)
            for (uint j=0;j&lt;v.size();j++)
            {
                v[j] = w[j] / e[i+1];
            }
        }
        RLogger::unindent();
    }

    try
    {
        REigenValueSolver::qlDecomposition(d,e);
    }
    catch (const RError &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"QL decomposition failed. %s",error.getMessage().toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101541.21">void REigenValueSolver::solveArnoldi(const RSparseMatrix &amp;M, const RSparseMatrix &amp;K, RRVector &amp;d, RRMatrix &amp;ev)
{
    uint ne = std::min(this-&gt;eigenValueSolverConf.getNEigenValues(),K.getNRows());
    uint n = M.getNRows();

    RRMatrix H(ne,ne,0.0);
    RRMatrix Qa(n,ne,0.0);
    RRMatrix Qq;
    RRVector q(n), qo(n);

    // generate random normalized vector
    for (uint i=0;i&lt;n;i++)
    {
        q[i] = double(rand()) / double(RAND_MAX);
    }
    R_ERROR_ASSERT(q.normalize() != 0.0);
    for (uint i=0;i&lt;n;i++)
    {
        Qa[i][0] = q[i];
    }

    RMatrixSolver solver(this-&gt;matrixSolverConf);

    // Arnoldi iteration
    for (uint i=1;i&lt;ne+1;i++)
    {
        RLogger::info("Arnoldi iteration %u of %u\n",i,ne);
        RLogger::indent();

        for (uint j=0;j&lt;n;j++)
        {
            qo[j] = Qa[j][i-1];
        }

        // K*q = M*qo
        RRVector f;
        RSparseMatrix::mlt(M,qo,f);
        try
        {
            solver.solve(K,f,q,R_MATRIX_PRECONDITIONER_JACOBI);
        }
        catch (const RError &amp;error)
        {
            RLogger::unindent();
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to solve matrix system. %s", error.getMessage().toUtf8().constData());
        }

        for (uint j=0;j&lt;i;j++)
        {
            for (uint k=0;k&lt;n;k++)
            {
                qo[k] = Qa[k][j];
            }
            H[j][i-1] = RRVector::dot(qo,q);
            for (uint k=0;k&lt;n;k++)
            {
                q[k] -= H[j][i-1] * qo[k];
            }
        }
        if (i &lt; ne)
        {
            H[i][i-1] = RRVector::norm(q);
            R_ASSERT(H[i][i-1] != 0.0);
            for (uint j=0;j&lt;n;j++)
            {
                Qa[j][i] = q[j] / H[i][i-1];
            }
        }
        RLogger::unindent();
    }

    try
    {
        REigenValueSolver::qrDecomposition(H,this-&gt;eigenValueSolverConf.getNIterations(),this-&gt;eigenValueSolverConf.getSolverCvgValue(),d,Qq);
    }
    catch (const RError &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"QR decomposition failed. %s",error.getMessage().toUtf8().constData());
    }

    RRMatrix::mlt(Qa,Qq,ev);
    ev.transpose();
}

</t>
<t tx="leo.20201108101541.22">void REigenValueSolver::solveRayleigh(const RSparseMatrix &amp;M, const RSparseMatrix &amp;K, RRVector &amp;e, RRMatrix &amp;ev)
{
    RSparseMatrix M2(M);
    uint n = M2.getNRows();

    e.resize(1,0.0);
    ev.resize(1,n,0.0);

    RRVector b(n);
    RRVector f(n);
    RRVector c(n);
    RRVector d(n);

    for (uint i=0;i&lt;n;i++)
    {
        b[i] = double(rand()) / double(RAND_MAX);
    }
    b.normalize();

    double eps = this-&gt;eigenValueSolverConf.getSolverCvgValue();
    double mu = std::max(d[0], 1.0e9 * double(rand()) / double(RAND_MAX));
    double muo = mu + 2 * eps;
    uint nIterations = this-&gt;eigenValueSolverConf.getNIterations();

    std::vector&lt; std::vector&lt;uint&gt; &gt; mIndexes;
    mIndexes.resize(n);
    for (uint i=0;i&lt;n;i++)
    {
        mIndexes[i] = M2.getRowIndexes(i);
    }

    std::vector&lt; std::vector&lt;uint&gt; &gt; kIndexes;
    kIndexes.resize(n);
    for (uint i=0;i&lt;n;i++)
    {
        kIndexes[i] = K.getRowIndexes(i);
    }

    RMatrixSolver solver(this-&gt;matrixSolverConf);

    for (uint it=0;it&lt;nIterations;it++)
    {
        RLogger::info("Rayleigh quotient iteration %u of %u\n",it+1,nIterations);
        RLogger::indent();

        muo = mu;

        // Add K*mu to M
        for (uint i=0;i&lt;n;i++)
        {
            f[i] = 0.0;
            for (uint j=0;j&lt;kIndexes[i].size();j++)
            {
                double value = K.getValue(i,j) * mu;
                if (value != 0.0)
                {
                    M2.addValue(i,kIndexes[i][j],value);
                }
                // K*bi
                f[i] += value * b[kIndexes[i][j]];
            }
        }

        // (M + K*ui)*ci = K*bi
        solver.solve(M2,f,c,R_MATRIX_PRECONDITIONER_JACOBI);

        // K*bi/||ci||
        double norm = RRVector::norm(c);
        R_ASSERT(norm != 0.0);
        f *= 1.0 / norm;

        // (M + K*ui)*b(i+1) = K*bi/||ci||
        solver.solve(M,f,b,R_MATRIX_PRECONDITIONER_JACOBI);

        // Remove K*mu from M
        for (uint i=0;i&lt;n;i++)
        {
            for (uint j=0;j&lt;kIndexes[i].size();j++)
            {
                double value = -1.0 * K.getValue(i,j) * mu;
                if (value != 0.0)
                {
                    M2.addValue(i,kIndexes[i][j],value);
                }
            }
        }

        // M*bi
        for (uint i=0;i&lt;n;i++)
        {
            f[i] = 0.0;
            for (uint j=0;j&lt;mIndexes[i].size();j++)
            {
                double value = M2.getValue(i,j);
                f[i] += value * b[mIndexes[i][j]];
            }
        }

        // K*di = M*bi
        solver.solve(K,f,d,R_MATRIX_PRECONDITIONER_JACOBI);

        // mui = bi dot di / ( bi * bi)
        double bDot = RRVector::dot(b,b);
        R_ASSERT(bDot != 0.0);
        mu = RRVector::dot(d,b) / bDot;

        double cvgVal = std::fabs(muo - mu);
        RLogger::info("Convergence rate = %g", cvgVal);

        RLogger::unindent();

        if (it &gt; 0)
        {
            if (cvgVal &lt; this-&gt;eigenValueSolverConf.getSolverCvgValue())
            {
                break;
            }
        }
    }

    e[0] = mu;
    for (uint i=0;i&lt;n;i++)
    {
        ev[0][i] = b[i];
    }
}

</t>
<t tx="leo.20201108101541.23">void REigenValueSolver::qlDecomposition(RRVector &amp;d, RRVector &amp;e)
{
    uint n = d.getNRows();

    // Convenient to renumber the elements of e
    for (uint i=1;i&lt;n;i++)
    {
        e[i-1] = e[i];
    }
    e[n-1] = 0.0;

    for (uint l=0;l&lt;n;l++)
    {
        RLogger::info("QL decomposition %u of %u\n",l+1,n);
        RLogger::indent();

        uint iter = 0;
        uint m = 0;
        while (true)
        {
            // Look for a single small subdiagonal element to split the matrix
            for (m=l;m&lt;n-1;m++)
            {
                double dd = std::fabs(d[m]) + std::fabs(d[m+1]);
                if (std::fabs(e[m]+dd) == dd)
                {
                    break;
                }
            }
            if (m &gt;= l)
            {
                break;
            }
            if (iter ++ &gt;= 30)
            {
                RLogger::warning("Too many iterations %u.\n",iter);
            }
            // Form shift
            double g = (d[l+1] - d[l]) / (2.0*e[l]);
            double r = R_EIS_PYTHAG(g,1.0);
            // This is dm - ks
            g = d[m] - d[l] + e[l] / (g+R_SAME_SIGN(r,g));

            double s = 1.0, c = 1.0, p = 0.0;
            // A plane rotation as in the original QL, followed by Givens rotations to restore tridiagonal form
            uint i;
            for (i=m-1;i&gt;=l;i++)
            {
                double f = s * e[i];
                double b = c * e[i];
                e[i+1] = (r = R_EIS_PYTHAG(f,g));

                // Recover from underflow
                if (r == 0.0)
                {
                    d[i+1] -= p;
                    e[m] = 0.0;
                    break;
                }

                s = f/r;
                c = g/r;
                g = d[i+1] - p;
                r = (d[i] - g) * s + 2.0 * c * b;
                d[i+1] = g + (p = s * r);
                g = c * r - b;
            }
            if (r == 0.0 &amp;&amp; i &gt;= l)
            {
                continue;
            }
            d[l] -= p;
            e[l] = g;
            e[m] = 0.0;
        }
        RLogger::unindent();
    }
}

</t>
<t tx="leo.20201108101541.24">void REigenValueSolver::qrDecomposition(const RRMatrix &amp;H, uint nIterations, double convergenceValue, RRVector &amp;d, RRMatrix &amp;V)
{
    uint n = H.getNRows();

    d.resize(n);
    V.resize(n,n,0.0);

    RRVector a(n);
    RRVector e(n);
    RRMatrix A(H);
    RRMatrix Q(n,n,0.0);
    RRMatrix R(n,n,0.0);

    for (uint it=0;it&lt;nIterations;it++)
    {
        RLogger::info("QR / Gram-Schmidt %u of %u\n",it+1,nIterations);
        RLogger::indent();

        for (uint i=0;i&lt;n;i++)
        {
            for (uint j=0;j&lt;n;j++)
            {
                a[j] = A[j][i];
            }
            RRVector u(a);
            for (uint j=0;j&lt;i;j++)
            {
                for (uint k=0;k&lt;n;k++)
                {
                    e[k] = Q[k][j];
                }
                double dot = RRVector::dot(a,e);
                for (uint k=0;k&lt;n;k++)
                {
                    u[k] -= dot * e[k];
                }
            }
            double norm = RRVector::norm(u);
            R_ASSERT(norm != 0.0);
            e = u;
            e *= 1.0 / norm;
            for (uint j=0;j&lt;n;j++)
            {
                Q[j][i] = e[j];
            }
        }
        for (uint i=0;i&lt;n;i++)
        {
            for (uint j=0;j&lt;n;j++)
            {
                e[j] = Q[j][i];
            }
            for (uint j=i;j&lt;n;j++)
            {
                for (uint k=0;k&lt;n;k++)
                {
                    a[k] = A[k][j];
                }
                R[i][j] = RRVector::dot(a,e);
            }
        }

        RRMatrix::mlt(R,Q,A);

        if (it == 0)
        {
            V = Q;
        }
        else
        {
            RRMatrix Vo(V);
            RRMatrix::mlt(Vo,Q,V);
        }

        bool converged = true;

        for (uint i=1;i&lt;n;i++)
        {
            if (std::fabs(A[i][i-1]) &gt; convergenceValue)
            {
                converged = false;
            }
        }
        if (converged)
        {
            break;
        }
        RLogger::unindent();
    }
    for (uint i=0;i&lt;n;i++)
    {
        d[i] = A[i][i];
    }
}
</t>
<t tx="leo.20201108101541.25">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rhemicube.cpp                                            *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   24-th July 2014                                          *
 *                                                                   *
 *  DESCRIPTION: View-factor hemi cube class definition              *
 *********************************************************************/

#include &lt;omp.h&gt;

#include "rhemicube.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.26">class RHemicubeTriangle
{
    protected:

        RTriangle triangle;
        uint color;

    public:

        RHemicubeTriangle(const RTriangle &amp;triangle, uint color) : triangle(triangle), color(color) {}

        const RTriangle &amp;getTriangle(void) const { return this-&gt;triangle; }

        uint getColor(void) const { return this-&gt;color; }
};

</t>
<t tx="leo.20201108101541.27">class RHemicubeTriangleComp
{
    protected:

        RR3Vector eye;

    public:

        RHemicubeTriangleComp(const RR3Vector &amp;eye) : eye(eye) {}

        @others
};

</t>
<t tx="leo.20201108101541.28">bool operator() (const RHemicubeTriangle &amp;t1,const RHemicubeTriangle &amp;t2)
{
    double d1 = RSegment::findLength(RNode(this-&gt;eye),t1.getTriangle().getNode1());
    d1 = std::min(d1,RSegment::findLength(RNode(this-&gt;eye),t1.getTriangle().getNode2()));
    d1 = std::min(d1,RSegment::findLength(RNode(this-&gt;eye),t1.getTriangle().getNode3()));

    double d2 = RSegment::findLength(RNode(this-&gt;eye),t2.getTriangle().getNode1());
    d2 = std::min(d2,RSegment::findLength(RNode(this-&gt;eye),t2.getTriangle().getNode2()));
    d2 = std::min(d2,RSegment::findLength(RNode(this-&gt;eye),t2.getTriangle().getNode3()));

    return (d1 &lt; d2);
}
</t>
<t tx="leo.20201108101541.29">void RHemiCube::_init(const RHemiCube *pHemiCube)
{
    if (pHemiCube)
    {
        this-&gt;eyeDirection = pHemiCube-&gt;eyeDirection;
        this-&gt;sectors.resize(pHemiCube-&gt;sectors.size());
        for (uint i=0;i&lt;pHemiCube-&gt;sectors.size();i++)
        {
            this-&gt;sectors[i] = new RHemiCubeSector(*pHemiCube-&gt;sectors[i]);
        }
    }
}

RHemiCube::RHemiCube(const RR3Vector &amp;eyePosition, const RR3Vector &amp;eyeDirection, uint resolution, double size)
    : eyeDirection(eyeDirection)
{
    this-&gt;_init();
    this-&gt;generate(eyePosition,eyeDirection,resolution,size);
}

RHemiCube::RHemiCube(const RHemiCube &amp;hemiCube)
{
    this-&gt;_init(&amp;hemiCube);
}

RHemiCube::~RHemiCube()
{
    for (uint i=0;i&lt;this-&gt;sectors.size();i++)
    {
        delete this-&gt;sectors[i];
    }
}

RHemiCube &amp;RHemiCube::operator =(const RHemiCube &amp;hemiCube)
{
    this-&gt;_init(&amp;hemiCube);
    return (*this);
}

</t>
<t tx="leo.20201108101541.3">typedef struct _RConvectionDesc
{
    QString description;
    bool    natural;
    bool    available;
} RConvectionDesc;

</t>
<t tx="leo.20201108101541.30">void RHemiCube::rayTraceTriangle(const RTriangle &amp;triangle, uint color)
{
//    #pragma omp parallel for default(shared)
    for (uint i=0;i&lt;this-&gt;sectors.size();i++)
    {
        this-&gt;sectors[i]-&gt;rayTraceTriangle(triangle,color);
    }
}

std::map&lt;uint, double&gt; RHemiCube::getViewFactors(void) const
{

    std::map&lt;uint, double&gt; viewFactors;

    for (uint i=0;i&lt;this-&gt;sectors.size();i++)
    {
        for (uint j=0;j&lt;this-&gt;sectors[i]-&gt;getSize();j++)
        {
            const RHemiCubePixel &amp;rPixel = this-&gt;sectors[i]-&gt;getPixel(j);
            uint color = rPixel.getColor();
            if (color == RConstants::eod)
            {
                continue;
            }
            if (viewFactors.find(color) == viewFactors.end())
            {
                viewFactors[color] = rPixel.getWeight();
            }
            else
            {
                viewFactors[color] += rPixel.getWeight();
            }
        }
    }

    return viewFactors;
}

double RHemiCube::getFillRatio(void) const
{
    uint totalSize = 0;
    uint totalFill = 0;

    for (uint i=0;i&lt;this-&gt;sectors.size();i++)
    {
        for (uint j=0;j&lt;this-&gt;sectors[i]-&gt;getSize();j++)
        {
            if (this-&gt;sectors[i]-&gt;getPixel(j).getColor() != RConstants::eod)
            {
                totalFill++;
            }
            totalSize++;
        }
    }

    return double(totalFill)/double(totalSize);
}

</t>
<t tx="leo.20201108101541.31">void RHemiCube::calculateViewFactors(const RModel &amp;model, RViewFactorMatrix &amp;rViewFactorMatrix)
{
    RPatchBook &amp;rPatchBook = rViewFactorMatrix.getPatchBook();
    std::vector&lt;RPatchInput&gt; &amp;rPatchInput = rViewFactorMatrix.getHeader().getPatchInput();


    rViewFactorMatrix.getHeader().setNElements(model.getNElements());
    rViewFactorMatrix.getHeader().setHemicubeResolution(model.getProblemSetup().getRadiationSetup().getResolution());

    rViewFactorMatrix.resize(rPatchBook.getNPatches());

    RLogger::info("Calculating view-factors.\n");
    RLogger::indent();

    uint nPatchesProcessed = 0;

    RProgressInitialize("Calculating view-factors");
    #pragma omp parallel for default(shared)
    for (int64_t eyePatchID=0;eyePatchID&lt;int64_t(rPatchBook.getNPatches());eyePatchID++)
    {
        RViewFactorRow &amp;rViewFactorRow = rViewFactorMatrix.getRow(eyePatchID);
        rViewFactorRow.getViewFactors().clear();

        const RPatch &amp;rPatch = rPatchBook.getPatch(eyePatchID);
        uint surfaceID = rPatch.getSurfaceID();
        if (rPatchInput[surfaceID].getEmitter())
        {
            RR3Vector eyePosition;
            RR3Vector eyeDirection;

            model.findPatchCenter(rPatch,eyePosition[0],eyePosition[1],eyePosition[2]);
            model.findPatchNormal(rPatch,eyeDirection[0],eyeDirection[1],eyeDirection[2]);

            RHemiCube hemiCube(eyePosition,eyeDirection,rViewFactorMatrix.getHeader().getHemicubeResolution(),100);

            RHemicubeTriangleComp hemiCubeTriangleComp(eyePosition);

            std::vector&lt;RHemicubeTriangle&gt; hemiCubeTriangles;
            hemiCubeTriangles.reserve(rPatchBook.getNPatches()*2);

            // Fill vector of triangles to be rendered / ray-traced.
            for (uint patchID=0;patchID&lt;rPatchBook.getNPatches();patchID++)
            {
                if (eyePatchID == patchID)
                {
                    continue;
                }
                if (!rPatchInput[rPatchBook.getPatch(patchID).getSurfaceID()].getReceiver())
                {
                    continue;
                }

                const RUVector &amp;rElementIDs = rPatchBook.getPatch(patchID).getElementIDs();
                for (uint j=0;j&lt;rElementIDs.size();j++)
                {
                    const RElement &amp;rElement = model.getElement(rElementIDs[j]);
                    std::vector&lt;RTriangle&gt; triangles = rElement.triangulate(model.getNodes());
                    for (uint k=0;k&lt;triangles.size();k++)
                    {
                        hemiCubeTriangles.push_back(RHemicubeTriangle(triangles[k],patchID));
                    }
                }
            }

            // Sort vector of triangles by distance.
            // This way closest triangles will be rendered first and those which are at the back
            // will not waste computatuional time.
            std::sort(hemiCubeTriangles.begin(),hemiCubeTriangles.end(),hemiCubeTriangleComp);

            // Raytrace triangles.
            for (uint i=0;i&lt;hemiCubeTriangles.size();i++)
            {
                hemiCube.rayTraceTriangle(hemiCubeTriangles[i].getTriangle(),hemiCubeTriangles[i].getColor());
            }

            // Transfer view-factors from hemi-cube to view-factor row storage.
            std::map&lt;uint,double&gt; viewFactorMap = hemiCube.getViewFactors();
            std::map&lt;uint,double&gt;::const_iterator iter;
            for (iter = viewFactorMap.begin(); iter != viewFactorMap.end(); ++iter)
            {
                uint patchID = uint(iter-&gt;first);
                double viewFactor = double(iter-&gt;second);
                rViewFactorRow.getViewFactors().addValue(patchID,viewFactor);
            }
        }

        // Calculate view-factor row sum.
        const RSparseVector&lt;double&gt; &amp;viewFactors = rViewFactorRow.getViewFactors();
        double vfRowSum = 0.0;
        for (uint i=0;i&lt;uint(viewFactors.size());i++)
        {
            vfRowSum += viewFactors.getValue(i);
        }

#pragma omp critical
        {
            RProgressPrint(++nPatchesProcessed,rPatchBook.getNPatches());
            RLogger::info("[%9u of %-9u] Patch %9u: row sum = %g\n",nPatchesProcessed,rPatchBook.getNPatches(),eyePatchID+1,vfRowSum);
        }
    }
    RProgressFinalize("Done");
    RLogger::unindent();
}

</t>
<t tx="leo.20201108101541.32">void RHemiCube::generate(const RR3Vector &amp;eyePosition, const RR3Vector &amp;eyeDirection, uint resolution, double size)
{
    uint nSubSectors = 5;
    uint subSectorResolution = uint(std::ceil(double(resolution)/double(nSubSectors)));

    this-&gt;sectors.resize(R_HEMICUBE_SECTOR_N_TYPES * nSubSectors * nSubSectors);

    uint idx = 0;
    double totalWeight = 0.0;
    for (uint i=0;i&lt;R_HEMICUBE_SECTOR_N_TYPES;i++)
    {
        for (uint k=0;k&lt;nSubSectors;k++)
        {
            for (uint l=0;l&lt;nSubSectors;l++)
            {
                this-&gt;sectors[idx] = new RHemiCubeSector(eyePosition,eyeDirection,subSectorResolution,k,l,nSubSectors,size,RHemiCubeSectorType(i));
                for (uint j=0;j&lt;this-&gt;sectors[idx]-&gt;getSize();j++)
                {
                    totalWeight += this-&gt;sectors[idx]-&gt;getPixel(j).getWeight();
                }
                idx ++;
            }
        }
    }
    if (totalWeight == 0.0)
    {
        return;
    }
    idx = 0;
    for (uint i=0;i&lt;R_HEMICUBE_SECTOR_N_TYPES;i++)
    {
        for (uint j=0;j&lt;nSubSectors*nSubSectors;j++)
        {
            for (uint k=0;k&lt;this-&gt;sectors[idx]-&gt;getSize();k++)
            {
                this-&gt;sectors[idx]-&gt;getPixel(k).setWeight(this-&gt;sectors[idx]-&gt;getPixel(k).getWeight()/totalWeight);
            }
            idx++;
        }
    }
}
</t>
<t tx="leo.20201108101541.33">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rhemicubepixel.cpp                                       *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   24-th July 2014                                          *
 *                                                                   *
 *  DESCRIPTION: View-factor hemi cube pixel class definition        *
 *********************************************************************/

#include &lt;cfloat&gt;

#include "rhemicubepixel.h"


@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.34">void RHemiCubePixel::_init(const RHemiCubePixel *pHemiCubePixel)
{
    if (pHemiCubePixel)
    {
        this-&gt;position = pHemiCubePixel-&gt;position;
        this-&gt;color = pHemiCubePixel-&gt;color;
        this-&gt;depth = pHemiCubePixel-&gt;depth;
        this-&gt;weight = pHemiCubePixel-&gt;weight;
    }
}

RHemiCubePixel::RHemiCubePixel()
    : color(RConstants::eod)
    , depth(DBL_MAX)
    , weight(1.0)
{
    this-&gt;_init();
}

RHemiCubePixel::RHemiCubePixel(const RHemiCubePixel &amp;hemiCubePixel)
{
    this-&gt;_init(&amp;hemiCubePixel);
}

RHemiCubePixel::~RHemiCubePixel()
{
}

RHemiCubePixel &amp;RHemiCubePixel::operator =(const RHemiCubePixel &amp;hemiCubePixel)
{
    this-&gt;_init(&amp;hemiCubePixel);
    return (*this);
}

</t>
<t tx="leo.20201108101541.35">const RR3Vector &amp;RHemiCubePixel::getPosition(void) const
{
    return this-&gt;position;
}

RR3Vector &amp;RHemiCubePixel::getPosition(void)
{
    return this-&gt;position;
}

</t>
<t tx="leo.20201108101541.36">void RHemiCubePixel::setPosition(const RR3Vector &amp;position)
{
    this-&gt;position = position;
}

uint RHemiCubePixel::getColor(void) const
{
    return this-&gt;color;
}

</t>
<t tx="leo.20201108101541.37">void RHemiCubePixel::setColor(uint color)
{
    this-&gt;color = color;
}

double RHemiCubePixel::getDepth(void) const
{
    return this-&gt;depth;
}

</t>
<t tx="leo.20201108101541.38">void RHemiCubePixel::setDepth(double depth)
{
    this-&gt;depth = depth;
}

double RHemiCubePixel::getWeight(void) const
{
    return this-&gt;weight;
}

</t>
<t tx="leo.20201108101541.39">void RHemiCubePixel::setWeight(double weight)
{
    this-&gt;weight = weight;
}
</t>
<t tx="leo.20201108101541.4">static RConvectionDesc convectionDesc [] =
{
    { "Natural convection, External flow, Vertical plane",      true,  true  },
    { "Natural convection, External flow, Vertical cylinders",  true,  false },
    { "Natural convection, External flow, Horizontal plates",   true,  true  },
    { "Natural convection, External flow, Horizontal cylinder", true,  false },
    { "Natural convection, External flow, Spheres",             true,  false },
    { "Forced convection, Internal flow, Laminar flow",         false, true  },
    { "Forced convection, Internal flow, Turbulent flow",       false, true  },
    { "Forced convection, External flow",                       false, true  }
};

</t>
<t tx="leo.20201108101541.40">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rhemicubesector.cpp                                      *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   24-th July 2014                                          *
 *                                                                   *
 *  DESCRIPTION: View-factor hemi-cube sector class definition       *
 *********************************************************************/

#include "rhemicubesector.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.41">void RHemiCubeSector::_init(const RHemiCubeSector *pHemiCubeSector)
{
    if (pHemiCubeSector)
    {
        this-&gt;limitPolygon = pHemiCubeSector-&gt;limitPolygon;
        this-&gt;resolution = pHemiCubeSector-&gt;resolution;
        this-&gt;eyePosition = pHemiCubeSector-&gt;eyePosition;
        this-&gt;eyeDirection = pHemiCubeSector-&gt;eyeDirection;
        this-&gt;pixels = pHemiCubeSector-&gt;pixels;
    }
}

RHemiCubeSector::RHemiCubeSector(const RR3Vector &amp;eyePosition,
</t>
<t tx="leo.20201108101541.42">                                 const RR3Vector &amp;eyeDirection,
                                 uint resolution, uint iSubIndex, uint jSubIndex, uint nSubIndexes,
                                 double size,
                                 RHemiCubeSectorType type)
    : resolution(resolution)
    , eyePosition(eyePosition)
    , eyeDirection(eyeDirection)
{
    this-&gt;_init();
    uint sectorSize = resolution * resolution;
    this-&gt;pixels.resize(sectorSize);
    this-&gt;generate(resolution,iSubIndex,jSubIndex,nSubIndexes,size,type);
    this-&gt;limitPolygon = this-&gt;findLimitPolygon();
}

RHemiCubeSector::RHemiCubeSector(const RHemiCubeSector &amp;hemiCubeSector)
{
    this-&gt;_init(&amp;hemiCubeSector);
}

RHemiCubeSector::~RHemiCubeSector()
{
}

RHemiCubeSector &amp;RHemiCubeSector::operator =(const RHemiCubeSector &amp;hemiCubeSector)
{
    this-&gt;_init(&amp;hemiCubeSector);
    return (*this);
}

uint RHemiCubeSector::getSize(void) const
{
    return uint(this-&gt;pixels.size());
}

</t>
<t tx="leo.20201108101541.43">const RHemiCubePixel &amp;RHemiCubeSector::getPixel(uint position) const
{
    return this-&gt;pixels[position];
}

RHemiCubePixel &amp;RHemiCubeSector::getPixel(uint position)
{
    return this-&gt;pixels[position];
}

</t>
<t tx="leo.20201108101541.44">void RHemiCubeSector::rayTraceTriangle(const RTriangle &amp;triangle, uint color)
{
    if (!this-&gt;testVisibility(triangle))
    {
        return;
    }

    double shortestDistance = RSegment::findLength(RNode(this-&gt;eyePosition),triangle.getNode1());
    shortestDistance = std::min(shortestDistance,RSegment::findLength(RNode(this-&gt;eyePosition),triangle.getNode2()));
    shortestDistance = std::min(shortestDistance,RSegment::findLength(RNode(this-&gt;eyePosition),triangle.getNode3()));

    RR3Vector rayDirection;
    RR3Vector x;
    double u;

    bool iPrevFound = false;
    for (uint i=0;i&lt;this-&gt;resolution;i++)
    {
        bool jPrevFound = false;
        bool iCurrFound = false;

        for (uint j=0;j&lt;this-&gt;resolution;j++)
        {
            uint pixelId = i * this-&gt;resolution + j;
            if (this-&gt;pixels[pixelId].getColor() != RConstants::eod &amp;&amp; this-&gt;pixels[i].getDepth() &lt; shortestDistance)
            {
                continue;
            }
            rayDirection[0] = this-&gt;pixels[pixelId].getPosition()[0] - this-&gt;eyePosition[0];
            rayDirection[1] = this-&gt;pixels[pixelId].getPosition()[1] - this-&gt;eyePosition[1];
            rayDirection[2] = this-&gt;pixels[pixelId].getPosition()[2] - this-&gt;eyePosition[2];

            bool jCurrFound = false;
            if (triangle.findLineIntersection(this-&gt;eyePosition,rayDirection,x,u))
            {
                if (u &gt; 0.0)
                {
                    iPrevFound = true;
                    iCurrFound = true;
                    jPrevFound = true;
                    jCurrFound = true;
                    if (u &lt; this-&gt;pixels[pixelId].getDepth() || this-&gt;pixels[pixelId].getColor() == RConstants::eod)
                    {
                        this-&gt;pixels[pixelId].setDepth(u);
                        this-&gt;pixels[pixelId].setColor(color);
                    }
                }
            }

            if (jPrevFound &amp;&amp; !jCurrFound)
            {
                // No need to continue with current row. Triangle has already ended.
                break;
            }
        }

        if (iPrevFound &amp;&amp; !iCurrFound)
        {
            // No need to continue with current sector. Triangle has already ended.
            break;
        }
    }
}

</t>
<t tx="leo.20201108101541.45">bool RHemiCubeSector::testVisibility(const RTriangle &amp;triangle) const
{
    // Check if triangle's normal is opposite to eye direction.
    RR3Vector trianglePosition;
    RR3Vector triangleCenter;

    triangle.findCenter(triangleCenter);
    RR3Vector::subtract(triangleCenter,this-&gt;eyePosition,trianglePosition);
    trianglePosition.normalize();

    if (RR3Vector::angle(trianglePosition,this-&gt;eyeDirection) &gt;= RConstants::pi/2.0 ||
        RR3Vector::angle(trianglePosition,triangle.getNormal()) &lt;= RConstants::pi/2.0)
    {
        return false;
    }

    // Check if at least one node is visible.
    RR3Vector d1(triangle.getNode1().getX()-this-&gt;eyePosition[0],
                 triangle.getNode1().getY()-this-&gt;eyePosition[1],
                 triangle.getNode1().getZ()-this-&gt;eyePosition[2]);
    RR3Vector d2(triangle.getNode2().getX()-this-&gt;eyePosition[0],
                 triangle.getNode2().getY()-this-&gt;eyePosition[1],
                 triangle.getNode2().getZ()-this-&gt;eyePosition[2]);
    RR3Vector d3(triangle.getNode3().getX()-this-&gt;eyePosition[0],
                 triangle.getNode3().getY()-this-&gt;eyePosition[1],
                 triangle.getNode3().getZ()-this-&gt;eyePosition[2]);

    d1.normalize();
    d2.normalize();
    d3.normalize();

    if (RR3Vector::angle(d1,this-&gt;eyeDirection) &gt; RConstants::pi/2.0 &amp;&amp;
        RR3Vector::angle(d2,this-&gt;eyeDirection) &gt; RConstants::pi/2.0 &amp;&amp;
        RR3Vector::angle(d3,this-&gt;eyeDirection) &gt; RConstants::pi/2.0)
    {
        return false;
    }

    // Project triangle to sector plane and check whether limit boxes of triangle and sector overlap.
    RPlane plane(this-&gt;limitPolygon[0],this-&gt;limitPolygon[1],this-&gt;limitPolygon[2]);
    double u;
    RR3Vector x;
    std::vector&lt;RR3Vector&gt; xNodes;
    xNodes.reserve(3);

    if (plane.findLineIntersection(this-&gt;eyePosition,d1,x,u))
    {
        if (u &gt;= 0.0)
        {
            xNodes.push_back(x);
        }
    }
    if (plane.findLineIntersection(this-&gt;eyePosition,d2,x,u))
    {
        if (u &gt;= 0.0)
        {
            xNodes.push_back(x);
        }
    }
    if (plane.findLineIntersection(this-&gt;eyePosition,d3,x,u))
    {
        if (u &gt;= 0.0)
        {
            xNodes.push_back(x);
        }
    }

    if (xNodes.size() == 0)
    {
        return false;
    }

    double xl = 0.0, yl = 0.0, zl = 0.0;
    double xu = 0.0, yu = 0.0, zu = 0.0;

    for (uint i=0;i&lt;xNodes.size();i++)
    {
        if (i == 0)
        {
            xl = xu = xNodes[i][0];
            yl = yu = xNodes[i][1];
            zl = zu = xNodes[i][2];
        }
        else
        {
            xl = std::min(xl,xNodes[i][0]);
            yl = std::min(yl,xNodes[i][1]);
            zl = std::min(zl,xNodes[i][2]);

            xu = std::max(xu,xNodes[i][0]);
            yu = std::max(yu,xNodes[i][1]);
            zu = std::max(zu,xNodes[i][2]);
        }
    }
    RLimitBox triangleLimitBox(xl,xu,yl,yu,zl,zu);
    triangleLimitBox.scale(1.0 + RConstants::eps);

    return RLimitBox::areIntersecting(this-&gt;findLimitBox(),triangleLimitBox);
}

</t>
<t tx="leo.20201108101541.46">void RHemiCubeSector::generate(uint resolution, uint iSubIndex, uint jSubIndex, uint nSubIndexes, double size, RHemiCubeSectorType type)
{
    double si,sj,sk;
    double x(0.0),y(0.0),z(0.0);

    RRMatrix R;
    this-&gt;eyeDirection.findRotationMatrix(R);

    RR3Vector v;

    uint totalResolution = resolution * nSubIndexes;

    for (uint i=0;i&lt;resolution;i++)
    {
        for (uint j=0;j&lt;resolution;j++)
        {
            si = double(i+iSubIndex*resolution) * size / double(totalResolution);
            sj = double(j+jSubIndex*resolution) * size / double(totalResolution);
            sk = size;

            if (type == R_HEMICUBE_SECTOR_FRONT_NORTH_EAST)
            {
                x = sk;
                y = si;
                z = sj;
            }
            else if (type == R_HEMICUBE_SECTOR_FRONT_NORTH_WEST)
            {
                x = sk;
                y = -si;
                z = sj;
            }
            else if (type == R_HEMICUBE_SECTOR_FRONT_SOUTH_EAST)
            {
                x = sk;
                y = si;
                z = -sj;
            }
            else if (type == R_HEMICUBE_SECTOR_FRONT_SOUTH_WEST)
            {
                x = sk;
                y = -si;
                z = -sj;
            }
            else if (type == R_HEMICUBE_SECTOR_EAST_NORTH)
            {
                x = si;
                y = sk;
                z = sj;
            }
            else if (type == R_HEMICUBE_SECTOR_EAST_SOUTH)
            {
                x = si;
                y = sk;
                z = -sj;
            }
            else if (type == R_HEMICUBE_SECTOR_WEST_NORTH)
            {
                x = si;
                y = -sk;
                z = sj;
            }
            else if (type == R_HEMICUBE_SECTOR_WEST_SOUTH)
            {
                x = si;
                y = -sk;
                z = -sj;
            }
            else if (type == R_HEMICUBE_SECTOR_NORTH_EAST)
            {
                x = si;
                y = sj;
                z = sk;
            }
            else if (type == R_HEMICUBE_SECTOR_NORTH_WEST)
            {
                x = si;
                y = -sj;
                z = sk;
            }
            else if (type == R_HEMICUBE_SECTOR_SOUTH_EAST)
            {
                x = si;
                y = sj;
                z = -sk;
            }
            else if (type == R_HEMICUBE_SECTOR_SOUTH_WEST)
            {
                x = si;
                y = -sj;
                z = -sk;
            }

            double weight = x / (RConstants::pi * std::pow(x*x+y*y+z*z,2));
            RRMatrix::mlt(R,RR3Vector(x,y,z),v);
            v[0] += this-&gt;eyePosition[0];
            v[1] += this-&gt;eyePosition[1];
            v[2] += this-&gt;eyePosition[2];
            this-&gt;pixels[i*resolution+j].setPosition(v);
            this-&gt;pixels[i*resolution+j].setWeight(weight);
        }
    }
}

std::vector&lt;RR3Vector&gt; RHemiCubeSector::findLimitPolygon(void) const
{
    std::vector&lt;RR3Vector&gt; polygon;

    polygon.push_back(this-&gt;pixels[0].getPosition());
    polygon.push_back(this-&gt;pixels[this-&gt;resolution-1].getPosition());
    polygon.push_back(this-&gt;pixels[this-&gt;resolution * this-&gt;resolution - 1].getPosition());
    polygon.push_back(this-&gt;pixels[this-&gt;resolution * (this-&gt;resolution - 1)].getPosition());

    return polygon;
}

RLimitBox RHemiCubeSector::findLimitBox(void) const
{
    double xl = 0.0, yl = 0.0, zl = 0.0;
    double xu = 0.0, yu = 0.0, zu = 0.0;

    for (uint i=0;i&lt;this-&gt;limitPolygon.size();i++)
    {
        if (i == 0)
        {
            xl = xu = this-&gt;limitPolygon[i][0];
            yl = yu = this-&gt;limitPolygon[i][1];
            zl = zu = this-&gt;limitPolygon[i][2];
        }
        else
        {
            xl = std::min(xl,this-&gt;limitPolygon[i][0]);
            yl = std::min(yl,this-&gt;limitPolygon[i][1]);
            zl = std::min(zl,this-&gt;limitPolygon[i][2]);

            xu = std::max(xu,this-&gt;limitPolygon[i][0]);
            yu = std::max(yu,this-&gt;limitPolygon[i][1]);
            zu = std::max(zu,this-&gt;limitPolygon[i][2]);
        }
    }

    return RLimitBox(xl,xu,yl,yu,zl,zu);
}
</t>
<t tx="leo.20201108101541.47">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   riterationinfo.cpp                                       *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   23-rd January 2013                                       *
 *                                                                   *
 *  DESCRIPTION: Iteration info class header                         *
 *********************************************************************/

#include &lt;QFile&gt;
#include &lt;QFileInfo&gt;
#include &lt;QTextStream&gt;

#include &lt;cmath&gt;

#include &lt;rblib.h&gt;

#include "riterationinfo.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.48">void RIterationInfo::_init(const RIterationInfo *pIterationInfo)
{
    if (pIterationInfo)
    {
        this-&gt;nIterations = pIterationInfo-&gt;nIterations;
        this-&gt;convergenceValue = pIterationInfo-&gt;convergenceValue;
        this-&gt;outputFrequency = pIterationInfo-&gt;outputFrequency;
        this-&gt;iteration = pIterationInfo-&gt;iteration;
        this-&gt;error = pIterationInfo-&gt;error;
        this-&gt;trend = pIterationInfo-&gt;trend;
        this-&gt;equationScale = pIterationInfo-&gt;equationScale;
        this-&gt;outputFileName = pIterationInfo-&gt;outputFileName;
    }
}

RIterationInfo::RIterationInfo()
    : nIterations(0)
    , convergenceValue(RConstants::eps)
    , outputFrequency(1)
    , iteration(0)
    , error(0.0)
    , trend(0.0)
    , equationScale(1.0)
{
    this-&gt;_init();
}

RIterationInfo::RIterationInfo(const RIterationInfo &amp;iterationInfo)
{
    this-&gt;_init(&amp;iterationInfo);
}

RIterationInfo::~RIterationInfo()
{
}

RIterationInfo &amp;RIterationInfo::operator =(const RIterationInfo &amp;iterationInfo)
{
    this-&gt;_init(&amp;iterationInfo);
    return (*this);
}

</t>
<t tx="leo.20201108101541.49">void RIterationInfo::setNIterations(unsigned int nIterations)
{
    this-&gt;nIterations = nIterations;
}

</t>
<t tx="leo.20201108101541.5">void RConvection::_init(const RConvection *pConvection)
{
    this-&gt;type = R_CONVECTION_FORCED_EXTERNAL;
    this-&gt;matName.clear();
    this-&gt;mu = 0.0;
    this-&gt;ro = 0.0;
    this-&gt;k = 0.0;
    this-&gt;c = 0.0;
    this-&gt;b = 0.0;
    this-&gt;d = 0.0;
    this-&gt;v = 0.0;
    this-&gt;g = 9.81;
    this-&gt;Ts = 293.15;
    this-&gt;Tf = 293.15;

    if (pConvection)
    {
        this-&gt;type = pConvection-&gt;type;
        this-&gt;matName = pConvection-&gt;matName;
        this-&gt;mu = pConvection-&gt;mu;
        this-&gt;ro = pConvection-&gt;ro;
        this-&gt;k = pConvection-&gt;k;
        this-&gt;c = pConvection-&gt;c;
        this-&gt;b = pConvection-&gt;b;
        this-&gt;d = pConvection-&gt;d;
        this-&gt;v = pConvection-&gt;v;
        this-&gt;g = pConvection-&gt;g;
        this-&gt;Ts = pConvection-&gt;Ts;
        this-&gt;Tf = pConvection-&gt;Tf;
    }
}

RConvection::RConvection()
{
    this-&gt;_init();
}

RConvection::RConvection(const RConvection &amp;convection)
{
    this-&gt;_init(&amp;convection);
}

RConvection::~RConvection()
{
}

RConvection &amp;RConvection::operator =(const RConvection &amp;convection)
{
    this-&gt;_init(&amp;convection);
    return *this;
}

</t>
<t tx="leo.20201108101541.50">void RIterationInfo::setOutputFrequency(unsigned int outputFrequency)
{
    this-&gt;outputFrequency = outputFrequency;
}

</t>
<t tx="leo.20201108101541.51">void RIterationInfo::setConvergenceValue(double convergenceValue)
{
    this-&gt;convergenceValue = convergenceValue;
}

</t>
<t tx="leo.20201108101541.52">void RIterationInfo::setIteration(unsigned int iteration)
{
    this-&gt;iteration = iteration;
}

</t>
<t tx="leo.20201108101541.53">void RIterationInfo::setError(double error)
{
    this-&gt;trend = error - this-&gt;error;
    this-&gt;error = error;
}

</t>
<t tx="leo.20201108101541.54">void RIterationInfo::setEquationScale(double equationScale)
{
    this-&gt;equationScale = equationScale;
}

</t>
<t tx="leo.20201108101541.55">void RIterationInfo::setOutputFileName(const QString &amp;outputFileName)
{
    this-&gt;outputFileName = outputFileName;
}

</t>
<t tx="leo.20201108101541.56">bool RIterationInfo::hasConverged(void) const
{
    if (!std::isnormal(this-&gt;error))
    {
        return true;
    }
    if (!std::isnormal(this-&gt;trend))
    {
        return true;
    }
    if (this-&gt;error &lt; this-&gt;convergenceValue)
    {
        return true;
    }
    if (std::abs(this-&gt;trend) &lt; std::pow(RConstants::eps,2))
    {
        return true;
    }
    return false;
}

</t>
<t tx="leo.20201108101541.57">void RIterationInfo::printHeader(const QString &amp;title) const
{
    if (this-&gt;outputFrequency == 0)
    {
        return;
    }
    RLogger::info("-------------------------------------------------------------------------------\n");
    RLogger::info("%s\n",title.toUtf8().constData());
    RLogger::info("-------------------------------------------------------------------------------\n");
    RLogger::info("&gt;    Iteration     |   Residual   |    Trend     |                             \n");
    RLogger::info("-------------------------------------------------------------------------------\n");
}

</t>
<t tx="leo.20201108101541.58">void RIterationInfo::printFooter(void) const
{
    if (this-&gt;outputFrequency == 0)
    {
        return;
    }
    RLogger::info("-------------------------------------------------------------------------------\n");
}

</t>
<t tx="leo.20201108101541.59">void RIterationInfo::printIteration(void) const
{
    if (this-&gt;outputFrequency == 0)
    {
        return;
    }
    if (!this-&gt;hasConverged() &amp;&amp; this-&gt;iteration % this-&gt;outputFrequency != 0)
    {
        return;
    }
    RLogger::info("&gt; %6u of %-6u |% 12e |% 12e |\n",this-&gt;iteration+1,this-&gt;nIterations, this-&gt;error, this-&gt;trend);
    this-&gt;writeToFile();
}

</t>
<t tx="leo.20201108101541.6">void RConvection::setType(RConvectionType type)
{
    this-&gt;type = type;
}

</t>
<t tx="leo.20201108101541.60">void RIterationInfo::writeToFile(const QString &amp;fileName, uint iteration, const std::vector&lt;RIterationInfoValue&gt; &amp;iterationValues)
{
    if (fileName.isEmpty())
    {
        return;
    }
    bool firstWrite = !QFileInfo::exists(fileName);

    QFile file(fileName);

    file.open(QIODevice::Append | QIODevice::Text);

    QTextStream out(&amp;file);
    out.setRealNumberNotation(QTextStream::ScientificNotation);
    out.setRealNumberPrecision(7);

    if (firstWrite)
    {
        out &lt;&lt; "Iteration number";
        for (uint i=0;i&lt;iterationValues.size();i++)
        {
            out &lt;&lt; "|" &lt;&lt; iterationValues[i].getName();
        }
        out &lt;&lt; "\n";
    }

    out &lt;&lt; iteration + 1;
    for (uint i=0;i&lt;iterationValues.size();i++)
    {
        out &lt;&lt; "|" &lt;&lt; iterationValues[i].getValue();
    }
    out &lt;&lt; "\n";

    file.close();
}

</t>
<t tx="leo.20201108101541.61">void RIterationInfo::writeToFile(void) const
{
    std::vector&lt;RIterationInfoValue&gt; cvgValues;
    cvgValues.push_back(RIterationInfoValue("Solver residual",this-&gt;error));
    cvgValues.push_back(RIterationInfoValue("Solver convergence",this-&gt;trend));
    RIterationInfo::writeToFile(this-&gt;outputFileName,this-&gt;iteration,cvgValues);
}
</t>
<t tx="leo.20201108101541.62">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   riterationinfovalue.cpp                                  *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th January 2016                                        *
 *                                                                   *
 *  DESCRIPTION: Iteration info value class definition               *
 *********************************************************************/

#include "riterationinfovalue.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.63">void RIterationInfoValue::_init(const RIterationInfoValue *pIterationInfoValue)
{
    if (pIterationInfoValue)
    {
        this-&gt;name = pIterationInfoValue-&gt;name;
        this-&gt;value = pIterationInfoValue-&gt;value;
    }
}

RIterationInfoValue::RIterationInfoValue()
    : name(QString())
    , value(0.0)
{
    this-&gt;_init();
}

RIterationInfoValue::RIterationInfoValue(const QString &amp;name, double value)
    : name(name)
    , value(value)
{
    this-&gt;_init();
}

RIterationInfoValue::RIterationInfoValue(const RIterationInfoValue &amp;iterationInfoValue)
{
    this-&gt;_init(&amp;iterationInfoValue);
}

RIterationInfoValue::~RIterationInfoValue()
{

}

RIterationInfoValue &amp;RIterationInfoValue::operator =(const RIterationInfoValue &amp;iterationInfoValue)
{
    this-&gt;_init(&amp;iterationInfoValue);
    return (*this);
}

</t>
<t tx="leo.20201108101541.64">const QString &amp;RIterationInfoValue::getName(void) const
{
    return this-&gt;name;
}

double RIterationInfoValue::getValue(void) const
{
    return this-&gt;value;
}
</t>
<t tx="leo.20201108101541.65">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rlocalrotation.cpp                                       *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th January 2016                                       *
 *                                                                   *
 *  DESCRIPTION: Local rotation class definition                     *
 *********************************************************************/

#include "rlocalrotation.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.66">void RLocalRotation::_init(const RLocalRotation *pLocalRotation)
{
    if (pLocalRotation)
    {
        this-&gt;active = pLocalRotation-&gt;active;
        this-&gt;R = pLocalRotation-&gt;R;
        this-&gt;iR = pLocalRotation-&gt;iR;
    }
}

RLocalRotation::RLocalRotation()
    : active(false)
{
    this-&gt;_init();
}

RLocalRotation::RLocalRotation(const RLocalRotation &amp;localRotation)
{
    this-&gt;_init(&amp;localRotation);
}

RLocalRotation::~RLocalRotation()
{

}

RLocalRotation &amp;RLocalRotation::operator =(const RLocalRotation &amp;localRotation)
{
    this-&gt;_init(&amp;localRotation);
    return (*this);
}

</t>
<t tx="leo.20201108101541.67">bool RLocalRotation::isActive(void) const
{
    return this-&gt;active;
}

</t>
<t tx="leo.20201108101541.68">void RLocalRotation::activate(const RRMatrix &amp;matrix)
{
    R_ERROR_ASSERT(matrix.getNRows() == matrix.getNColumns() &amp;&amp; matrix.getNRows() == 3);

    this-&gt;active = true;
    this-&gt;R = matrix;
    this-&gt;iR = matrix;
    this-&gt;iR.invert();
}

</t>
<t tx="leo.20201108101541.69">void RLocalRotation::deactivate(void)
{
    this-&gt;active = false;
    this-&gt;R.clear();
    this-&gt;iR.clear();
}

</t>
<t tx="leo.20201108101541.7">void RConvection::setMaterial(const RMaterial &amp;material, double temperature)
{
    this-&gt;matName = material.getName();

    unsigned int roPos = material.findPosition(R_MATERIAL_PROPERTY_DENSITY);
    unsigned int muPos = material.findPosition(R_MATERIAL_PROPERTY_DYNAMIC_VISCOSITY);
    unsigned int cPos = material.findPosition(R_MATERIAL_PROPERTY_HEAT_CAPACITY);
    unsigned int kPos = material.findPosition(R_MATERIAL_PROPERTY_THERMAL_CONDUCTIVITY);
    unsigned int bPos = material.findPosition(R_MATERIAL_PROPERTY_THERMAL_EXPANSION_COEFFICIENT);

    if (roPos &lt; material.size())
    {
        this-&gt;ro = material.get(roPos).get(temperature);
    }

    if (muPos &lt; material.size())
    {
        this-&gt;mu = material.get(muPos).get(temperature);
    }

    if (cPos &lt; material.size())
    {
        this-&gt;c = material.get(cPos).get(temperature);
    }

    if (kPos &lt; material.size())
    {
        this-&gt;k = material.get(kPos).get(temperature);
    }

    if (bPos &lt; material.size())
    {
        this-&gt;b = material.get(bPos).get(temperature);
    }
}

</t>
<t tx="leo.20201108101541.70">void RLocalRotation::rotateResultsVector(RRVector &amp;v) const
{
    R_ERROR_ASSERT(v.getNRows() % 3 == 0);

    RR3Vector v3;

    uint nRotations = v.getNRows() / 3;

    for (uint i=0;i&lt;nRotations;i++)
    {
        v3[0] = v[3*i+0];
        v3[1] = v[3*i+1];
        v3[2] = v[3*i+2];

        v[3*i+0] = this-&gt;iR[0][0] * v3[0] + this-&gt;iR[1][0] * v3[1] + this-&gt;iR[2][0] * v3[2];
        v[3*i+1] = this-&gt;iR[0][1] * v3[0] + this-&gt;iR[1][1] * v3[1] + this-&gt;iR[2][1] * v3[2];
        v[3*i+2] = this-&gt;iR[0][2] * v3[0] + this-&gt;iR[1][2] * v3[1] + this-&gt;iR[2][2] * v3[2];
    }
}
</t>
<t tx="leo.20201108101541.71">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rmatrixmanager.cpp                                       *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th October 2017                                       *
 *                                                                   *
 *  DESCRIPTION: Matrix manager class definition                     *
 *********************************************************************/

//#include "rmatrixmanager.h"

//template&lt;class T&gt;
//RMatrixManager&lt;T&gt;::RMatrixManager()
//{
//    this-&gt;c.resize(R_ELEMENT_N_TYPES);
//}

//template&lt;class T&gt;
//T &amp;RMatrixManager&lt;T&gt;::getMatricies(RElementType type)
//{
//    if (!this-&gt;c[type].initialized)
//    {
//        this-&gt;c[type].resize(RElement::getNNodes(type));
//    }
//    return this-&gt;c[type];
//}
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.72">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rmatrixpreconditioner.cpp                                *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   23-rd January 2013                                       *
 *                                                                   *
 *  DESCRIPTION: Matrix preconditioner class definition              *
 *********************************************************************/

#include &lt;cmath&gt;

#include &lt;omp.h&gt;

#include "rmatrixpreconditioner.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.73">void RMatrixPreconditioner::_init(const RMatrixPreconditioner *pMatrixPreconditioner)
{
    if (pMatrixPreconditioner)
    {
        this-&gt;matrixPreconditionerType = pMatrixPreconditioner-&gt;matrixPreconditionerType;
        this-&gt;data = pMatrixPreconditioner-&gt;data;
    }
}

RMatrixPreconditioner::RMatrixPreconditioner(const RSparseMatrix &amp;matrix, RMatrixPreconditionerType matrixPreconditionerType, unsigned int blockSize)
    : matrixPreconditionerType(matrixPreconditionerType)
{
    this-&gt;_init();

    switch (matrixPreconditionerType)
    {
        case R_MATRIX_PRECONDITIONER_JACOBI:
            this-&gt;constructJacobi(matrix);
            break;
        case R_MATRIX_PRECONDITIONER_BLOCK_JACOBI:
            this-&gt;constructBlockJacobi(matrix,blockSize);
            break;
        default:
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid matrix preconditioner type \'%d\'",matrixPreconditionerType);
    }
}

RMatrixPreconditioner::RMatrixPreconditioner(const RMatrixPreconditioner &amp;matrixPreconditioner)
{
    this-&gt;_init(&amp;matrixPreconditioner);
}

RMatrixPreconditioner::~RMatrixPreconditioner()
{
}

RMatrixPreconditioner &amp;RMatrixPreconditioner::operator =(const RMatrixPreconditioner &amp;matrixPreconditioner)
{
    this-&gt;_init(&amp;matrixPreconditioner);
    return (*this);
}

</t>
<t tx="leo.20201108101541.74">void RMatrixPreconditioner::compute(const RRVector &amp;x, RRVector &amp;y) const
{
    switch (matrixPreconditionerType)
    {
        case R_MATRIX_PRECONDITIONER_JACOBI:
            this-&gt;computeJacobi(x,y);
            break;
        case R_MATRIX_PRECONDITIONER_BLOCK_JACOBI:
            this-&gt;computeBlockJacobi(x,y);
            break;
        default:
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Invalid matrix preconditioner type \'%d\'",matrixPreconditionerType);
    }
}

</t>
<t tx="leo.20201108101541.75">void RMatrixPreconditioner::constructJacobi(const RSparseMatrix &amp;matrix)
{
    unsigned int nRows = matrix.getNRows();

    this-&gt;data.resize(nRows,1);
    this-&gt;data.fill(0.0);

    for (unsigned int i=0;i&lt;nRows;i++)
    {
        unsigned int columnPosition = 0;
        if (matrix.findColumnPosition(i,i,columnPosition))
        {
            this-&gt;data[i][0] = matrix.getValue(i,columnPosition);
        }
    }
}

</t>
<t tx="leo.20201108101541.76">void RMatrixPreconditioner::constructBlockJacobi(const RSparseMatrix &amp;matrix, unsigned int blockSize)
{
    unsigned int width = blockSize;

    // Matrix mus be dividable by block size.
    unsigned int nRows = matrix.getNRows();
    while (nRows % width != 0)
    {
        width --;
    }

    this-&gt;data.resize(nRows,width,0.0);

    unsigned int nBlocks = nRows/width;

    for (unsigned int i=0;i&lt;nBlocks;i++)
    {
        for (unsigned int k=0;k&lt;width;k++)
        {
            unsigned int m = i*width + k;
            for (unsigned int l=0;l&lt;width;l++)
            {
                unsigned int n = i*width + l;
                unsigned int columnPosition = 0;
                if (matrix.findColumnPosition(m,n,columnPosition))
                {
                    this-&gt;data[m][l] = matrix.getValue(m,columnPosition);
                }
            }
        }
    }
}

</t>
<t tx="leo.20201108101541.77">void RMatrixPreconditioner::computeJacobi(const RRVector &amp;x, RRVector &amp;y) const
{
    unsigned int nRows = this-&gt;data.getNRows();

    y.resize(nRows);

    for (unsigned int i=0;i&lt;nRows;i++)
    {
        y[i] = (this-&gt;data[i][0] == 0.0) ? 0.0 : x[i] / this-&gt;data[i][0];
    }
}

</t>
<t tx="leo.20201108101541.78">void RMatrixPreconditioner::computeBlockJacobi(const RRVector &amp;x, RRVector &amp;y) const
{
    unsigned int nRows = this-&gt;data.getNRows();
    unsigned int width = this-&gt;data.getNColumns();

    y.resize(nRows);

    RRMatrix As(width,width);
    RRVector xs(width);
    RRVector ys(width);

    unsigned int nBlocks = nRows/width;

    for (unsigned int i=0;i&lt;nBlocks;i++)
    {
        for (unsigned int k=0;k&lt;width;k++)
        {
            unsigned int m = i*width + k;
            for (unsigned int l=0;l&lt;width;l++)
            {
                As[k][l] = this-&gt;data[m][l];
            }
            xs[k] = x[m];
        }

        RRMatrix::solveLU(As,xs,ys);

        for (unsigned int k=0;k&lt;width;k++)
        {
            unsigned int m = i*width + k;
            y[m] = ys[k];
        }
    }
}
</t>
<t tx="leo.20201108101541.79">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rmatrixsolver.cpp                                        *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   23-rd January 2013                                       *
 *                                                                   *
 *  DESCRIPTION: Matrix solver class definition                      *
 *********************************************************************/

#include &lt;string&gt;
#include &lt;cmath&gt;

#include &lt;omp.h&gt;

#include "rmatrixsolver.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101541.8">void RConvection::setMaterial(const QString &amp;matName, double mu, double ro, double k, double c, double b)
{
    this-&gt;matName = matName;
    this-&gt;mu = mu;
    this-&gt;ro = ro;
    this-&gt;k = k;
    this-&gt;c = c;
    this-&gt;b = b;
}

</t>
<t tx="leo.20201108101541.80">void RMatrixSolver::_init(const RMatrixSolver *pMatrixSolver)
{
    this-&gt;iterationInfo.setConvergenceValue(this-&gt;matrixSolverConf.getSolverCvgValue());
    this-&gt;iterationInfo.setNIterations(this-&gt;matrixSolverConf.getNOuterIterations());
    this-&gt;iterationInfo.setOutputFrequency(this-&gt;matrixSolverConf.getOutputFrequency());
    this-&gt;iterationInfo.setOutputFileName(this-&gt;matrixSolverConf.getOutputFileName());

    if (pMatrixSolver)
    {
        this-&gt;matrixSolverConf = pMatrixSolver-&gt;matrixSolverConf;
        this-&gt;iterationInfo = pMatrixSolver-&gt;iterationInfo;
    }
}

RMatrixSolver::RMatrixSolver(const RMatrixSolverConf &amp;matrixSolverConf)
    : matrixSolverConf(matrixSolverConf)
{
    this-&gt;_init();
}

RMatrixSolver::RMatrixSolver(const RMatrixSolver &amp;matrixSolver)
{
    this-&gt;_init(&amp;matrixSolver);
}

RMatrixSolver::~RMatrixSolver()
{
}

RMatrixSolver &amp; RMatrixSolver::operator =(const RMatrixSolver &amp;matrixSolver)
{
    this-&gt;_init(&amp;matrixSolver);
    return (*this);
}

</t>
<t tx="leo.20201108101541.81">void RMatrixSolver::solve(const RSparseMatrix &amp;A, const RRVector &amp;b, RRVector &amp;x, RMatrixPreconditionerType matrixPreconditionerType, unsigned int blockSize)
{
    RMatrixPreconditioner P(A,matrixPreconditionerType,blockSize);
    RRVector y(b);

    double An = A.findNorm();
    double bn = RRVector::norm(b);
    double equationScale = 1.0;

    if (bn != 0.0 &amp;&amp; An != 0.0)
    {
        equationScale = 1.0e9 / std::abs(bn/An);
    }

    RLogger::info("Unknowns = %u\n",b.size());
    RLogger::info("||A|| = %13e\n",An);
    RLogger::info("||b|| = %13e\n",bn);

    this-&gt;iterationInfo.printHeader(RMatrixSolverConf::getName(this-&gt;matrixSolverConf.getType()));

    this-&gt;iterationInfo.setEquationScale(equationScale);

    x.resize(b.getNRows(),0.0);

    y *= equationScale;
    x *= equationScale;

    switch (this-&gt;matrixSolverConf.getType())
    {
        case RMatrixSolverConf::CG:
            this-&gt;solveCG(A,y,x,P);
            break;
        case RMatrixSolverConf::GMRES:
            this-&gt;solveGMRES(A,y,x,P);
            break;
        default:
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Unknown matrix solver type \'%d\'",this-&gt;matrixSolverConf.getType());
    }

    x *= 1.0/equationScale;

    this-&gt;iterationInfo.printFooter();
}

</t>
<t tx="leo.20201108101541.82">void RMatrixSolver::disableConvergenceLogFile(void)
{
    this-&gt;iterationInfo.setOutputFileName(QString());
}

</t>
<t tx="leo.20201108101541.83">void RMatrixSolver::solveCG(const RSparseMatrix &amp;A, const RRVector &amp;b, RRVector &amp;x, RMatrixPreconditioner &amp;P)
{
    unsigned int m = A.getNRows();

    RRVector r(m);
    RRVector z(m);
    RRVector p(m);
    RRVector q(m);

    r.fill(0.0);
    z.fill(0.0);
    p.fill(0.0);
    q.fill(0.0);

    double An = 0.0;
    double bn = 0.0;
    double ro[] = {0.0,0.0};
    double beta = 0.0;
    double dot = 0.0;
    std::vector&lt; std::vector&lt;unsigned int&gt; &gt; index(m);

#pragma omp parallel default(shared)
    {
        // Compute initial residual.
#pragma omp for reduction(+:An,bn)
        for (int64_t i=0;i&lt;int64_t(m);i++)
        {
            r[i] = b[i];
            bn = bn + (b[i]*b[i]);
            index[i] = A.getRowIndexes(i);
            for (unsigned int j=0;j&lt;index[i].size();j++)
            {
                double value = A.getValue(i,j);
                An = An + std::pow(value,2);
                if (value != 0.0)
                {
                    if (x[index[i][j]] != 0.0)
                    {
                        r[i] -= value * x[index[i][j]];
                    }
                }
            }
        }
#pragma omp barrier
#pragma omp master
        {
            An = std::sqrt(An);
            bn = std::sqrt(bn);
        }

        // Iterate and look for the solution
        for (unsigned int it=0;it&lt;this-&gt;matrixSolverConf.getNOuterIterations();it++)
        {
#pragma omp barrier
#pragma omp master
            {
                this-&gt;iterationInfo.setIteration(it);

                P.compute(r,z);

                ro[0] = RRVector::dot(r,z);

                if (it &gt; 0)
                {
                    beta = ro[0] / ro[1];
                    ro[1]= std::max(ro[1],RConstants::eps);
                }
            }

#pragma omp barrier
#pragma omp for
            for (int64_t i=0;i&lt;int64_t(m);i++)
            {
                if (it == 0)
                {
                    p[i] = z[i];
                }
                else
                {
                    p[i] = p[i]*beta + z[i];
                }
            }

            // q = A*p
#pragma omp master
            dot = 0.0;
#pragma omp barrier
#pragma omp for reduction(+:dot)
            for (int64_t i=0;i&lt;int64_t(m);i++)
            {
                q[i] = 0.0;
                for (unsigned int j=0;j&lt;index[i].size();j++)
                {
                    double value = A.getValue(i,j);
                    if (value != 0.0)
                    {
                        q[i] += value * p[index[i][j]];
                    }
                }
                dot = dot + p[i]*q[i];
            }

#pragma omp master
            {
                if (dot &gt; 0.0)
                {
                    dot = std::max(dot,RConstants::eps);
                }
                else if (dot &lt; 0.0)
                {
                    dot = std::min(dot,-RConstants::eps);
                }
                else
                {
                    dot = RConstants::eps;
                }

                double alpha = ro[0] / dot;
                ro[1] = ro[0];

                // x += alpha*p
                // r -= alpha*q
                for (unsigned int i=0;i&lt;m;i++)
                {
                    x[i] += alpha * p[i];
                    r[i] -= alpha * q[i];
                }

                double xn = RRVector::norm(x);
                double rn = RRVector::norm(r);

                double norm = An * xn + bn;
                if (std::abs(norm) &lt; RConstants::eps)
                {
                    norm = RConstants::eps;;
                }

                this-&gt;iterationInfo.setError(rn / norm);
                this-&gt;iterationInfo.printIteration();
            }

#pragma omp barrier
            if (this-&gt;iterationInfo.hasConverged())
            {
                break;
            }
        }
    }
}

</t>
<t tx="leo.20201108101541.84">void RMatrixSolver::solveGMRES(const RSparseMatrix &amp;A, const RRVector &amp;b, RRVector &amp;x, RMatrixPreconditioner &amp;P)
{
    uint mA = A.getNRows();
    uint nouter = this-&gt;matrixSolverConf.getNOuterIterations();
    uint ninner = this-&gt;matrixSolverConf.getNInnerIterations();

    RRVector ro(mA,0.0);
    RRVector w(mA,0.0);
    RRVector p(ninner+1,0.0);
    RRVector y(ninner,0.0);
    RRVector c(ninner,0.0);
    RRVector s(ninner,0.0);
    RRMatrix v(ninner+1,mA,0.0);
    RRMatrix z(ninner+1,mA,0.0);
    RRMatrix h(ninner+1,ninner,0.0);

    std::vector&lt; std::vector&lt;uint&gt; &gt; indexes;
    for (uint i=0;i&lt;mA;i++)
    {
        indexes.push_back(A.getRowIndexes(i));
    }

    double An = A.findNorm();
    double bn = RRVector::norm(b);

    double beta = 0.0;
    double xn = 0.0;

#pragma omp parallel default(shared)
    {
        uint iti = 0;

        // Outer iteration
        for (uint ito=0;ito&lt;nouter;ito++)
        {
#pragma omp master
            {
                this-&gt;iterationInfo.setIteration(ito);

                // Initialize matrix h, Krylov
                h.fill(0.0);

                // Compute initial residual ro and norm beta
                beta = 0.0;
                xn = 0.0;
            }
#pragma omp for reduction(+:xn,beta)
            for (int64_t i=0;i&lt;int64_t(mA);i++)
            {
                ro[i] = b[i];
                double lxn = 0.0;
                for (uint j=0;j&lt;indexes[i].size();j++)
                {
                    ro[i] -= A.getValue(i,j) * x[indexes[i][j]];
                    lxn += std::pow(x[indexes[i][j]],2);
                }
                xn += lxn;
                beta += std::pow(ro[i],2);
            }

#pragma omp master
            {
                xn = std::sqrt(xn);
                beta = std::sqrt(beta);

                // Check convergence
                double norm = An * xn + bn;
                if (std::fabs(norm) &lt; RConstants::eps)
                {
                    norm = RConstants::eps;
                }
                this-&gt;iterationInfo.setError(beta / norm);
                this-&gt;iterationInfo.printIteration();
            }
#pragma omp barrier
            if (this-&gt;iterationInfo.hasConverged())
            {
                break;
            }

            // Define first krylov vector v[0]
#pragma omp for
            for (int64_t i=0;i&lt;int64_t(mA);i++)
            {
                v[0][i] = (beta == 0.0) ? 0.0 : ro[i] / beta;
            }
#pragma omp master
            {
                // Initial rhs define p
                p.fill(0.0);
                p[0] = beta;
            }
            // Inner iteration
            for (iti=0;iti&lt;ninner;iti++)
            {
#pragma omp barrier
#pragma omp master
                {
                    // Preconditioning
                    P.compute(v[iti],z[iti]);
//                    RLogger::warning("%u v %13g\n",iti,RRVector::norm(v[iti])-1.0);
//                    RLogger::warning("%u z %13g\n",iti,RRVector::norm(z[iti]));
                }
#pragma omp barrier
                // A multiplied by the last krylov vector at present
#pragma omp for
                for (int64_t i=0;i&lt;int64_t(mA);i++)
                {
                    w[i] = 0.0;
                    for (uint j=0;j&lt;indexes[i].size();j++)
                    {
                        w[i] += A.getValue(i,j) * z[iti][indexes[i][j]];
                    }
                }
#pragma omp barrier
                // of potential krylov vector with existing subtract dot prod to get orthogonal
#pragma omp master
                {
                    for (uint i=0;i&lt;=iti;i++)
                    {
                        for (uint j=0;j&lt;mA;j++)
                        {
                            h[i][iti] += w[j] * v[i][j];
                        }
                        for (uint j=0;j&lt;mA;j++)
                        {
                            w[j] -= h[i][iti] * v[i][j];
                        }
                    }
                    // Finding norm of the krylov vector
                    h[iti+1][iti] = RRVector::norm(w);
//                    RLogger::warning("%u w %13g\n",iti,RRVector::norm(w));
                }
#pragma omp barrier
                // New krylov vector formed
#pragma omp for
                for (int64_t i=0;i&lt;int64_t(mA);i++)
                {
                    v[iti+1][i] = (h[iti+1][iti] == 0.0) ? 0.0 : w[i] / h[iti+1][iti];
                }
#pragma omp barrier
#pragma omp master
                {
                    for (uint i=1;i&lt;=iti;i++)
                    {
                        double hsave = h[i-1][iti];
                        h[i-1][iti] =  c[i-1]*hsave + s[i-1]*h[i][iti];
                        h[i]  [iti] = -s[i-1]*hsave + c[i-1]*h[i][iti];
                    }

                    @others
}
</t>
<t tx="leo.20201108101541.9">void RConvection::setDiameter(double d)
{
    this-&gt;d = d;
}

</t>
<t tx="leo.20201108101542.1">                    double g = std::sqrt(  h[iti][iti]   * h[iti][iti]
                                         + h[iti+1][iti] * h[iti+1][iti]);
//                    RLogger::warning("%u g %13g\n",iti,g);
                    if (g == 0.0)
                    {
                        c[iti] = s[iti] = 0.0;
                    }
                    else
                    {
                        c[iti] = h[iti][iti]/g;
                        s[iti] = h[iti+1][iti]/g;
                    }
                    h[iti]  [iti] = g;
                    h[iti+1][iti] = 0.0;
                    p[iti+1]      = -s[iti]*p[iti];
                    p[iti]        =  c[iti]*p[iti];
                }
#pragma omp barrier
                if (fabs(p[iti+1]) &lt; beta*1.0e-4)
                {
                    iti++;
                    break;
                }
            } // inner iteration

#pragma omp barrier
            // Backward substitution
#pragma omp master
            {
                y[iti-1] = (h[iti-1][iti-1] == 0.0) ? 0.0 : p[iti-1] / h[iti-1][iti-1];
                for (int i=iti-2;i&gt;=0;i--)
                {
                    for (int j=iti-1;j&gt;i;j--)
                    {
                        p[i] -= y[j] * h[i][j];
                    }
                    y[i] = (h[i][i] == 0.0) ? 0.0 : p[i] / h[i][i];
//                    RLogger::warning("%u %u y %13g\n",iti,i,y[i]);
                }
            }

#pragma omp barrier
            // Update prod
#pragma omp for
            for (int64_t i=0;i&lt;int64_t(mA);i++)
            {
                for (uint j=0;j&lt;=iti-1;j++)
                {
                    x[i] += z[j][i] * y[j];
                }
            }
        } // outer iteration
    }
</t>
<t tx="leo.20201108101542.10">void RSolver::run(void)
{
    RTimeSolver &amp;timeSolver = this-&gt;pModel-&gt;getTimeSolver();
    timeSolver.harmonizeTimesWithInput(this-&gt;pModel-&gt;getProblemSetup().getRestart());

    if (timeSolver.getEnabled() &amp;&amp; RProblem::getTimeSolverEnabled(this-&gt;pModel-&gt;getProblemTaskTree().getProblemTypeMask()))
    {
        if (this-&gt;pModel-&gt;getProblemSetup().getRestart())
        {
            timeSolver.setNextTimeStep();
        }
        RSolverGeneric::updateOldRecords(timeSolver,this-&gt;modelFileName);

        do {
            RLogger::info("time step: %9u of %-9u | time = % 12e [sec] | dt = % 12e [sec]\n",
                          timeSolver.getCurrentTimeStep()+1,
                          timeSolver.getNTimeSteps(),
                          timeSolver.getCurrentTime(),
                          timeSolver.getCurrentTimeStepSize());
            timeSolver.setComputedTime(timeSolver.getCurrentTime());

            RLogger::indent();
            this-&gt;runSingle();
            RLogger::unindent();

            if (RApplicationState::getInstance().getStateType() == R_APPLICATION_STATE_STOP)
            {
                break;
            }
        } while (timeSolver.setNextTimeStep() != RConstants::eod);
    }
    else
    {
        timeSolver.setCurrentTimeStep(0);
        timeSolver.setComputedTime(0.0);
        timeSolver.setTimes(RTimeSolver::findTimesVector(1, 0.0, 0.0));
        this-&gt;runSingle();
    }
}

</t>
<t tx="leo.20201108101542.11">void RSolver::runSingle(void)
{
    this-&gt;runProblemTask(this-&gt;pModel-&gt;getProblemTaskTree(),0);
}

</t>
<t tx="leo.20201108101542.12">bool RSolver::runProblemTask(const RProblemTaskItem &amp;problemTaskItem, uint taskIteration)
{
    bool converged = false;

    if (problemTaskItem.getProblemType() == R_PROBLEM_NONE)
    {
        for (uint i=0;i&lt;problemTaskItem.getNIterations();i++)
        {
            uint nConverged = 0;
            RLogger::info("Problem task iteration: %u of %u\n",i+1,problemTaskItem.getNIterations());
            RLogger::indent();
            for (uint j=0;j&lt;problemTaskItem.getNChildren();j++)
            {
                if (this-&gt;runProblemTask(problemTaskItem.getChild(j),i))
                {
                    nConverged++;
                }
            }
            if (nConverged == problemTaskItem.getNChildren())
            {
                converged = true;
            }
            RLogger::unindent();
            if (converged)
            {
                RLogger::info("All sub-tasks have converged.\n");
                break;
            }

            if (RApplicationState::getInstance().getStateType() == R_APPLICATION_STATE_STOP)
            {
                break;
            }
        }
    }
    else
    {
        if (this-&gt;solvers.contains(problemTaskItem.getProblemType()))
        {
            RProblemType problemType = problemTaskItem.getProblemType();
            if (!this-&gt;solversExecutionCount.contains(problemType))
            {
                this-&gt;solversExecutionCount[problemType] = 0;
            }
            uint executionCount = this-&gt;solversExecutionCount[problemType];

            bool firstRun = (executionCount == 0 &amp;&amp; !this-&gt;pModel-&gt;getProblemSetup().getRestart());

            RLogger::info("Solving problem task: %s\n",RProblem::getName(problemTaskItem.getProblemType()).toUtf8().constData());
            RLogger::indent();

            this-&gt;solvers[problemType]-&gt;run(firstRun,taskIteration);
            converged = this-&gt;solvers[problemTaskItem.getProblemType()]-&gt;hasConverged();
            if (this-&gt;solvers[problemTaskItem.getProblemType()]-&gt;getMeshChanged())
            {
                RProblemTypeMask problemTypeMask = this-&gt;pModel-&gt;getProblemTaskTree().getProblemTypeMask();
                std::vector&lt;RProblemType&gt; problemTypes = RProblem::getTypes(problemTypeMask);
                for (uint i=0;i&lt;problemTypes.size();i++)
                {
                    this-&gt;solvers[problemTypes[i]]-&gt;setMeshChanged(true);
                }
            }

            RLogger::unindent();

            this-&gt;solversExecutionCount[problemType]++;
        }
    }

    return converged;
}
</t>
<t tx="leo.20201108101542.13">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolveracoustic.cpp                                      *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th August 2015                                        *
 *                                                                   *
 *  DESCRIPTION: Acoustic solver class definition                    *
 *********************************************************************/

#include "rsolveracoustic.h"
#include "rmatrixsolver.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101542.14">void RSolverAcoustic::_init(const RSolverAcoustic *pAcousticSolver)
{
    if (pAcousticSolver)
    {
        this-&gt;elementElasticityModulus = pAcousticSolver-&gt;elementElasticityModulus;
        this-&gt;elementDensity = pAcousticSolver-&gt;elementDensity;
        this-&gt;elementDampingFactor = pAcousticSolver-&gt;elementDampingFactor;
        this-&gt;nodeVelocityPotential = pAcousticSolver-&gt;nodeVelocityPotential;
        this-&gt;nodeVelocityPotentialVelocity = pAcousticSolver-&gt;nodeVelocityPotentialVelocity;
        this-&gt;nodeVelocityPotentialAcceleration = pAcousticSolver-&gt;nodeVelocityPotentialAcceleration;
        this-&gt;nodeAcousticPressure = pAcousticSolver-&gt;nodeAcousticPressure;
        this-&gt;elementAcousticParticleVelocity = pAcousticSolver-&gt;elementAcousticParticleVelocity;
    }
    else
    {
        this-&gt;nodeVelocityPotentialVelocity.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
        this-&gt;nodeVelocityPotentialAcceleration.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    }
}

RSolverAcoustic::RSolverAcoustic(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
{
    this-&gt;problemType = R_PROBLEM_ACOUSTICS;
    this-&gt;_init();
}

RSolverAcoustic::RSolverAcoustic(const RSolverAcoustic &amp;acousticSolver)
    : RSolverGeneric(acousticSolver)
{
    this-&gt;_init(&amp;acousticSolver);
}

RSolverAcoustic::~RSolverAcoustic()
{

}

RSolverAcoustic &amp;RSolverAcoustic::operator =(const RSolverAcoustic &amp;acousticSolver)
{
    RSolverGeneric::operator =(acousticSolver);
    this-&gt;_init(&amp;acousticSolver);
    return (*this);
}

</t>
<t tx="leo.20201108101542.15">bool RSolverAcoustic::hasConverged(void) const
{
    return true;
}

double RSolverAcoustic::findSoundSpeedScale(void) const
{
    if (this-&gt;pModel-&gt;getNElements() == 0)
    {
        return 1.0;
    }

    RRVector E, ro;

    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_MODULUS_OF_ELASTICITY,E);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_DENSITY,ro);

    double cavg = 0.0;
    uint ne = 0;
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        if (this-&gt;computableElements[i])
        {
            cavg += std::sqrt(E[i]/ro[i]);
            ne++;
        }
    }
    cavg /= double(ne);
    if (cavg &lt; RConstants::eps)
    {
        cavg = 1.0;
    }
    return 1.0 / cavg;
}

</t>
<t tx="leo.20201108101542.16">void RSolverAcoustic::updateScales(void)
{
//    double sScale = this-&gt;findSoundSpeedScale();
//    double eScale = this-&gt;findElementScale(true);

//    this-&gt;scales.setMetre(eScale*sScale);
//    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();
//    this-&gt;scales.setMetre(1.0/eScale);
//    this-&gt;scales.setSecond(1.0/dt);
//    this-&gt;scales.print(false);
//    this-&gt;scales.setMetre(eScale*sScale);
    this-&gt;scales.setMetre(this-&gt;findMeshScale());
    //    this-&gt;scales.setSecond(eScale/sScale);
}

</t>
<t tx="leo.20201108101542.17">void RSolverAcoustic::recover(void)
{
    this-&gt;recoverVariable(R_VARIABLE_POTENTIAL,
                          R_VARIABLE_APPLY_NODE,
                          this-&gt;pModel-&gt;getNNodes(),
                          0,
                          this-&gt;nodeVelocityPotential,
                          0.0);
    this-&gt;recoverVariable(R_VARIABLE_POTENTIAL_VELOCITY,
                          R_VARIABLE_APPLY_NODE,
                          this-&gt;pModel-&gt;getNNodes(),
                          0,
                          this-&gt;nodeVelocityPotentialVelocity,
                          0.0);
    this-&gt;recoverVariable(R_VARIABLE_POTENTIAL_ACCELERATION,
                          R_VARIABLE_APPLY_NODE,
                          this-&gt;pModel-&gt;getNNodes(),
                          0,
                          this-&gt;nodeVelocityPotentialAcceleration,
                          0.0);
}

</t>
<t tx="leo.20201108101542.18">void RSolverAcoustic::prepare(void)
{
    //! Element velocity potential - displacement.
    RRVector elementVelocityPotential;
    RBVector velocityPotentialSetValues;
    //! Element velocity normal.
    RRVector elementVelocityNormal;
    RBVector velocityNormalSetValues;

    this-&gt;generateNodeBook(R_PROBLEM_ACOUSTICS);

    this-&gt;generateVariableVector(R_VARIABLE_POTENTIAL,elementVelocityPotential,velocityPotentialSetValues,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_VELOCITY,elementVelocityNormal,velocityNormalSetValues,true,this-&gt;firstRun,this-&gt;firstRun);

    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_MODULUS_OF_ELASTICITY,this-&gt;elementElasticityModulus);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_DENSITY,this-&gt;elementDensity);

    this-&gt;elementDampingFactor.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementVelocityPotential,velocityPotentialSetValues,this-&gt;nodeVelocityPotential,true);
    this-&gt;nodeVelocityPotentialOld = this-&gt;nodeVelocityPotential;

    this-&gt;b.resize(this-&gt;nodeBook.getNEnabled());
    this-&gt;x.resize(this-&gt;nodeBook.getNEnabled());

    this-&gt;A.clear();
    this-&gt;b.fill(0.0);
    this-&gt;x.fill(0.0);

    // Prepare point elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNPoints();i++)
    {
        RPoint &amp;point = this-&gt;pModel-&gt;getPoint(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(point.size());j++)
        {
            try
            {
                uint elementID = point.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_POINT(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size(),element.size());
                RRMatrix Ce(element.size(),element.size());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());

                Me.fill(0.0);
                Ce.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        for (uint n=0;n&lt;element.size();n++)
                        {
                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
                            {
                                Me[m][n] += (-1.0) * N[m] * N[n] * detJ * shapeFunc.getW() * point.getVolume();
                            }
                        }
                        // Velocity / force
                        fe[m] += elementVelocityNormal[elementID] * N[m] * detJ * shapeFunc.getW();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ce,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare line elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        RLine &amp;line = this-&gt;pModel-&gt;getLine(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(line.size());j++)
        {
            try
            {
                uint elementID = line.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_LINE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size(),element.size());
                RRMatrix Ce(element.size(),element.size());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());
                RRMatrix B(element.size(),1);

                Me.fill(0.0);
                Ce.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                double c = std::sqrt(this-&gt;elementElasticityModulus[elementID]/this-&gt;elementDensity[elementID]);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += dN[m][0]*J[0][0];
                    }

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        for (uint n=0;n&lt;element.size();n++)
                        {
                            // Stiffness
                            Ke[m][n] += (B[m][0]*B[n][0]) * line.getCrossArea() * c * c * detJ * shapeFunc.getW();

                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
                            {
                                Me[m][n] += (-1.0) * N[m] * N[n] * detJ * shapeFunc.getW() * line.getCrossArea();
                            }
                        }
                        // Velocity / force
                        fe[m] += elementVelocityNormal[elementID] * N[m] * detJ * shapeFunc.getW();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ce,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare surface elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        RSurface &amp;surface = this-&gt;pModel-&gt;getSurface(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(surface.size());j++)
        {
            try
            {
                uint elementID = surface.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_SURFACE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size(),element.size());
                RRMatrix Ce(element.size(),element.size());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());
                RRMatrix B(element.size(),2);

                Me.fill(0.0);
                Ce.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                double c = std::sqrt(this-&gt;elementElasticityModulus[elementID]/this-&gt;elementDensity[elementID]);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1]);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1]);
                    }

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        for (uint n=0;n&lt;element.size();n++)
                        {
                            // Stiffness
                            Ke[m][n] += (B[m][0]*B[n][0]+B[m][1]*B[n][1]) * surface.getThickness() * c * c * detJ * shapeFunc.getW();

                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
                            {
                                Me[m][n] += (-1.0) * N[m] * N[n] * detJ * shapeFunc.getW() * surface.getThickness();
                            }
                        }
                        // Velocity / force
                        fe[m] += elementVelocityNormal[elementID] * N[m] * detJ * shapeFunc.getW();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ce,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare volume elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        RVolume &amp;volume = this-&gt;pModel-&gt;getVolume(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(volume.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = volume.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_VOLUME(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size(),element.size());
                RRMatrix Ce(element.size(),element.size());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());
                RRMatrix B(element.size(),3);

                Me.fill(0.0);
                Ce.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                double c = std::sqrt(this-&gt;elementElasticityModulus[elementID]/this-&gt;elementDensity[elementID]);

                // Conduction
                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]);
                        B[m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]);
                    }

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        for (uint n=0;n&lt;element.size();n++)
                        {
                            // Stiffness
                            Ke[m][n] += (B[m][0]*B[n][0] + B[m][1]*B[n][1] + B[m][2]*B[n][2])
                                     * c * c
                                     * detJ
                                     * shapeFunc.getW();

                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
                            {
                                Me[m][n] += (-1.0) * N[m] * N[n] * detJ * shapeFunc.getW();
                            }
                        }
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ce,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }
}

</t>
<t tx="leo.20201108101542.19">void RSolverAcoustic::solve(void)
{
    try
    {
        RLogger::indent();
        RMatrixSolver matrixSolver(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));
        matrixSolver.solve(this-&gt;A,this-&gt;b,this-&gt;x,R_MATRIX_PRECONDITIONER_JACOBI,1);
        RLogger::unindent();
    }
    catch (RError error)
    {
        RLogger::unindent();
        throw error;
    }

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        uint position;
        if (this-&gt;nodeBook.getValue(i,position))
        {
            this-&gt;nodeVelocityPotential[i] = this-&gt;x[position];
        }
    }

    double alpha = 1.0 / 2.0;
    double beta = this-&gt;pModel-&gt;getTimeSolver().getTimeMarchApproximationCoefficient() / 2.0;
    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();

    double a0 = 1.0 / (beta * std::pow(dt,2));
    double a2 = 1.0 / (beta * dt);
    double a3 = (1.0 / (2.0 * beta)) - 1.0;
    double a6 = dt * (1.0 - alpha);
    double a7 = dt * alpha;

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        double puo = this-&gt;nodeVelocityPotentialOld[i];
        double pvo = this-&gt;nodeVelocityPotentialVelocity[i];
        double pao = this-&gt;nodeVelocityPotentialAcceleration[i];

        double pu = this-&gt;nodeVelocityPotential[i];
        double pa = a0 * (pu - puo) - a2 * pvo - a3 * pao;
        double pv = pvo + a6 * pao + a7 * pa;

        this-&gt;nodeVelocityPotentialVelocity[i] = pv;
        this-&gt;nodeVelocityPotentialAcceleration[i] = pa;
    }
}

</t>
<t tx="leo.20201108101542.2">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rscales.cpp                                              *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   26-th May 2014                                           *
 *                                                                   *
 *  DESCRIPTION: Scales class definition                             *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rscales.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101542.20">void RSolverAcoustic::process(void)
{
    // Process absorbing boundary
    this-&gt;processAbsorbingBoundary();

    // Acoustic pressure
    this-&gt;processAcousticPressure();

    // Acoustic particle velocity
    this-&gt;processAcousticParticleVelocity();
}

</t>
<t tx="leo.20201108101542.21">void RSolverAcoustic::processAbsorbingBoundary(void)
{
    // Find nodes which are on absorbing boundary.
    std::vector&lt;bool&gt; absorbingBoundaryNodes = this-&gt;findAbsorbingBoundaryNodes();

    // Find absorbing boundary normals for each node.
    std::vector&lt;RR3Vector&gt; absorbingBoundaryNormals = this-&gt;findAbsorbingBoundaryNormals(absorbingBoundaryNodes);

    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();

    RRVector t(this-&gt;pModel-&gt;getNNodes(),0.0);
    RUVector ncount(this-&gt;pModel-&gt;getNNodes(),0);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        if (!this-&gt;computableElements[i])
        {
            continue;
        }

        const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(i);
        double c = std::sqrt(this-&gt;elementElasticityModulus[i]/this-&gt;elementDensity[i]);

        for (uint j=0;j&lt;rElement.size();j++)
        {
            if (!absorbingBoundaryNodes[rElement.getNodeId(j)])
            {
                continue;
            }
            for (uint k=j+1;k&lt;rElement.size();k++)
            {
                if (absorbingBoundaryNodes[rElement.getNodeId(k)])
                {
                    continue;
                }
                RR3Vector distance;
                RR3Vector::subtract(this-&gt;pModel-&gt;getNode(rElement.getNodeId(k)).toVector(),
                                    this-&gt;pModel-&gt;getNode(rElement.getNodeId(j)).toVector(),
                                    distance);
                distance[0] *= absorbingBoundaryNormals[rElement.getNodeId(j)][0];
                distance[1] *= absorbingBoundaryNormals[rElement.getNodeId(j)][1];
                distance[2] *= absorbingBoundaryNormals[rElement.getNodeId(j)][2];

                double dl = distance.length();

                if (dl &lt; RConstants::eps)
                {
                    continue;
                }

                double B = 1.0;
                double b = 0.4;
                double V = c * dt / dl;
                double qx = (b*(B+V)-V)/((B+V)*(1.0-b));
                double qt = (b*(B+V)-B)/((B+V)*(1.0-b));
                double qtx = b/(b-1.0);

                t[rElement.getNodeId(j)] += -qx * this-&gt;nodeVelocityPotential[rElement.getNodeId(k)]
                                          -  qt * this-&gt;nodeVelocityPotentialOld[rElement.getNodeId(j)]
                                          -  qtx * this-&gt;nodeVelocityPotentialOld[rElement.getNodeId(k)];
                ncount[rElement.getNodeId(j)] ++;
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        if (ncount[i] &gt; 0)
        {
            this-&gt;nodeVelocityPotential[i] = t[i] / ncount[i];
        }
    }
}

</t>
<t tx="leo.20201108101542.22">void RSolverAcoustic::processAcousticPressure(void)
{
    this-&gt;nodeAcousticPressure.resize(this-&gt;pModel-&gt;getNNodes(),0.0);

    RRVector nodeDensity;
    RBVector nodeDensitySetValues(this-&gt;pModel-&gt;getNNodes(),false);
    this-&gt;pModel-&gt;convertElementToNodeVector(this-&gt;elementDensity,nodeDensitySetValues,nodeDensity);

    //double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();
    //double ct = this-&gt;pModel-&gt;getTimeSolver().getCurrentTime();

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        //this-&gt;nodeAcousticPressure[i] = (-1.0) * nodeDensity[i] * (this-&gt;nodeVelocityPotentialDisplacement[i] - this-&gt;nodeVelocityPotentialDisplacementOld[i]) / dt;
        // Per second
        this-&gt;nodeAcousticPressure[i] = nodeDensity[i] * this-&gt;nodeVelocityPotential[i];
    }
}

</t>
<t tx="leo.20201108101542.23">void RSolverAcoustic::processAcousticParticleVelocity(void)
{
    this-&gt;elementAcousticParticleVelocity.x.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;elementAcousticParticleVelocity.y.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;elementAcousticParticleVelocity.z.resize(this-&gt;pModel-&gt;getNElements(),0.0);

    // Process line elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        RLine &amp;line = this-&gt;pModel-&gt;getLine(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(line.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = line.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_LINE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRVector B(element.size());

                RR3Vector ve(0.0,0.0,0.0);

                if (line.getCrossArea() &gt; 0.0)
                {
                    double vi = 0.0;

                    for (uint k=0;k&lt;nInp;k++)
                    {
                        const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                        const RRMatrix &amp;dN = shapeFunc.getDN();
                        RRMatrix J, Rt;
                        double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                        if (line.getCrossArea() != 0.0)
                        {
                            for (uint m=0;m&lt;dN.getNRows();m++)
                            {
                                B[m] += dN[m][0] * J[0][0] * detJ / double(nInp);
                            }
                        }
                    }

                    for (uint k=0;k&lt;element.size();k++)
                    {
                        uint nodeID = element.getNodeId(k);

                        vi -= B[k] * this-&gt;nodeVelocityPotential[nodeID];
                    }

                    RRMatrix R;
                    RRVector t;
                    this-&gt;pModel-&gt;getElement(elementID).findTransformationMatrix(this-&gt;pModel-&gt;getNodes(),R,t);

                    ve[0] += R[0][0]*vi;
                    ve[1] += R[1][0]*vi;
                    ve[2] += R[2][0]*vi;
                }

                this-&gt;elementAcousticParticleVelocity.x[elementID] = ve[0];
                this-&gt;elementAcousticParticleVelocity.y[elementID] = ve[1];
                this-&gt;elementAcousticParticleVelocity.z[elementID] = ve[2];
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to process acoustic particle velocity.");
        }
    }

    // Process surface elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        RSurface &amp;surface = this-&gt;pModel-&gt;getSurface(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(surface.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = surface.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_SURFACE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix B(element.size(),2);

                RR3Vector ve(0.0,0.0,0.0);

                if (surface.getThickness() &gt; 0.0)
                {
                    double vi = 0.0;
                    double vj = 0.0;

                    for (uint k=0;k&lt;nInp;k++)
                    {
                        const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                        const RRMatrix &amp;dN = shapeFunc.getDN();
                        RRMatrix J, Rt;
                        double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                        if (surface.getThickness() != 0.0)
                        {
                            for (uint m=0;m&lt;dN.getNRows();m++)
                            {
                                B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1]) * detJ / double(nInp);
                                B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1]) * detJ / double(nInp);
                            }
                        }
                    }

                    for (uint k=0;k&lt;element.size();k++)
                    {
                        uint nodeID = element.getNodeId(k);

                        vi -= B[k][0] * this-&gt;nodeVelocityPotential[nodeID];
                        vj -= B[k][1] * this-&gt;nodeVelocityPotential[nodeID];
                    }

                    RRMatrix R;
                    RRVector t;
                    this-&gt;pModel-&gt;getElement(elementID).findTransformationMatrix(this-&gt;pModel-&gt;getNodes(),R,t);

                    ve[0] += R[0][0]*vi + R[0][1]*vj;
                    ve[1] += R[1][0]*vi + R[1][1]*vj;
                    ve[2] += R[2][0]*vi + R[2][1]*vj;
                }

                this-&gt;elementAcousticParticleVelocity.x[elementID] = ve[0];
                this-&gt;elementAcousticParticleVelocity.y[elementID] = ve[1];
                this-&gt;elementAcousticParticleVelocity.z[elementID] = ve[2];
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to process acoustic particle velocity.");
        }
    }

    // Process volume elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        RVolume &amp;volume = this-&gt;pModel-&gt;getVolume(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(volume.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = volume.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_VOLUME(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix B(element.size(),3);
                RR3Vector ve(0.0,0.0,0.0);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]) * detJ / double(nInp);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]) * detJ / double(nInp);
                        B[m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]) * detJ / double(nInp);
                    }
                }

                for (uint m=0;m&lt;element.size();m++)
                {
                    uint nodeId = element.getNodeId(m);
                    ve[0] -= B[m][0] * this-&gt;nodeVelocityPotential[nodeId];
                    ve[1] -= B[m][1] * this-&gt;nodeVelocityPotential[nodeId];
                    ve[2] -= B[m][2] * this-&gt;nodeVelocityPotential[nodeId];
                }

                this-&gt;elementAcousticParticleVelocity.x[elementID] = ve[0];
                this-&gt;elementAcousticParticleVelocity.y[elementID] = ve[1];
                this-&gt;elementAcousticParticleVelocity.z[elementID] = ve[2];
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to process acoustic particle velocity.");
        }
    }
}

</t>
<t tx="leo.20201108101542.24">void RSolverAcoustic::store(void)
{
    RLogger::info("Storing results\n");
    RLogger::indent();

    // Velocity potential
    uint velocityPotentialPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_POTENTIAL);
    if (velocityPotentialPos == RConstants::eod)
    {
        velocityPotentialPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_POTENTIAL);
        this-&gt;pModel-&gt;getVariable(velocityPotentialPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumValue(this-&gt;nodeVelocityPotential),
                    RStatistics::findMaximumValue(this-&gt;nodeVelocityPotential));
    }
    RVariable &amp;velocityPotential =  this-&gt;pModel-&gt;getVariable(velocityPotentialPos);

    velocityPotential.setApplyType(R_VARIABLE_APPLY_NODE);
    velocityPotential.resize(1,this-&gt;pModel-&gt;getNNodes());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        velocityPotential.setValue(0,i,this-&gt;nodeVelocityPotential[i]);
    }

    // Acoustic pressure
    uint acousticPressurePos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_ACOUSTIC_PRESSURE);
    if (acousticPressurePos == RConstants::eod)
    {
        acousticPressurePos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_ACOUSTIC_PRESSURE);
        this-&gt;pModel-&gt;getVariable(acousticPressurePos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumValue(this-&gt;nodeAcousticPressure),
                    RStatistics::findMaximumValue(this-&gt;nodeAcousticPressure));
    }
    RVariable &amp;acousticPressure =  this-&gt;pModel-&gt;getVariable(acousticPressurePos);

    acousticPressure.setApplyType(R_VARIABLE_APPLY_NODE);
    acousticPressure.resize(1,this-&gt;pModel-&gt;getNNodes());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        acousticPressure.setValue(0,i,this-&gt;nodeAcousticPressure[i]);
    }

    // Acoustic particle velocity
    uint acousticParticleVelocityPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_ACOUSTIC_PARTICLE_VELOCITY);
    if (acousticParticleVelocityPos == RConstants::eod)
    {
        acousticParticleVelocityPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_ACOUSTIC_PARTICLE_VELOCITY);

        double umin = 0.0;
        double umax = 0.0;
        for (uint i=0;i&lt;this-&gt;elementAcousticParticleVelocity.x.size();i++)
        {
            @others
}

</t>
<t tx="leo.20201108101542.25">        double u = RR3Vector(this-&gt;elementAcousticParticleVelocity.x[i],
                             this-&gt;elementAcousticParticleVelocity.y[i],
                             this-&gt;elementAcousticParticleVelocity.z[i]).length();
        if (i == 0)
        {
            umin = umax = u;
        }
        else
        {
            umin = std::min(umin,u);
            umax = std::max(umax,u);
        }
    }

    this-&gt;pModel-&gt;getVariable(acousticParticleVelocityPos).getVariableData().setMinMaxDisplayValue(umin,umax);
}
RVariable &amp;acousticParticleVelocity =  this-&gt;pModel-&gt;getVariable(acousticParticleVelocityPos);

acousticParticleVelocity.setApplyType(R_VARIABLE_APPLY_ELEMENT);
acousticParticleVelocity.resize(3,this-&gt;pModel-&gt;getNElements());
for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
{
    acousticParticleVelocity.setValue(0,i,this-&gt;elementAcousticParticleVelocity.x[i]);
    acousticParticleVelocity.setValue(1,i,this-&gt;elementAcousticParticleVelocity.y[i]);
    acousticParticleVelocity.setValue(2,i,this-&gt;elementAcousticParticleVelocity.z[i]);
}

RLogger::unindent();
</t>
<t tx="leo.20201108101542.26">void RSolverAcoustic::statistics(void)
{
    this-&gt;printStats(R_VARIABLE_POTENTIAL);
    this-&gt;printStats(R_VARIABLE_ACOUSTIC_PARTICLE_VELOCITY);
    this-&gt;printStats(R_VARIABLE_ACOUSTIC_PRESSURE);
    this-&gt;processMonitoringPoints();
}

std::vector&lt;bool&gt; RSolverAcoustic::findAbsorbingBoundaryNodes(void) const
{
    std::vector&lt;bool&gt; absorbingBoundaryNodes;
    absorbingBoundaryNodes.resize(this-&gt;pModel-&gt;getNNodes(),false);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNPoints();i++)
    {
        const RPoint &amp;rPoint(this-&gt;pModel-&gt;getPoint(i));
        if (rPoint.hasBoundaryCondition(R_BOUNDARY_CONDITION_ABSORBING_BOUNDARY))
        {
            for (uint j=0;j&lt;rPoint.size();j++)
            {
                const RElement &amp;rElement(this-&gt;pModel-&gt;getElement(rPoint.get(j)));
                for (uint k=0;k&lt;rElement.size();k++)
                {
                    absorbingBoundaryNodes[rElement.getNodeId(k)] = true;
                }
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        const RLine &amp;rLine(this-&gt;pModel-&gt;getLine(i));
        if (rLine.hasBoundaryCondition(R_BOUNDARY_CONDITION_ABSORBING_BOUNDARY))
        {
            for (uint j=0;j&lt;rLine.size();j++)
            {
                const RElement &amp;rElement(this-&gt;pModel-&gt;getElement(rLine.get(j)));
                for (uint k=0;k&lt;rElement.size();k++)
                {
                    absorbingBoundaryNodes[rElement.getNodeId(k)] = true;
                }
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        const RSurface &amp;rSurface(this-&gt;pModel-&gt;getSurface(i));
        if (rSurface.hasBoundaryCondition(R_BOUNDARY_CONDITION_ABSORBING_BOUNDARY))
        {
            for (uint j=0;j&lt;rSurface.size();j++)
            {
                const RElement &amp;rElement(this-&gt;pModel-&gt;getElement(rSurface.get(j)));
                for (uint k=0;k&lt;rElement.size();k++)
                {
                    absorbingBoundaryNodes[rElement.getNodeId(k)] = true;
                }
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        const RVolume &amp;rVolume(this-&gt;pModel-&gt;getVolume(i));
        if (rVolume.hasBoundaryCondition(R_BOUNDARY_CONDITION_ABSORBING_BOUNDARY))
        {
            for (uint j=0;j&lt;rVolume.size();j++)
            {
                const RElement &amp;rElement(this-&gt;pModel-&gt;getElement(rVolume.get(j)));
                for (uint k=0;k&lt;rElement.size();k++)
                {
                    absorbingBoundaryNodes[rElement.getNodeId(k)] = true;
                }
            }
        }
    }
    return absorbingBoundaryNodes;
}

std::vector&lt;bool&gt; RSolverAcoustic::findAbsorbingBoundaryElements() const
{
    std::vector&lt;bool&gt; absorbingBoundaryElements;
    absorbingBoundaryElements.resize(this-&gt;pModel-&gt;getNElements(),false);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNPoints();i++)
    {
        const RPoint &amp;rPoint(this-&gt;pModel-&gt;getPoint(i));
        if (rPoint.getVolume() &lt; RConstants::eps)
        {
            continue;
        }
        if (rPoint.hasBoundaryCondition(R_BOUNDARY_CONDITION_ABSORBING_BOUNDARY))
        {
            for (uint j=0;j&lt;rPoint.size();j++)
            {
                absorbingBoundaryElements[rPoint.get(j)] = true;
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        const RLine &amp;rLine(this-&gt;pModel-&gt;getLine(i));
        if (rLine.getCrossArea() &lt; RConstants::eps)
        {
            continue;
        }
        if (rLine.hasBoundaryCondition(R_BOUNDARY_CONDITION_ABSORBING_BOUNDARY))
        {
            for (uint j=0;j&lt;rLine.size();j++)
            {
                absorbingBoundaryElements[rLine.get(j)] = true;
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        const RSurface &amp;rSurface(this-&gt;pModel-&gt;getSurface(i));
        if (rSurface.getThickness() &lt; RConstants::eps)
        {
            continue;
        }
        if (rSurface.hasBoundaryCondition(R_BOUNDARY_CONDITION_ABSORBING_BOUNDARY))
        {
            for (uint j=0;j&lt;rSurface.size();j++)
            {
                absorbingBoundaryElements[rSurface.get(j)] = true;
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        const RVolume &amp;rVolume(this-&gt;pModel-&gt;getVolume(i));
        if (rVolume.hasBoundaryCondition(R_BOUNDARY_CONDITION_ABSORBING_BOUNDARY))
        {
            for (uint j=0;j&lt;rVolume.size();j++)
            {
                absorbingBoundaryElements[rVolume.get(j)] = true;
            }
        }
    }
    return absorbingBoundaryElements;
}

std::vector&lt;RR3Vector&gt; RSolverAcoustic::findAbsorbingBoundaryNormals(const std::vector&lt;bool&gt; &amp;absorbingBoundaryNodes) const
{
    std::vector&lt;RR3Vector&gt; normals;
    normals.resize(this-&gt;pModel-&gt;getNNodes(),RR3Vector(0.0,0.0,0.0));

    RUVector ncount(this-&gt;pModel-&gt;getNNodes(),0);

    // Find elements which belong to absorbing boundary.
    std::vector&lt;bool&gt; absorbingBoundaryElements = this-&gt;findAbsorbingBoundaryElements();

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        if (!absorbingBoundaryElements[i])
        {
            continue;
        }

        const RElement &amp;rElement(this-&gt;pModel-&gt;getElement(i));
        std::vector&lt;RElement&gt; edgeElements = rElement.generateEdgeElements();
        for (uint j=0;j&lt;edgeElements.size();j++)
        {
            const RElement &amp;rEdgeElement = edgeElements[i];
            bool isAbsorbing = true;

            for (uint k=0;k&lt;rEdgeElement.size();k++)
            {
                if (!absorbingBoundaryNodes[rEdgeElement.getNodeId(k)])
                {
                    isAbsorbing = false;
                    break;
                }
            }
            if (!isAbsorbing)
            {
                continue;
            }

            RR3Vector edgeElementNormal;
            bool normalFound = false;

            if (R_ELEMENT_TYPE_IS_POINT(rEdgeElement.getType()))
            {
                uint n1 = 1, n2 = 0;

                if (rEdgeElement.getNodeId(0) == rElement.getNodeId(0))
                {
                    n1 = 0;
                    n2 = 1;
                }

                RR3Vector::subtract(this-&gt;pModel-&gt;getNode(rEdgeElement.getNodeId(n1)).toVector(),
                                    this-&gt;pModel-&gt;getNode(rEdgeElement.getNodeId(n2)).toVector(),
                                    edgeElementNormal);

                edgeElementNormal.normalize();
                normalFound = true;
            }
            else if (R_ELEMENT_TYPE_IS_LINE(rEdgeElement.getType()))
            {
                RR3Vector elementNormal;
                if (rElement.findNormal(this-&gt;pModel-&gt;getNodes(),elementNormal[0],elementNormal[1],elementNormal[2]))
                {
                    RR3Vector direction;

                    RR3Vector::subtract(this-&gt;pModel-&gt;getNode(rEdgeElement.getNodeId(1)).toVector(),
                                        this-&gt;pModel-&gt;getNode(rEdgeElement.getNodeId(0)).toVector(),
                                        direction);

                    RR3Vector::cross(elementNormal,direction,edgeElementNormal);
                    edgeElementNormal.normalize();
                    normalFound = true;
                }
            }
            else if (R_ELEMENT_TYPE_IS_SURFACE(rEdgeElement.getType()))
            {
                normalFound = rEdgeElement.findNormal(this-&gt;pModel-&gt;getNodes(),edgeElementNormal[0],edgeElementNormal[1],edgeElementNormal[2]);
            }

            if (normalFound)
            {
                for (uint l=0;l&lt;rEdgeElement.size();l++)
                {
                    uint nodeID = rEdgeElement.getNodeId(l);
                    normals[nodeID][0] += edgeElementNormal[0];
                    normals[nodeID][1] += edgeElementNormal[1];
                    normals[nodeID][2] += edgeElementNormal[2];
                    ncount[nodeID] ++;
                }
            }
        }
    }

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        if (ncount[i] &gt; 0)
        {
            normals[i][0] /= double(ncount[i]);
            normals[i][1] /= double(ncount[i]);
            normals[i][2] /= double(ncount[i]);
        }
    }

    return normals;
}

</t>
<t tx="leo.20201108101542.27">void RSolverAcoustic::assemblyMatrix(uint elementID, const RRMatrix &amp;Me, const RRMatrix &amp;Ce, const RRMatrix &amp;Ke, const RRVector &amp;fe)
{
    double alpha = 1.0 / 2.0;
    double beta = this-&gt;pModel-&gt;getTimeSolver().getTimeMarchApproximationCoefficient() / 2.0;
    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();

    const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);

    RRMatrix Ae(element.size(),element.size());
    RRVector be(element.size());

    Ae.fill(0.0);
    be.fill(0.0);

    double a0 = 1.0 / (beta * std::pow(dt,2));
    double a1 = alpha / (beta * dt);
    double a2 = 1.0 / (beta * dt);
    double a3 = (1.0 / (2.0 * beta)) - 1.0;
    double a4 = (alpha / beta) - 1.0;
    double a5 = (1.0 / 2.0) * dt * ((alpha / beta) - 2.0);

    if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
    {
        for (uint m=0;m&lt;element.size();m++)
        {
            be[m] = fe[m];
            for (uint n=0;n&lt;element.size();n++)
            {
                double pu = this-&gt;nodeVelocityPotential[element.getNodeId(n)];
                double pv = this-&gt;nodeVelocityPotentialVelocity[element.getNodeId(n)];
                double pa = this-&gt;nodeVelocityPotentialAcceleration[element.getNodeId(n)];

                Ae[m][n] = Ke[m][n] + a0 * Me[m][n] + a1 * Ce[m][n];
                be[m] += Me[m][n] * (a0 * pu + a2 * pv + a3 * pa) + Ce[m][n] * (a1 * pu + a4 * pv + a5 * pa);
            }
        }
    }
    else
    {
        Ae = Ke;
        be = fe;
    }

    // Apply explicit boundary conditions.
    for (uint m=0;m&lt;element.size();m++)
    {
        uint position;
        uint nodeID = element.getNodeId(m);
        if (!this-&gt;nodeBook.getValue(nodeID,position))
        {
            for (uint n=0;n&lt;element.size();n++)
            {
                be[n] -= Ae[n][m] * this-&gt;nodeVelocityPotential[nodeID];
            }
        }
    }


    // Assembly final matrix system
    for (uint m=0;m&lt;element.size();m++)
    {
        uint mp;

        if (this-&gt;nodeBook.getValue(element.getNodeId(m),mp))
        {
            this-&gt;b[mp] += be[m];
            for (uint n=0;n&lt;element.size();n++)
            {
                uint np = 0;

                if (this-&gt;nodeBook.getValue(element.getNodeId(n),np))
                {
                    this-&gt;A.addValue(mp,np,Ae[m][n]);
                }
            }
        }
    }
}
</t>
<t tx="leo.20201108101542.28">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolverelectrostatics.cpp                                *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   19-th November 2015                                      *
 *                                                                   *
 *  DESCRIPTION: Electrostatics solver class definition              *
 *********************************************************************/

#include "rsolverelectrostatics.h"
#include "rmatrixsolver.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101542.29">void RSolverElectrostatics::_init(const RSolverElectrostatics *pSolver)
{
    if (pSolver)
    {
        this-&gt;nodeElectricPotential = pSolver-&gt;nodeElectricPotential;
        this-&gt;elementElectricField = pSolver-&gt;elementElectricField;
        this-&gt;elementCurrentDensity = pSolver-&gt;elementCurrentDensity;
        this-&gt;elementRelativePermittivity = pSolver-&gt;elementRelativePermittivity;
        this-&gt;elementElectricConductivity = pSolver-&gt;elementElectricConductivity;
        this-&gt;elementElectricEnergy = pSolver-&gt;elementElectricEnergy;
        this-&gt;elementElectricResistivity = pSolver-&gt;elementElectricResistivity;
        this-&gt;elementJouleHeat = pSolver-&gt;elementJouleHeat;
    }
}

RSolverElectrostatics::RSolverElectrostatics(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
{
    this-&gt;problemType = R_PROBLEM_ELECTROSTATICS;
    this-&gt;_init();
}

RSolverElectrostatics::RSolverElectrostatics(const RSolverElectrostatics &amp;solver)
    : RSolverGeneric(solver)
{
    this-&gt;_init(&amp;solver);
}

RSolverElectrostatics::~RSolverElectrostatics()
{

}

RSolverElectrostatics &amp;RSolverElectrostatics::operator =(const RSolverElectrostatics &amp;solver)
{
    RSolverGeneric::operator =(solver);
    this-&gt;_init(&amp;solver);
    return (*this);
}

</t>
<t tx="leo.20201108101542.3">void RScales::_init(const RScales *pScales)
{
    if (pScales)
    {
        this-&gt;metre = pScales-&gt;metre;
        this-&gt;kilogram = pScales-&gt;kilogram;
        this-&gt;second = pScales-&gt;second;
        this-&gt;ampere = pScales-&gt;ampere;
        this-&gt;kelvin = pScales-&gt;kelvin;
        this-&gt;candela = pScales-&gt;candela;
        this-&gt;mole = pScales-&gt;mole;
    }
}

RScales::RScales()
    : metre(1.0)
    , kilogram(1.0)
    , second(1.0)
    , ampere(1.0)
    , kelvin(1.0)
    , candela(1.0)
    , mole(1.0)
{
    this-&gt;_init();
}

RScales::RScales(const RScales &amp;scales)
{
    this-&gt;_init(&amp;scales);
}

RScales::~RScales()
{

}

RScales &amp;RScales::operator =(const RScales &amp;scales)
{
    this-&gt;_init(&amp;scales);
    return (*this);
}

double RScales::findScaleFactor(RVariableType variableType) const
{
    switch (variableType)
    {
        case R_VARIABLE_ACCELERATION:
        case R_VARIABLE_ACCELERATION_X:
        case R_VARIABLE_ACCELERATION_Y:
        case R_VARIABLE_ACCELERATION_Z:
            return this-&gt;metre/std::pow(this-&gt;second,2);
        case R_VARIABLE_ACOUSTIC_PRESSURE:
            return this-&gt;kilogram/(this-&gt;metre*std::pow(this-&gt;second,2));
        case R_VARIABLE_ACOUSTIC_PARTICLE_VELOCITY:
            return this-&gt;metre*this-&gt;second;
        case R_VARIABLE_CHARGE_DENSITY:
            return this-&gt;ampere*this-&gt;second;
        case R_VARIABLE_CONVECTION_COEFFICIENT:
            return this-&gt;kilogram*this-&gt;kelvin/std::pow(this-&gt;second,3);
        case R_VARIABLE_CURRENT_DENSITY:
        case R_VARIABLE_CURRENT_DENSITY_X:
        case R_VARIABLE_CURRENT_DENSITY_Y:
        case R_VARIABLE_CURRENT_DENSITY_Z:
            return this-&gt;ampere/std::pow(this-&gt;metre,2);
        case R_VARIABLE_DENSITY:
            return this-&gt;kilogram/std::pow(this-&gt;metre,3);
        case R_VARIABLE_DISPLACEMENT:
        case R_VARIABLE_DISPLACEMENT_X:
        case R_VARIABLE_DISPLACEMENT_Y:
        case R_VARIABLE_DISPLACEMENT_Z:
            return this-&gt;metre;
        case R_VARIABLE_DYNAMIC_VISCOSITY:
            return this-&gt;kilogram/(this-&gt;metre*this-&gt;second);
        case R_VARIABLE_ELECTRIC_ENERGY:
            return this-&gt;kilogram*std::pow(this-&gt;metre,2)/std::pow(this-&gt;second,2);
        case R_VARIABLE_ELECTRIC_FIELD:
        case R_VARIABLE_ELECTRIC_FIELD_X:
        case R_VARIABLE_ELECTRIC_FIELD_Y:
        case R_VARIABLE_ELECTRIC_FIELD_Z:
            return this-&gt;kilogram*this-&gt;metre/(std::pow(this-&gt;second,3)*this-&gt;ampere);
        case R_VARIABLE_ELECTRIC_POTENTIAL:
            return this-&gt;kilogram*std::pow(this-&gt;metre,2)/(std::pow(this-&gt;second,3)*this-&gt;ampere);
        case R_VARIABLE_ELECTRICAL_CONDUCTIVITY:
            return std::pow(this-&gt;second,3)*std::pow(this-&gt;ampere,2)/(this-&gt;kilogram*std::pow(this-&gt;metre,3));
        case R_VARIABLE_ELECTRICAL_RESISTIVITY:
            return this-&gt;kilogram*std::pow(this-&gt;metre,3)/(std::pow(this-&gt;second,3)*std::pow(this-&gt;ampere,2));
        case R_VARIABLE_EMISSIVITY:
            return 1.0;
        case R_VARIABLE_FLUID_TEMPERATURE:
            return this-&gt;kelvin;
        case R_VARIABLE_FREQUENCY:
            return 1.0/this-&gt;second;
        case R_VARIABLE_FORCE:
        case R_VARIABLE_FORCE_X:
        case R_VARIABLE_FORCE_Y:
        case R_VARIABLE_FORCE_Z:
            return this-&gt;kilogram*this-&gt;metre/std::pow(this-&gt;second,2);
        case R_VARIABLE_FORCE_UNIT_AREA:
        case R_VARIABLE_FORCE_UNIT_AREA_X:
        case R_VARIABLE_FORCE_UNIT_AREA_Y:
        case R_VARIABLE_FORCE_UNIT_AREA_Z:
            return this-&gt;kilogram/(this-&gt;metre*std::pow(this-&gt;second,2));
        case R_VARIABLE_G_ACCELERATION:
        case R_VARIABLE_G_ACCELERATION_X:
        case R_VARIABLE_G_ACCELERATION_Y:
        case R_VARIABLE_G_ACCELERATION_Z:
            return this-&gt;metre/std::pow(this-&gt;second,2);
        case R_VARIABLE_HEAT_CAPACITY:
            return std::pow(this-&gt;metre,2)/(this-&gt;kelvin*std::pow(this-&gt;second,2));
        case R_VARIABLE_HEAT:
            return this-&gt;kilogram*std::pow(this-&gt;metre,2)/std::pow(this-&gt;second,3);
        case R_VARIABLE_HEAT_FLUX:
        case R_VARIABLE_HEAT_FLUX_X:
        case R_VARIABLE_HEAT_FLUX_Y:
        case R_VARIABLE_HEAT_FLUX_Z:
            return this-&gt;kilogram/std::pow(this-&gt;second,3);
        case R_VARIABLE_HEAT_RATE_AREA:
            return this-&gt;kilogram/std::pow(this-&gt;second,3);
        case R_VARIABLE_HEAT_RATE_VOLUME:
            return this-&gt;kilogram/(std::pow(this-&gt;second,3)*this-&gt;metre);
        case R_VARIABLE_HEAT_TRANSFER_COEFFICIENT:
            return this-&gt;kilogram*this-&gt;kelvin/std::pow(this-&gt;second,3);
        case R_VARIABLE_HYDRAULIC_DIAMETER:
            return this-&gt;metre;
        case R_VARIABLE_ITERATION:
            return 1.0;
        case R_VARIABLE_JOULE_HEAT:
            return this-&gt;kilogram*std::pow(this-&gt;metre,2)/std::pow(this-&gt;second,3);
        case R_VARIABLE_MAGNETIC_FIELD:
        case R_VARIABLE_MAGNETIC_FIELD_X:
        case R_VARIABLE_MAGNETIC_FIELD_Y:
        case R_VARIABLE_MAGNETIC_FIELD_Z:
            return this-&gt;kilogram/(std::pow(this-&gt;second,2)*this-&gt;ampere);
        case R_VARIABLE_MASS_FLOW_RATE:
        case R_VARIABLE_MASS_FLOW_RATE_X:
        case R_VARIABLE_MASS_FLOW_RATE_Y:
        case R_VARIABLE_MASS_FLOW_RATE_Z:
            return this-&gt;kilogram/this-&gt;second;
        case R_VARIABLE_PARTICLE_CONCENTRATION:
            return this-&gt;kilogram/std::pow(this-&gt;metre,3);
        case R_VARIABLE_PARTICLE_FLUX:
        case R_VARIABLE_PARTICLE_RATE:
            return this-&gt;kilogram/(std::pow(this-&gt;metre,3)*this-&gt;second);
        case R_VARIABLE_PERMEABILITY_TO_FLUIDS:
            return std::pow(this-&gt;metre,2);
        case R_VARIABLE_RELATIVE_PERMITTIVITY:
            return std::pow(this-&gt;second*this-&gt;ampere,2);
        case R_VARIABLE_POISSON_RATIO:
            return 1.0;
        case R_VARIABLE_POTENTIAL:
            return 1.0;
        case R_VARIABLE_POTENTIAL_VELOCITY:
            return 1.0/this-&gt;second;
        case R_VARIABLE_POTENTIAL_ACCELERATION:
            return 1.0/std::pow(this-&gt;second,2);
        case R_VARIABLE_PRESSURE:
        case R_VARIABLE_MODULUS_OF_ELASTICITY:
        case R_VARIABLE_STRESS:
        case R_VARIABLE_STRESS_X:
        case R_VARIABLE_STRESS_Y:
        case R_VARIABLE_STRESS_Z:
        case R_VARIABLE_STRESS_XY:
        case R_VARIABLE_STRESS_XZ:
        case R_VARIABLE_STRESS_YZ:
        case R_VARIABLE_STRESS_VON_MISES:
        case R_VARIABLE_STRESS_NORMAL:
        case R_VARIABLE_STRESS_SHEAR:
            return this-&gt;kilogram/(this-&gt;metre*std::pow(this-&gt;second,2));
        case R_VARIABLE_TEMPERATURE:
            return this-&gt;kelvin;
        case R_VARIABLE_THERMAL_CONDUCTIVITY:
            return this-&gt;kilogram*this-&gt;metre/(std::pow(this-&gt;second,3)*this-&gt;kelvin);
        case R_VARIABLE_THERMAL_EXPANSION_COEFFICIENT:
            return 1.0/this-&gt;kelvin;
        case R_VARIABLE_TIME:
            return this-&gt;second;
        case R_VARIABLE_SOUND_SPEED:
        case R_VARIABLE_VELOCITY:
        case R_VARIABLE_VELOCITY_X:
        case R_VARIABLE_VELOCITY_Y:
        case R_VARIABLE_VELOCITY_Z:
            return this-&gt;metre/this-&gt;second;
        case R_VARIABLE_VOF:
            return 1.0;
        case R_VARIABLE_VOLUME_FLOW_RATE:
            return std::pow(this-&gt;metre,3)/this-&gt;second;
        case R_VARIABLE_WAVE_DISPLACEMENT:
            return 1.0;
        case R_VARIABLE_WEIGHT:
            return this-&gt;kilogram;
        case R_VARIABLE_LENGTH:
            return this-&gt;metre;
        case R_VARIABLE_AREA:
            return std::pow(this-&gt;metre,2);
        case R_VARIABLE_VOLUME:
            return std::pow(this-&gt;metre,3);
        default:
            return 1.0;
    }
}

double RScales::findScaleFactor(RMaterialPropertyType materialPropertyType) const
{
    return this-&gt;findScaleFactor(RMaterialProperty::getVariableType(materialPropertyType));
}

</t>
<t tx="leo.20201108101542.30">bool RSolverElectrostatics::hasConverged(void) const
{
    return true;
}

</t>
<t tx="leo.20201108101542.31">void RSolverElectrostatics::updateScales(void)
{

}

</t>
<t tx="leo.20201108101542.32">void RSolverElectrostatics::recover(void)
{
    this-&gt;recoverVariable(R_VARIABLE_ELECTRIC_POTENTIAL,
                          R_VARIABLE_APPLY_NODE,
                          this-&gt;pModel-&gt;getNNodes(),
                          0,
                          this-&gt;nodeElectricPotential,
                          0.0);
//    this-&gt;syncShared("node-electric_potential",this-&gt;nodeElectricPotential);
}

</t>
<t tx="leo.20201108101542.33">void RSolverElectrostatics::prepare(void)
{
    RRVector elementElectricPotential;
    RBVector electricPotentialSetValues;

    RRVector elementChargeDensity;
    RBVector chargeDensitySetValues;

    this-&gt;generateNodeBook(R_PROBLEM_ELECTROSTATICS);

    this-&gt;generateVariableVector(R_VARIABLE_ELECTRIC_POTENTIAL,elementElectricPotential,electricPotentialSetValues,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_CHARGE_DENSITY,elementChargeDensity,chargeDensitySetValues,true,this-&gt;firstRun,this-&gt;firstRun);

    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_RELATIVE_PERMITTIVITY,this-&gt;elementRelativePermittivity);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_ELECTRICAL_CONDUCTIVITY,this-&gt;elementElectricConductivity);

    this-&gt;pModel-&gt;convertElementToNodeVector(elementElectricPotential,electricPotentialSetValues,this-&gt;nodeElectricPotential,true);

    this-&gt;b.resize(this-&gt;nodeBook.getNEnabled());
    this-&gt;x.resize(this-&gt;nodeBook.getNEnabled());

    this-&gt;A.clear();
    this-&gt;b.fill(0.0);
    this-&gt;x.fill(0.0);

    // Prepare point elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNPoints();i++)
    {
        RPoint &amp;point = this-&gt;pModel-&gt;getPoint(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(point.size());j++)
        {
            try
            {
                uint elementID = point.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_POINT(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());

                Ke.fill(0.0);
                fe.fill(0.0);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    for (unsigned m=0;m&lt;element.size();m++)
                    {
                        // Force
                        fe[m] += elementChargeDensity[elementID] * N[m] * detJ * shapeFunc.getW();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare line elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        RLine &amp;line = this-&gt;pModel-&gt;getLine(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(line.size());j++)
        {
            try
            {
                uint elementID = line.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_LINE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());

                RRMatrix B(element.size(),1);

                Ke.fill(0.0);
                fe.fill(0.0);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += dN[m][0]*J[0][0];
                    }

                    for (unsigned m=0;m&lt;element.size();m++)
                    {
                        for (unsigned n=0;n&lt;element.size();n++)
                        {
                            // Conduction
                            Ke[m][n] += B[m][0] * B[n][0]
                                     * this-&gt;elementRelativePermittivity[elementID]
                                     * RSolverGeneric::e0
                                     * detJ
                                     * shapeFunc.getW()
                                     * line.getCrossArea();
                        }
                        // Force
                        fe[m] -= elementChargeDensity[elementID] * N[m] * detJ * shapeFunc.getW();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare surface elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        RSurface &amp;surface = this-&gt;pModel-&gt;getSurface(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(surface.size());j++)
        {
            try
            {
                uint elementID = surface.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_SURFACE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());
                RRMatrix B(element.size(),2);

                Ke.fill(0.0);
                fe.fill(0.0);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1]);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1]);
                    }

                    for (unsigned m=0;m&lt;element.size();m++)
                    {
                        for (unsigned n=0;n&lt;element.size();n++)
                        {
                            // Conduction
                            Ke[m][n] += (B[m][0] * B[n][0] + B[m][1] * B[n][1])
                                     * this-&gt;elementRelativePermittivity[elementID]
                                     * RSolverGeneric::e0
                                     * surface.getThickness()
                                     * detJ
                                     * shapeFunc.getW();
                        }
                        // Force
                        fe[m] -= elementChargeDensity[elementID] * N[m] * detJ * shapeFunc.getW();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare volume elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        RVolume &amp;volume = this-&gt;pModel-&gt;getVolume(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(volume.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = volume.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_VOLUME(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());
                RRMatrix B(element.size(),3);

                Ke.fill(0.0);
                fe.fill(0.0);

                // Conduction
                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]);
                        B[m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]);
                    }

                    for (unsigned m=0;m&lt;element.size();m++)
                    {
                        for (unsigned n=0;n&lt;element.size();n++)
                        {
                            // Conduction
                            Ke[m][n] += (B[m][0]*B[n][0] + B[m][1]*B[n][1] + B[m][2]*B[n][2])
                                     * this-&gt;elementRelativePermittivity[elementID]
                                     * RSolverGeneric::e0
                                     * detJ
                                     * shapeFunc.getW();
                        }
                        // Force
                        fe[m] -= elementChargeDensity[elementID] * N[m] * detJ * shapeFunc.getW();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }
}

</t>
<t tx="leo.20201108101542.34">void RSolverElectrostatics::solve(void)
{
    try
    {
        RLogger::indent();
        RMatrixSolver matrixSolver(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));
        matrixSolver.solve(this-&gt;A,this-&gt;b,this-&gt;x,R_MATRIX_PRECONDITIONER_JACOBI,1);
        RLogger::unindent();
    }
    catch (RError error)
    {
        RLogger::unindent();
        throw error;
    }

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        uint position;
        if (this-&gt;nodeBook.getValue(i,position))
        {
            this-&gt;nodeElectricPotential[i] = this-&gt;x[position];
        }
    }
}

</t>
<t tx="leo.20201108101542.35">void RSolverElectrostatics::process(void)
{
    // Initialize vectors
    this-&gt;elementElectricField.resize(this-&gt;pModel-&gt;getNElements(),RR3Vector(0.0,0.0,0.0));
    this-&gt;elementCurrentDensity.resize(this-&gt;pModel-&gt;getNElements(),RR3Vector(0.0,0.0,0.0));
    this-&gt;elementElectricEnergy.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;elementElectricResistivity.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;elementJouleHeat.resize(this-&gt;pModel-&gt;getNElements(),0.0);

    RR3Vector electricField;
    RR3Vector currentDensity;

    // Process line elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        RLine &amp;line = this-&gt;pModel-&gt;getLine(i);

        for (uint j=0;j&lt;line.size();j++)
        {
            uint elementID = line.get(j);

            if (!this-&gt;computableElements[elementID])
            {
                continue;
            }

            const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
            uint nInp = RElement::getNIntegrationPoints(element.getType());
            RRVector B(element.size());

            electricField.fill(0.0);
            currentDensity.fill(0.0);

            // Conduction
            if (line.getCrossArea() &gt; 0.0)
            {
                double Ei = 0.0;

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    if (line.getCrossArea() != 0.0)
                    {
                        for (uint m=0;m&lt;dN.getNRows();m++)
                        {
                            B[m] += dN[m][0] * J[0][0] * detJ / double(nInp);
                        }
                    }
                }

                for (uint k=0;k&lt;element.size();k++)
                {
                    uint nodeID = element.getNodeId(k);

                    Ei -= B[k] * this-&gt;nodeElectricPotential[nodeID];
                }

                RRMatrix R;
                RRVector t;
                this-&gt;pModel-&gt;getElement(elementID).findTransformationMatrix(this-&gt;pModel-&gt;getNodes(),R,t);

                electricField[0] += R[0][0]*Ei;
                electricField[1] += R[1][0]*Ei;
                electricField[2] += R[2][0]*Ei;

                double dElectricField = RRVector::dot(electricField,electricField);
                double ere = std::sqrt(dElectricField);

                currentDensity[0] = electricField[0] * this-&gt;elementElectricConductivity[elementID];
                currentDensity[1] = electricField[1] * this-&gt;elementElectricConductivity[elementID];
                currentDensity[2] = electricField[2] * this-&gt;elementElectricConductivity[elementID];

                double jre = RRVector::norm(currentDensity);

                double elementLength = 0.0;
                element.findLength(this-&gt;pModel-&gt;getNodes(),elementLength);

                this-&gt;elementElectricField[elementID] = electricField;
                this-&gt;elementCurrentDensity[elementID] = currentDensity;
                this-&gt;elementElectricEnergy[elementID] = this-&gt;elementRelativePermittivity[elementID] * RSolverGeneric::e0 * dElectricField / 2.0;
                this-&gt;elementElectricResistivity[elementID] = (jre &gt; RConstants::eps ? ere / jre : 0.0);
                this-&gt;elementJouleHeat[elementID] = this-&gt;elementElectricConductivity[elementID] * dElectricField * elementLength;
            }
        }
    }

    // Process surface elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        RSurface &amp;surface = this-&gt;pModel-&gt;getSurface(i);

        for (uint j=0;j&lt;surface.size();j++)
        {
            uint elementID = surface.get(j);

            if (!this-&gt;computableElements[elementID])
            {
                continue;
            }

            const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
            uint nInp = RElement::getNIntegrationPoints(element.getType());
            RRMatrix B(element.size(),2);

            electricField.fill(0.0);
            currentDensity.fill(0.0);

            // Conduction
            if (surface.getThickness() &gt; 0.0)
            {
                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    if (surface.getThickness() != 0.0)
                    {
                        for (uint m=0;m&lt;dN.getNRows();m++)
                        {
                            B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1]) * detJ / double(nInp);
                            B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1]) * detJ / double(nInp);
                        }
                    }
                }

                double Ei = 0.0;
                double Ej = 0.0;

                for (uint k=0;k&lt;element.size();k++)
                {
                    uint nodeID = element.getNodeId(k);

                    Ei -= B[k][0] * this-&gt;nodeElectricPotential[nodeID] * surface.getThickness();
                    Ej -= B[k][1] * this-&gt;nodeElectricPotential[nodeID] * surface.getThickness();
                }

                RRMatrix R;
                RRVector t;
                this-&gt;pModel-&gt;getElement(elementID).findTransformationMatrix(this-&gt;pModel-&gt;getNodes(),R,t);

                electricField[0] += R[0][0]*Ei + R[0][1]*Ej;
                electricField[1] += R[1][0]*Ei + R[1][1]*Ej;
                electricField[2] += R[2][0]*Ei + R[2][1]*Ej;

                double dElectricField = RRVector::dot(electricField,electricField);
                double ere = std::sqrt(dElectricField);

                currentDensity[0] = electricField[0] * this-&gt;elementElectricConductivity[elementID];
                currentDensity[1] = electricField[1] * this-&gt;elementElectricConductivity[elementID];
                currentDensity[2] = electricField[2] * this-&gt;elementElectricConductivity[elementID];

                double jre = RRVector::norm(currentDensity);

                double elementLength = 0.0;

                RRVector s(2,0.0);
                if (ere &gt; RConstants::eps)
                {
                    s[0] = Ei / ere;
                    s[1] = Ej / ere;
                }
                for (uint m=0;m&lt;element.size();m++)
                {
                    elementLength += std::fabs(s[0] * B[m][0] + s[1] * B[m][1]);
                }
                if (elementLength &gt; RConstants::eps)
                {
                    elementLength = 2.0 / elementLength;
                }

                this-&gt;elementElectricField[elementID] = electricField;
                this-&gt;elementCurrentDensity[elementID] = currentDensity;
                this-&gt;elementElectricEnergy[elementID] = this-&gt;elementRelativePermittivity[elementID] * RSolverGeneric::e0 * dElectricField / 2.0;
                this-&gt;elementElectricResistivity[elementID] = (jre &gt; RConstants::eps ? ere / jre : 0.0);
                this-&gt;elementJouleHeat[elementID] = this-&gt;elementElectricConductivity[elementID] * dElectricField * elementLength;
            }
        }
    }

    // Process volume elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        RVolume &amp;volume = this-&gt;pModel-&gt;getVolume(i);

        for (uint j=0;j&lt;volume.size();j++)
        {
            uint elementID = volume.get(j);

            if (!this-&gt;computableElements[elementID])
            {
                continue;
            }

            const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
            uint nInp = RElement::getNIntegrationPoints(element.getType());
            RRMatrix B(element.size(),3);

            B.fill(0.0);

            // Conduction
            for (uint k=0;k&lt;nInp;k++)
            {
                const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                const RRMatrix &amp;dN = shapeFunc.getDN();
                RRMatrix J, Rt;
                double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                for (uint m=0;m&lt;dN.getNRows();m++)
                {
                    B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]) * detJ / double(nInp);
                    B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]) * detJ / double(nInp);
                    B[m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]) * detJ / double(nInp);
                }
            }

            electricField.fill(0.0);
            currentDensity.fill(0.0);

            for (uint m=0;m&lt;element.size();m++)
            {
                uint nodeID = element.getNodeId(m);

                electricField[0] -= B[m][0] * this-&gt;nodeElectricPotential[nodeID];
                electricField[1] -= B[m][1] * this-&gt;nodeElectricPotential[nodeID];
                electricField[2] -= B[m][2] * this-&gt;nodeElectricPotential[nodeID];
            }

            double dElectricField = RRVector::dot(electricField,electricField);
            double ere = std::sqrt(dElectricField);

            currentDensity[0] = electricField[0] * this-&gt;elementElectricConductivity[elementID];
            currentDensity[1] = electricField[1] * this-&gt;elementElectricConductivity[elementID];
            currentDensity[2] = electricField[2] * this-&gt;elementElectricConductivity[elementID];

            double jre = RRVector::norm(currentDensity);

            double elementLength = 0.0;

            RR3Vector s(0.0,0.0,0.0);
            if (ere &gt; RConstants::eps)
            {
                s[0] = electricField[0] / ere;
                s[1] = electricField[1] / ere;
                s[2] = electricField[2] / ere;
            }
            for (uint m=0;m&lt;element.size();m++)
            {
                elementLength += std::fabs(s[0] * B[m][0] + s[1] * B[m][1] + s[2] * B[m][2]);
            }
            if (elementLength &gt; RConstants::eps)
            {
                elementLength = 2.0 / elementLength;
            }

            this-&gt;elementElectricField[elementID] = electricField;
            this-&gt;elementCurrentDensity[elementID] = currentDensity;
            this-&gt;elementElectricEnergy[elementID] = this-&gt;elementRelativePermittivity[elementID] * RSolverGeneric::e0 * dElectricField / 2.0;
            this-&gt;elementElectricResistivity[elementID] = (jre &gt; RConstants::eps ? ere / jre : 0.0);
            this-&gt;elementJouleHeat[elementID] = this-&gt;elementElectricConductivity[elementID] * dElectricField * elementLength;
        }
    }
}

</t>
<t tx="leo.20201108101542.36">void RSolverElectrostatics::store(void)
{
    RLogger::info("Storing results\n");
    RLogger::indent();

    // Electric potential
    uint electricPotentialPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_ELECTRIC_POTENTIAL);
    if (electricPotentialPos == RConstants::eod)
    {
        electricPotentialPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_ELECTRIC_POTENTIAL);
        this-&gt;pModel-&gt;getVariable(electricPotentialPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumValue(this-&gt;nodeElectricPotential),
                    RStatistics::findMaximumValue(this-&gt;nodeElectricPotential));
    }
    RVariable &amp;electricPotential =  this-&gt;pModel-&gt;getVariable(electricPotentialPos);

    electricPotential.setApplyType(R_VARIABLE_APPLY_NODE);
    electricPotential.resize(1,this-&gt;pModel-&gt;getNNodes());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        electricPotential.setValue(0,i,this-&gt;nodeElectricPotential[i]);
    }

    // Electric field
    uint electricFieldPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_ELECTRIC_FIELD);
    if (electricFieldPos == RConstants::eod)
    {
        electricFieldPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_ELECTRIC_FIELD);
        this-&gt;pModel-&gt;getVariable(electricFieldPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumMagnitude(this-&gt;elementElectricField),
                    RStatistics::findMaximumMagnitude(this-&gt;elementElectricField));
    }
    RVariable &amp;electricField =  this-&gt;pModel-&gt;getVariable(electricFieldPos);

    electricField.setApplyType(R_VARIABLE_APPLY_ELEMENT);
    electricField.resize(3,this-&gt;pModel-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        electricField.setValue(0,i,this-&gt;elementElectricField[i][0]);
        electricField.setValue(1,i,this-&gt;elementElectricField[i][1]);
        electricField.setValue(2,i,this-&gt;elementElectricField[i][2]);
    }

    // Current density
    uint currentDensityPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_CURRENT_DENSITY);
    if (currentDensityPos == RConstants::eod)
    {
        currentDensityPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_CURRENT_DENSITY);
        this-&gt;pModel-&gt;getVariable(currentDensityPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumMagnitude(this-&gt;elementCurrentDensity),
                    RStatistics::findMaximumMagnitude(this-&gt;elementCurrentDensity));
    }
    RVariable &amp;currentDensity =  this-&gt;pModel-&gt;getVariable(currentDensityPos);

    currentDensity.setApplyType(R_VARIABLE_APPLY_ELEMENT);
    currentDensity.resize(3,this-&gt;pModel-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        currentDensity.setValue(0,i,this-&gt;elementCurrentDensity[i][0]);
        currentDensity.setValue(1,i,this-&gt;elementCurrentDensity[i][1]);
        currentDensity.setValue(2,i,this-&gt;elementCurrentDensity[i][2]);
    }

    // Electric energy
    uint electricEnergyPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_ELECTRIC_ENERGY);
    if (electricEnergyPos == RConstants::eod)
    {
        electricEnergyPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_ELECTRIC_ENERGY);
        this-&gt;pModel-&gt;getVariable(electricEnergyPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumValue(this-&gt;elementElectricEnergy),
                    RStatistics::findMaximumValue(this-&gt;elementElectricEnergy));
    }
    RVariable &amp;electricEnergy =  this-&gt;pModel-&gt;getVariable(electricEnergyPos);

    electricEnergy.setApplyType(R_VARIABLE_APPLY_ELEMENT);
    electricEnergy.resize(1,this-&gt;pModel-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        electricEnergy.setValue(0,i,this-&gt;elementElectricEnergy[i]);
    }

    // Electric resistivity
    uint electricResistivityPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_ELECTRICAL_RESISTIVITY);
    if (electricResistivityPos == RConstants::eod)
    {
        electricResistivityPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_ELECTRICAL_RESISTIVITY);
        this-&gt;pModel-&gt;getVariable(electricResistivityPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumValue(this-&gt;elementElectricResistivity),
                    RStatistics::findMaximumValue(this-&gt;elementElectricResistivity));
    }
    RVariable &amp;electricResistivity =  this-&gt;pModel-&gt;getVariable(electricResistivityPos);

    electricResistivity.setApplyType(R_VARIABLE_APPLY_ELEMENT);
    electricResistivity.resize(1,this-&gt;pModel-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        electricResistivity.setValue(0,i,this-&gt;elementElectricResistivity[i]);
    }

    // Joule heat
    uint jouleHeatPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_JOULE_HEAT);
    if (jouleHeatPos == RConstants::eod)
    {
        jouleHeatPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_JOULE_HEAT);
        this-&gt;pModel-&gt;getVariable(jouleHeatPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumValue(this-&gt;elementJouleHeat),
                    RStatistics::findMaximumValue(this-&gt;elementJouleHeat));
    }
    RVariable &amp;jouleHeat =  this-&gt;pModel-&gt;getVariable(jouleHeatPos);

    jouleHeat.setApplyType(R_VARIABLE_APPLY_ELEMENT);
    jouleHeat.resize(1,this-&gt;pModel-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        jouleHeat.setValue(0,i,this-&gt;elementJouleHeat[i]);
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101542.37">void RSolverElectrostatics::statistics(void)
{
    this-&gt;printStats(R_VARIABLE_ELECTRIC_POTENTIAL);
    this-&gt;printStats(R_VARIABLE_ELECTRIC_FIELD);
    this-&gt;printStats(R_VARIABLE_CURRENT_DENSITY);
    this-&gt;printStats(R_VARIABLE_ELECTRIC_ENERGY);
    this-&gt;printStats(R_VARIABLE_ELECTRICAL_RESISTIVITY);
    this-&gt;printStats(R_VARIABLE_JOULE_HEAT);
    this-&gt;processMonitoringPoints();
}

</t>
<t tx="leo.20201108101542.38">void RSolverElectrostatics::assemblyMatrix(unsigned int elementID, const RRMatrix &amp;Ke, const RRVector &amp;fe)
{
    const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);

    RRMatrix Ae(Ke);
    RRVector be(fe);

    // Apply explicit boundary conditions.
    for (uint m=0;m&lt;element.size();m++)
    {
        uint position;
        uint nodeID = element.getNodeId(m);
        if (!this-&gt;nodeBook.getValue(nodeID,position))
        {
            for (uint n=0;n&lt;element.size();n++)
            {
                be[n] -= Ae[n][m] * this-&gt;nodeElectricPotential[nodeID];
            }
        }
    }

    // Assembly final matrix system
    for (uint m=0;m&lt;element.size();m++)
    {
        uint mp;

        if (this-&gt;nodeBook.getValue(element.getNodeId(m),mp))
        {
            this-&gt;b[mp] += be[m];
            for (uint n=0;n&lt;element.size();n++)
            {
                uint np = 0;

                if (this-&gt;nodeBook.getValue(element.getNodeId(n),np))
                {
                    this-&gt;A.addValue(mp,np,Ae[m][n]);
                }
            }
        }
    }
}
</t>
<t tx="leo.20201108101542.39">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolverfluid.cpp                                         *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th November 2015                                      *
 *                                                                   *
 *  DESCRIPTION: Fluid solver class definition                       *
 *********************************************************************/

#include &lt;omp.h&gt;

#include "rsolverfluid.h"
#include "rmatrixsolver.h"

//#define _OPTIMAL_ASSEMBLY_

static const double inv6 = 1.0 / 6.0;

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101542.4">void RScales::downscale(RModel &amp;model) const
{
    this-&gt;convert(model,false);
}

</t>
<t tx="leo.20201108101542.40">class FluidMatrixContainer
{
    public:

        bool initialized;

        // Element level matricies
        RRMatrix me;    // m
        RRMatrix ce;    // c
        RRMatrix ke;    // k
        RRMatrix ge;    // g
        RRMatrix geT;   // gT
        RRMatrix cpe;   // c+
        RRMatrix cte;   // c~
        RRMatrix ctpe;  // c~+
        RRMatrix kte;   // k~
        RRMatrix ktpe;  // k~+
        RRMatrix ktppe; // k~++
        RRMatrix yte;   // y~
        RRMatrix ytpe;  // y~+
        RRMatrix bte;   // B
        RRMatrix ye;    // y
        RRMatrix ype;   // y+
        RRMatrix the;   // 0
        RRMatrix epe;   // e

        // Element level vectors
        RRVector fv;    // f
        RRVector ftv;   // f~
        RRVector etv;   // e~
        RRVector mv;    // m
        RRVector cv;    // c
        RRVector kv;    // k
        RRVector gv;    // g
        RRVector gvT;   // gT
        RRVector ctv;   // c~
        RRVector ktv;   // k~
        RRVector ytv;   // y~
        RRVector btv;   // B
        RRVector yv;    // y
        RRVector thv;   // 0
        RRVector ev;    // e

        // Element level equations
        RRMatrix Ae11;
        RRMatrix Ae12;
        RRMatrix Ae21;
        RRMatrix Ae22;
        RRVector be1;
        RRVector be2;

    public:

        FluidMatrixContainer() : initialized(false)
        {

        }

        @others
};

</t>
<t tx="leo.20201108101542.41">void resize(uint nen)
{
    this-&gt;me.resize(nen*3,nen*3,0.0);
    this-&gt;ce.resize(nen*3,nen*3,0.0);
    this-&gt;ke.resize(nen*3,nen*3,0.0);
    this-&gt;ge.resize(nen*3,nen,0.0);
    this-&gt;geT.resize(nen,nen*3,0.0);
    this-&gt;cpe.resize(nen*3,nen*3,0.0);
    this-&gt;cte.resize(nen*3,nen*3,0.0);
    this-&gt;ctpe.resize(nen*3,nen*3,0.0);
    this-&gt;kte.resize(nen*3,nen*3,0.0);
    this-&gt;ktpe.resize(nen*3,nen*3,0.0);
    this-&gt;ktppe.resize(nen*3,nen*3,0.0);
    this-&gt;yte.resize(nen*3,nen,0.0);
    this-&gt;ytpe.resize(nen*3,nen*3,0.0);
    this-&gt;bte.resize(nen,nen*3,0.0);
    this-&gt;ye.resize(nen,nen*3,0.0);
    this-&gt;ype.resize(nen,nen*3,0.0);
    this-&gt;the.resize(nen,nen,0.0);
    this-&gt;epe.resize(nen*3,nen*3,0.0);

    this-&gt;fv.resize(nen*3,0.0);
    this-&gt;ftv.resize(nen*3,0.0);
    this-&gt;etv.resize(nen,0.0);
    this-&gt;mv.resize(nen*3,0.0);
    this-&gt;cv.resize(nen*3,0.0);
    this-&gt;kv.resize(nen*3,0.0);
    this-&gt;gv.resize(nen*3,0.0);
    this-&gt;gvT.resize(nen,0.0);
    this-&gt;ctv.resize(nen*3,0.0);
    this-&gt;ktv.resize(nen*3,0.0);
    this-&gt;ytv.resize(nen*3,0.0);
    this-&gt;btv.resize(nen,0.0);
    this-&gt;yv.resize(nen,0.0);
    this-&gt;thv.resize(nen,0.0);
    this-&gt;ev.resize(nen*3,0.0);

    this-&gt;Ae11.resize(nen*3,nen*3,0.0);
    this-&gt;Ae12.resize(nen*3,nen,0.0);
    this-&gt;Ae21.resize(nen,nen*3,0.0);
    this-&gt;Ae22.resize(nen,nen,0.0);
    this-&gt;be1.resize(nen*3,0.0);
    this-&gt;be2.resize(nen,0.0);

    this-&gt;initialized = true;
}

</t>
<t tx="leo.20201108101542.42">void clear(void)
{
    this-&gt;me.fill(0.0);
    this-&gt;ce.fill(0.0);
    this-&gt;ke.fill(0.0);
    this-&gt;ge.fill(0.0);
    this-&gt;geT.fill(0.0);
    this-&gt;cpe.fill(0.0);
    this-&gt;cte.fill(0.0);
    this-&gt;ctpe.fill(0.0);
    this-&gt;kte.fill(0.0);
    this-&gt;ktpe.fill(0.0);
    this-&gt;ktppe.fill(0.0);
    this-&gt;yte.fill(0.0);
    this-&gt;ytpe.fill(0.0);
    this-&gt;bte.fill(0.0);
    this-&gt;ye.fill(0.0);
    this-&gt;ype.fill(0.0);
    this-&gt;the.fill(0.0);
    this-&gt;epe.fill(0.0);

    this-&gt;fv.fill(0.0);
    this-&gt;ftv.fill(0.0);
    this-&gt;etv.fill(0.0);
    this-&gt;mv.fill(0.0);
    this-&gt;cv.fill(0.0);
    this-&gt;kv.fill(0.0);
    this-&gt;gv.fill(0.0);
    this-&gt;gvT.fill(0.0);
    this-&gt;ctv.fill(0.0);
    this-&gt;ktv.fill(0.0);
    this-&gt;ytv.fill(0.0);
    this-&gt;btv.fill(0.0);
    this-&gt;yv.fill(0.0);
    this-&gt;thv.fill(0.0);
    this-&gt;ev.fill(0.0);

    this-&gt;Ae11.fill(0.0);
    this-&gt;Ae12.fill(0.0);
    this-&gt;Ae21.fill(0.0);
    this-&gt;Ae22.fill(0.0);
    this-&gt;be1.fill(0.0);
    this-&gt;be2.fill(0.0);
}
</t>
<t tx="leo.20201108101542.43">void RSolverFluid::_init(const RSolverFluid *pSolver)
{
    if (pSolver)
    {
        this-&gt;freePressureNodeHeight = pSolver-&gt;freePressureNodeHeight;
        this-&gt;elementScales = pSolver-&gt;elementScales;
        this-&gt;elementPressure = pSolver-&gt;elementPressure;
        this-&gt;elementVelocity = pSolver-&gt;elementVelocity;
        this-&gt;elementGravity = pSolver-&gt;elementGravity;
        this-&gt;nodePressure = pSolver-&gt;nodePressure;
        this-&gt;nodeVelocity = pSolver-&gt;nodeVelocity;
        this-&gt;nodeVelocityOld = pSolver-&gt;nodeVelocityOld;
        this-&gt;nodeAcceleration = pSolver-&gt;nodeAcceleration;
        this-&gt;streamVelocity = pSolver-&gt;streamVelocity;
        this-&gt;invStreamVelocity = pSolver-&gt;invStreamVelocity;
        this-&gt;elementDensity = pSolver-&gt;elementDensity;
        this-&gt;elementViscosity = pSolver-&gt;elementViscosity;
        this-&gt;avgRo = pSolver-&gt;avgRo;
        this-&gt;avgU = pSolver-&gt;avgU;
        this-&gt;cvgV = pSolver-&gt;cvgV;
        this-&gt;cvgP = pSolver-&gt;cvgP;
    }
    else
    {
        this-&gt;nodeAcceleration.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
        this-&gt;nodeAcceleration.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
        this-&gt;nodeAcceleration.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
        this-&gt;nodeVelocity.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
        this-&gt;nodeVelocity.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
        this-&gt;nodeVelocity.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
        this-&gt;nodeVelocityOld.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
        this-&gt;nodeVelocityOld.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
        this-&gt;nodeVelocityOld.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
        this-&gt;nodePressure.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    }
}

RSolverFluid::RSolverFluid(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
    , streamVelocity(1.0)
    , invStreamVelocity(1.0)
    , cvgV(0.0)
    , cvgP(0.0)
{
    this-&gt;problemType = R_PROBLEM_FLUID;
    this-&gt;_init();
}

RSolverFluid::RSolverFluid(const RSolverFluid &amp;solver)
    : RSolverGeneric(solver)
{
    this-&gt;_init(&amp;solver);
}

RSolverFluid::~RSolverFluid()
{
    this-&gt;clearShapeDerivatives();
}

RSolverFluid &amp;RSolverFluid::operator =(const RSolverFluid &amp;solver)
{
    RSolverGeneric::operator =(solver);
    this-&gt;_init(&amp;solver);
    return (*this);
}

</t>
<t tx="leo.20201108101542.44">bool RSolverFluid::hasConverged(void) const
{
    return false;
}

</t>
<t tx="leo.20201108101542.45">void RSolverFluid::updateScales(void)
{
    this-&gt;nodeVelocity.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeVelocity.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeVelocity.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;elementVelocity.x.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;elementVelocity.y.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;elementVelocity.z.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;nodeAcceleration.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeAcceleration.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeAcceleration.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeVelocityOld.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeVelocityOld.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeVelocityOld.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;elementPressure.resize(this-&gt;pModel-&gt;getNElements(),0.0);

    if (this-&gt;taskIteration &gt; 0)
    {
        return;
    }

    RRVector eRo;
    RRVector eU;

    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_DENSITY,eRo);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_DYNAMIC_VISCOSITY,eU);

    this-&gt;avgRo = 0.0;
    this-&gt;avgU = 0.0;
    uint n = 0;
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        if (eRo[i] != 0.0 &amp;&amp; eU[i] != 0.0)
        {
            this-&gt;avgRo += eRo[i];
            this-&gt;avgU += eU[i];
            n++;
        }
    }
    if (n &gt; 0)
    {
        this-&gt;avgRo /= double(n);
        this-&gt;avgU /= double(n);
    }

    this-&gt;scales.setMetre(this-&gt;findMeshScale());
    this-&gt;scales.setSecond(this-&gt;findTimeScale());
    this-&gt;scales.setKilogram(this-&gt;findWeightScale());
}

</t>
<t tx="leo.20201108101542.46">void RSolverFluid::recover(void)
{
    this-&gt;recoveryStopWatch.reset();
    this-&gt;recoveryStopWatch.resume();

    this-&gt;recoverVariable(R_VARIABLE_VELOCITY,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),0,this-&gt;nodeVelocity.x,0.0);
    this-&gt;recoverVariable(R_VARIABLE_VELOCITY,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),1,this-&gt;nodeVelocity.y,0.0);
    this-&gt;recoverVariable(R_VARIABLE_VELOCITY,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),2,this-&gt;nodeVelocity.z,0.0);
//    this-&gt;recoverVariable(R_VARIABLE_ACCELERATION,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),0,this-&gt;nodeAcceleration.x);
//    this-&gt;recoverVariable(R_VARIABLE_ACCELERATION,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),1,this-&gt;nodeAcceleration.y);
//    this-&gt;recoverVariable(R_VARIABLE_ACCELERATION,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),2,this-&gt;nodeAcceleration.z);
    this-&gt;recoverVariable(R_VARIABLE_PRESSURE,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),0,this-&gt;nodePressure,0.0);

    this-&gt;recoveryStopWatch.pause();
}

</t>
<t tx="leo.20201108101542.47">void RSolverFluid::prepare(void)
{
    RLogger::info("Building matrix system\n");
    RLogger::indent();

    this-&gt;buildStopWatch.reset();

    if (this-&gt;taskIteration == 0 || this-&gt;meshChanged)
    {
        this-&gt;generateNodeBook();
        this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_DENSITY,this-&gt;elementDensity);
        this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_DYNAMIC_VISCOSITY,this-&gt;elementViscosity);

        this-&gt;findInputVectors();
    }

    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodePressure,this-&gt;elementPressure);
    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeVelocity.x,this-&gt;elementVelocity.x);
    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeVelocity.y,this-&gt;elementVelocity.y);
    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeVelocity.z,this-&gt;elementVelocity.z);

    if (this-&gt;meshChanged)
    {
        this-&gt;computeElementScales();
        this-&gt;computeShapeDerivatives();
    }
    if (this-&gt;taskIteration == 0)
    {
        this-&gt;computeFreePressureNodeHeight();
        this-&gt;streamVelocity = RSolverFluid::computeStreamVelocity(*this-&gt;pModel,this-&gt;nodeVelocity,false);
        this-&gt;invStreamVelocity = 1.0 / this-&gt;streamVelocity;
    }

    RRVector elementFreePressure;
    RBVector elementFreePressureSetValues;
    this-&gt;computeElementFreePressure(elementFreePressure,elementFreePressureSetValues);

    this-&gt;A.clear();
    this-&gt;A.setNRows(this-&gt;nodeBook.getNEnabled());
    this-&gt;A.reserveNColumns(100);
    this-&gt;b.resize(this-&gt;nodeBook.getNEnabled());
    this-&gt;b.fill(0.0);
    this-&gt;x.resize(this-&gt;nodeBook.getNEnabled());
    this-&gt;x.fill(0.0);

#ifdef _OPTIMAL_ASSEMBLY_
    int np = omp_get_max_threads();

    QVector&lt;RSparseMatrix&gt; Ap;
    Ap.resize(np);
    QVector&lt;RRVector&gt; bp;
    bp.resize(np);

    for (int i=0;i&lt;np;i++)
    {
        Ap[i].setNRows(this-&gt;nodeBook.getNEnabled());
        Ap[i].reserveNColumns(100);
        bp[i].resize(this-&gt;nodeBook.getNEnabled());
        bp[i].fill(0.0);
    }
#endif /* _OPTIMAL_ASSEMBLY_ */

    bool abort = false;

    RMatrixManager&lt;FluidMatrixContainer&gt; matrixManager;

    if (this-&gt;meshChanged)
    {
        this-&gt;elementNormals.resize(this-&gt;pModel-&gt;getNElements(),RR3Vector(0.0,0.0,0.0));
        this-&gt;elementGravityMagnitude.resize(this-&gt;pModel-&gt;getNElements());
    }

    this-&gt;buildStopWatch.resume();

    // Compute element matrices
    #pragma omp parallel for default(shared) private(matrixManager)
    for (int64_t i=0;i&lt;int64_t(this-&gt;pModel-&gt;getNElements());i++)
    {
        uint elementID = uint(i);

        const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);

        #pragma omp flush (abort)
        if (abort)
        {
            continue;
        }
        try
        {
            uint nen = element.size();
            uint nInp = RElement::getNIntegrationPoints(element.getType());

            RRMatrix Ae(nen*4,nen*4,0.0);
            RRVector be(nen*4,0.0);

            if (R_ELEMENT_TYPE_IS_SURFACE(element.getType()))
            {
                if (!elementFreePressureSetValues[elementID])
                {
                    continue;
                }

                RR3Vector &amp;normal = this-&gt;elementNormals[elementID];
                if (this-&gt;meshChanged)
                {
                    // no need to recalculate if mesh does not change !!!
                    element.findNormal(this-&gt;pModel-&gt;getNodes(),normal[0],normal[1],normal[2]);
                    this-&gt;elementGravityMagnitude[elementID] = std::sqrt(  std::pow(elementGravity.x[elementID],2)
                                                                         + std::pow(elementGravity.y[elementID],2)
                                                                         + std::pow(elementGravity.z[elementID],2));
                }

                double ro = this-&gt;elementDensity[elementID];

                double fp = elementFreePressure[elementID];
                double gm = this-&gt;elementGravityMagnitude[elementID];

                for (uint intPoint=0;intPoint&lt;nInp;intPoint++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),intPoint);
                    const RRVector &amp;N = shapeFunc.getN();
                    double detJ = this-&gt;shapeDerivations[elementID]-&gt;getJacobian(intPoint);
                    double integValue = detJ * shapeFunc.getW();

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        double nh = this-&gt;freePressureNodeHeight[element.getNodeId(m)];

                        // Pressure vector
                        double value = N[m] * (fp + ro * gm * nh) * integValue;
                        be[4*m+0] -= value * normal[0];
                        be[4*m+1] -= value * normal[1];
                        be[4*m+2] -= value * normal[2];
                    }
                }
                if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
                {
                    be *= this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();
                }
            }

            if (R_ELEMENT_TYPE_IS_VOLUME(element.getType()))
            {
                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }
                this-&gt;computeElement(elementID,Ae,be,matrixManager);
            }
            this-&gt;applyLocalRotations(elementID,Ae);
#ifdef _OPTIMAL_ASSEMBLY_
            this-&gt;assemblyMatrix(elementID,Ae,be,Ap[omp_get_thread_num()],bp[omp_get_thread_num()]);
#else
            this-&gt;assemblyMatrix(elementID,Ae,be);
#endif
        }
        catch (const RError &amp;rError)
        {
            #pragma omp critical
            {
                RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                abort = true;
            }
            #pragma omp flush (abort)
        }
    }

#ifdef _OPTIMAL_ASSEMBLY_
#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(this-&gt;A.getNRows());i++)
    {
        for (int j=0;j&lt;np;j++)
        {
            A.getVector(uint(i)).addVector(Ap[j].getVector(uint(i)));
            this-&gt;b[uint(i)] += bp[j][uint(i)];
        }
    }
#endif

    this-&gt;buildStopWatch.pause();

    if (abort)
    {
        RLogger::unindent();
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101542.48">void RSolverFluid::solve(void)
{
    RLogger::info("Solving matrix system\n");
    RLogger::indent();

    this-&gt;solverStopWatch.reset();
    this-&gt;solverStopWatch.resume();

    try
    {
        RLogger::indent();
        RMatrixSolver matrixSolver(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::GMRES));
        matrixSolver.solve(this-&gt;A,this-&gt;b,this-&gt;x,R_MATRIX_PRECONDITIONER_JACOBI,1);
        RLogger::unindent();
    }
    catch (RError error)
    {
        RLogger::unindent();
        throw error;
    }

    this-&gt;solverStopWatch.pause();

    this-&gt;nodeVelocity.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeVelocity.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeVelocity.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodePressure.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeAcceleration.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeAcceleration.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeAcceleration.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);

    this-&gt;updateStopWatch.reset();
    this-&gt;updateStopWatch.resume();

    double uOld = 0.0;
    for (uint i=0;i&lt;this-&gt;nodeVelocity.x.size();i++)
    {
        RR3Vector vec(this-&gt;nodeVelocity.x[i],this-&gt;nodeVelocity.y[i],this-&gt;nodeVelocity.z[i]);
        uOld += RRVector::dot(vec,vec);
    }
    uOld = std::sqrt(uOld);
    double pOld = RRVector::norm(this-&gt;nodePressure);

    if (!this-&gt;pModel-&gt;getTimeSolver().getEnabled())
    {
        this-&gt;nodeVelocityOld.x = this-&gt;nodeVelocity.x;
        this-&gt;nodeVelocityOld.y = this-&gt;nodeVelocity.y;
        this-&gt;nodeVelocityOld.z = this-&gt;nodeVelocity.z;
    }

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        uint position = 0;
        double dvx = 0.0;
        double dvy = 0.0;
        double dvz = 0.0;
        double dp = 0.0;

        if (this-&gt;nodeBook.getValue(4*i+0,position))
        {
            dvx = this-&gt;x[position];
        }
        if (this-&gt;nodeBook.getValue(4*i+1,position))
        {
            dvy = this-&gt;x[position];
        }
        if (this-&gt;nodeBook.getValue(4*i+2,position))
        {
            dvz = this-&gt;x[position];
        }
        if (this-&gt;nodeBook.getValue(4*i+3,position))
        {
            dp = this-&gt;x[position];
        }
        if (this-&gt;localRotations[i].isActive())
        {
            RR3Vector v(dvx,dvy,dvz);
            this-&gt;localRotations[i].rotateResultsVector(v);
            dvx = v[0];
            dvy = v[1];
            dvz = v[2];
        }
        this-&gt;nodeVelocity.x[i] += dvx;
        this-&gt;nodeVelocity.y[i] += dvy;
        this-&gt;nodeVelocity.z[i] += dvz;
        this-&gt;nodePressure[i] += dp;
    }
    if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
    {
        double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();
        for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
        {
            this-&gt;nodeAcceleration.x[i] = (this-&gt;nodeVelocity.x[i] - this-&gt;nodeVelocityOld.x[i]) / dt;
            this-&gt;nodeAcceleration.y[i] = (this-&gt;nodeVelocity.y[i] - this-&gt;nodeVelocityOld.y[i]) / dt;
            this-&gt;nodeAcceleration.z[i] = (this-&gt;nodeVelocity.z[i] - this-&gt;nodeVelocityOld.z[i]) / dt;
        }
    }

    double u = 0.0;
    for (uint i=0;i&lt;this-&gt;nodeVelocity.x.size();i++)
    {
        RR3Vector vec(this-&gt;nodeVelocity.x[i],this-&gt;nodeVelocity.y[i],this-&gt;nodeVelocity.z[i]);
        u += RRVector::dot(vec,vec);
    }
    u = std::sqrt(u);
    double p = RRVector::norm(this-&gt;nodePressure);

    this-&gt;cvgV = (u - uOld) / this-&gt;scales.findScaleFactor(R_VARIABLE_VELOCITY);
    this-&gt;cvgP = (p - pOld) / this-&gt;scales.findScaleFactor(R_VARIABLE_PRESSURE);

    this-&gt;updateStopWatch.pause();

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101542.49">void RSolverFluid::process(void)
{

}

</t>
<t tx="leo.20201108101542.5">void RScales::upscale(RModel &amp;model) const
{
    this-&gt;convert(model,true);
}

</t>
<t tx="leo.20201108101542.50">void RSolverFluid::store(void)
{
    RLogger::info("Storing results\n");
    RLogger::indent();

    // Velocity
    uint velocityPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_VELOCITY);
    if (velocityPos == RConstants::eod)
    {
        velocityPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_VELOCITY);

        double umin = 0.0;
        double umax = 0.0;
        for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
        {
            @others
}

</t>
<t tx="leo.20201108101542.51">        double u = RR3Vector(this-&gt;nodeVelocity.x[i],
                             this-&gt;nodeVelocity.y[i],
                             this-&gt;nodeVelocity.z[i]).length();
        if (i == 0)
        {
            umin = umax = u;
        }
        else
        {
            umin = std::min(umin,u);
            umax = std::max(umax,u);
        }
    }

    this-&gt;pModel-&gt;getVariable(velocityPos).getVariableData().setMinMaxDisplayValue(umin,umax);
}
RVariable &amp;velocity =  this-&gt;pModel-&gt;getVariable(velocityPos);

velocity.setApplyType(R_VARIABLE_APPLY_NODE);
velocity.resize(3,this-&gt;pModel-&gt;getNNodes());
for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
{
    velocity.setValue(0,i,this-&gt;nodeVelocity.x[i]);
    velocity.setValue(1,i,this-&gt;nodeVelocity.y[i]);
    velocity.setValue(2,i,this-&gt;nodeVelocity.z[i]);
}

\\-4.//    // Acceleration
\\-4.//    uint accelerationPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_ACCELERATION);
\\-4.//    if (accelerationPos == RConstants::eod)
\\-4.//    {
\\-4.//        accelerationPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_ACCELERATION);

\\-4.//        double amin = 0.0;
\\-4.//        double amax = 0.0;
\\-4.//        for (uint i=0;i&lt;this-&gt;nodeVelocity.x.size();i++)
\\-4.//        {
\\-4.//            double u = RR3Vector(this-&gt;nodeAcceleration.x[i],
\\-4.//                                 this-&gt;nodeAcceleration.y[i],
\\-4.//                                 this-&gt;nodeAcceleration.z[i]).length();
\\-4.//            if (i == 0)
\\-4.//            {
\\-4.//                amin = amax = u;
\\-4.//            }
\\-4.//            else
\\-4.//            {
\\-4.//                amin = std::min(amin,u);
\\-4.//                amax = std::max(amax,u);
\\-4.//            }
\\-4.//        }

\\-4.//        this-&gt;pModel-&gt;getVariable(accelerationPos).getVariableData().setMinMaxDisplayValue(amin,amax);
\\-4.//    }
\\-4.//    RVariable &amp;acceleration =  this-&gt;pModel-&gt;getVariable(accelerationPos);

\\-4.//    acceleration.setApplyType(R_VARIABLE_APPLY_NODE);
\\-4.//    acceleration.resize(3,this-&gt;pModel-&gt;getNNodes());
\\-4.//    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
\\-4.//    {
\\-4.//        acceleration.setValue(0,i,this-&gt;nodeAcceleration.x[i]);
\\-4.//        acceleration.setValue(1,i,this-&gt;nodeAcceleration.y[i]);
\\-4.//        acceleration.setValue(2,i,this-&gt;nodeAcceleration.z[i]);
\\-4.//    }

// Pressure
uint pressurePos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_PRESSURE);
if (pressurePos == RConstants::eod)
{
    pressurePos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_PRESSURE);

    this-&gt;pModel-&gt;getVariable(pressurePos).getVariableData().setMinMaxDisplayValue(
                RStatistics::findMinimumValue(this-&gt;nodePressure),
                RStatistics::findMaximumValue(this-&gt;nodePressure));
}
RVariable &amp;pressure =  this-&gt;pModel-&gt;getVariable(pressurePos);

pressure.setApplyType(R_VARIABLE_APPLY_NODE);
pressure.resize(1,this-&gt;pModel-&gt;getNNodes());
for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
{
    pressure.setValue(0,i,this-&gt;nodePressure[i]);
}

RLogger::unindent();
</t>
<t tx="leo.20201108101542.52">void RSolverFluid::statistics(void)
{
    static uint counter = 0;
    static double oldResidual = 0.0;

    double scale = std::pow(this-&gt;scales.getSecond(),2) / this-&gt;scales.getKilogram();
    double residual = RRVector::norm(this-&gt;b)*scale;
    double convergence = residual - oldResidual;
    oldResidual = residual;

    std::vector&lt;RIterationInfoValue&gt; cvgValues;
    cvgValues.push_back(RIterationInfoValue("Solver residual",residual));
    cvgValues.push_back(RIterationInfoValue("Solver convergence",convergence));
    cvgValues.push_back(RIterationInfoValue("Velocity convergence",this-&gt;cvgV));
    cvgValues.push_back(RIterationInfoValue("Pressure convergence",this-&gt;cvgP));

    RIterationInfo::writeToFile(this-&gt;convergenceFileName,counter,cvgValues);

    this-&gt;printStats(R_VARIABLE_VELOCITY);
    this-&gt;printStats(R_VARIABLE_PRESSURE);
    this-&gt;processMonitoringPoints();

    RLogger::info("Convergence:   %-13g\n",residual);

    RLogger::info("Build time:        %9u [ms]\n",this-&gt;buildStopWatch.getMiliSeconds());
    RLogger::info("Solver time:       %9u [ms]\n",this-&gt;solverStopWatch.getMiliSeconds());
    RLogger::info("Update time:       %9u [ms]\n",this-&gt;updateStopWatch.getMiliSeconds());

    counter++;
}

</t>
<t tx="leo.20201108101542.53">void RSolverFluid::findInputVectors(void)
{
    RBVector elementVelocitySetValues(this-&gt;pModel-&gt;getNElements(),false);
    RBVector elementPressureSetValues(this-&gt;pModel-&gt;getNElements(),false);

    this-&gt;elementVelocity.x.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;elementVelocity.y.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;elementVelocity.z.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;nodeAcceleration.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeAcceleration.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeAcceleration.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeVelocityOld.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeVelocityOld.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeVelocityOld.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;elementPressure.resize(this-&gt;pModel-&gt;getNElements(),0.0);

    // Apply initial conditions
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = this-&gt;pModel-&gt;getElementGroupPtr(i);
        if (!pElementGroup)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Element group could not be found (%u of %u).",i,this-&gt;pModel-&gt;getNElementGroups());
        }

        if (this-&gt;firstRun)
        {
            // Apply initial conditions
            for (uint j=0;j&lt;pElementGroup-&gt;getNInitialConditions();j++)
            {
                RR3Vector velocity(0.0,0.0,0.0);
                double pressure = 0.0;

                bool velocitySet = false;
                bool pressureSet = false;

                const RInitialCondition &amp;ic = pElementGroup-&gt;getInitialCondition(j);

                if (ic.getType() == R_INITIAL_CONDITION_VELOCITY)
                {
                    uint icComponentPosition = ic.findComponentPosition(R_VARIABLE_VELOCITY_X);
                    if (icComponentPosition != RConstants::eod)
                    {
                        const RConditionComponent &amp;conditionComponent = ic.getComponent(icComponentPosition);
                        velocity[0] = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
                    }

                    icComponentPosition = ic.findComponentPosition(R_VARIABLE_VELOCITY_Y);
                    if (icComponentPosition != RConstants::eod)
                    {
                        const RConditionComponent &amp;conditionComponent = ic.getComponent(icComponentPosition);
                        velocity[1] = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
                    }

                    icComponentPosition = ic.findComponentPosition(R_VARIABLE_VELOCITY_Z);
                    if (icComponentPosition != RConstants::eod)
                    {
                        const RConditionComponent &amp;conditionComponent = ic.getComponent(icComponentPosition);
                        velocity[2] = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
                    }
                    velocitySet = true;
                }
                else if (ic.getType() == R_INITIAL_CONDITION_PRESSURE)
                {
                    uint icComponentPosition = ic.findComponentPosition(R_VARIABLE_PRESSURE);
                    if (icComponentPosition == RConstants::eod)
                    {
                        continue;
                    }
                    const RConditionComponent &amp;conditionComponent = ic.getComponent(icComponentPosition);
                    pressure = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
                    pressureSet = true;
                }

                if (!velocitySet &amp;&amp; !pressureSet)
                {
                    continue;
                }

                for (uint k=0;k&lt;pElementGroup-&gt;size();k++)
                {
                    if (velocitySet)
                    {
                        this-&gt;elementVelocity.x[pElementGroup-&gt;get(k)] = velocity[0];
                        this-&gt;elementVelocity.y[pElementGroup-&gt;get(k)] = velocity[1];
                        this-&gt;elementVelocity.z[pElementGroup-&gt;get(k)] = velocity[2];
                        elementVelocitySetValues[pElementGroup-&gt;get(k)] = true;
                    }
                    if (pressureSet)
                    {
                        this-&gt;elementPressure[pElementGroup-&gt;get(k)] = pressure;
                        elementPressureSetValues[pElementGroup-&gt;get(k)] = true;
                    }
                }
            }
        }
    }

    RBVector elementWall(this-&gt;pModel-&gt;getNElements(),false);
    RBVector elementFrictionlessWall(this-&gt;pModel-&gt;getNElements(),false);

    // Apply boundary conditions
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = this-&gt;pModel-&gt;getElementGroupPtr(i);
        if (!pElementGroup)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Element group could not be found (%u of %u).",i,this-&gt;pModel-&gt;getNElementGroups());
        }
        // Apply boundary conditions
        for (uint j=0;j&lt;pElementGroup-&gt;getNBoundaryConditions();j++)
        {
            RR3Vector velocity(0.0,0.0,0.0);
            double pressure = 0.0;

            bool wallSet = false;
            bool frictionlessWallSet = false;
            bool velocitySet = false;
            bool pressureSet = false;

            const RBoundaryCondition &amp;bc = pElementGroup-&gt;getBoundaryCondition(j);

            if (bc.getType() == R_BOUNDARY_CONDITION_WALL)
            {
                wallSet = true;
                velocitySet = true;
            }
            else if (bc.getType() == R_BOUNDARY_CONDITION_WALL_FRICTIONLESS)
            {
                frictionlessWallSet = true;
            }
            else if (bc.getType() == R_BOUNDARY_CONDITION_INFLOW_VELOCITY)
            {
                uint bcComponentPosition = bc.findComponentPosition(R_VARIABLE_VELOCITY);
                if (bcComponentPosition == RConstants::eod)
                {
                    continue;
                }
                const RConditionComponent &amp;conditionComponent = bc.getComponent(bcComponentPosition);
                double value = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
                RR3Vector normal;

                const RSurface *pSurface = static_cast&lt;const RSurface*&gt;(pElementGroup);
                pSurface-&gt;findAverageNormal(this-&gt;pModel-&gt;getNodes(),this-&gt;pModel-&gt;getElements(),normal);

                if (pSurface-&gt;size() &gt; 0)
                {
                    if (!this-&gt;inwardElements[pSurface-&gt;get(0)])
                    {
                        normal *= -1.0;
                    }
                }

                velocity[0] = value * normal[0];
                velocity[1] = value * normal[1];
                velocity[2] = value * normal[2];
                velocitySet = true;
            }
            else if (bc.getType() == R_BOUNDARY_CONDITION_INFLOW_VOLURATE)
            {
                uint bcComponentPosition = bc.findComponentPosition(R_VARIABLE_VOLUME_FLOW_RATE);
                if (bcComponentPosition == RConstants::eod)
                {
                    continue;
                }
                const RConditionComponent &amp;conditionComponent = bc.getComponent(bcComponentPosition);
                double volumetricFlowRate = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

                const RSurface *pSurface = static_cast&lt;const RSurface*&gt;(pElementGroup);

                double area = pSurface-&gt;findArea(this-&gt;pModel-&gt;getNodes(),this-&gt;pModel-&gt;getElements());
                double value = volumetricFlowRate / area;

                RR3Vector normal;
                pSurface-&gt;findAverageNormal(this-&gt;pModel-&gt;getNodes(),this-&gt;pModel-&gt;getElements(),normal);

                if (pSurface-&gt;size() &gt; 0)
                {
                    if (!this-&gt;inwardElements[pSurface-&gt;get(0)])
                    {
                        normal *= -1.0;
                    }
                }

                velocity[0] = value * normal[0];
                velocity[1] = value * normal[1];
                velocity[2] = value * normal[2];
                velocitySet = true;
            }
            else if (bc.getType() == R_BOUNDARY_CONDITION_PRESSURE_EXPLICIT)
            {
                uint bcComponentPosition = bc.findComponentPosition(R_VARIABLE_PRESSURE);
                if (bcComponentPosition == RConstants::eod)
                {
                    continue;
                }
                const RConditionComponent &amp;conditionComponent = bc.getComponent(bcComponentPosition);
                pressure = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
                pressureSet = true;
            }
//            else if (bc.getType() == R_BOUNDARY_CONDITION_PRESSURE_IMPLICIT)
//            {
//                uint bcComponentPosition = bc.findComponentPosition(R_VARIABLE_PRESSURE);
//                if (bcComponentPosition == RConstants::eod)
//                {
//                    continue;
//                }
//                const RConditionComponent &amp;conditionComponent = bc.getComponent(bcComponentPosition);
//                pressure = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
//                pressureSet = true;
//            }

            if (!wallSet &amp;&amp; !frictionlessWallSet &amp;&amp; !velocitySet &amp;&amp; !pressureSet)
            {
                continue;
            }

            for (uint k=0;k&lt;pElementGroup-&gt;size();k++)
            {
                elementWall[pElementGroup-&gt;get(k)] = wallSet;
                elementFrictionlessWall[pElementGroup-&gt;get(k)] = frictionlessWallSet;

                if (velocitySet)
                {
                    this-&gt;elementVelocity.x[pElementGroup-&gt;get(k)] = velocity[0];
                    this-&gt;elementVelocity.y[pElementGroup-&gt;get(k)] = velocity[1];
                    this-&gt;elementVelocity.z[pElementGroup-&gt;get(k)] = velocity[2];
                    elementVelocitySetValues[pElementGroup-&gt;get(k)] = true;
                }
                if (pressureSet)
                {
                    this-&gt;elementPressure[pElementGroup-&gt;get(k)] = pressure;
                    elementPressureSetValues[pElementGroup-&gt;get(k)] = true;
                }
            }
        }
    }

    RBVector elementGravitySetValues;

    this-&gt;generateVariableVector(R_VARIABLE_G_ACCELERATION_X,this-&gt;elementGravity.x,elementGravitySetValues,true,true,true);
    this-&gt;generateVariableVector(R_VARIABLE_G_ACCELERATION_Y,this-&gt;elementGravity.y,elementGravitySetValues,true,true,true);
    this-&gt;generateVariableVector(R_VARIABLE_G_ACCELERATION_Z,this-&gt;elementGravity.z,elementGravitySetValues,true,true,true);

    this-&gt;pModel-&gt;convertElementToNodeVector(this-&gt;elementVelocity.x,elementVelocitySetValues,this-&gt;nodeVelocity.x,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(this-&gt;elementVelocity.y,elementVelocitySetValues,this-&gt;nodeVelocity.y,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(this-&gt;elementVelocity.z,elementVelocitySetValues,this-&gt;nodeVelocity.z,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(this-&gt;elementPressure,elementPressureSetValues,this-&gt;nodePressure,true);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(i);
        if (elementWall[i])
        {
            for (uint j=0;j&lt;rElement.size();j++)
            {
                this-&gt;nodeVelocity.x[rElement.getNodeId(j)] = 0.0;
                this-&gt;nodeVelocity.y[rElement.getNodeId(j)] = 0.0;
                this-&gt;nodeVelocity.z[rElement.getNodeId(j)] = 0.0;
            }
        }
        if (elementFrictionlessWall[i])
        {
            RR3Vector elementNormal;
            rElement.findNormal(this-&gt;pModel-&gt;getNodes(),elementNormal[0],elementNormal[1],elementNormal[2]);

            bool hasX = false;
            bool hasY = false;
            bool hasZ = false;

            if (std::fabs(elementNormal[0]) &gt; std::fabs(elementNormal[1]) &amp;&amp; std::fabs(elementNormal[0]) &gt; std::fabs(elementNormal[2]))
            {
                hasX = true;
            }
            else
            {
                if (std::fabs(elementNormal[1]) &gt; std::fabs(elementNormal[0]) &amp;&amp; std::fabs(elementNormal[1]) &gt; std::fabs(elementNormal[2]))
                {
                    hasY = true;
                }
                else
                {
                    hasZ = true;
                }
            }

            for (uint j=0;j&lt;rElement.size();j++)
            {
                if (hasX)
                {
                    this-&gt;nodeVelocity.x[rElement.getNodeId(j)] = 0.0;
                }
                if (hasY)
                {
                    this-&gt;nodeVelocity.y[rElement.getNodeId(j)] = 0.0;
                }
                if (hasZ)
                {
                    this-&gt;nodeVelocity.z[rElement.getNodeId(j)] = 0.0;
                }
            }
        }
    }

    this-&gt;nodeVelocityOld.x = this-&gt;nodeVelocity.x;
    this-&gt;nodeVelocityOld.y = this-&gt;nodeVelocity.y;
    this-&gt;nodeVelocityOld.z = this-&gt;nodeVelocity.z;

    this-&gt;nodeAcceleration.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeAcceleration.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeAcceleration.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
}

</t>
<t tx="leo.20201108101542.54">void RSolverFluid::generateNodeBook(void)
{
    this-&gt;nodeBook.resize(this-&gt;pModel-&gt;getNNodes()*4);
    this-&gt;nodeBook.initialize();

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = this-&gt;pModel-&gt;getElementGroupPtr(i);
        if (!pElementGroup)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Element group could not be found (%u of %u).",i,this-&gt;pModel-&gt;getNElementGroups());
        }
        bool hasVelocityX = false;
        bool hasVelocityY = false;
        bool hasVelocityZ = false;
        bool hasFriction = false;
        bool hasPressure = false;
        for (uint j=0;j&lt;pElementGroup-&gt;getNBoundaryConditions();j++)
        {
            const RBoundaryCondition &amp;bc = pElementGroup-&gt;getBoundaryCondition(j);
            if (RBoundaryCondition::getProblemTypeMask(bc.getType()) &amp; R_PROBLEM_FLUID)
            {
                if (bc.getType() == R_BOUNDARY_CONDITION_INFLOW_VELOCITY ||
                    bc.getType() == R_BOUNDARY_CONDITION_INFLOW_VOLURATE ||
                    bc.getType() == R_BOUNDARY_CONDITION_WALL)
                {
                    hasVelocityX = true;
                    hasVelocityY = true;
                    hasVelocityZ = true;
                }
                if (bc.getType() == R_BOUNDARY_CONDITION_WALL_FRICTIONLESS)
                {
                    hasFriction = true;
                }
                if (bc.getType() == R_BOUNDARY_CONDITION_PRESSURE_EXPLICIT)
                {
                    hasPressure = true;
                }
            }
        }
        if (!hasVelocityX &amp;&amp; !hasVelocityY &amp;&amp; !hasVelocityZ &amp;&amp; !hasFriction &amp;&amp; !hasPressure)
        {
            continue;
        }
        for (int64_t j=0;j&lt;pElementGroup-&gt;size();j++)
        {
            uint elementID = pElementGroup-&gt;get(uint(j));
            const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);

            bool elementHasVelocityX = hasVelocityX;
            bool elementHasVelocityY = hasVelocityY;
            bool elementHasVelocityZ = hasVelocityZ;

            if (hasFriction)
            {
                RR3Vector elementNormal;
                rElement.findNormal(this-&gt;pModel-&gt;getNodes(),elementNormal[0],elementNormal[1],elementNormal[2]);

                if (std::fabs(elementNormal[0]) &gt; std::fabs(elementNormal[1]) &amp;&amp; std::fabs(elementNormal[0]) &gt; std::fabs(elementNormal[2]))
                {
                    elementHasVelocityX = true;
                }
                else
                {
                    if (std::fabs(elementNormal[1]) &gt; std::fabs(elementNormal[0]) &amp;&amp; std::fabs(elementNormal[1]) &gt; std::fabs(elementNormal[2]))
                    {
                        elementHasVelocityY = true;
                    }
                    else
                    {
                        elementHasVelocityZ = true;
                    }
                }
            }
            for (uint k=0;k&lt;rElement.size();k++)
            {
                uint nodeId = rElement.getNodeId(k);
                if (elementHasVelocityX)
                {
                    this-&gt;nodeBook.disable(4*nodeId+0,true);
                }
                if (elementHasVelocityY)
                {
                    this-&gt;nodeBook.disable(4*nodeId+1,true);
                }
                if (elementHasVelocityZ)
                {
                    this-&gt;nodeBook.disable(4*nodeId+2,true);
                }
                if (hasPressure)
                {
                    this-&gt;nodeBook.disable(4*nodeId+3,true);
                }
            }
        }
    }
    RBVector computableNodes(this-&gt;pModel-&gt;getNNodes(),false);
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        if (this-&gt;computableElements[i])
        {
            const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(i);
            for (uint j=0;j&lt;rElement.size();j++)
            {
                computableNodes[rElement.getNodeId(j)] = true;
            }
        }
    }
    for (uint i=0;i&lt;computableNodes.size();i++)
    {
        if (!computableNodes[i])
        {
            this-&gt;nodeBook.disable(4*i+0,true);
            this-&gt;nodeBook.disable(4*i+1,true);
            this-&gt;nodeBook.disable(4*i+2,true);
            this-&gt;nodeBook.disable(4*i+3,true);
        }
    }
}

</t>
<t tx="leo.20201108101542.55">void RSolverFluid::computeFreePressureNodeHeight(void)
{
    this-&gt;freePressureNodeHeight.resize(this-&gt;pModel-&gt;getNNodes());
    this-&gt;freePressureNodeHeight.fill(0.0);

    // Based on average gravity vector on surface elements.

    RR3Vector g(0.0,0.0,0.0);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        const RSurface &amp;rSurface = this-&gt;pModel-&gt;getSurface(i);

        if (!rSurface.hasBoundaryCondition(R_BOUNDARY_CONDITION_PRESSURE_IMPLICIT))
        {
            continue;
        }

        if (rSurface.hasEnvironmentCondition(R_ENVIRONMENT_CONDITION_G_ACCELERATION))
        {
            const REnvironmentCondition &amp;ec = rSurface.getEnvironmentCondition(R_ENVIRONMENT_CONDITION_G_ACCELERATION);
            uint componentPosition = 0;
            componentPosition = ec.findComponentPosition(R_VARIABLE_G_ACCELERATION_X);
            if (componentPosition != RConstants::eod)
            {
                const RConditionComponent &amp;conditionComponent = ec.getComponent(componentPosition);
                g[0] += conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
            }
            componentPosition = ec.findComponentPosition(R_VARIABLE_G_ACCELERATION_Y);
            if (componentPosition != RConstants::eod)
            {
                const RConditionComponent &amp;conditionComponent = ec.getComponent(componentPosition);
                g[1] += conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
            }
            componentPosition = ec.findComponentPosition(R_VARIABLE_G_ACCELERATION_Z);
            if (componentPosition != RConstants::eod)
            {
                const RConditionComponent &amp;conditionComponent = ec.getComponent(componentPosition);
                g[2] += conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
            }
        }
    }
    g.normalize();

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        const RNode &amp;rNode = this-&gt;pModel-&gt;getNode(i);
        this-&gt;freePressureNodeHeight[i] = rNode.getX()*g[0]
                                        + rNode.getY()*g[1]
                                        + rNode.getZ()*g[2];
    }

    double md = RStatistics::findMinimumValue(this-&gt;freePressureNodeHeight);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        this-&gt;freePressureNodeHeight[i] -= md;
        this-&gt;freePressureNodeHeight[i] = std::fabs(this-&gt;freePressureNodeHeight[i]);
    }
}

</t>
<t tx="leo.20201108101542.56">void RSolverFluid::computeShapeDerivatives(void)
{
    this-&gt;shapeDerivations.resize(this-&gt;pModel-&gt;getNElements(),nullptr);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        uint elementID = i;

        const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);
//        if (R_ELEMENT_TYPE_IS_VOLUME(rElement.getType()))
        {
            if (!this-&gt;computableElements[elementID])
            {
                continue;
            }
            if (!this-&gt;shapeDerivations[elementID])
            {
                this-&gt;shapeDerivations[elementID] = new RElementShapeDerivation(rElement,this-&gt;pModel-&gt;getNodes(),R_PROBLEM_FLUID);
            }
        }
    }
}

</t>
<t tx="leo.20201108101542.57">void RSolverFluid::clearShapeDerivatives(void)
{
    for (uint i=0;i&lt;this-&gt;shapeDerivations.size();i++)
    {
        delete this-&gt;shapeDerivations[i];
    }
}

</t>
<t tx="leo.20201108101542.58">void RSolverFluid::computeElement(unsigned int elementID, RRMatrix &amp;Ae, RRVector &amp;be, RMatrixManager&lt;FluidMatrixContainer&gt; &amp;matrixManager)
{
    if (RElement::hasConstantDerivative(this-&gt;pModel-&gt;getElement(elementID).getType()))
    {
        this-&gt;computeElementConstantDerivative(elementID,Ae,be,matrixManager);
    }
    else
    {
        this-&gt;computeElementGeneral(elementID,Ae,be,matrixManager);
    }
}

</t>
<t tx="leo.20201108101542.59">void RSolverFluid::computeElementGeneral(unsigned int elementID, RRMatrix &amp;Ae, RRVector &amp;be, RMatrixManager&lt;FluidMatrixContainer&gt; &amp;matrixManager)
{
    bool unsteady = (this-&gt;pModel-&gt;getTimeSolver().getEnabled());

    const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
    uint nen = element.size();
    uint nInp = RElement::getNIntegrationPoints(element.getType());

    double ro = this-&gt;elementDensity[elementID];
    double invro = 1.0 / ro;
    double u = this-&gt;elementViscosity[elementID];

    Ae.fill(0.0);
    be.fill(0.0);

    FluidMatrixContainer &amp;matrixCotainer = matrixManager.getMatricies(element.getType());
    matrixCotainer.clear();

    // Element level matricies
    RRMatrix &amp;me = matrixCotainer.me;
    RRMatrix &amp;ce = matrixCotainer.ce;
    RRMatrix &amp;ke = matrixCotainer.ke;
    RRMatrix &amp;ge = matrixCotainer.ge;
    RRMatrix &amp;geT = matrixCotainer.geT;
    RRMatrix &amp;cpe = matrixCotainer.cpe;
    RRMatrix &amp;cte = matrixCotainer.cte;
    RRMatrix &amp;ctpe = matrixCotainer.ctpe;
    RRMatrix &amp;kte = matrixCotainer.kte;
    RRMatrix &amp;ktpe = matrixCotainer.ktpe;
    RRMatrix &amp;ktppe = matrixCotainer.ktppe;
    RRMatrix &amp;yte = matrixCotainer.yte;
    RRMatrix &amp;ytpe = matrixCotainer.ytpe;
    RRMatrix &amp;bte = matrixCotainer.bte;
    RRMatrix &amp;ye = matrixCotainer.ye;
    RRMatrix &amp;ype = matrixCotainer.ype;
    RRMatrix &amp;the = matrixCotainer.the;
    RRMatrix &amp;epe = matrixCotainer.epe;

    // Element level vectors
    RRVector &amp;fv = matrixCotainer.fv;
    RRVector &amp;ftv = matrixCotainer.ftv;
    RRVector &amp;etv = matrixCotainer.etv;
    RRVector &amp;mv = matrixCotainer.mv;
    RRVector &amp;cv = matrixCotainer.cv;
    RRVector &amp;kv = matrixCotainer.kv;
    RRVector &amp;gv = matrixCotainer.gv;
    RRVector &amp;gvT = matrixCotainer.gvT;
    RRVector &amp;ctv = matrixCotainer.ctv;
    RRVector &amp;ktv = matrixCotainer.ktv;
    RRVector &amp;ytv = matrixCotainer.ytv;
    RRVector &amp;btv = matrixCotainer.btv;
    RRVector &amp;yv = matrixCotainer.yv;
    RRVector &amp;thv = matrixCotainer.thv;
    RRVector &amp;ev = matrixCotainer.ev;

    // Element level equations
    RRMatrix &amp;Ae11 = matrixCotainer.Ae11;
    RRMatrix &amp;Ae12 = matrixCotainer.Ae12;
    RRMatrix &amp;Ae21 = matrixCotainer.Ae21;
    RRMatrix &amp;Ae22 = matrixCotainer.Ae22;
    RRVector &amp;be1 = matrixCotainer.be1;
    RRVector &amp;be2 = matrixCotainer.be2;

    double mVh = this-&gt;streamVelocity;
    double invmVh = this-&gt;invStreamVelocity;
    double alpha = this-&gt;pModel-&gt;getTimeSolver().getTimeMarchApproximationCoefficient();
    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();
    double alphaDt = alpha * dt;

    // Element level input -------------------------------------------
    RR3Vector ve(this-&gt;elementVelocity.x[elementID],
                 this-&gt;elementVelocity.y[elementID],
                 this-&gt;elementVelocity.z[elementID]);
    RR3Vector veo(0.0,0.0,0.0);
    for (uint i=0;i&lt;nen;i++)
    {
        veo[0] += this-&gt;nodeVelocityOld.x[element.getNodeId(i)];
        veo[1] += this-&gt;nodeVelocityOld.y[element.getNodeId(i)];
        veo[2] += this-&gt;nodeVelocityOld.z[element.getNodeId(i)];
    }
    veo *= 1.0/double(nen);
    RRVector ax(nen,0.0);
    RRVector ay(nen,0.0);
    RRVector az(nen,0.0);
    for (uint i=0;i&lt;nen;i++)
    {
        ax[i] = this-&gt;nodeAcceleration.x[element.getNodeId(i)];
        ay[i] = this-&gt;nodeAcceleration.y[element.getNodeId(i)];
        az[i] = this-&gt;nodeAcceleration.z[element.getNodeId(i)];
    }
    RR3Vector g(this-&gt;elementGravity.x[elementID],
                this-&gt;elementGravity.y[elementID],
                this-&gt;elementGravity.z[elementID]);
    double p = this-&gt;elementPressure[elementID];
    // element level velocity magnitude
    double mvh = veo.length();
    double invmvh = 1.0 / mvh;
    // element level velocity direction
    RR3Vector s(veo);
    s.normalize();

    for (uint intPoint=0;intPoint&lt;nInp;intPoint++)
    {
        const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),intPoint);
        const RRVector &amp;N = shapeFunc.getN();
        const RRMatrix &amp;B = this-&gt;shapeDerivations[elementID]-&gt;getDerivative(intPoint);
        double detJ = this-&gt;shapeDerivations[elementID]-&gt;getJacobian(intPoint);

        double integValue = detJ * shapeFunc.getW();

        // velocity divergence
        RRVector vdiv(nen,0.0);
        // partial derivatives
        RR3Vector vex(0.0,0.0,0.0), vey(0.0,0.0,0.0), vez(0.0,0.0,0.0);
        double px = 0.0, py = 0.0, pz = 0.0;
        // element length scale
        double h = 0.0;
        double hn = this-&gt;elementScales[elementID];

        for (uint m=0;m&lt;nen;m++)
        {
            vdiv[m] += ve[0] * B[m][0] + ve[1] * B[m][1] + ve[2] * B[m][2];

            vex[0] += B[m][0] * this-&gt;nodeVelocity.x[element.getNodeId(m)];
            vex[1] += B[m][0] * this-&gt;nodeVelocity.y[element.getNodeId(m)];
            vex[2] += B[m][0] * this-&gt;nodeVelocity.z[element.getNodeId(m)];

            vey[0] += B[m][1] * this-&gt;nodeVelocity.x[element.getNodeId(m)];
            vey[1] += B[m][1] * this-&gt;nodeVelocity.y[element.getNodeId(m)];
            vey[2] += B[m][1] * this-&gt;nodeVelocity.z[element.getNodeId(m)];

            vez[0] += B[m][2] * this-&gt;nodeVelocity.x[element.getNodeId(m)];
            vez[1] += B[m][2] * this-&gt;nodeVelocity.y[element.getNodeId(m)];
            vez[2] += B[m][2] * this-&gt;nodeVelocity.z[element.getNodeId(m)];

            px += B[m][0] * this-&gt;nodePressure[element.getNodeId(m)];
            py += B[m][1] * this-&gt;nodePressure[element.getNodeId(m)];
            pz += B[m][2] * this-&gt;nodePressure[element.getNodeId(m)];

            h += std::fabs(s[0]*B[m][0] + s[1]*B[m][1] + s[2]*B[m][2]);
        }
        if (h != 0.0)
        {
            h = 2.0/h;
        }
        // Reynolds numbers
        double roD2u = 0.5 * ro / u;
        double Re = roD2u * mvh * h;
        double Ren = roD2u * mVh * hn;

        // SUPG stabilization parameter
        double Tsupg = 0.0;
        if (mvh &gt; 0.0)
        {
            if (Re &gt; 0.0 &amp;&amp; Re &lt;= 3.0)
            {
                Tsupg = h * Re *invmvh * inv6;
            }
            else
            {
                Tsupg = h * invmvh * 0.5;
            }
        }

        // PSPG stabilization parameter
        double Tpspg = 0.0;
        if (mVh &gt; 0.0)
        {
            if (Ren &gt; 0.0 &amp;&amp; Ren &lt;= 3.0)
            {
                Tpspg = hn * Ren * invmVh * inv6;
            }
            else
            {
                Tpspg = hn * invmVh * 0.5;
            }
        }

        // LSIC stabilization parameter
        double Tlsic = mvh*h * 0.5;

        double value = 0.0;
        for (uint m=0;m&lt;nen;m++)
        {
            for (uint n=0;n&lt;nen;n++)
            {
                // m matrix
                if (unsteady)
                {
                    value = ro * N[m]*N[n];
                    me[3*m+0][3*m+0] = value;
                    me[3*m+1][3*m+1] = value;
                    me[3*m+2][3*m+2] = value;
                }
                // c matrix
                value = ro * N[m] * vdiv[n];
                ce[3*m+0][3*n+0] = value;
                ce[3*m+1][3*n+1] = value;
                ce[3*m+2][3*n+2] = value;
                // k matrix
                value = ro * u;
                double tmpValue = B[m][0] * B[n][0] + B[m][1] * B[n][1] + B[m][2] * B[n][2];
                ke[3*m+0][3*n+0] = value * (tmpValue + B[m][0] * B[n][0]);
                ke[3*m+1][3*n+0] = value * (           B[m][0] * B[n][1]);
                ke[3*m+2][3*n+0] = value * (           B[m][0] * B[n][2]);
                ke[3*m+0][3*n+1] = value * (           B[m][1] * B[n][0]);
                ke[3*m+1][3*n+1] = value * (tmpValue + B[m][1] * B[n][1]);
                ke[3*m+2][3*n+1] = value * (           B[m][1] * B[n][2]);
                ke[3*m+0][3*n+2] = value * (           B[m][2] * B[n][0]);
                ke[3*m+1][3*n+2] = value * (           B[m][2] * B[n][1]);
                ke[3*m+2][3*n+2] = value * (tmpValue + B[m][2] * B[n][2]);
                // g matrix
                ge[3*m+0][n] = B[m][0] * N[n];
                ge[3*m+1][n] = B[m][1] * N[n];
                ge[3*m+2][n] = B[m][2] * N[n];
                // gT matrix
                geT[n][3*m+0] = ge[3*m+0][n];
                geT[n][3*m+1] = ge[3*m+1][n];
                geT[n][3*m+2] = ge[3*m+2][n];
                // c+ matrix
                value = ro * N[m] * N[n];
                cpe[3*m+0][3*n+0] = value * vex[0];
                cpe[3*m+0][3*n+1] = value * vey[0];
                cpe[3*m+0][3*n+2] = value * vez[0];
                cpe[3*m+1][3*n+0] = value * vex[1];
                cpe[3*m+1][3*n+1] = value * vey[1];
                cpe[3*m+1][3*n+2] = value * vez[1];
                cpe[3*m+2][3*n+0] = value * vex[2];
                cpe[3*m+2][3*n+1] = value * vey[2];
                cpe[3*m+2][3*n+2] = value * vez[2];
                // c~ matrix
                if (unsteady)
                {
                    value = Tsupg * ro * vdiv[m] * N[n];
                    cte[3*m+0][3*n+0] = value;
                    cte[3*m+1][3*n+1] = value;
                    cte[3*m+2][3*n+2] = value;
                }
                // c~+ matrix
                if (unsteady)
                {
                    value = Tsupg * ro * N[n];
                    ctpe[3*m+0][3*n+0] = value * B[m][0] * ax[n];
                    ctpe[3*m+1][3*n+0] = value * B[m][0] * ay[n];
                    ctpe[3*m+2][3*n+0] = value * B[m][0] * az[n];
                    ctpe[3*m+0][3*n+1] = value * B[m][1] * ax[n];
                    ctpe[3*m+1][3*n+1] = value * B[m][1] * ay[n];
                    ctpe[3*m+2][3*n+1] = value * B[m][1] * az[n];
                    ctpe[3*m+0][3*n+2] = value * B[m][2] * ax[n];
                    ctpe[3*m+1][3*n+2] = value * B[m][2] * ay[n];
                    ctpe[3*m+2][3*n+2] = value * B[m][2] * az[n];
                }
                // k~ matrix
                value = Tsupg * ro * vdiv[m] * vdiv[n];
                kte[3*m+0][3*n+0] = value;
                kte[3*m+1][3*n+1] = value;
                kte[3*m+2][3*n+2] = value;
                // k~+ matrix
                value = Tsupg * ro * vdiv[m] * N[n];
                ktpe[3*m+0][3*n+0] = value * vex[0];
                ktpe[3*m+0][3*n+1] = value * vey[0];
                ktpe[3*m+0][3*n+2] = value * vez[0];
                ktpe[3*m+1][3*n+0] = value * vex[1];
                ktpe[3*m+1][3*n+1] = value * vey[1];
                ktpe[3*m+1][3*n+2] = value * vez[1];
                ktpe[3*m+2][3*n+0] = value * vex[2];
                ktpe[3*m+2][3*n+1] = value * vey[2];
                ktpe[3*m+2][3*n+2] = value * vez[2];
                // k~++ matrix
                value = Tsupg * ro * N[n];
                ktppe[3*m+0][3*n+0] = value * B[m][0] * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0]);
                ktppe[3*m+0][3*n+1] = value * B[m][1] * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0]);
                ktppe[3*m+0][3*n+2] = value * B[m][2] * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0]);

                ktppe[3*m+1][3*n+0] = value * B[m][0] * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1]);
                ktppe[3*m+1][3*n+1] = value * B[m][1] * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1]);
                ktppe[3*m+1][3*n+2] = value * B[m][2] * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1]);

                ktppe[3*m+2][3*n+0] = value * B[m][0] * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]);
                ktppe[3*m+2][3*n+1] = value * B[m][1] * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]);
                ktppe[3*m+2][3*n+2] = value * B[m][2] * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]);
                // y~ matrix
                value = Tsupg * vdiv[m];
                yte[3*m+0][n] = value * B[n][0];
                yte[3*m+1][n] = value * B[n][1];
                yte[3*m+2][n] = value * B[n][2];
                // y~+ matrix
                value = Tsupg * N[n];
                ytpe[3*m+0][3*n+0] = value * B[m][0] * px;
                ytpe[3*m+0][3*n+1] = value * B[m][1] * px;
                ytpe[3*m+0][3*n+2] = value * B[m][2] * px;
                ytpe[3*m+1][3*n+0] = value * B[m][0] * py;
                ytpe[3*m+1][3*n+1] = value * B[m][1] * py;
                ytpe[3*m+1][3*n+2] = value * B[m][2] * py;
                ytpe[3*m+2][3*n+0] = value * B[m][0] * pz;
                ytpe[3*m+2][3*n+1] = value * B[m][1] * pz;
                ytpe[3*m+2][3*n+2] = value * B[m][2] * pz;
                // B matrix
                value = Tpspg * N[n];
                bte[m][3*n+0] = value * B[m][0];
                bte[m][3*n+1] = value * B[m][1];
                bte[m][3*n+2] = value * B[m][2];
                // y matrix
                value = Tpspg * vdiv[n];
                ye[m][3*n+0] = value * B[m][0];
                ye[m][3*n+1] = value * B[m][1];
                ye[m][3*n+2] = value * B[m][2];
                // y+ matrix
                value = Tpspg * N[n];
                ype[m][3*n+0] = value * (B[m][0]*vex[0] + B[m][1]*vex[1] + B[m][2]*vex[2]);
                ype[m][3*n+1] = value * (B[m][0]*vey[0] + B[m][1]*vey[1] + B[m][2]*vey[2]);
                ype[m][3*n+2] = value * (B[m][0]*vez[0] + B[m][1]*vez[1] + B[m][2]*vez[2]);
                // 0 matrix
                the[m][n] = Tpspg * ((B[m][0]*B[n][0] + B[m][1]*B[n][1] + B[m][2]*B[n][2]) * invro);
                // ep matrix
                value = Tlsic * ro;
                epe[3*m+0][3*n+0] = B[m][0] * B[n][0] * value;
                epe[3*m+0][3*n+1] = B[m][0] * B[n][1] * value;
                epe[3*m+0][3*n+2] = B[m][0] * B[n][2] * value;
                epe[3*m+1][3*n+0] = B[m][1] * B[n][0] * value;
                epe[3*m+1][3*n+1] = B[m][1] * B[n][1] * value;
                epe[3*m+1][3*n+2] = B[m][1] * B[n][2] * value;
                epe[3*m+2][3*n+0] = B[m][2] * B[n][0] * value;
                epe[3*m+2][3*n+1] = B[m][2] * B[n][1] * value;
                epe[3*m+2][3*n+2] = B[m][2] * B[n][2] * value;
            }
            // m vector
            value = N[m] * ro;
            if (unsteady)
            {
                mv[3*m+0] = value * ax[m];
                mv[3*m+1] = value * ay[m];
                mv[3*m+2] = value * az[m];
            }
            // c vector
            cv[3*m+0] = value * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0]);
            cv[3*m+1] = value * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1]);
            cv[3*m+2] = value * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]);
            // k vector
            kv[3*m+0] = u * (  B[m][0]*vex[0] + B[m][1]*vey[0] + B[m][2]*vez[0]
                             + B[m][0]*vex[0] + B[m][1]*vex[1] + B[m][2]*vex[2]);
            kv[3*m+1] = u * (  B[m][0]*vex[1] + B[m][1]*vey[1] + B[m][2]*vez[1]
                             + B[m][0]*vey[0] + B[m][1]*vey[1] + B[m][2]*vey[2]);
            kv[3*m+2] = u * (  B[m][0]*vex[2] + B[m][1]*vey[2] + B[m][2]*vez[2]
                             + B[m][0]*vez[0] + B[m][1]*vez[1] + B[m][2]*vez[2]);
            // g vector
            gv[3*m+0] = B[m][0] * p;
            gv[3*m+1] = B[m][1] * p;
            gv[3*m+2] = B[m][2] * p;
            // gT vector
            gvT[m] = N[m] * (vex[0] + vey[1] + vez[2]);
            // c~ vector
            value = Tsupg * vdiv[m];
            if (unsteady)
            {
                ctv[3*m+0] = value * ro * ax[m];
                ctv[3*m+1] = value * ro * ay[m];
                ctv[3*m+2] = value * ro * az[m];
            }
            // k~ vector
            ktv[3*m+0] = value * ro * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0]);
            ktv[3*m+1] = value * ro * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1]);
            ktv[3*m+2] = value * ro * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]);
            // y~ vector
            ytv[3*m+0] = value * px;
            ytv[3*m+1] = value * py;
            ytv[3*m+2] = value * pz;
            // B vector
            if (unsteady)
            {
                btv[m] = Tpspg * (B[m][0]*ax[m] + B[m][1]*ay[m] + B[m][2]*az[m]);
            }
            // y vector
            yv[m] = Tpspg * (  B[m][0] * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0])
                             + B[m][1] * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1])
                             + B[m][2] * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]));
            // 0 vector
            thv[m] = Tpspg * ((B[m][0]*px + B[m][1]*py + B[m][2]*pz) * invro);
            // e vector
            value = Tlsic * ro * (vex[0] + vey[1] + vez[2]);
            ev[3*m+0] = value * B[m][0];
            ev[3*m+1] = value * B[m][1];
            ev[3*m+2] = value * B[m][2];
            // f vector
            value = ro * N[m];
            fv[3*m+0] = value * g[0];
            fv[3*m+1] = value * g[1];
            fv[3*m+2] = value * g[2];
            // f~ vector
            value = Tsupg * ro * vdiv[m];
            ftv[3*m+0] = value * g[0];
            ftv[3*m+1] = value * g[1];
            ftv[3*m+2] = value * g[2];
            // e~ vector
            etv[m] = Tpspg * (B[m][0]*g[0] + B[m][1]*g[1] + B[m][2]*g[2]);
        }

        // Assembly element level matrixes
        for (uint m=0;m&lt;nen*3;m++)
        {
            for (uint n=0;n&lt;nen*3;n++)
            {
                if (unsteady)
                {
                    Ae11[m][n] = me[m][n] + cte[m][n]
                               + alphaDt * (
                                              ce[m][n]    + cpe[m][n]
                                            + ctpe[m][n]  + ke[m][n]
                                            + kte[m][n]   + ktpe[m][n]
                                            + ktppe[m][n] + ytpe[m][n] )
                               + dt * epe[m][n];
                }
                else
                {
                    Ae11[m][n] = ce[m][n]    + cpe[m][n]
                               + ke[m][n]
                               + kte[m][n]   + ktpe[m][n]
                               + ktppe[m][n] + ytpe[m][n]
                               + epe[m][n];
                }
            }
            for (uint n=0;n&lt;nen;n++)
            {
                if (unsteady)
                {
                    Ae12[m][n] = -dt * (ge[m][n] + yte[m][n]);
                    Ae21[n][m] = bte[n][m]
                               + dt * geT[n][m]
                               + alphaDt * (ye[n][m] + ype[n][m]);
                }
                else
                {
                    Ae12[m][n] = -ge[m][n] - yte[m][n];
                    Ae21[n][m] =  geT[n][m] + ye[n][m] + ype[n][m];
                }
            }
            if (unsteady)
            {
                be1[m] = dt * (fv[m] + ftv[m] - (  mv[m]  + ctv[m]
                                                 + cv[m]  + kv[m]
                                                 - gv[m]  + ktv[m]
                                                 - ytv[m] + ev[m]) );
            }
            else
            {
                be1[m] = fv[m] + ftv[m] - (  cv[m]  + kv[m]
                                           - gv[m]  + ktv[m]
                                           - ytv[m] + ev[m]);
            }

            for (uint k=0;k&lt;nen;k++)
            {
                for (uint l=0;l&lt;nen;l++)
                {
                    if (unsteady)
                    {
                        Ae22[k][l] = dt * the[k][l];
                    }
                    else
                    {
                        Ae22[k][l] = the[k][l];
                    }
                }
                if (unsteady)
                {
                    be2[k] = dt * (etv[k] - (  btv[k] + gvT[k]
                                             + yv[k] + thv[k]) );
                }
                else
                {
                    be2[k] = etv[k] - (gvT[k] + yv[k] + thv[k]);
                }
            }
        }

        for (uint m=0;m&lt;nen;m++)
        {
            for (uint n=0;n&lt;nen;n++)
            {
                Ae[4*m+0][4*n+0] += Ae11[3*m+0][3*n+0] * integValue;
                Ae[4*m+0][4*n+1] += Ae11[3*m+0][3*n+1] * integValue;
                Ae[4*m+0][4*n+2] += Ae11[3*m+0][3*n+2] * integValue;
                Ae[4*m+1][4*n+0] += Ae11[3*m+1][3*n+0] * integValue;
                Ae[4*m+1][4*n+1] += Ae11[3*m+1][3*n+1] * integValue;
                Ae[4*m+1][4*n+2] += Ae11[3*m+1][3*n+2] * integValue;
                Ae[4*m+2][4*n+0] += Ae11[3*m+2][3*n+0] * integValue;
                Ae[4*m+2][4*n+1] += Ae11[3*m+2][3*n+1] * integValue;
                Ae[4*m+2][4*n+2] += Ae11[3*m+2][3*n+2] * integValue;

                Ae[4*m+0][4*n+3] += Ae12[3*m+0][n] * integValue;
                Ae[4*m+1][4*n+3] += Ae12[3*m+1][n] * integValue;
                Ae[4*m+2][4*n+3] += Ae12[3*m+2][n] * integValue;

                Ae[4*m+3][4*n+0] += Ae21[m][3*n+0] * integValue;
                Ae[4*m+3][4*n+1] += Ae21[m][3*n+1] * integValue;
                Ae[4*m+3][4*n+2] += Ae21[m][3*n+2] * integValue;

                Ae[4*m+3][4*n+3] += Ae22[m][n] * integValue;
            }
            be[4*m+0] += be1[3*m+0] * integValue;
            be[4*m+1] += be1[3*m+1] * integValue;
            be[4*m+2] += be1[3*m+2] * integValue;

            be[4*m+3] += be2[m] * integValue;
        }
    }
}

</t>
<t tx="leo.20201108101542.6">void RScales::print(bool allVariables) const
{
    uint totalWidth = 70;
    uint firstColWidth = 10;
    for (uint i=0;i&lt;R_VARIABLE_N_TYPES;i++)
    {
        firstColWidth = std::max(firstColWidth,uint(RVariable::getName(RVariableType(i)).length())+1);
    }

    uint secondColWidth = totalWidth - firstColWidth;

    RLogger::info("+ %s + %s +\n",QString(firstColWidth,'-').toUtf8().constData(),QString(secondColWidth,'-').toUtf8().constData());
    RLogger::info("| %-*s | %*s |\n",firstColWidth,"Variable",secondColWidth,"Scale value");
    RLogger::info("+ %s + %s +\n",QString(firstColWidth,'-').toUtf8().constData(),QString(secondColWidth,'-').toUtf8().constData());
    RLogger::info("| %-*s | %*g |\n",firstColWidth,"Metre",secondColWidth,this-&gt;metre);
    RLogger::info("| %-*s | %*g |\n",firstColWidth,"Kilogram",secondColWidth,this-&gt;kilogram);
    RLogger::info("| %-*s | %*g |\n",firstColWidth,"Second",secondColWidth,this-&gt;second);
    RLogger::info("| %-*s | %*g |\n",firstColWidth,"Ampere",secondColWidth,this-&gt;ampere);
    RLogger::info("| %-*s | %*g |\n",firstColWidth,"Kelvin",secondColWidth,this-&gt;kelvin);
    RLogger::info("| %-*s | %*g |\n",firstColWidth,"Candela",secondColWidth,this-&gt;candela);
    RLogger::info("| %-*s | %*g |\n",firstColWidth,"Mole",secondColWidth,this-&gt;mole);
    RLogger::info("+ %s + %s +\n",QString(firstColWidth,'-').toUtf8().constData(),QString(secondColWidth,'-').toUtf8().constData());
    if (allVariables)
    {
        for (uint i=0;i&lt;R_VARIABLE_N_TYPES;i++)
        {
            RLogger::info("| %-*s | %*g |\n",firstColWidth,RVariable::getName(RVariableType(i)).toUtf8().constData(),secondColWidth,this-&gt;findScaleFactor(RVariableType(i)));
        }
        RLogger::info("+ %s + %s +\n",QString(firstColWidth,'-').toUtf8().constData(),QString(secondColWidth,'-').toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101542.60">void RSolverFluid::computeElementConstantDerivative(unsigned int elementID, RRMatrix &amp;Ae, RRVector &amp;be, RMatrixManager&lt;FluidMatrixContainer&gt; &amp;matrixManager)
{
    bool unsteady = (this-&gt;pModel-&gt;getTimeSolver().getEnabled());

    const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
    uint nen = element.size();

    double ro = this-&gt;elementDensity[elementID];
    double invro = 1.0 / ro;
    double u = this-&gt;elementViscosity[elementID];

    Ae.fill(0.0);
    be.fill(0.0);

    FluidMatrixContainer &amp;matrixCotainer = matrixManager.getMatricies(element.getType());
    matrixCotainer.clear();

    // Element level matricies
    RRMatrix &amp;me = matrixCotainer.me;
    RRMatrix &amp;ce = matrixCotainer.ce;
    RRMatrix &amp;ke = matrixCotainer.ke;
    RRMatrix &amp;ge = matrixCotainer.ge;
    RRMatrix &amp;geT = matrixCotainer.geT;
    RRMatrix &amp;cpe = matrixCotainer.cpe;
    RRMatrix &amp;cte = matrixCotainer.cte;
    RRMatrix &amp;ctpe = matrixCotainer.ctpe;
    RRMatrix &amp;kte = matrixCotainer.kte;
    RRMatrix &amp;ktpe = matrixCotainer.ktpe;
    RRMatrix &amp;ktppe = matrixCotainer.ktppe;
    RRMatrix &amp;yte = matrixCotainer.yte;
    RRMatrix &amp;ytpe = matrixCotainer.ytpe;
    RRMatrix &amp;bte = matrixCotainer.bte;
    RRMatrix &amp;ye = matrixCotainer.ye;
    RRMatrix &amp;ype = matrixCotainer.ype;
    RRMatrix &amp;the = matrixCotainer.the;
    RRMatrix &amp;epe = matrixCotainer.epe;

    // Element level vectors
    RRVector &amp;fv = matrixCotainer.fv;
    RRVector &amp;ftv = matrixCotainer.ftv;
    RRVector &amp;etv = matrixCotainer.etv;
    RRVector &amp;mv = matrixCotainer.mv;
    RRVector &amp;cv = matrixCotainer.cv;
    RRVector &amp;kv = matrixCotainer.kv;
    RRVector &amp;gv = matrixCotainer.gv;
    RRVector &amp;gvT = matrixCotainer.gvT;
    RRVector &amp;ctv = matrixCotainer.ctv;
    RRVector &amp;ktv = matrixCotainer.ktv;
    RRVector &amp;ytv = matrixCotainer.ytv;
    RRVector &amp;btv = matrixCotainer.btv;
    RRVector &amp;yv = matrixCotainer.yv;
    RRVector &amp;thv = matrixCotainer.thv;
    RRVector &amp;ev = matrixCotainer.ev;

    // Element level equations
    RRMatrix &amp;Ae11 = matrixCotainer.Ae11;
    RRMatrix &amp;Ae12 = matrixCotainer.Ae12;
    RRMatrix &amp;Ae21 = matrixCotainer.Ae21;
    RRMatrix &amp;Ae22 = matrixCotainer.Ae22;
    RRVector &amp;be1 = matrixCotainer.be1;
    RRVector &amp;be2 = matrixCotainer.be2;

    double mVh = this-&gt;streamVelocity;
    double invmVh = this-&gt;invStreamVelocity;
    double alpha = this-&gt;pModel-&gt;getTimeSolver().getTimeMarchApproximationCoefficient();
    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();
    double alphaDt = alpha * dt;

    // Element level input -------------------------------------------
    RR3Vector ve(this-&gt;elementVelocity.x[elementID],
                 this-&gt;elementVelocity.y[elementID],
                 this-&gt;elementVelocity.z[elementID]);
    RR3Vector veo(0.0,0.0,0.0);
    for (uint i=0;i&lt;nen;i++)
    {
        veo[0] += this-&gt;nodeVelocityOld.x[element.getNodeId(i)];
        veo[1] += this-&gt;nodeVelocityOld.y[element.getNodeId(i)];
        veo[2] += this-&gt;nodeVelocityOld.z[element.getNodeId(i)];
    }
    veo *= 1.0/double(nen);
    RRVector ax(nen,0.0);
    RRVector ay(nen,0.0);
    RRVector az(nen,0.0);
    for (uint i=0;i&lt;nen;i++)
    {
        ax[i] = this-&gt;nodeAcceleration.x[element.getNodeId(i)];
        ay[i] = this-&gt;nodeAcceleration.y[element.getNodeId(i)];
        az[i] = this-&gt;nodeAcceleration.z[element.getNodeId(i)];
    }

    RR3Vector g(this-&gt;elementGravity.x[elementID],
                this-&gt;elementGravity.y[elementID],
                this-&gt;elementGravity.z[elementID]);
    double p = this-&gt;elementPressure[elementID];
    // element level velocity magnitude
    double mvh = veo.length();
    double invmvh = 1.0 / mvh;
    // element level velocity direction
    RR3Vector s(veo);
    s.normalize();

    const RRVector &amp;iN = RElement::getMassVector(element.getType());
    const RRMatrix &amp;iNiN = RElement::getMassMatrix(element.getType());
    double wt = RElement::getTotalWeightFactor(element.getType());
    const RRMatrix &amp;B = this-&gt;shapeDerivations[elementID]-&gt;getDerivative(0);

    // velocity divergence
    RRVector vdiv(nen,0.0);
    // partial derivatives
    RR3Vector vex(0.0,0.0,0.0), vey(0.0,0.0,0.0), vez(0.0,0.0,0.0);
    double px = 0.0, py = 0.0, pz = 0.0;
    // element length scale
    double h = 0.0;
    double hn = this-&gt;elementScales[elementID];

    for (uint m=0;m&lt;nen;m++)
    {
        vdiv[m] += ve[0] * B[m][0] + ve[1] * B[m][1] + ve[2] * B[m][2];

        vex[0] += B[m][0] * this-&gt;nodeVelocity.x[element.getNodeId(m)];
        vex[1] += B[m][0] * this-&gt;nodeVelocity.y[element.getNodeId(m)];
        vex[2] += B[m][0] * this-&gt;nodeVelocity.z[element.getNodeId(m)];

        vey[0] += B[m][1] * this-&gt;nodeVelocity.x[element.getNodeId(m)];
        vey[1] += B[m][1] * this-&gt;nodeVelocity.y[element.getNodeId(m)];
        vey[2] += B[m][1] * this-&gt;nodeVelocity.z[element.getNodeId(m)];

        vez[0] += B[m][2] * this-&gt;nodeVelocity.x[element.getNodeId(m)];
        vez[1] += B[m][2] * this-&gt;nodeVelocity.y[element.getNodeId(m)];
        vez[2] += B[m][2] * this-&gt;nodeVelocity.z[element.getNodeId(m)];

        px += B[m][0] * this-&gt;nodePressure[element.getNodeId(m)];
        py += B[m][1] * this-&gt;nodePressure[element.getNodeId(m)];
        pz += B[m][2] * this-&gt;nodePressure[element.getNodeId(m)];

        h += std::fabs(s[0]*B[m][0] + s[1]*B[m][1] + s[2]*B[m][2]);
    }
    if (h != 0.0)
    {
        h = 2.0/h;
    }
    // Reynolds numbers
    double roD2u = 0.5 * ro / u;
    double Re = roD2u * mvh * h;
    double Ren = roD2u * mVh * hn;

    // SUPG stabilization parameter
    double Tsupg = 0.0;
    if (mvh &gt; 0.0)
    {
        if (Re &gt; 0.0 &amp;&amp; Re &lt;= 3.0)
        {
            Tsupg = h * Re * invmvh * inv6;
        }
        else
        {
            Tsupg = h * invmvh * 0.5;
        }
    }

    // PSPG stabilization parameter
    double Tpspg = 0.0;
    if (mVh &gt; 0.0)
    {
        if (Ren &gt; 0.0 &amp;&amp; Ren &lt;= 3.0)
        {
            Tpspg = hn * Ren * invmVh * inv6;
        }
        else
        {
            Tpspg = hn * invmVh * 0.5;
        }
    }

    // LSIC stabilization parameter
    double Tlsic = mvh*h * 0.5;

    double value = 0.0;
    for (uint m=0;m&lt;nen;m++)
    {
        for (uint n=0;n&lt;nen;n++)
        {
            // m matrix
            if (unsteady)
            {
                value = ro * iNiN[m][n];
                me[3*m+0][3*n+0] = value;
                me[3*m+1][3*n+1] = value;
                me[3*m+2][3*n+2] = value;
            }
            // c matrix
            value = ro * iN[m] * vdiv[n];
            ce[3*m+0][3*n+0] = value;
            ce[3*m+1][3*n+1] = value;
            ce[3*m+2][3*n+2] = value;
            // k matrix
            value = ro * u * wt;
            double tmpValue = B[m][0] * B[n][0] + B[m][1] * B[n][1] + B[m][2] * B[n][2];
            ke[3*m+0][3*n+0] = value * (tmpValue + B[m][0] * B[n][0]);
            ke[3*m+1][3*n+0] = value * (           B[m][0] * B[n][1]);
            ke[3*m+2][3*n+0] = value * (           B[m][0] * B[n][2]);
            ke[3*m+0][3*n+1] = value * (           B[m][1] * B[n][0]);
            ke[3*m+1][3*n+1] = value * (tmpValue + B[m][1] * B[n][1]);
            ke[3*m+2][3*n+1] = value * (           B[m][1] * B[n][2]);
            ke[3*m+0][3*n+2] = value * (           B[m][2] * B[n][0]);
            ke[3*m+1][3*n+2] = value * (           B[m][2] * B[n][1]);
            ke[3*m+2][3*n+2] = value * (tmpValue + B[m][2] * B[n][2]);
            // g matrix
            ge[3*m+0][n] = B[m][0] * iN[n];
            ge[3*m+1][n] = B[m][1] * iN[n];
            ge[3*m+2][n] = B[m][2] * iN[n];
            // gT matrix
            geT[n][3*m+0] = ge[3*m+0][n];
            geT[n][3*m+1] = ge[3*m+1][n];
            geT[n][3*m+2] = ge[3*m+2][n];
            // c+ matrix
            value = ro * iNiN[m][n];
            cpe[3*m+0][3*n+0] = value * vex[0];
            cpe[3*m+0][3*n+1] = value * vey[0];
            cpe[3*m+0][3*n+2] = value * vez[0];
            cpe[3*m+1][3*n+0] = value * vex[1];
            cpe[3*m+1][3*n+1] = value * vey[1];
            cpe[3*m+1][3*n+2] = value * vez[1];
            cpe[3*m+2][3*n+0] = value * vex[2];
            cpe[3*m+2][3*n+1] = value * vey[2];
            cpe[3*m+2][3*n+2] = value * vez[2];
            // c~ matrix
            if (unsteady)
            {
                value = Tsupg * ro * vdiv[m] * iN[n];
                cte[3*m+0][3*n+0] = value;
                cte[3*m+1][3*n+1] = value;
                cte[3*m+2][3*n+2] = value;
            }
            // c~+ matrix
            if (unsteady)
            {
                value = Tsupg * ro * iN[n];
                ctpe[3*m+0][3*n+0] = value * B[m][0] * ax[n];
                ctpe[3*m+1][3*n+0] = value * B[m][0] * ay[n];
                ctpe[3*m+2][3*n+0] = value * B[m][0] * az[n];
                ctpe[3*m+0][3*n+1] = value * B[m][1] * ax[n];
                ctpe[3*m+1][3*n+1] = value * B[m][1] * ay[n];
                ctpe[3*m+2][3*n+1] = value * B[m][1] * az[n];
                ctpe[3*m+0][3*n+2] = value * B[m][2] * ax[n];
                ctpe[3*m+1][3*n+2] = value * B[m][2] * ay[n];
                ctpe[3*m+2][3*n+2] = value * B[m][2] * az[n];
            }
            // k~ matrix
            value = Tsupg * ro * vdiv[m] * vdiv[n] * wt;
            kte[3*m+0][3*n+0] = value;
            kte[3*m+1][3*n+1] = value;
            kte[3*m+2][3*n+2] = value;
            // k~+ matrix
            value = Tsupg * ro * vdiv[m] * iN[n];
            ktpe[3*m+0][3*n+0] = value * vex[0];
            ktpe[3*m+0][3*n+1] = value * vey[0];
            ktpe[3*m+0][3*n+2] = value * vez[0];
            ktpe[3*m+1][3*n+0] = value * vex[1];
            ktpe[3*m+1][3*n+1] = value * vey[1];
            ktpe[3*m+1][3*n+2] = value * vez[1];
            ktpe[3*m+2][3*n+0] = value * vex[2];
            ktpe[3*m+2][3*n+1] = value * vey[2];
            ktpe[3*m+2][3*n+2] = value * vez[2];
            // k~++ matrix
            value = Tsupg * ro * iN[n];
            ktppe[3*m+0][3*n+0] = value * B[m][0] * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0]);
            ktppe[3*m+0][3*n+1] = value * B[m][1] * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0]);
            ktppe[3*m+0][3*n+2] = value * B[m][2] * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0]);

            ktppe[3*m+1][3*n+0] = value * B[m][0] * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1]);
            ktppe[3*m+1][3*n+1] = value * B[m][1] * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1]);
            ktppe[3*m+1][3*n+2] = value * B[m][2] * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1]);

            ktppe[3*m+2][3*n+0] = value * B[m][0] * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]);
            ktppe[3*m+2][3*n+1] = value * B[m][1] * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]);
            ktppe[3*m+2][3*n+2] = value * B[m][2] * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]);
            // y~ matrix
            value = Tsupg * vdiv[m] * wt;
            yte[3*m+0][n] = value * B[n][0];
            yte[3*m+1][n] = value * B[n][1];
            yte[3*m+2][n] = value * B[n][2];
            // y~+ matrix
            value = Tsupg * iN[n];
            ytpe[3*m+0][3*n+0] = value * B[m][0] * px;
            ytpe[3*m+0][3*n+1] = value * B[m][1] * px;
            ytpe[3*m+0][3*n+2] = value * B[m][2] * px;
            ytpe[3*m+1][3*n+0] = value * B[m][0] * py;
            ytpe[3*m+1][3*n+1] = value * B[m][1] * py;
            ytpe[3*m+1][3*n+2] = value * B[m][2] * py;
            ytpe[3*m+2][3*n+0] = value * B[m][0] * pz;
            ytpe[3*m+2][3*n+1] = value * B[m][1] * pz;
            ytpe[3*m+2][3*n+2] = value * B[m][2] * pz;
            // B matrix
            value = Tpspg * iN[n];
            bte[m][3*n+0] = value * B[m][0];
            bte[m][3*n+1] = value * B[m][1];
            bte[m][3*n+2] = value * B[m][2];
            // y matrix
            value = Tpspg * vdiv[n] * wt;
            ye[m][3*n+0] = value * B[m][0];
            ye[m][3*n+1] = value * B[m][1];
            ye[m][3*n+2] = value * B[m][2];
            // y+ matrix
            value = Tpspg * iN[n];
            ype[m][3*n+0] = value * (B[m][0]*vex[0] + B[m][1]*vex[1] + B[m][2]*vex[2]);
            ype[m][3*n+1] = value * (B[m][0]*vey[0] + B[m][1]*vey[1] + B[m][2]*vey[2]);
            ype[m][3*n+2] = value * (B[m][0]*vez[0] + B[m][1]*vez[1] + B[m][2]*vez[2]);
            // 0 matrix
            the[m][n] = Tpspg * ((B[m][0]*B[n][0] + B[m][1]*B[n][1] + B[m][2]*B[n][2]) * invro) * wt;
            // ep matrix
            value = Tlsic * ro * wt;
            epe[3*m+0][3*n+0] = B[m][0] * B[n][0] * value;
            epe[3*m+0][3*n+1] = B[m][0] * B[n][1] * value;
            epe[3*m+0][3*n+2] = B[m][0] * B[n][2] * value;
            epe[3*m+1][3*n+0] = B[m][1] * B[n][0] * value;
            epe[3*m+1][3*n+1] = B[m][1] * B[n][1] * value;
            epe[3*m+1][3*n+2] = B[m][1] * B[n][2] * value;
            epe[3*m+2][3*n+0] = B[m][2] * B[n][0] * value;
            epe[3*m+2][3*n+1] = B[m][2] * B[n][1] * value;
            epe[3*m+2][3*n+2] = B[m][2] * B[n][2] * value;
        }
        // m vector
        if (unsteady)
        {
            value = iN[m] * ro;
            mv[3*m+0] = value * ax[m];
            mv[3*m+1] = value * ay[m];
            mv[3*m+2] = value * az[m];
        }
        // c vector
        value = iN[m] * ro;
        cv[3*m+0] = value * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0]);
        cv[3*m+1] = value * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1]);
        cv[3*m+2] = value * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]);
        // k vector
        kv[3*m+0] = u * (  B[m][0]*vex[0] + B[m][1]*vey[0] + B[m][2]*vez[0]
                         + B[m][0]*vex[0] + B[m][1]*vex[1] + B[m][2]*vex[2]) * wt;
        kv[3*m+1] = u * (  B[m][0]*vex[1] + B[m][1]*vey[1] + B[m][2]*vez[1]
                         + B[m][0]*vey[0] + B[m][1]*vey[1] + B[m][2]*vey[2]) * wt;
        kv[3*m+2] = u * (  B[m][0]*vex[2] + B[m][1]*vey[2] + B[m][2]*vez[2]
                         + B[m][0]*vez[0] + B[m][1]*vez[1] + B[m][2]*vez[2]) * wt;
        // g vector
        value = p * wt;
        gv[3*m+0] = B[m][0] * value;
        gv[3*m+1] = B[m][1] * value;
        gv[3*m+2] = B[m][2] * value;
        // gT vector
        gvT[m] = iN[m] * (vex[0] + vey[1] + vez[2]);
        // c~ vector
        if (unsteady)
        {
            value = Tsupg * ro * vdiv[m] * wt;
            ctv[3*m+0] = value * ax[m];
            ctv[3*m+1] = value * ay[m];
            ctv[3*m+2] = value * az[m];
        }
        // k~ vector
        value = Tsupg * ro * vdiv[m] * wt;
        ktv[3*m+0] = value * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0]);
        ktv[3*m+1] = value * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1]);
        ktv[3*m+2] = value * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2]);
        // y~ vector
        value = Tsupg * vdiv[m] * wt;
        ytv[3*m+0] = value * px;
        ytv[3*m+1] = value * py;
        ytv[3*m+2] = value * pz;
        // B vector
        if (unsteady)
        {
            btv[m] = Tpspg * (B[m][0]*ax[m] + B[m][1]*ay[m] + B[m][2]*az[m]) * wt;
        }
        // y vector
        yv[m] = Tpspg * (  B[m][0] * (ve[0]*vex[0] + ve[1]*vey[0] + ve[2]*vez[0])
                         + B[m][1] * (ve[0]*vex[1] + ve[1]*vey[1] + ve[2]*vez[1])
                         + B[m][2] * (ve[0]*vex[2] + ve[1]*vey[2] + ve[2]*vez[2])) * wt;
        // 0 vector
        thv[m] = Tpspg * ((B[m][0]*px + B[m][1]*py + B[m][2]*pz) * invro) * wt;
        // e vector
        value = Tlsic * ro * (vex[0] + vey[1] + vez[2]) * wt;
        ev[3*m+0] = value * B[m][0];
        ev[3*m+1] = value * B[m][1];
        ev[3*m+2] = value * B[m][2];
        // f vector
        value = ro * iN[m];
        fv[3*m+0] = value * g[0];
        fv[3*m+1] = value * g[1];
        fv[3*m+2] = value * g[2];
        // f~ vector
        value = Tsupg * ro * vdiv[m] * wt;
        ftv[3*m+0] = value * g[0];
        ftv[3*m+1] = value * g[1];
        ftv[3*m+2] = value * g[2];
        // e~ vector
        etv[m] = Tpspg * (B[m][0]*g[0] + B[m][1]*g[1] + B[m][2]*g[2]) * wt;
    }

    // Assembly element level matrixes
    for (uint m=0;m&lt;nen*3;m++)
    {
        for (uint n=0;n&lt;nen*3;n++)
        {
            if (unsteady)
            {
                Ae11[m][n] = me[m][n] + cte[m][n]
                           + alphaDt * (
                                          ce[m][n]    + cpe[m][n]
                                        + ctpe[m][n]  + ke[m][n]
                                        + kte[m][n]   + ktpe[m][n]
                                        + ktppe[m][n] + ytpe[m][n] )
                           + dt * epe[m][n];
            }
            else
            {
                Ae11[m][n] = ce[m][n]    + cpe[m][n]
                           + ke[m][n]
                           + kte[m][n]   + ktpe[m][n]
                           + ktppe[m][n] + ytpe[m][n]
                           + epe[m][n];
            }
        }
        for (uint n=0;n&lt;nen;n++)
        {
            if (unsteady)
            {
                Ae12[m][n] = -dt * (ge[m][n] + yte[m][n]);
                Ae21[n][m] = bte[n][m]
                           + dt * geT[n][m]
                           + alphaDt * (ye[n][m] + ype[n][m]);
            }
            else
            {
                Ae12[m][n] = -ge[m][n] - yte[m][n];
                Ae21[n][m] =  geT[n][m] + ye[n][m] + ype[n][m];
            }
        }
        if (unsteady)
        {
            be1[m] = dt * (fv[m] + ftv[m] - (  mv[m]  + ctv[m]
                                             + cv[m]  + kv[m]
                                             - gv[m]  + ktv[m]
                                             - ytv[m] + ev[m]) );
        }
        else
        {
            be1[m] = fv[m] + ftv[m] - (  cv[m]  + kv[m]
                                       - gv[m]  + ktv[m]
                                       - ytv[m] + ev[m]);
        }

        for (uint k=0;k&lt;nen;k++)
        {
            for (uint l=0;l&lt;nen;l++)
            {
                if (unsteady)
                {
                    Ae22[k][l] = dt * the[k][l];
                }
                else
                {
                    Ae22[k][l] = the[k][l];
                }
            }
            if (unsteady)
            {
                be2[k] = dt * (etv[k] - (  btv[k] + gvT[k]
                                         + yv[k] + thv[k]) );
            }
            else
            {
                be2[k] = etv[k] - (gvT[k] + yv[k] + thv[k]);
            }
        }
    }

    for (uint m=0;m&lt;nen;m++)
    {
        for (uint n=0;n&lt;nen;n++)
        {
            Ae[4*m+0][4*n+0] += Ae11[3*m+0][3*n+0];
            Ae[4*m+0][4*n+1] += Ae11[3*m+0][3*n+1];
            Ae[4*m+0][4*n+2] += Ae11[3*m+0][3*n+2];
            Ae[4*m+1][4*n+0] += Ae11[3*m+1][3*n+0];
            Ae[4*m+1][4*n+1] += Ae11[3*m+1][3*n+1];
            Ae[4*m+1][4*n+2] += Ae11[3*m+1][3*n+2];
            Ae[4*m+2][4*n+0] += Ae11[3*m+2][3*n+0];
            Ae[4*m+2][4*n+1] += Ae11[3*m+2][3*n+1];
            Ae[4*m+2][4*n+2] += Ae11[3*m+2][3*n+2];

            Ae[4*m+0][4*n+3] += Ae12[3*m+0][n];
            Ae[4*m+1][4*n+3] += Ae12[3*m+1][n];
            Ae[4*m+2][4*n+3] += Ae12[3*m+2][n];

            Ae[4*m+3][4*n+0] += Ae21[m][3*n+0];
            Ae[4*m+3][4*n+1] += Ae21[m][3*n+1];
            Ae[4*m+3][4*n+2] += Ae21[m][3*n+2];

            Ae[4*m+3][4*n+3] += Ae22[m][n];
        }
        be[4*m+0] += be1[3*m+0];
        be[4*m+1] += be1[3*m+1];
        be[4*m+2] += be1[3*m+2];

        be[4*m+3] += be2[m];
    }

    double detJ = this-&gt;shapeDerivations[elementID]-&gt;getJacobian(0);
    Ae *= detJ;
    be *= detJ;
}

double RSolverFluid::findTimeScale() const
{
    double v = RSolverFluid::computeStreamVelocity(*this-&gt;pModel,this-&gt;nodeVelocity,true);
    double l = 1.0 / this-&gt;scales.getMetre();

    return v/l;
}

double RSolverFluid::findReScale(void) const
{
    double v = RSolverFluid::computeStreamVelocity(*this-&gt;pModel,this-&gt;nodeVelocity,true);
    double l = 1.0 / this-&gt;scales.getMetre();

    double Re = (this-&gt;avgU == 0.0) ? 1.0 : this-&gt;avgRo * v * l / this-&gt;avgU;

    return (Re == 0.0) ? 1.0 : 1.0e-2 / Re;
}

double RSolverFluid::findWeightScale(void) const
{
    double v = RSolverFluid::computeStreamVelocity(*this-&gt;pModel,this-&gt;nodeVelocity,true);
    double l = 1.0 / this-&gt;scales.getMetre();

    double ws = (this-&gt;avgU == 0.0) ? 1.0 : 1.0 *  v / (this-&gt;avgU * l * l);
    if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
    {
        ws *= 1.0e-2 / this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();
    }

    return ws;
}

</t>
<t tx="leo.20201108101542.61">void RSolverFluid::computeElementScales(void)
{
    this-&gt;elementScales.resize(this-&gt;pModel-&gt;getNElements());
    this-&gt;elementScales.fill(0.0);

    double third = 1.0/3.0;

#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(this-&gt;pModel-&gt;getNElements());i++)
    {
        if (!this-&gt;computableElements[uint(i)])
        {
            continue;
        }
        const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(uint(i));
        double volume = 0.0;
        if (!rElement.findVolume(this-&gt;pModel-&gt;getNodes(),volume))
        {
            continue;
        }
        if (rElement.getType() == R_ELEMENT_TETRA1)
        {
            this-&gt;elementScales[uint(i)] = std::pow(6.0 * volume / RConstants::pi, third);
        }
        else if (rElement.getType() == R_ELEMENT_HEXA1)
        {
            this-&gt;elementScales[uint(i)] = std::pow(volume, third);
        }
        else
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                         "Failed to calculate element scales. Unsupported elemenent type \'%s\'.",
                         RElement::getName(rElement.getType()).toUtf8().constData());
        }
    }
}

</t>
<t tx="leo.20201108101542.62">void RSolverFluid::computeElementFreePressure(RRVector &amp;values, RBVector &amp;setValues)
{
    values.resize(this-&gt;pModel-&gt;getNElements());
    values.fill(0.0);
    setValues.resize(this-&gt;pModel-&gt;getNElements());
    setValues.fill(false);

#pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(this-&gt;pModel-&gt;getNSurfaces());i++)
    {
        const RSurface &amp;rSurface = this-&gt;pModel-&gt;getSurface(uint(i));
        for (uint j=0;j&lt;rSurface.getNBoundaryConditions();j++)
        {
            const RBoundaryCondition &amp;bc = rSurface.getBoundaryCondition(j);
            if (bc.getType() != R_BOUNDARY_CONDITION_PRESSURE_IMPLICIT)
            {
                continue;
            }
            double p = 0.0;
            uint cpos = bc.findComponentPosition(R_VARIABLE_PRESSURE);
            if (cpos != RConstants::eod)
            {
                p = bc.getComponent(cpos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());
            }

            for (uint k=0;k&lt;rSurface.size();k++)
            {
                values[rSurface.get(k)] = p;
                setValues[rSurface.get(k)] = true;
            }
            break;
        }
    }
}

</t>
<t tx="leo.20201108101542.63">void RSolverFluid::assemblyMatrix(uint elementID, const RRMatrix &amp;Ae, const RRVector &amp;fe)
{
    const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);

    // Assembly final matrix system
    uint dims = 4;
    for (uint m=0;m&lt;rElement.size();m++)
    {
        for (uint i=0;i&lt;dims;i++)
        {
            uint mp = 0;

            if (this-&gt;nodeBook.getValue(dims*rElement.getNodeId(m)+i,mp))
            {
#pragma omp atomic
                this-&gt;b[mp] += fe[dims*m+i];
#pragma omp critical
                {
                    for (uint n=0;n&lt;rElement.size();n++)
                    {
                        for (uint j=0;j&lt;dims;j++)
                        {
                            uint np = 0;

                            if (this-&gt;nodeBook.getValue(dims*rElement.getNodeId(n)+j,np))
                            {
                                this-&gt;A.addValue(mp,np,Ae[dims*m+i][dims*n+j]);
                            }
                        }
                    }
                }
            }
        }
    }
}

</t>
<t tx="leo.20201108101542.64">void RSolverFluid::assemblyMatrix(unsigned int elementID, const RRMatrix &amp;Ae, const RRVector &amp;fe, RSparseMatrix &amp;Ap, RRVector &amp;bp)
{
    const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);

    // Assembly final matrix system
    uint dims = 4;
    for (uint m=0;m&lt;rElement.size();m++)
    {
        for (uint i=0;i&lt;dims;i++)
        {
            uint mp = 0;
            if (this-&gt;nodeBook.getValue(dims*rElement.getNodeId(m)+i,mp))
            {
                bp[mp] += fe[dims*m+i];
                for (uint n=0;n&lt;rElement.size();n++)
                {
                    for (uint j=0;j&lt;dims;j++)
                    {
                        uint np = 0;
                        if (this-&gt;nodeBook.getValue(dims*rElement.getNodeId(n)+j,np))
                        {
                            Ap.addValue(mp,np,Ae[dims*m+i][dims*n+j]);
                        }
                    }
                }
            }
        }
    }
}

</t>
<t tx="leo.20201108101542.65">void RSolverFluid::applyLocalRotations(unsigned int elementID, RRMatrix &amp;Ae)
{
    const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);
    RRMatrix T;

    bool first = true;

    for (uint i=0;i&lt;rElement.size();i++)
    {
        uint nodeId = rElement.getNodeId(i);
        if (this-&gt;localRotations[nodeId].isActive())
        {
            if (first)
            {
                T.setIdentity(Ae.getNRows());
                first = false;
            }
            T.setBlock(this-&gt;localRotations[nodeId].getR(),4*i,4*i);
        }
    }
    if (!first)
    {
        RRMatrix Tt(T);
        Tt.transpose();

        RRMatrix Aetmp;

        RRMatrix::mlt(Tt,Ae,Aetmp);
        RRMatrix::mlt(Aetmp,T,Ae);
    }
}

double RSolverFluid::computeStreamVelocity(const RModel &amp;rModel, const RSolverCartesianVector&lt;RRVector&gt; &amp;nodeVelocity, bool averageBased, double streamVelocity)
{
    double velocity = 1.0;

    double totalArea = 0.0;
    double totalVolurate = 0.0;

    for (uint i=0;i&lt;rModel.getNSurfaces();i++)
    {
        const RSurface &amp;rSurface = rModel.getSurface(i);

        bool hasVelocity = rSurface.hasBoundaryCondition(R_BOUNDARY_CONDITION_INFLOW_VELOCITY);
        bool hasVolurate = rSurface.hasBoundaryCondition(R_BOUNDARY_CONDITION_INFLOW_VOLURATE);

        double v = 0.0;
        double q = 0.0;

        if (!hasVelocity &amp;&amp; !hasVolurate)
        {
            continue;
        }

        if (hasVelocity)
        {
            const RBoundaryCondition &amp;rBoundaryCondition = rSurface.getBoundaryCondition(R_BOUNDARY_CONDITION_INFLOW_VELOCITY);
            uint vp = rBoundaryCondition.findComponentPosition(R_VARIABLE_VELOCITY);
            if (vp != RConstants::eod)
            {
                v = rBoundaryCondition.getComponent(vp).get(rModel.getTimeSolver().getCurrentTime());
            }
        }

        if (hasVolurate)
        {
            const RBoundaryCondition &amp;rBoundaryCondition = rSurface.getBoundaryCondition(R_BOUNDARY_CONDITION_INFLOW_VOLURATE);
            uint vp = rBoundaryCondition.findComponentPosition(R_VARIABLE_VOLUME_FLOW_RATE);
            if (vp != RConstants::eod)
            {
                q = rBoundaryCondition.getComponent(vp).get(rModel.getTimeSolver().getCurrentTime());
            }
        }

        double area = rSurface.findArea(rModel.getNodes(),rModel.getElements());
        if (area &lt; RConstants::eps)
        {
            continue;
        }
        if (hasVelocity)
        {
            q = v * area;
        }
        totalArea += area;
        totalVolurate += std::fabs(q);
    }

    if (totalArea &lt; RConstants::eps)
    {
        velocity = 1.0;
    }
    else
    {
        velocity = totalVolurate / totalArea;
    }

    if (averageBased)
    {
        double vm = 0.0;

#pragma omp parallel default(shared)
        {
        double vm_local = 0.0;
#pragma omp for
            for (int64_t i=0;i&lt;rModel.getNNodes();i++)
            {
                vm_local += std::sqrt(  std::pow(nodeVelocity.x[uint(i)],2)
                                      + std::pow(nodeVelocity.y[uint(i)],2)
                                      + std::pow(nodeVelocity.z[uint(i)],2));
            }
#pragma omp atomic
            vm += vm_local;
        }
        if (rModel.getNNodes())
        {
            vm /= double(rModel.getNNodes());
        }
        velocity = (vm + streamVelocity) / 2.0;
    }
    if (velocity &lt; RConstants::eps)
    {
        velocity = 1.0;
    }
    return velocity;
}
</t>
<t tx="leo.20201108101542.66">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolverfluidheat.cpp                                     *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-th January 2016                                       *
 *                                                                   *
 *  DESCRIPTION: Fluid - heat transfer solver class definition       *
 *********************************************************************/

#include &lt;omp.h&gt;

#include "rsolverfluid.h"
#include "rsolverfluidheat.h"
#include "rmatrixsolver.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101542.67">class FluidHeatMatrixContainer
{
    public:

        bool initialized;

        // Element level matricies
        RRMatrix me;    // m
        RRMatrix ce;    // c
        RRMatrix ke;    // k
        RRMatrix cte;   // c~
        RRMatrix kte;   // k~
        RRMatrix yte;   // y~

        // Element level vectors
        RRVector fv;    // f

    public:

        FluidHeatMatrixContainer() : initialized(false)
        {

        }

        @others
};

</t>
<t tx="leo.20201108101542.68">void resize(uint nen)
{
    this-&gt;me.resize(nen,nen,0.0);
    this-&gt;ce.resize(nen,nen,0.0);
    this-&gt;ke.resize(nen,nen,0.0);
    this-&gt;cte.resize(nen,nen,0.0);
    this-&gt;kte.resize(nen,nen,0.0);
    this-&gt;yte.resize(nen,nen,0.0);

    this-&gt;fv.resize(nen,0.0);

    this-&gt;initialized = true;
}

</t>
<t tx="leo.20201108101542.69">void clear(void)
{
    this-&gt;me.fill(0.0);
    this-&gt;ce.fill(0.0);
    this-&gt;ke.fill(0.0);
    this-&gt;cte.fill(0.0);
    this-&gt;kte.fill(0.0);
    this-&gt;yte.fill(0.0);

    this-&gt;fv.fill(0.0);
}
</t>
<t tx="leo.20201108101542.7">void RScales::convert(RModel &amp;model, bool invert) const
{
    double lengthScale = this-&gt;findScaleFactor(R_VARIABLE_LENGTH);
    double areaScale = this-&gt;findScaleFactor(R_VARIABLE_AREA);
    double volumeScale = this-&gt;findScaleFactor(R_VARIABLE_VOLUME);

    if (invert)
    {
        lengthScale = 1.0/lengthScale;
        areaScale = 1.0/areaScale;
        volumeScale = 1.0/volumeScale;
    }
#pragma omp parallel default(shared)
    {
        // Scale nodes
#pragma omp for
        for (int64_t i=0;i&lt;int64_t(model.getNNodes());i++)
        {
            RNode &amp;rNode = model.getNode(i);
            rNode.set(rNode.getX()*lengthScale,
                      rNode.getY()*lengthScale,
                      rNode.getZ()*lengthScale);
        }

        // Scale geometric values of element groups.
#pragma omp for
        for (int64_t i=0;i&lt;int64_t(model.getNPoints());i++)
        {
            RPoint &amp;rPoint = model.getPoint(i);
            rPoint.setVolume(rPoint.getVolume()*volumeScale);
        }
#pragma omp for
        for (int64_t i=0;i&lt;int64_t(model.getNLines());i++)
        {
            RLine &amp;rLine = model.getLine(i);
            rLine.setCrossArea(rLine.getCrossArea()*areaScale);
        }
#pragma omp for
        for (int64_t i=0;i&lt;int64_t(model.getNSurfaces());i++)
        {
            RSurface &amp;rSurface = model.getSurface(i);
            rSurface.setThickness(rSurface.getThickness()*lengthScale);
        }

        // Scale conditions.
        QList&lt;RConditionComponent*&gt; conditionComponents;

#pragma omp critical
        {
            for (uint i=0;i&lt;model.getNElementGroups();i++)
            {
                RElementGroup *pElementGroup = model.getElementGroupPtr(i);

                // Boundary conditions
                for (uint i=0;i&lt;pElementGroup-&gt;getNBoundaryConditions();i++)
                {
                    RCondition &amp;rCondition = pElementGroup-&gt;getBoundaryCondition(i);
                    for (uint j=0;j&lt;rCondition.size();j++)
                    {
                        conditionComponents.append(&amp;rCondition.getComponent(j));
                    }
                }
                // Initial conditions
                for (uint i=0;i&lt;pElementGroup-&gt;getNInitialConditions();i++)
                {
                    RCondition &amp;rCondition = pElementGroup-&gt;getInitialCondition(i);
                    for (uint j=0;j&lt;rCondition.size();j++)
                    {
                        conditionComponents.append(&amp;rCondition.getComponent(j));
                    }
                }
                // Environment conditions
                for (uint i=0;i&lt;pElementGroup-&gt;getNEnvironmentConditions();i++)
                {
                    RCondition &amp;rCondition = pElementGroup-&gt;getEnvironmentCondition(i);
                    for (uint j=0;j&lt;rCondition.size();j++)
                    {
                        conditionComponents.append(&amp;rCondition.getComponent(j));
                    }
                }
            }
        }

#pragma omp for
        for (int i=0;i&lt;conditionComponents.size();i++)
        {
            RConditionComponent *pConditionComponent = conditionComponents.at(i);

            double keyScale = this-&gt;findScaleFactor(pConditionComponent-&gt;getKeyType());
            double valueScale = this-&gt;findScaleFactor(pConditionComponent-&gt;getType());

            if (invert)
            {
                keyScale = 1.0 / keyScale;
                valueScale = 1.0 / valueScale;
            }

            RValueTable valueTable;

            for (uint j=0;j&lt;pConditionComponent-&gt;size();j++)
            {
                valueTable.add(pConditionComponent-&gt;getKey(j)*keyScale,
                               pConditionComponent-&gt;getValue(j)*valueScale);
            }

            pConditionComponent-&gt;RValueTable::clear();

            for (uint j=0;j&lt;valueTable.size();j++)
            {
                pConditionComponent-&gt;add(valueTable.getKey(j),
                                         valueTable.getValue(j));
            }
        }

        // Scale materials.
#pragma omp for
        for (int64_t i=0;i&lt;int64_t(model.getNElementGroups());i++)
        {
            RMaterial &amp;rMaterial = model.getElementGroupPtr(i)-&gt;getMaterial();

            for (uint j=0;j&lt;rMaterial.size();j++)
            {
                RMaterialProperty &amp;rProperty = rMaterial.get(j);

                double keyScale = this-&gt;findScaleFactor(rProperty.getKeyType());
                double valueScale = this-&gt;findScaleFactor(rProperty.getType());

                if (invert)
                {
                    keyScale = 1.0 / keyScale;
                    valueScale = 1.0 / valueScale;
                }

                RValueTable valueTable;

                for (uint k=0;k&lt;rProperty.size();k++)
                {
                    valueTable.add(rProperty.getKey(k)*keyScale,
                                   rProperty.getValue(k)*valueScale);
                }

                rProperty.clear();

                for (uint k=0;k&lt;valueTable.size();k++)
                {
                    rProperty.add(valueTable.getKey(k),
                                  valueTable.getValue(k));
                }
            }
        }

        // Scale variables.
#pragma omp for
        for (int64_t i=0;i&lt;int64_t(model.getNVariables());i++)
        {
            RVariable &amp;rVariable = model.getVariable(i);

            double valueScale = this-&gt;findScaleFactor(rVariable.getType());

            if (invert)
            {
                valueScale = 1.0 / valueScale;
            }

            for (uint j=0;j&lt;rVariable.getNVectors();j++)
            {
                for (uint k=0;k&lt;rVariable.getNValues();k++)
                {
                    rVariable.setValue(j,k,rVariable.getValue(j,k)*valueScale);
                }
            }

            rVariable.getVariableData().setMinMaxDisplayValue(rVariable.getVariableData().getMinDisplayValue()*valueScale,
                                                              rVariable.getVariableData().getMaxDisplayValue()*valueScale);
        }
    }

    // Scale problem settings.
    RTimeSolver &amp;rTimeSolver = model.getTimeSolver();
    std::vector&lt;double&gt; &amp;rTimes = rTimeSolver.getTimes();
    double valueScale = this-&gt;second;

    if (invert)
    {
        valueScale = 1.0 / valueScale;
    }

    for (uint i=0;i&lt;rTimes.size();i++)
    {
        rTimes[i] *= valueScale;
    }
    rTimeSolver.setInputStartTime(rTimeSolver.getInputStartTime()*valueScale);
    rTimeSolver.setInputTimeStepSize(rTimeSolver.getInputTimeStepSize()*valueScale);
}
</t>
<t tx="leo.20201108101542.70">void RSolverFluidHeat::_init(const RSolverFluidHeat *pSolver)
{
    if (pSolver)
    {
        this-&gt;elementCapacity = pSolver-&gt;elementCapacity;
        this-&gt;elementConduction = pSolver-&gt;elementConduction;
        this-&gt;elementDensity = pSolver-&gt;elementDensity;
        this-&gt;nodeTemperature = pSolver-&gt;nodeTemperature;
        this-&gt;nodeHeat = pSolver-&gt;nodeHeat;
        this-&gt;elementHeat = pSolver-&gt;elementHeat;
        this-&gt;elementRadiativeHeat = pSolver-&gt;elementRadiativeHeat;
        this-&gt;elementJouleHeat = pSolver-&gt;elementJouleHeat;
        this-&gt;elementHeatFlux = pSolver-&gt;elementHeatFlux;
        this-&gt;elementVelocity = pSolver-&gt;elementVelocity;
        this-&gt;nodeVelocity = pSolver-&gt;nodeVelocity;
        this-&gt;streamVelocity = pSolver-&gt;streamVelocity;
    }
}

RSolverFluidHeat::RSolverFluidHeat(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
{
    this-&gt;problemType = R_PROBLEM_FLUID_HEAT;
    this-&gt;_init();
}

RSolverFluidHeat::RSolverFluidHeat(const RSolverFluidHeat &amp;solver)
    : RSolverGeneric(solver)
{
    this-&gt;_init(&amp;solver);
}

RSolverFluidHeat::~RSolverFluidHeat()
{
    this-&gt;clearShapeDerivatives();
}

RSolverFluidHeat &amp;RSolverFluidHeat::operator =(const RSolverFluidHeat &amp;solver)
{
    RSolverGeneric::operator =(solver);
    this-&gt;_init(&amp;solver);
    return (*this);
}

</t>
<t tx="leo.20201108101542.71">bool RSolverFluidHeat::hasConverged(void) const
{
    return true;
}

double RSolverFluidHeat::findTemperatureScale(void) const
{
    return 1.0;
}

</t>
<t tx="leo.20201108101542.72">void RSolverFluidHeat::generateNodeHeatVector(void)
{
    RBVector heatSetValues;
    this-&gt;generateVariableVector(R_VARIABLE_HEAT,this-&gt;elementHeat,heatSetValues,true,this-&gt;firstRun,this-&gt;firstRun);

    this-&gt;nodeHeat.fill(0.0); // Heat on node is meant as an input - needs to be cleared
    this-&gt;pModel-&gt;convertElementToNodeVector(this-&gt;elementHeat,heatSetValues,this-&gt;nodeHeat,true);

    RRVector qv(this-&gt;pModel-&gt;getNElements(),0.0);
    RUVector qc(this-&gt;pModel-&gt;getNElements(),0);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        double q = this-&gt;elementJouleHeat[i] + this-&gt;elementRadiativeHeat[i];

        if (q == 0.0)
        {
            continue;
        }

        const RElement &amp;rElement(this-&gt;pModel-&gt;getElement(i));
        for (uint j=0;j&lt;rElement.size();j++)
        {
            qv[rElement.getNodeId(j)] += q;
            qc[rElement.getNodeId(j)]++;
        }
    }

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        if (qc[i] == 0)
        {
            continue;
        }
        this-&gt;nodeHeat[i] += qv[i] / double(qc[i]);
    }
}

</t>
<t tx="leo.20201108101542.73">void RSolverFluidHeat::updateScales(void)
{
    this-&gt;scales.setMetre(this-&gt;findMeshScale());
    this-&gt;scales.setKelvin(this-&gt;findTemperatureScale());
}

</t>
<t tx="leo.20201108101542.74">void RSolverFluidHeat::recover(void)
{
    this-&gt;recoveryStopWatch.reset();
    this-&gt;recoveryStopWatch.resume();
    this-&gt;recoverVariable(R_VARIABLE_TEMPERATURE,
                          R_VARIABLE_APPLY_NODE,
                          this-&gt;pModel-&gt;getNNodes(),
                          0,
                          this-&gt;nodeTemperature,
                          RVariable::getInitValue(R_VARIABLE_TEMPERATURE));
    this-&gt;recoverVariable(R_VARIABLE_HEAT,
                          R_VARIABLE_APPLY_ELEMENT,
                          this-&gt;pModel-&gt;getNElements(),
                          0,
                          this-&gt;elementHeat,
                          0.0);
    this-&gt;recoverVariable(R_VARIABLE_HEAT_RADIATION,
                          R_VARIABLE_APPLY_ELEMENT,
                          this-&gt;pModel-&gt;getNElements(),
                          0,
                          this-&gt;elementRadiativeHeat,
                          0.0);
    this-&gt;recoverVariable(R_VARIABLE_JOULE_HEAT,
                          R_VARIABLE_APPLY_ELEMENT,
                          this-&gt;pModel-&gt;getNElements(),
                          0,
                          this-&gt;elementJouleHeat,
                          0.0);

    this-&gt;recoverVariable(R_VARIABLE_VELOCITY,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),0,this-&gt;nodeVelocity.x,0.0);
    this-&gt;recoverVariable(R_VARIABLE_VELOCITY,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),1,this-&gt;nodeVelocity.y,0.0);
    this-&gt;recoverVariable(R_VARIABLE_VELOCITY,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),2,this-&gt;nodeVelocity.z,0.0);
    this-&gt;recoveryStopWatch.pause();
}

</t>
<t tx="leo.20201108101542.75">void RSolverFluidHeat::prepare(void)
{
    RLogger::info("Building matrix system\n");
    RLogger::indent();

    this-&gt;buildStopWatch.reset();
    this-&gt;assemblyStopWatch.reset();

    RBVector temperatureSetValues;

    this-&gt;generateNodeBook(R_PROBLEM_FLUID_HEAT);

    this-&gt;generateVariableVector(R_VARIABLE_TEMPERATURE,this-&gt;elementTemperature,temperatureSetValues,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_THERMAL_CONDUCTIVITY,this-&gt;elementConduction);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_HEAT_CAPACITY,this-&gt;elementCapacity);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_DENSITY,this-&gt;elementDensity);

    this-&gt;generateNodeHeatVector();

    this-&gt;pModel-&gt;convertElementToNodeVector(this-&gt;elementTemperature,temperatureSetValues,this-&gt;nodeTemperature,true);

    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeVelocity.x,this-&gt;elementVelocity.x);
    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeVelocity.y,this-&gt;elementVelocity.y);
    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeVelocity.z,this-&gt;elementVelocity.z);

    this-&gt;computeShapeDerivatives();
    this-&gt;streamVelocity = RSolverFluid::computeStreamVelocity(*this-&gt;pModel,this-&gt;nodeVelocity,false);

    this-&gt;b.resize(this-&gt;nodeBook.getNEnabled());
    this-&gt;x.resize(this-&gt;nodeBook.getNEnabled());

    this-&gt;A.clear();
    this-&gt;A.setNRows(this-&gt;nodeBook.getNEnabled());
    this-&gt;b.fill(0.0);
    this-&gt;x.fill(0.0);

    bool abort = false;

    RMatrixManager&lt;FluidHeatMatrixContainer&gt; matrixManager;

    // Compute element matrices
    #pragma omp parallel for default(shared) private(matrixManager)
    for (int64_t i=0;i&lt;int64_t(this-&gt;pModel-&gt;getNElements());i++)
    {
        uint elementID = i;

        const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);

        #pragma omp flush (abort)
        if (abort)
        {
            continue;
        }
        try
        {
            uint nen = element.size();

            RRMatrix Ae(nen,nen,0.0);
            RRVector be(nen,0.0);

            RStopWatch localStopWatch;
            localStopWatch.reset();

            if (R_ELEMENT_TYPE_IS_VOLUME(element.getType()))
            {
                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }
                localStopWatch.resume();
                this-&gt;computeElement(elementID,Ae,be,matrixManager);
                localStopWatch.pause();
            }
            #pragma omp critical
            {
                this-&gt;buildStopWatch.addElapsedTime(localStopWatch.getMiliSeconds());

                this-&gt;assemblyStopWatch.resume();
                this-&gt;assemblyMatrix(elementID,Ae,be);
                this-&gt;assemblyStopWatch.pause();
            }
        }
        catch (const RError &amp;rError)
        {
            #pragma omp critical
            {
                RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                abort = true;
            }
            #pragma omp flush (abort)
        }
    }

    if (abort)
    {
        RLogger::unindent();
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101542.76">void RSolverFluidHeat::solve(void)
{
    RLogger::info("Solving matrix system\n");
    RLogger::indent();

    this-&gt;solverStopWatch.reset();
    this-&gt;solverStopWatch.resume();

    try
    {
        RLogger::indent();
        RMatrixSolver matrixSolver(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::GMRES));
        matrixSolver.solve(this-&gt;A,this-&gt;b,this-&gt;x,R_MATRIX_PRECONDITIONER_JACOBI,1);
        RLogger::unindent();
    }
    catch (RError error)
    {
        RLogger::unindent();
        throw error;
    }

    this-&gt;solverStopWatch.pause();

    this-&gt;nodeTemperature.resize(this-&gt;pModel-&gt;getNNodes(),0.0);

    this-&gt;updateStopWatch.reset();
    this-&gt;updateStopWatch.resume();

    double tOld = RRVector::norm(this-&gt;nodeTemperature);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        uint position = 0;
        if (this-&gt;nodeBook.getValue(i,position))
        {
            this-&gt;nodeTemperature[i] = std::max(this-&gt;x[position],0.0);
        }
    }

    double t = RRVector::norm(this-&gt;nodeTemperature);

    this-&gt;cvgT = (t - tOld) / this-&gt;scales.findScaleFactor(R_VARIABLE_TEMPERATURE);

    this-&gt;updateStopWatch.pause();

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101542.77">void RSolverFluidHeat::process(void)
{
    double Qx;
    double Qy;
    double Qz;

    // Initialize heat flux vector vector
    this-&gt;elementHeatFlux.resize(this-&gt;pModel-&gt;getNElements(),RR3Vector(0.0,0.0,0.0));

    // Process volume elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        uint elementID = i;
        const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
        if (!R_ELEMENT_TYPE_IS_VOLUME(element.getType()) || !this-&gt;computableElements[elementID])
        {
            continue;
        }

        uint nInp = RElement::getNIntegrationPoints(element.getType());
        RRMatrix B(element.size(),3);

        Qx = Qy = Qz = 0.0;

        B.fill(0.0);

        // Conduction
        for (uint k=0;k&lt;nInp;k++)
        {
            const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
            const RRMatrix &amp;dN = shapeFunc.getDN();
            RRMatrix J, Rt;
            double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

            for (uint m=0;m&lt;dN.getNRows();m++)
            {
                B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]) * detJ / double(nInp);
                B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]) * detJ / double(nInp);
                B[m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]) * detJ / double(nInp);
            }
        }

        for (uint m=0;m&lt;element.size();m++)
        {
            uint nodeID = element.getNodeId(m);

            Qx -= B[m][0] * this-&gt;elementConduction[elementID] * this-&gt;nodeTemperature[nodeID];
            Qy -= B[m][1] * this-&gt;elementConduction[elementID] * this-&gt;nodeTemperature[nodeID];
            Qz -= B[m][2] * this-&gt;elementConduction[elementID] * this-&gt;nodeTemperature[nodeID];
        }

        this-&gt;elementHeatFlux[elementID][0] = Qx;
        this-&gt;elementHeatFlux[elementID][1] = Qy;
        this-&gt;elementHeatFlux[elementID][2] = Qz;
    }
}

</t>
<t tx="leo.20201108101542.78">void RSolverFluidHeat::store(void)
{
    RLogger::info("Storing results\n");
    RLogger::indent();

    // Temperature
    uint temperaturePos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_TEMPERATURE);
    if (temperaturePos == RConstants::eod)
    {
        temperaturePos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_TEMPERATURE);
        this-&gt;pModel-&gt;getVariable(temperaturePos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumValue(this-&gt;nodeTemperature),
                    RStatistics::findMaximumValue(this-&gt;nodeTemperature));
    }
    RVariable &amp;temperature =  this-&gt;pModel-&gt;getVariable(temperaturePos);

    temperature.setApplyType(R_VARIABLE_APPLY_NODE);
    temperature.resize(1,this-&gt;pModel-&gt;getNNodes());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        temperature.setValue(0,i,this-&gt;nodeTemperature[i]);
    }

    // Heat flux
    uint heatFluxPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_HEAT_FLUX);
    if (heatFluxPos == RConstants::eod)
    {
        heatFluxPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_HEAT_FLUX);
        this-&gt;pModel-&gt;getVariable(heatFluxPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumMagnitude(this-&gt;elementHeatFlux),
                    RStatistics::findMaximumMagnitude(this-&gt;elementHeatFlux));
    }
    RVariable &amp;heatFlux =  this-&gt;pModel-&gt;getVariable(heatFluxPos);

    heatFlux.setApplyType(R_VARIABLE_APPLY_ELEMENT);
    heatFlux.resize(3,this-&gt;pModel-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        heatFlux.setValue(0,i,this-&gt;elementHeatFlux[i][0]);
        heatFlux.setValue(1,i,this-&gt;elementHeatFlux[i][1]);
        heatFlux.setValue(2,i,this-&gt;elementHeatFlux[i][2]);
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101542.79">void RSolverFluidHeat::statistics(void)
{
    static uint counter = 0;
    static double oldResidual = 0.0;

    double scale = std::pow(this-&gt;scales.getSecond(),2) / this-&gt;scales.getKilogram();
    double residual = RRVector::norm(this-&gt;b)*scale;
    double convergence = residual - oldResidual;
    oldResidual = residual;

    std::vector&lt;RIterationInfoValue&gt; cvgValues;
    cvgValues.push_back(RIterationInfoValue("Solver residual",residual));
    cvgValues.push_back(RIterationInfoValue("Solver convergence",convergence));
    cvgValues.push_back(RIterationInfoValue("Temperature convergence",this-&gt;cvgT));

    RIterationInfo::writeToFile(this-&gt;convergenceFileName,counter,cvgValues);

    this-&gt;printStats(R_VARIABLE_TEMPERATURE);
    this-&gt;printStats(R_VARIABLE_HEAT_FLUX);
    this-&gt;processMonitoringPoints();

    RLogger::info("Convergence:   %-13g\n",residual);
    RLogger::info("Build time:    %9u [ms]\n",this-&gt;buildStopWatch.getMiliSeconds());
    RLogger::info("Assembly time: %9u [ms]\n",this-&gt;assemblyStopWatch.getMiliSeconds());
    RLogger::info("Solver time:   %9u [ms]\n",this-&gt;solverStopWatch.getMiliSeconds());
    RLogger::info("Update time:   %9u [ms]\n",this-&gt;updateStopWatch.getMiliSeconds());

    counter++;
}

</t>
<t tx="leo.20201108101542.8">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolver.cpp                                              *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   11-th December 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Range solver class definition                       *
 *********************************************************************/

#include "rsolver.h"
#include "rsolveracoustic.h"
#include "rsolverfluidparticle.h"
#include "rsolverelectrostatics.h"
#include "rsolvermagnetostatics.h"
#include "rsolverfluid.h"
#include "rsolverfluidheat.h"
#include "rsolverheat.h"
#include "rsolvermesh.h"
#include "rsolverradiativeheat.h"
#include "rsolverstress.h"
#include "rsolverwave.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101542.80">void RSolverFluidHeat::computeShapeDerivatives(void)
{
    this-&gt;shapeDerivations.resize(this-&gt;pModel-&gt;getNElements(),0);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        uint elementID = i;

        const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);
        if (R_ELEMENT_TYPE_IS_VOLUME(rElement.getType()))
        {
            if (!this-&gt;computableElements[elementID])
            {
                continue;
            }
            if (!this-&gt;shapeDerivations[elementID])
            {
                this-&gt;shapeDerivations[elementID] = new RElementShapeDerivation(rElement,this-&gt;pModel-&gt;getNodes(),R_PROBLEM_FLUID);
            }
        }
    }
}

</t>
<t tx="leo.20201108101542.81">void RSolverFluidHeat::clearShapeDerivatives(void)
{
    for (uint i=0;i&lt;this-&gt;shapeDerivations.size();i++)
    {
        delete this-&gt;shapeDerivations[i];
    }
}

</t>
<t tx="leo.20201108101542.82">void RSolverFluidHeat::computeElement(unsigned int elementID, RRMatrix &amp;Ae, RRVector &amp;be, RMatrixManager&lt;FluidHeatMatrixContainer&gt; &amp;matrixManager)
{
    if (RElement::hasConstantDerivative(this-&gt;pModel-&gt;getElement(elementID).getType()))
    {
        this-&gt;computeElementConstantDerivative(elementID,Ae,be,matrixManager);
    }
    else
    {
        this-&gt;computeElementGeneral(elementID,Ae,be,matrixManager);
    }
}

</t>
<t tx="leo.20201108101542.83">void RSolverFluidHeat::computeElementGeneral(unsigned int elementID, RRMatrix &amp;Ae, RRVector &amp;be, RMatrixManager&lt;FluidHeatMatrixContainer&gt; &amp;matrixManager)
{
    bool unsteady = (this-&gt;pModel-&gt;getTimeSolver().getEnabled());

    const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
    uint nen = element.size();
    uint nInp = RElement::getNIntegrationPoints(element.getType());

    double ro = this-&gt;elementDensity[elementID];
    double c = this-&gt;elementCapacity[elementID];
    double k = this-&gt;elementConduction[elementID];

    double ca = ro*c;

    Ae.fill(0.0);
    be.fill(0.0);

    FluidHeatMatrixContainer &amp;matrixCotainer = matrixManager.getMatricies(element.getType());
    matrixCotainer.clear();

    // Element level matricies
    RRMatrix &amp;me = matrixCotainer.me;
    RRMatrix &amp;ce = matrixCotainer.ce;
    RRMatrix &amp;ke = matrixCotainer.ke;
    RRMatrix &amp;cte = matrixCotainer.cte;
    RRMatrix &amp;kte = matrixCotainer.kte;
    RRMatrix &amp;yte = matrixCotainer.yte;

    // Element level vectors
    RRVector &amp;fv = matrixCotainer.fv;

    double alpha = this-&gt;pModel-&gt;getTimeSolver().getTimeMarchApproximationCoefficient();
    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();

    // Element level input -------------------------------------------
    RR3Vector ve(this-&gt;elementVelocity.x[elementID],
                 this-&gt;elementVelocity.y[elementID],
                 this-&gt;elementVelocity.z[elementID]);
    // element level velocity magnitude
    double mvh = ve.length();
    // element level velocity direction
    RR3Vector s(ve);
    s.normalize();

    for (uint intPoint=0;intPoint&lt;nInp;intPoint++)
    {
        const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),intPoint);
        const RRVector &amp;N = shapeFunc.getN();
        const RRMatrix &amp;B = this-&gt;shapeDerivations[elementID]-&gt;getDerivative(intPoint);
        double detJ = this-&gt;shapeDerivations[elementID]-&gt;getJacobian(intPoint);

        double integValue = detJ * shapeFunc.getW();

        // velocity divergence
        RRVector vdiv(nen,0.0);
        // element length scale
        double h = 0.0;

        for (uint m=0;m&lt;nen;m++)
        {
            vdiv[m] += ve[0] * B[m][0] + ve[1] * B[m][1] + ve[2] * B[m][2];
            h += std::fabs(s[0]*B[m][0] + s[1]*B[m][1] + s[2]*B[m][2]);
        }
        if (h != 0.0)
        {
            h = 2.0/h;
        }
        // Reynolds numbers
        double Re(k == 0.0 ? 0.0 : mvh * h / (2.0 * k));

        // SUPG stabilization parameter
        double Tsupg = 0.0;
        if (mvh &gt; 0.0)
        {
            Tsupg = h / (2.0 * mvh);
            if (Re &gt; 0.0 &amp;&amp; Re &lt;= 3.0)
            {
                Tsupg *= Re / 3.0;
            }
        }

        for (uint m=0;m&lt;nen;m++)
        {
            for (uint n=0;n&lt;nen;n++)
            {
                // m matrix
                if (unsteady)
                {
                    me[m][n] = ca * N[m] * N[n];
                }
                // c matrix
                ce[m][n] = ca * N[m] * vdiv[n];
                // k matrix
                ke[m][n] = -k * (B[m][0] * B[n][0] + B[m][1] * B[n][1] + B[m][2] * B[n][2]);
                // k~ matrix
                kte[m][n] = Tsupg * ca * vdiv[m] * vdiv[n];
                // y~ matrix
                yte[m][n] = Tsupg * vdiv[m];
            }
            // f vector
            fv[m] = this-&gt;nodeHeat[element.getNodeId(m)] * N[m];
        }

        // Assembly element level matrixes
        for (uint m=0;m&lt;nen;m++)
        {
            for (uint n=0;n&lt;nen;n++)
            {
                if (unsteady)
                {
                    Ae[m][n] += me[m][n] + cte[m][n]
                              + alpha * dt * (  ce[m][n]  + ke[m][n]
                                             + kte[m][n] + yte[m][n] );
                }
                else
                {
                    Ae[m][n] += ce[m][n] + ke[m][n]
                              + kte[m][n] + yte[m][n];
                }
            }
            if (unsteady)
            {
                be[m] += dt * fv[m];
                for (uint n=0;n&lt;nen;n++)
                {
                    be[m] += (me[m][n] + cte[m][n] - (1.0 - alpha) * dt * (ce[m][n] + ke[m][n] + kte[m][n] + yte[m][n]))
                           * this-&gt;nodeTemperature[element.getNodeId(n)];
                }
            }
            else
            {
                be[m] = fv[m];
            }
        }
        for (uint m=0;m&lt;nen;m++)
        {
            for (uint n=0;n&lt;nen;n++)
            {
                Ae[m][n] *= integValue;
            }
            be[m] *= integValue;
        }
    }
}

</t>
<t tx="leo.20201108101542.84">void RSolverFluidHeat::computeElementConstantDerivative(unsigned int elementID, RRMatrix &amp;Ae, RRVector &amp;be, RMatrixManager&lt;FluidHeatMatrixContainer&gt; &amp;matrixManager)
{
    bool unsteady = (this-&gt;pModel-&gt;getTimeSolver().getEnabled());

    const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
    uint nen = element.size();

    double ro = this-&gt;elementDensity[elementID];
    double c = this-&gt;elementCapacity[elementID];
    double k = this-&gt;elementConduction[elementID];

    double ca = ro*c;

    Ae.fill(0.0);
    be.fill(0.0);

    FluidHeatMatrixContainer &amp;matrixCotainer = matrixManager.getMatricies(element.getType());
    matrixCotainer.clear();

    // Element level matricies
    RRMatrix &amp;me = matrixCotainer.me;
    RRMatrix &amp;ce = matrixCotainer.ce;
    RRMatrix &amp;ke = matrixCotainer.ke;
    RRMatrix &amp;cte = matrixCotainer.cte;
    RRMatrix &amp;kte = matrixCotainer.kte;
    RRMatrix &amp;yte = matrixCotainer.yte;

    // Element level vectors
    RRVector &amp;fv = matrixCotainer.fv;

    double alpha = this-&gt;pModel-&gt;getTimeSolver().getTimeMarchApproximationCoefficient();
    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();

    // Element level input -------------------------------------------
    RR3Vector ve(this-&gt;elementVelocity.x[elementID],
                 this-&gt;elementVelocity.y[elementID],
                 this-&gt;elementVelocity.z[elementID]);
    // element level velocity magnitude
    double mvh = ve.length();
    // element level velocity direction
    RR3Vector s(ve);
    s.normalize();

    const RRVector &amp;iN = RElement::getMassVector(element.getType());
    const RRMatrix &amp;iNiN = RElement::getMassMatrix(element.getType());
    double wt = RElement::getTotalWeightFactor(element.getType());
    const RRMatrix &amp;B = this-&gt;shapeDerivations[elementID]-&gt;getDerivative(0);

    // velocity divergence
    RRVector vdiv(nen,0.0);
    // element length scale
    double h = 0.0;

    for (uint m=0;m&lt;nen;m++)
    {
        vdiv[m] += ve[0] * B[m][0] + ve[1] * B[m][1] + ve[2] * B[m][2];
        h += std::fabs(s[0]*B[m][0] + s[1]*B[m][1] + s[2]*B[m][2]);
    }
    if (h != 0.0)
    {
        h = 2.0/h;
    }
    // Reynolds numbers
    double Re(k == 0.0 ? 0.0 : mvh * h / (2.0 * k));

    // SUPG stabilization parameter
    double Tsupg = 0.0;
    if (mvh &gt; 0.0)
    {
        Tsupg = h / (2.0 * mvh);
        if (Re &gt; 0.0 &amp;&amp; Re &lt;= 3.0)
        {
            Tsupg *= Re / 3.0;
        }
    }

    for (uint m=0;m&lt;nen;m++)
    {
        for (uint n=0;n&lt;nen;n++)
        {
            // m matrix
            if (unsteady)
            {
                me[m][n] = ca * iNiN[m][n];
            }
            // c matrix
            ce[m][n] = ca * iN[m] * vdiv[n];
            // k matrix
            ke[m][n] = -k * wt * (B[m][0] * B[n][0] + B[m][1] * B[n][1] + B[m][2] * B[n][2]);
            // k~ matrix
            kte[m][n] = Tsupg * ca * vdiv[m] * vdiv[n] * wt;
            // y~ matrix
            yte[m][n] = Tsupg * vdiv[m] * wt;
        }
        // f vector
        fv[m] = this-&gt;nodeHeat[element.getNodeId(m)] * iN[m];
    }

    // Assembly element level matrixes
    for (uint m=0;m&lt;nen;m++)
    {
        for (uint n=0;n&lt;nen;n++)
        {
            if (unsteady)
            {
                Ae[m][n] = me[m][n] + cte[m][n]
                         + alpha * dt * (  ce[m][n]  + ke[m][n]
                                         + kte[m][n] + yte[m][n] );
            }
            else
            {
                Ae[m][n] = ce[m][n] + ke[m][n]
                         + kte[m][n] + yte[m][n];
            }
        }
        if (unsteady)
        {
            be[m] = dt * fv[m];
            for (uint n=0;n&lt;nen;n++)
            {
                be[m] += (me[m][n] + cte[m][n] - (1.0 - alpha) * dt * (ce[m][n] + ke[m][n] + kte[m][n] + yte[m][n]))
                       * this-&gt;nodeTemperature[element.getNodeId(n)];
            }
        }
        else
        {
            be[m] = fv[m];
        }
    }

    double detJ = this-&gt;shapeDerivations[elementID]-&gt;getJacobian(0);
    Ae *= detJ;
    be *= detJ;
}

</t>
<t tx="leo.20201108101542.85">void RSolverFluidHeat::assemblyMatrix(unsigned int elementID, const RRMatrix &amp;Ae, const RRVector &amp;be)
{
    const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);
    RRVector fe(be);

    // Apply explicit boundary conditions.
    for (uint m=0;m&lt;rElement.size();m++)
    {
        uint mp = 0;
        if (!this-&gt;nodeBook.getValue(rElement.getNodeId(m),mp))
        {
            for (uint n=0;n&lt;rElement.size();n++)
            {
                fe[n] -= Ae[n][m] * this-&gt;nodeTemperature[rElement.getNodeId(m)];
            }
        }
    }

    // Assembly final matrix system
    for (uint m=0;m&lt;rElement.size();m++)
    {
        uint mp = 0;

        if (this-&gt;nodeBook.getValue(rElement.getNodeId(m),mp))
        {
            this-&gt;b[mp] += fe[m];

            for (uint n=0;n&lt;rElement.size();n++)
            {
                uint np = 0;

                if (this-&gt;nodeBook.getValue(rElement.getNodeId(n),np))
                {
                    this-&gt;A.addValue(mp,np,Ae[m][n]);
                }
            }
        }
    }
}
</t>
<t tx="leo.20201108101542.86">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolverfluidparticle.cpp                                 *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   28-th January 2016                                       *
 *                                                                   *
 *  DESCRIPTION: Fluid particle dispersion solver class definition   *
 *********************************************************************/

#include &lt;omp.h&gt;

#include "rsolverfluid.h"
#include "rsolverfluidparticle.h"
#include "rmatrixsolver.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101542.87">class FluidParticleMatrixContainer
{
    public:

        bool initialized;

        // Element level matricies
        RRMatrix me;    // m
        RRMatrix ce;    // c
        RRMatrix ke;    // k
        RRMatrix cte;   // c~
        RRMatrix kte;   // k~
        RRMatrix yte;   // y~

        // Element level vectors
        RRVector fv;    // f

    public:

        FluidParticleMatrixContainer() : initialized(false)
        {

        }

        @others
};

</t>
<t tx="leo.20201108101542.88">void resize(uint nen)
{
    this-&gt;me.resize(nen,nen,0.0);
    this-&gt;ce.resize(nen,nen,0.0);
    this-&gt;ke.resize(nen,nen,0.0);
    this-&gt;cte.resize(nen,nen,0.0);
    this-&gt;kte.resize(nen,nen,0.0);
    this-&gt;yte.resize(nen,nen,0.0);

    this-&gt;fv.resize(nen,0.0);

    this-&gt;initialized = true;
}

</t>
<t tx="leo.20201108101542.89">void clear(void)
{
    this-&gt;me.fill(0.0);
    this-&gt;ce.fill(0.0);
    this-&gt;ke.fill(0.0);
    this-&gt;cte.fill(0.0);
    this-&gt;kte.fill(0.0);
    this-&gt;yte.fill(0.0);

    this-&gt;fv.fill(0.0);
}
</t>
<t tx="leo.20201108101542.9">void RSolver::_init(const RSolver *pSolver)
{
    if (pSolver)
    {
        this-&gt;pModel = pSolver-&gt;pModel;
        this-&gt;sharedData = pSolver-&gt;sharedData;
        this-&gt;solvers = pSolver-&gt;solvers;
        // TODO - implement copy by value for solvers map
//        QMap&lt;RProblemType,RGenericSolver*&gt;::iterator iter = pSolver-&gt;solvers.begin();
//        for (iter = pSolver-&gt;solvers.begin();
//             iter != pSolver-&gt;solvers.end();
//             ++iter)
//        {
//            iter.key();
//            iter.value();
//        }
        this-&gt;solversExecutionCount = pSolver-&gt;solversExecutionCount;
    }
    else
    {
        this-&gt;sharedData.addData("element-temperature",RRVector(this-&gt;pModel-&gt;getNElements(),RVariable::getInitValue(R_VARIABLE_TEMPERATURE)));
        RProblemTypeMask problemTypeMask = this-&gt;pModel-&gt;getProblemTaskTree().getProblemTypeMask();

        std::vector&lt;RProblemType&gt; problemTypes = RProblem::getTypes(problemTypeMask);
        for (uint i=0;i&lt;problemTypes.size();i++)
        {
            QString problemConvergenceFileName(RFileManager::getFileNameWithSuffix(this-&gt;convergenceFileName,RProblem::getId(problemTypes[i])));
            if (problemTypes[i] == R_PROBLEM_ACOUSTICS)
            {
                // NOT WORKING
                this-&gt;solvers[problemTypes[i]] = new RSolverAcoustic(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData);
            }
            else if (problemTypes[i] == R_PROBLEM_FLUID_PARTICLE)
            {
                this-&gt;solvers[problemTypes[i]] = new RSolverFluidParticle(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData);
            }
            else if (problemTypes[i] == R_PROBLEM_ELECTROSTATICS)
            {
                this-&gt;solvers[problemTypes[i]] = new RSolverElectrostatics(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData);
            }
            else if (problemTypes[i] == R_PROBLEM_MAGNETOSTATICS)
            {
                this-&gt;solvers[problemTypes[i]] = new RSolverMagnetostatics(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData);
            }
            else if (problemTypes[i] == R_PROBLEM_FLUID)
            {
                this-&gt;solvers[problemTypes[i]] = new RSolverFluid(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData);
            }
            else if (problemTypes[i] == R_PROBLEM_FLUID_HEAT)
            {
                this-&gt;solvers[problemTypes[i]] = new RSolverFluidHeat(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData);
            }
            else if (problemTypes[i] == R_PROBLEM_RADIATIVE_HEAT)
            {
                this-&gt;solvers[problemTypes[i]] = new RSolverRadiativeHeat(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData);
            }
            else if (problemTypes[i] == R_PROBLEM_HEAT)
            {
                this-&gt;solvers[problemTypes[i]] = new RSolverHeat(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData);
            }
            else if (problemTypes[i] == R_PROBLEM_STRESS)
            {
                this-&gt;solvers[problemTypes[i]] = new RSolverStress(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData,false);
            }
            else if (problemTypes[i] == R_PROBLEM_STRESS_MODAL)
            {
                this-&gt;solvers[problemTypes[i]] = new RSolverStress(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData,true);
            }
            else if (problemTypes[i] == R_PROBLEM_POTENTIAL)
            {
                // NOT IMPLEMENTED
            }
            else if (problemTypes[i] == R_PROBLEM_WAVE)
            {
                // NOT WORKING
                this-&gt;solvers[problemTypes[i]] = new RSolverWave(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData);
            }
            else if (problemTypes[i] == R_PROBLEM_MESH)
            {
                this-&gt;solvers[problemTypes[i]] = new RSolverMesh(this-&gt;pModel,this-&gt;modelFileName,problemConvergenceFileName,this-&gt;sharedData);
            }
        }

        // if not restarting clear results data.
        if (!this-&gt;pModel-&gt;getProblemSetup().getRestart())
        {
            this-&gt;pModel-&gt;removeAllVariables();
        }
    }
}

RSolver::RSolver(RModel &amp;model, const QString &amp;modelFileName, const QString &amp;convergenceFileName)
    : pModel(&amp;model)
    , modelFileName(modelFileName)
    , convergenceFileName(convergenceFileName)
{
    this-&gt;_init();
}

RSolver::RSolver(const RSolver &amp;solver)
{
    this-&gt;_init(&amp;solver);
}

RSolver::~RSolver()
{
    foreach (RSolverGeneric *solver, this-&gt;solvers)
    {
        delete solver;
    }
}

RSolver &amp;RSolver::operator =(const RSolver &amp;solver)
{
    this-&gt;_init(&amp;solver);
    return (*this);
}

</t>
<t tx="leo.20201108101542.90">void RSolverFluidParticle::_init(const RSolverFluidParticle *pSolver)
{
    if (pSolver)
    {
        this-&gt;elementConcentration = pSolver-&gt;elementConcentration;
        this-&gt;elementRate = pSolver-&gt;elementRate;
        this-&gt;elementVelocity = pSolver-&gt;elementVelocity;
        this-&gt;streamVelocity = pSolver-&gt;streamVelocity;
        this-&gt;nodeConcentration = pSolver-&gt;nodeConcentration;
        this-&gt;nodeRate = pSolver-&gt;nodeRate;
        this-&gt;nodeVelocity = pSolver-&gt;nodeVelocity;
        this-&gt;elementDensity = pSolver-&gt;elementDensity;
        this-&gt;elementDiffusion = pSolver-&gt;elementDiffusion;
        this-&gt;cvgC = pSolver-&gt;cvgC;
    }
}

RSolverFluidParticle::RSolverFluidParticle(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
    , streamVelocity(1.0)
    , cvgC(0.0)
{
    this-&gt;problemType = R_PROBLEM_FLUID_PARTICLE;
    this-&gt;_init();
}

RSolverFluidParticle::RSolverFluidParticle(const RSolverFluidParticle &amp;solver)
    : RSolverGeneric(solver)
{
    this-&gt;_init(&amp;solver);
}

RSolverFluidParticle::~RSolverFluidParticle()
{
    this-&gt;clearShapeDerivatives();
}

RSolverFluidParticle &amp;RSolverFluidParticle::operator =(const RSolverFluidParticle &amp;solver)
{
    RSolverGeneric::operator =(solver);
    this-&gt;_init(&amp;solver);
    return (*this);
}

</t>
<t tx="leo.20201108101543.1">bool RSolverFluidParticle::hasConverged(void) const
{
    return true;
}

</t>
<t tx="leo.20201108101543.10">void RSolverFluidParticle::computeShapeDerivatives()
{
    this-&gt;shapeDerivations.resize(this-&gt;pModel-&gt;getNElements(),0);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        uint elementID = i;

        const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);
        if (R_ELEMENT_TYPE_IS_VOLUME(rElement.getType()))
        {
            if (!this-&gt;computableElements[elementID])
            {
                continue;
            }
            if (!this-&gt;shapeDerivations[elementID])
            {
                this-&gt;shapeDerivations[elementID] = new RElementShapeDerivation(rElement,this-&gt;pModel-&gt;getNodes(),R_PROBLEM_FLUID);
            }
        }
    }
}

</t>
<t tx="leo.20201108101543.100">void RSolverStress::solveEigenValue(void)
{
    RLogger::info("Solving eigen-value problem.\n");

    REigenValueSolverConf conf;

    if (this-&gt;pModel-&gt;getProblemSetup().getModalSetup().getMethod() == R_MODAL_MULTIPLE_MODES)
    {
        conf.setMethod(REigenValueSolverConf::Arnoldi);
    }
    else
    {
        conf.setMethod(REigenValueSolverConf::Rayleigh);
    }
    conf.setNEigenValues(this-&gt;pModel-&gt;getProblemSetup().getModalSetup().getNModesToExtract());
    conf.setNIterations(this-&gt;pModel-&gt;getProblemSetup().getModalSetup().getNIterations());
    conf.setSolverCvgValue(this-&gt;pModel-&gt;getProblemSetup().getModalSetup().getConvergenceValue());
    conf.setOutputFrequency(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::CG).getOutputFrequency());
    conf.setOutputFileName(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::CG).getOutputFileName());

    REigenValueSolver solver(conf,this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));

    try
    {
        RLogger::indent();
        solver.solve(this-&gt;M,this-&gt;A,this-&gt;d,this-&gt;ev);
        RLogger::unindent();
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to solve eigen-value problem. %s", error.getMessage().toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101543.101">void RSolverStress::setDisplacement(const RRVector &amp;v)
{
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        uint position;
        RR3Vector du(0.0,0.0,0.0);

        if (this-&gt;nodeBook.getValue(3*i+0,position))
        {
            du[0] = v[position];
        }
        if (this-&gt;nodeBook.getValue(3*i+1,position))
        {
            du[1] = v[position];
        }
        if (this-&gt;nodeBook.getValue(3*i+2,position))
        {
            du[2] = v[position];
        }

        if (this-&gt;localRotations[i].isActive())
        {
            this-&gt;localRotations[i].rotateResultsVector(du);
        }

        if (this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
        {
            du[0] += this-&gt;nodeInitialDisplacement.x[i];
            du[1] += this-&gt;nodeInitialDisplacement.y[i];
            du[2] += this-&gt;nodeInitialDisplacement.z[i];
        }

        this-&gt;nodeDisplacement.x[i] = du[0];
        this-&gt;nodeDisplacement.y[i] = du[1];
        this-&gt;nodeDisplacement.z[i] = du[2];
    }
}

</t>
<t tx="leo.20201108101543.102">void RSolverStress::process(void)
{
    if (this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
    {
        uint modeNum = this-&gt;pModel-&gt;getProblemSetup().getModalSetup().getMode();
        this-&gt;pModel-&gt;getProblemSetup().getModalSetup().setFrequency(this-&gt;d[modeNum]);

        RLogger::info("Eigen-value = %g\n",this-&gt;d[modeNum]);

        RRVector v(this-&gt;ev.getNColumns(),0.0);
        for (uint j=0;j&lt;this-&gt;ev.getNColumns();j++)
        {
            v[j] = this-&gt;ev[modeNum][j];
        }
        this-&gt;setDisplacement(v);
    }

    // Initialize force vector
    this-&gt;nodeForce.x.resize(this-&gt;pModel-&gt;getNNodes());
    this-&gt;nodeForce.y.resize(this-&gt;pModel-&gt;getNNodes());
    this-&gt;nodeForce.z.resize(this-&gt;pModel-&gt;getNNodes());

    this-&gt;nodeForce.x.fill(0.0);
    this-&gt;nodeForce.y.fill(0.0);
    this-&gt;nodeForce.z.fill(0.0);

    // Initialize stress vectors
    this-&gt;elementNormalStress.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;elementShearStress.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;elementVonMisses.resize(this-&gt;pModel-&gt;getNElements(),0.0);

    // Process line elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        RLine &amp;line = this-&gt;pModel-&gt;getLine(i);
        double lineCrossArea = line.getCrossArea();

        if (lineCrossArea == 0.0)
        {
            continue;
        }

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(line.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = line.get(uint(j));

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_LINE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size()*3,element.size()*3,0.0);
                RRMatrix Ke(element.size()*3,element.size()*3,0.0);
                RRVector fe(element.size()*3,0.0);
                RRVector ae(element.size()*3,0.0);
                RRVector xe(element.size()*3,0.0);
                double QeN = 0.0;

                RRMatrix Be(3*element.size(),1);
                RRMatrix BeT(1,3*element.size());

                double E = this-&gt;elementElasticityModulus[elementID];
                double De = E * lineCrossArea;

                RRMatrix Rl;
                RRVector tl;
                element.findTransformationMatrix(this-&gt;pModel-&gt;getNodes(),Rl,tl);
                Rl.invert();

                RRVector lxe(element.size(),0.0);
                for (uint k=0;k&lt;element.size();k++)
                {
                    RR3Vector xg(this-&gt;nodeDisplacement.x[element.getNodeId(k)],
                                 this-&gt;nodeDisplacement.y[element.getNodeId(k)],
                                 this-&gt;nodeDisplacement.z[element.getNodeId(k)]);
                    RR3Vector xl;
                    RRMatrix::mlt(Rl,xg,xl);
                    lxe[k] = xl[0];
                }

                for (uint k=0;k&lt;element.size();k++)
                {
                    ae[3*k+0] = this-&gt;nodeAcceleration.x[element.getNodeId(k)];
                    ae[3*k+1] = this-&gt;nodeAcceleration.y[element.getNodeId(k)];
                    ae[3*k+2] = this-&gt;nodeAcceleration.z[element.getNodeId(k)];

                    xe[3*k+0] = this-&gt;nodeDisplacement.x[element.getNodeId(k)];
                    xe[3*k+1] = this-&gt;nodeDisplacement.y[element.getNodeId(k)];
                    xe[3*k+2] = this-&gt;nodeDisplacement.z[element.getNodeId(k)];
                }

                double dT = this-&gt;elementTemperature[elementID] - this-&gt;elementEnvironmentTemperature[elementID];

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt, RtT;
                    double detJ = element.findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);
                    RtT.transpose(Rt);

                    Be.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        Be[3*m+0][0] += Rt[0][0]*dN[m][0]*J[0][0];
                        Be[3*m+1][0] += Rt[1][0]*dN[m][0]*J[0][0];
                        Be[3*m+2][0] += Rt[2][0]*dN[m][0]*J[0][0];
                    }
                    BeT.transpose(Be);

                    Be *= De;
                    RRMatrix::mlt(Be,BeT,Ke);
                    Ke *= detJ * shapeFunc.getW();

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        if (lineCrossArea &gt; 0.0)
                        {
                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled() || this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
                            {
                                for (uint n=0;n&lt;element.size();n++)
                                {
                                    double value = N[m] * N[n]
                    }

                    double integValue = 1.0/double(nInp);

                    // Element level stress.
                    for (uint m=0;m&lt;element.size();m++)
                    {
                        QeN += dN[m][0]*J[0][0] * De * lxe[m] * integValue;
                        QeN -= dN[m][0]*J[0][0] * De * this-&gt;elementThermalExpansion[elementID] * dT * lineCrossArea * integValue;
                    }
                }

                RRVector fae, fxe;
                RRMatrix::mlt(Me,ae,fae);
                RRMatrix::mlt(Ke,xe,fxe);
                RRVector::add(fae,fxe,fe);

                #pragma omp critical
                {
                    for (uint m=0;m&lt;element.size();m++)
                    {
                        this-&gt;nodeForce.x[element.getNodeId(m)] += fe[3*m+0];
                        this-&gt;nodeForce.y[element.getNodeId(m)] += fe[3*m+1];
                        this-&gt;nodeForce.z[element.getNodeId(m)] += fe[3*m+2];
                    }

                    this-&gt;elementNormalStress[elementID] = QeN;
                    this-&gt;elementShearStress[elementID] = 0.0;
                    this-&gt;elementVonMisses[elementID] = QeN;
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
                #pragma omp flush (abort)
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to process results.");
        }
    }

    // Process surface elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        RSurface &amp;surface = this-&gt;pModel-&gt;getSurface(i);
        double surfaceThickness = surface.getThickness();

        if (surfaceThickness == 0.0)
        {
            continue;
        }

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(surface.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = surface.get(uint(j));

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_SURFACE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size()*3,element.size()*3,0.0);
                RRMatrix Ke(element.size()*2,element.size()*2,0.0);
                RRVector fe(element.size()*3,0.0);
                RRVector ae(element.size()*3,0.0);
                RRVector xe(element.size()*3,0.0);
                RRVector Qe(3,0.0);
                double QeN = 0.0;
                double QeS = 0.0;
                double QeVM = 0.0;

                RRMatrix B(element.size(),3);
                RRMatrix Be(element.size()*2,3);
                RRMatrix BeT(3,element.size()*2);
                RRMatrix BeD(element.size()*2,3);
                RRMatrix Met(element.size()*2,element.size()*2);
                RRMatrix MeRt(element.size()*2,element.size()*2);
                RRMatrix Ket(element.size()*2,element.size()*2);
                RRMatrix KeRt(element.size()*2,element.size()*2);
                RRVector fet(element.size()*2);

                RRMatrix De(3,3,0.0);

                double E = this-&gt;elementElasticityModulus[elementID];
                double v = this-&gt;elementPoissonRatio[elementID];

                De[0][0] = 1-v;   De[0][1] = v;
                De[1][0] = v;     De[1][1] = 1-v;
                De[2][2] = (1-2*v)/2;
                De *= E/((1+v)*(1-2*v));

                RRMatrix Rl;
                RRVector tl;
                element.findTransformationMatrix(this-&gt;pModel-&gt;getNodes(),Rl,tl);
                Rl.invert();

                RRVector lxe(element.size()*2);
                for (uint k=0;k&lt;element.size();k++)
                {
                    RR3Vector xg(this-&gt;nodeDisplacement.x[element.getNodeId(k)],
                                 this-&gt;nodeDisplacement.y[element.getNodeId(k)],
                                 this-&gt;nodeDisplacement.z[element.getNodeId(k)]);
                    RR3Vector xl;
                    RRMatrix::mlt(Rl,xg,xl);
                    lxe[2*k+0] = xl[0];
                    lxe[2*k+1] = xl[1];
                }

                for (uint k=0;k&lt;element.size();k++)
                {
                    ae[3*k+0] = this-&gt;nodeAcceleration.x[element.getNodeId(k)];
                    ae[3*k+1] = this-&gt;nodeAcceleration.y[element.getNodeId(k)];
                    ae[3*k+2] = this-&gt;nodeAcceleration.z[element.getNodeId(k)];

                    xe[3*k+0] = this-&gt;nodeDisplacement.x[element.getNodeId(k)];
                    xe[3*k+1] = this-&gt;nodeDisplacement.y[element.getNodeId(k)];
                    xe[3*k+2] = this-&gt;nodeDisplacement.z[element.getNodeId(k)];
                }

                double dT = this-&gt;elementTemperature[elementID] - this-&gt;elementEnvironmentTemperature[elementID];

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt, RtT;
                    double detJ = element.findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);
                    RtT.transpose(Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1]);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1]);
                    }

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        Be[2*m][0] = B[m][0];   Be[2*m+1][0] = 0.0;
                        Be[2*m][1] = 0.0;       Be[2*m+1][1] = B[m][1];
                        Be[2*m][2] = B[m][1];   Be[2*m+1][2] = B[m][0];
                    }
                    BeT.transpose(Be);

                    RRMatrix::mlt(Be,De,BeD);
                    RRMatrix::mlt(BeD,BeT,Ket);
                    RRMatrix::mlt(Rt,Ket,KeRt);
                    RRMatrix::mlt(KeRt,RtT,Ke);
                    Ke *= detJ * shapeFunc.getW();

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        // Mass
                        if (this-&gt;pModel-&gt;getTimeSolver().getEnabled() || this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
                        {
                            for (uint n=0;n&lt;element.size();n++)
                            {
                                double value = N[m] * N[n]
                    // Mass
                    if (this-&gt;pModel-&gt;getTimeSolver().getEnabled() || this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
                    {
                        RRMatrix::mlt(Rt,Met,MeRt);
                        RRMatrix::mlt(MeRt,RtT,Me,true);
                    }

                    double integValue = 1.0/double(nInp);

                    // Element level stress.
                    for (uint m=0;m&lt;element.size();m++)
                    {
                        for (uint n=0;n&lt;3;n++)
                        {
                            Qe[n] += BeD[2*m+0][n] * lxe[2*m+0] * integValue
                                  +  BeD[2*m+1][n] * lxe[2*m+1] * integValue;
                        }
                        for (uint n=0;n&lt;2;n++)
                        {
                            Qe[0] -= BeD[2*m+0][n] * this-&gt;elementThermalExpansion[elementID] * dT * surfaceThickness * integValue;
                            Qe[1] -= BeD[2*m+1][n] * this-&gt;elementThermalExpansion[elementID] * dT * surfaceThickness * integValue;
                        }
                    }
                }

                RRVector fae, fxe;
                RRMatrix::mlt(Me,ae,fae);
                RRMatrix::mlt(Ke,xe,fxe);
                RRVector::add(fae,fxe,fe);

                QeN = std::sqrt(Qe[0] * Qe[0] + Qe[1] * Qe[1] - Qe[0] * Qe[1]);
                QeS = std::sqrt(3.0) * Qe[2];
                QeVM = QeN + QeS;

                #pragma omp critical
                {
                    for (uint m=0;m&lt;element.size();m++)
                    {
                        this-&gt;nodeForce.x[element.getNodeId(m)] += fe[3*m+0];
                        this-&gt;nodeForce.y[element.getNodeId(m)] += fe[3*m+1];
                        this-&gt;nodeForce.z[element.getNodeId(m)] += fe[3*m+2];
                    }

                    this-&gt;elementNormalStress[elementID] = QeN;
                    this-&gt;elementShearStress[elementID] = QeS;
                    this-&gt;elementVonMisses[elementID] = QeVM;
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
                #pragma omp flush (abort)
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to process results.");
        }
    }

    // Process volume elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        RVolume &amp;volume = this-&gt;pModel-&gt;getVolume(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(volume.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = volume.get(uint(j));

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_VOLUME(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size()*3,element.size()*3,0.0);
                RRMatrix Ke(element.size()*3,element.size()*3,0.0);
                RRVector fe(element.size()*3,0.0);
                RRVector ae(element.size()*3,0.0);
                RRVector xe(element.size()*3,0.0);
                RRVector Qe(6,0.0);

                RRMatrix B(element.size(),3);
                RRMatrix Be(element.size()*3,6);
                RRMatrix BeT(6,element.size()*3);
                RRMatrix BeD(element.size()*3,6);
                RRMatrix Ket(element.size()*3,element.size()*3);

                RRMatrix De(6,6,0.0);

                double E = this-&gt;elementElasticityModulus[elementID];
                double v = this-&gt;elementPoissonRatio[elementID];

                De[0][0] = 1-v;   De[0][1] = v;     De[0][2] = v;
                De[1][0] = v;     De[1][1] = 1-v;   De[1][2] = v;
                De[2][0] = v;     De[2][1] = v;     De[2][2] = 1-v;
                De[3][3] = De[4][4] = De[5][5] = (1-2*v)/2;
                De *= E/((1+v)*(1-2*v));

                double dT = this-&gt;elementTemperature[elementID] - this-&gt;elementEnvironmentTemperature[elementID];

                for (uint k=0;k&lt;element.size();k++)
                {
                    ae[3*k+0] = this-&gt;nodeAcceleration.x[element.getNodeId(k)];
                    ae[3*k+1] = this-&gt;nodeAcceleration.y[element.getNodeId(k)];
                    ae[3*k+2] = this-&gt;nodeAcceleration.z[element.getNodeId(k)];

                    xe[3*k+0] = this-&gt;nodeDisplacement.x[element.getNodeId(k)];
                    xe[3*k+1] = this-&gt;nodeDisplacement.y[element.getNodeId(k)];
                    xe[3*k+2] = this-&gt;nodeDisplacement.z[element.getNodeId(k)];
                }

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = element.findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]);
                        B[m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]);
                    }

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        Be[3*m+0][0] = B[m][0];   Be[3*m+1][0] = 0.0;       Be[3*m+2][0] = 0.0;
                        Be[3*m+0][1] = 0.0;       Be[3*m+1][1] = B[m][1];   Be[3*m+2][1] = 0.0;
                        Be[3*m+0][2] = 0.0;       Be[3*m+1][2] = 0.0;       Be[3*m+2][2] = B[m][2];
                        Be[3*m+0][3] = 0.0;       Be[3*m+1][3] = B[m][2];   Be[3*m+2][3] = B[m][1];
                        Be[3*m+0][4] = B[m][2];   Be[3*m+1][4] = 0.0;       Be[3*m+2][4] = B[m][0];
                        Be[3*m+0][5] = B[m][1];   Be[3*m+1][5] = B[m][0];   Be[3*m+2][5] = 0.0;
                    }
                    BeT.transpose(Be);

                    RRMatrix::mlt(Be,De,BeD);
                    RRMatrix::mlt(BeD,BeT,Ket);
                    for (uint m=0;m&lt;3*element.size();m++)
                    {
                        for (uint n=0;n&lt;3*element.size();n++)
                        {
                            // Stiffness matrix
                            Ke[m][n] += Ket[m][n] * detJ * shapeFunc.getW();
                        }
                    }

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        for (uint n=0;n&lt;element.size();n++)
                        {
                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled() || this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
                            {
                                double value = N[m] * N[n]
                    double integValue = 1.0/double(nInp);

                    // Element level stress.
                    for (uint m=0;m&lt;element.size();m++)
                    {
                        for (uint n=0;n&lt;6;n++)
                        {
                            Qe[n] += BeD[3*m+0][n] * this-&gt;nodeDisplacement.x[element.getNodeId(m)] * integValue
                                  +  BeD[3*m+1][n] * this-&gt;nodeDisplacement.y[element.getNodeId(m)] * integValue
                                  +  BeD[3*m+2][n] * this-&gt;nodeDisplacement.z[element.getNodeId(m)] * integValue;
                        }
                        for (uint n=0;n&lt;3;n++)
                        {
                            Qe[0] -= BeD[3*m+0][n] * this-&gt;elementThermalExpansion[elementID] * dT * integValue;
                            Qe[1] -= BeD[3*m+1][n] * this-&gt;elementThermalExpansion[elementID] * dT * integValue;
                            Qe[2] -= BeD[3*m+2][n] * this-&gt;elementThermalExpansion[elementID] * dT * integValue;
                        }
                    }
                }

                RRVector fae, fxe;
                RRMatrix::mlt(Me,ae,fae);
                RRMatrix::mlt(Ke,xe,fxe);
                RRVector::add(fae,fxe,fe);

                double QeN = std::sqrt(Qe[0]*Qe[0] + Qe[1]*Qe[1] + Qe[2]*Qe[2] - (Qe[0]*Qe[1] + Qe[1]*Qe[2] + Qe[2]*Qe[0]));
                double QeS = std::sqrt(3.0 * (Qe[3]*Qe[3] + Qe[4]*Qe[4] + Qe[5]*Qe[5]));
                double QeVM = QeN + QeS;

                #pragma omp critical
                {
                    for (uint m=0;m&lt;element.size();m++)
                    {
                        this-&gt;nodeForce.x[element.getNodeId(m)] += fe[3*m+0];
                        this-&gt;nodeForce.y[element.getNodeId(m)] += fe[3*m+1];
                        this-&gt;nodeForce.z[element.getNodeId(m)] += fe[3*m+2];
                    }

                    this-&gt;elementNormalStress[elementID] = QeN;
                    this-&gt;elementShearStress[elementID] = QeS;
                    this-&gt;elementVonMisses[elementID] = QeVM;
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
                #pragma omp flush (abort)
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to process results.");
        }
    }
}

</t>
<t tx="leo.20201108101543.103">void RSolverStress::store(void)
{
    RLogger::info("Storing results\n");
    RLogger::indent();

    // Displacement
    uint displacementPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_DISPLACEMENT);
    if (displacementPos == RConstants::eod)
    {
        displacementPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_DISPLACEMENT);

        double umin = 0.0;
        double umax = 0.0;
        for (uint i=0;i&lt;this-&gt;nodeDisplacement.x.size();i++)
        {
            @others
}

</t>
<t tx="leo.20201108101543.104">        double u = RR3Vector(this-&gt;nodeDisplacement.x[i],
                             this-&gt;nodeDisplacement.y[i],
                             this-&gt;nodeDisplacement.z[i]).length();
        if (i == 0)
        {
            umin = umax = u;
        }
        else
        {
            umin = std::min(umin,u);
            umax = std::max(umax,u);
        }
    }

    this-&gt;pModel-&gt;getVariable(displacementPos).getVariableData().setMinMaxDisplayValue(umin,umax);
}
RVariable &amp;displacement =  this-&gt;pModel-&gt;getVariable(displacementPos);

displacement.setApplyType(R_VARIABLE_APPLY_NODE);
displacement.resize(3,this-&gt;pModel-&gt;getNNodes());
for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
{
    displacement.setValue(0,i,this-&gt;nodeDisplacement.x[i]);
    displacement.setValue(1,i,this-&gt;nodeDisplacement.y[i]);
    displacement.setValue(2,i,this-&gt;nodeDisplacement.z[i]);
}

// VonMises Stress
uint vonMisesStressPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_STRESS_VON_MISES);
if (vonMisesStressPos == RConstants::eod)
{
    vonMisesStressPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_STRESS_VON_MISES);

    this-&gt;pModel-&gt;getVariable(vonMisesStressPos).getVariableData().setMinMaxDisplayValue(
                RStatistics::findMinimumValue(this-&gt;elementVonMisses),
                RStatistics::findMaximumValue(this-&gt;elementVonMisses));
}
RVariable &amp;vonMisesStress =  this-&gt;pModel-&gt;getVariable(vonMisesStressPos);

vonMisesStress.setApplyType(R_VARIABLE_APPLY_ELEMENT);
vonMisesStress.resize(1,this-&gt;pModel-&gt;getNElements());
for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
{
    vonMisesStress.setValue(0,i,this-&gt;elementVonMisses[i]);
}

// Normal Stress
uint normalStressPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_STRESS_NORMAL);
if (normalStressPos == RConstants::eod)
{
    normalStressPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_STRESS_NORMAL);

    this-&gt;pModel-&gt;getVariable(normalStressPos).getVariableData().setMinMaxDisplayValue(
                RStatistics::findMinimumValue(this-&gt;elementNormalStress),
                RStatistics::findMaximumValue(this-&gt;elementNormalStress));
}
RVariable &amp;normalStress =  this-&gt;pModel-&gt;getVariable(normalStressPos);

normalStress.setApplyType(R_VARIABLE_APPLY_ELEMENT);
normalStress.resize(1,this-&gt;pModel-&gt;getNElements());
for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
{
    normalStress.setValue(0,i,this-&gt;elementNormalStress[i]);
}

// Shear Stress
uint shearStressPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_STRESS_SHEAR);
if (shearStressPos == RConstants::eod)
{
    shearStressPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_STRESS_SHEAR);

    this-&gt;pModel-&gt;getVariable(shearStressPos).getVariableData().setMinMaxDisplayValue(
                RStatistics::findMinimumValue(this-&gt;elementShearStress),
                RStatistics::findMaximumValue(this-&gt;elementShearStress));
}
RVariable &amp;shearStress =  this-&gt;pModel-&gt;getVariable(shearStressPos);

shearStress.setApplyType(R_VARIABLE_APPLY_ELEMENT);
shearStress.resize(1,this-&gt;pModel-&gt;getNElements());
for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
{
    shearStress.setValue(0,i,this-&gt;elementShearStress[i]);
}

// Force
uint forcePos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_FORCE);
if (forcePos == RConstants::eod)
{
    forcePos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_FORCE);

    double fmin = 0.0;
    double fmax = 0.0;
    for (uint i=0;i&lt;this-&gt;nodeForce.x.size();i++)
    {
</t>
<t tx="leo.20201108101543.105">        double f = RR3Vector(this-&gt;nodeForce.x[i],
                             this-&gt;nodeForce.y[i],
                             this-&gt;nodeForce.z[i]).length();
        if (i == 0)
        {
            fmin = fmax = f;
        }
        else
        {
            fmin = std::min(fmin,f);
            fmax = std::max(fmax,f);
        }
    }

    this-&gt;pModel-&gt;getVariable(displacementPos).getVariableData().setMinMaxDisplayValue(fmin,fmax);
}
RVariable &amp;force =  this-&gt;pModel-&gt;getVariable(forcePos);

force.setApplyType(R_VARIABLE_APPLY_NODE);
force.resize(3,this-&gt;pModel-&gt;getNNodes());
for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
{
    force.setValue(0,i,this-&gt;nodeForce.x[i]);
    force.setValue(1,i,this-&gt;nodeForce.y[i]);
    force.setValue(2,i,this-&gt;nodeForce.z[i]);
}

RLogger::unindent();
</t>
<t tx="leo.20201108101543.106">void RSolverStress::statistics(void)
{
    this-&gt;printStats(R_VARIABLE_DISPLACEMENT);
    this-&gt;printStats(R_VARIABLE_STRESS_VON_MISES);
    this-&gt;printStats(R_VARIABLE_FORCE);
    this-&gt;processMonitoringPoints();
}

</t>
<t tx="leo.20201108101543.107">void RSolverStress::generateNodeBook(void)
{
    this-&gt;nodeBook.resize(this-&gt;pModel-&gt;getNNodes()*3);
    this-&gt;nodeBook.initialize();

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElementGroups();i++)
    {
        REntityGroupType entityType = this-&gt;pModel-&gt;getEntityGroupType(i);
        const RElementGroup *pElementGroup = this-&gt;pModel-&gt;getElementGroupPtr(i);
        if (!pElementGroup)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Element group could not be found (%u of %u).",i,this-&gt;pModel-&gt;getNElementGroups());
        }
        bool hasDisplacementX = false;
        bool hasDisplacementY = false;
        bool hasDisplacementZ = false;
        for (uint j=0;j&lt;pElementGroup-&gt;getNBoundaryConditions();j++)
        {
            const RBoundaryCondition &amp;bc = pElementGroup-&gt;getBoundaryCondition(j);
            if (RBoundaryCondition::getProblemTypeMask(bc.getType()) &amp; R_PROBLEM_STRESS)
            {
                if (bc.getType() == R_BOUNDARY_CONDITION_DISPLACEMENT || bc.getType() == R_BOUNDARY_CONDITION_DISPLACEMENT_NORMAL)
                {
                    hasDisplacementX = true;
                    hasDisplacementY = true;
                    hasDisplacementZ = true;
                }
                if (bc.getType() == R_BOUNDARY_CONDITION_DISPLACEMENT_ROLLER)
                {
                    if (entityType == R_ENTITY_GROUP_LINE)
                    {
                        hasDisplacementY = true;
                        hasDisplacementZ = true;
                    }
                    else
                    {
                        hasDisplacementX = true;
                    }
                }
            }
        }
        if (!hasDisplacementX &amp;&amp; !hasDisplacementY &amp;&amp; !hasDisplacementZ)
        {
            continue;
        }
        for (uint j=0;j&lt;pElementGroup-&gt;size();j++)
        {
            uint elementID = pElementGroup-&gt;get(j);
            const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
            for (uint k=0;k&lt;element.size();k++)
            {
                uint nodeId = element.getNodeId(k);
                if (hasDisplacementX)
                {
                    this-&gt;nodeBook.disable(3*nodeId+0,true);
                }
                if (hasDisplacementY)
                {
                    this-&gt;nodeBook.disable(3*nodeId+1,true);
                }
                if (hasDisplacementZ)
                {
                    this-&gt;nodeBook.disable(3*nodeId+2,true);
                }
            }
        }
    }
    RBVector computableNodes(this-&gt;pModel-&gt;getNNodes(),false);
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        if (this-&gt;computableElements[i])
        {
            const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(i);
            for (uint j=0;j&lt;rElement.size();j++)
            {
                computableNodes[rElement.getNodeId(j)] = true;
            }
        }
    }
    for (uint i=0;i&lt;computableNodes.size();i++)
    {
        if (!computableNodes[i])
        {
            this-&gt;nodeBook.disable(3*i+0,true);
            this-&gt;nodeBook.disable(3*i+1,true);
            this-&gt;nodeBook.disable(3*i+2,true);
        }
    }
}

</t>
<t tx="leo.20201108101543.108">void RSolverStress::assemblyMatrix(uint elementID, const RRMatrix &amp;Me, const RRMatrix &amp;Ke, const RRVector &amp;fe)
{
    double alpha = this-&gt;pModel-&gt;getTimeSolver().getTimeMarchApproximationCoefficient();
    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();

    const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);

    RRMatrix Ae(3*rElement.size(),3*rElement.size());
    RRMatrix Be(3*rElement.size(),3*rElement.size());
    RRVector be(3*rElement.size());

    Ae.fill(0.0);
    Be.fill(0.0);
    be.fill(0.0);

    if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
    {
        for (unsigned m=0;m&lt;rElement.size();m++)
        {
            be[3*m+0] = dt * fe[3*m+0];
            be[3*m+1] = dt * fe[3*m+1];
            be[3*m+2] = dt * fe[3*m+2];
            for (unsigned n=0;n&lt;rElement.size();n++)
            {
                Ae[3*m+0][3*n+0] = Me[3*m+0][3*n+0] + alpha * dt * Ke[3*m+0][3*n+0];
                Ae[3*m+1][3*n+0] = Me[3*m+1][3*n+0] + alpha * dt * Ke[3*m+1][3*n+0];
                Ae[3*m+2][3*n+0] = Me[3*m+2][3*n+0] + alpha * dt * Ke[3*m+2][3*n+0];

                Ae[3*m+0][3*n+1] = Me[3*m+0][3*n+1] + alpha * dt * Ke[3*m+0][3*n+1];
                Ae[3*m+1][3*n+1] = Me[3*m+1][3*n+1] + alpha * dt * Ke[3*m+1][3*n+1];
                Ae[3*m+2][3*n+1] = Me[3*m+2][3*n+1] + alpha * dt * Ke[3*m+2][3*n+1];

                Ae[3*m+0][3*n+2] = Me[3*m+0][3*n+2] + alpha * dt * Ke[3*m+0][3*n+2];
                Ae[3*m+1][3*n+2] = Me[3*m+1][3*n+2] + alpha * dt * Ke[3*m+1][3*n+2];
                Ae[3*m+2][3*n+2] = Me[3*m+2][3*n+2] + alpha * dt * Ke[3*m+2][3*n+2];

                be[3*m+0] += (Me[3*m+0][3*n+0] - (1.0 - alpha) * dt * Ke[3*m+0][3*n+0]) * this-&gt;nodeDisplacement.x[rElement.getNodeId(n)]
                          +  (Me[3*m+0][3*n+1] - (1.0 - alpha) * dt * Ke[3*m+0][3*n+1]) * this-&gt;nodeDisplacement.y[rElement.getNodeId(n)]
                          +  (Me[3*m+0][3*n+2] - (1.0 - alpha) * dt * Ke[3*m+0][3*n+2]) * this-&gt;nodeDisplacement.z[rElement.getNodeId(n)];

                be[3*m+1] += (Me[3*m+1][3*n+0] - (1.0 - alpha) * dt * Ke[3*m+1][3*n+0]) * this-&gt;nodeDisplacement.x[rElement.getNodeId(n)]
                          +  (Me[3*m+1][3*n+1] - (1.0 - alpha) * dt * Ke[3*m+1][3*n+1]) * this-&gt;nodeDisplacement.y[rElement.getNodeId(n)]
                          +  (Me[3*m+1][3*n+2] - (1.0 - alpha) * dt * Ke[3*m+1][3*n+2]) * this-&gt;nodeDisplacement.z[rElement.getNodeId(n)];

                be[3*m+2] += (Me[3*m+2][3*n+0] - (1.0 - alpha) * dt * Ke[3*m+2][3*n+0]) * this-&gt;nodeDisplacement.x[rElement.getNodeId(n)]
                          +  (Me[3*m+2][3*n+1] - (1.0 - alpha) * dt * Ke[3*m+2][3*n+1]) * this-&gt;nodeDisplacement.y[rElement.getNodeId(n)]
                          +  (Me[3*m+2][3*n+2] - (1.0 - alpha) * dt * Ke[3*m+2][3*n+2]) * this-&gt;nodeDisplacement.z[rElement.getNodeId(n)];
            }
        }
    }
    else if (this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
    {
        Ae = Ke;
        Be = Me;
        be = fe;
    }
    else
    {
        Ae = Ke;
        be = fe;
    }
    this-&gt;applyLocalRotations(elementID,Ae);
    this-&gt;applyLocalRotations(elementID,Be);
    this-&gt;applyLocalRotations(elementID,be);

    // Apply explicit boundary conditions.
    for (uint m=0;m&lt;rElement.size();m++)
    {
        uint position;
        uint nodeID = rElement.getNodeId(m);
        for (uint n=0;n&lt;3*rElement.size();n++)
        {
            if (!this-&gt;nodeBook.getValue(3*nodeID+0,position))
            {
                be[n] -= (Ae[n][3*m+0] + Be[n][3*m+0]) * this-&gt;nodeDisplacement.x[nodeID];
            }
            if (!this-&gt;nodeBook.getValue(3*nodeID+1,position))
            {
                be[n] -= (Ae[n][3*m+1] + Be[n][3*m+1]) * this-&gt;nodeDisplacement.y[nodeID];
            }
            if (!this-&gt;nodeBook.getValue(3*nodeID+2,position))
            {
                be[n] -= (Ae[n][3*m+2] + Be[n][3*m+2]) * this-&gt;nodeDisplacement.z[nodeID];
            }
        }
    }

    // Assembly final matrix system
    uint dims = 3;
    for (uint m=0;m&lt;rElement.size();m++)
    {
        for (uint i=0;i&lt;dims;i++)
        {
            uint mp = 0;

            if (this-&gt;nodeBook.getValue(dims*rElement.getNodeId(m)+i,mp))
            {
                this-&gt;b[mp] += be[dims*m+i];

                for (uint n=0;n&lt;rElement.size();n++)
                {
                    for (uint j=0;j&lt;dims;j++)
                    {
                        uint np = 0;

                        if (this-&gt;nodeBook.getValue(dims*rElement.getNodeId(n)+j,np))
                        {
                            this-&gt;A.addValue(mp,np,Ae[dims*m+i][dims*n+j]);
                            if (this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
                            {
                                this-&gt;M.addValue(mp,np,Me[dims*m+i][dims*n+j]);
                            }
                        }
                    }
                }
            }
        }
    }
}

</t>
<t tx="leo.20201108101543.109">void RSolverStress::applyLocalRotations(unsigned int elementID, RRMatrix &amp;Ae)
{
    const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);
    RRMatrix T;

    bool first = true;

    for (uint i=0;i&lt;rElement.size();i++)
    {
        uint nodeId = rElement.getNodeId(i);
        if (this-&gt;localRotations[nodeId].isActive())
        {
            if (first)
            {
                T.setIdentity(Ae.getNRows());
                first = false;
            }
            T.setBlock(this-&gt;localRotations[nodeId].getR(),3*i,3*i);
        }
    }
    if (!first)
    {
        RRMatrix Tt(T);
        Tt.transpose();

        RRMatrix Aetmp;

        RRMatrix::mlt(Tt,Ae,Aetmp);
        RRMatrix::mlt(Aetmp,T,Ae);
    }
}

</t>
<t tx="leo.20201108101543.11">void RSolverFluidParticle::clearShapeDerivatives()
{
    for (uint i=0;i&lt;this-&gt;shapeDerivations.size();i++)
    {
        delete this-&gt;shapeDerivations[i];
    }
}

</t>
<t tx="leo.20201108101543.110">void RSolverStress::applyLocalRotations(unsigned int elementID, RRVector &amp;fe)
{
    const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);
    RRMatrix T;

    bool first = true;

    for (uint i=0;i&lt;rElement.size();i++)
    {
        uint nodeId = rElement.getNodeId(i);
        if (this-&gt;localRotations[nodeId].isActive())
        {
            if (first)
            {
                T.setIdentity(fe.getNRows());
                first = false;
            }
            T.setBlock(this-&gt;localRotations[nodeId].getR(),3*i,3*i);
        }
    }
    if (!first)
    {
        RRVector fetmp;

        RRMatrix::mlt(T,fe,fetmp);
        fe = fetmp;
    }
}
</t>
<t tx="leo.20201108101543.12">void RSolverFluidParticle::computeElement(unsigned int elementID, RRMatrix &amp;Ae, RRVector &amp;be, RMatrixManager&lt;FluidParticleMatrixContainer&gt; &amp;matrixManager)
{
    if (RElement::hasConstantDerivative(this-&gt;pModel-&gt;getElement(elementID).getType()))
    {
        this-&gt;computeElementConstantDerivative(elementID,Ae,be,matrixManager);
    }
    else
    {
        this-&gt;computeElementGeneral(elementID,Ae,be,matrixManager);
    }
}

</t>
<t tx="leo.20201108101543.13">void RSolverFluidParticle::computeElementGeneral(unsigned int elementID, RRMatrix &amp;Ae, RRVector &amp;be, RMatrixManager&lt;FluidParticleMatrixContainer&gt; &amp;matrixManager)
{
    bool unsteady = (this-&gt;pModel-&gt;getTimeSolver().getEnabled());

    const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
    uint nen = element.size();
    uint nInp = RElement::getNIntegrationPoints(element.getType());

    double ro = this-&gt;elementDensity[elementID];
    double k = this-&gt;elementDiffusion[elementID];

    double ca = ro;
    ca = 1.0; // Seems like density should not be part of calculation

    Ae.fill(0.0);
    be.fill(0.0);

    FluidParticleMatrixContainer &amp;matrixCotainer = matrixManager.getMatricies(element.getType());
    matrixCotainer.clear();

    // Element level matricies
    RRMatrix &amp;me = matrixCotainer.me;
    RRMatrix &amp;ce = matrixCotainer.ce;
    RRMatrix &amp;ke = matrixCotainer.ke;
    RRMatrix &amp;cte = matrixCotainer.cte;
    RRMatrix &amp;kte = matrixCotainer.kte;
    RRMatrix &amp;yte = matrixCotainer.yte;

    // Element level vectors
    RRVector &amp;fv = matrixCotainer.fv;

    double alpha = this-&gt;pModel-&gt;getTimeSolver().getTimeMarchApproximationCoefficient();
    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();

    // Element level input -------------------------------------------
    RR3Vector ve(this-&gt;elementVelocity.x[elementID],
                 this-&gt;elementVelocity.y[elementID],
                 this-&gt;elementVelocity.z[elementID]);
    // element level velocity magnitude
    double mvh = ve.length();
    // element level velocity direction
    RR3Vector s(ve);
    s.normalize();

    for (uint intPoint=0;intPoint&lt;nInp;intPoint++)
    {
        const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),intPoint);
        const RRVector &amp;N = shapeFunc.getN();
        const RRMatrix &amp;B = this-&gt;shapeDerivations[elementID]-&gt;getDerivative(intPoint);
        double detJ = this-&gt;shapeDerivations[elementID]-&gt;getJacobian(intPoint);

        double integValue = detJ * shapeFunc.getW();

        // velocity divergence
        RRVector vdiv(nen,0.0);
        // element length scale
        double h = 0.0;

        for (uint m=0;m&lt;nen;m++)
        {
            vdiv[m] += ve[0] * B[m][0] + ve[1] * B[m][1] + ve[2] * B[m][2];
            h += std::fabs(s[0]*B[m][0] + s[1]*B[m][1] + s[2]*B[m][2]);
        }
        if (h != 0.0)
        {
            h = 2.0/h;
        }
        // Reynolds numbers
        double Re(k == 0.0 ? 0.0 : mvh * h / (2.0 * k));

        // SUPG stabilization parameter
        double Tsupg = 0.0;
        if (mvh &gt; 0.0)
        {
            Tsupg = h / (2.0 * mvh);
            if (Re &gt; 0.0 &amp;&amp; Re &lt;= 3.0)
            {
                Tsupg *= Re / 3.0;
            }
        }

        for (uint m=0;m&lt;nen;m++)
        {
            for (uint n=0;n&lt;nen;n++)
            {
                // m matrix
                if (unsteady)
                {
                    me[m][n] = ca * N[m] * N[n];
                }
                // c matrix
                ce[m][n] = ca * N[m] * vdiv[n];
                // k matrix
                ke[m][n] = -k * (B[m][0] * B[n][0] + B[m][1] * B[n][1] + B[m][2] * B[n][2]);
                // k~ matrix
                kte[m][n] = Tsupg * ca * vdiv[m] * vdiv[n];
                // y~ matrix
                yte[m][n] = Tsupg * vdiv[m];
            }
            // f vector
            fv[m] = this-&gt;nodeRate[element.getNodeId(m)] * N[m];
        }

        // Assembly element level matrixes
        for (uint m=0;m&lt;nen;m++)
        {
            for (uint n=0;n&lt;nen;n++)
            {
                if (unsteady)
                {
                    Ae[m][n] += me[m][n] + cte[m][n]
                              + alpha * dt * (  ce[m][n]  + ke[m][n]
                                             + kte[m][n] + yte[m][n] );
                }
                else
                {
                    Ae[m][n] += ce[m][n] + ke[m][n]
                              + kte[m][n] + yte[m][n];
                }
            }
            if (unsteady)
            {
                be[m] += dt * fv[m];
                for (uint n=0;n&lt;nen;n++)
                {
                    be[m] += (me[m][n] + cte[m][n] - (1.0 - alpha) * dt * (ce[m][n] + ke[m][n] + kte[m][n] + yte[m][n]))
                           * this-&gt;nodeConcentration[element.getNodeId(n)];
                }
            }
            else
            {
                be[m] = fv[m];
            }
        }
        for (uint m=0;m&lt;nen;m++)
        {
            for (uint n=0;n&lt;nen;n++)
            {
                Ae[m][n] *= integValue;
            }
            be[m] *= integValue;
        }
    }
}

</t>
<t tx="leo.20201108101543.14">void RSolverFluidParticle::computeElementConstantDerivative(unsigned int elementID, RRMatrix &amp;Ae, RRVector &amp;be, RMatrixManager&lt;FluidParticleMatrixContainer&gt; &amp;matrixManager)
{
    bool unsteady = (this-&gt;pModel-&gt;getTimeSolver().getEnabled());

    const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
    uint nen = element.size();

    double ro = this-&gt;elementDensity[elementID];
    double k = this-&gt;elementDiffusion[elementID];

    double ca = ro;
    ca = 1.0; // Seems like density should not be part of calculation

    Ae.fill(0.0);
    be.fill(0.0);

    FluidParticleMatrixContainer &amp;matrixCotainer = matrixManager.getMatricies(element.getType());
    matrixCotainer.clear();

    // Element level matricies
    RRMatrix &amp;me = matrixCotainer.me;
    RRMatrix &amp;ce = matrixCotainer.ce;
    RRMatrix &amp;ke = matrixCotainer.ke;
    RRMatrix &amp;cte = matrixCotainer.cte;
    RRMatrix &amp;kte = matrixCotainer.kte;
    RRMatrix &amp;yte = matrixCotainer.yte;

    // Element level vectors
    RRVector &amp;fv = matrixCotainer.fv;

    double alpha = this-&gt;pModel-&gt;getTimeSolver().getTimeMarchApproximationCoefficient();
    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();

    // Element level input -------------------------------------------
    RR3Vector ve(this-&gt;elementVelocity.x[elementID],
                 this-&gt;elementVelocity.y[elementID],
                 this-&gt;elementVelocity.z[elementID]);
    // element level velocity magnitude
    double mvh = ve.length();
    // element level velocity direction
    RR3Vector s(ve);
    s.normalize();

    const RRVector &amp;iN = RElement::getMassVector(element.getType());
    const RRMatrix &amp;iNiN = RElement::getMassMatrix(element.getType());
    double wt = RElement::getTotalWeightFactor(element.getType());
    const RRMatrix &amp;B = this-&gt;shapeDerivations[elementID]-&gt;getDerivative(0);

    // velocity divergence
    RRVector vdiv(nen,0.0);
    // element length scale
    double h = 0.0;

    for (uint m=0;m&lt;nen;m++)
    {
        vdiv[m] += ve[0] * B[m][0] + ve[1] * B[m][1] + ve[2] * B[m][2];
        h += std::fabs(s[0]*B[m][0] + s[1]*B[m][1] + s[2]*B[m][2]);
    }
    if (h != 0.0)
    {
        h = 2.0/h;
    }
    // Reynolds numbers
    double Re(k == 0.0 ? 0.0 : mvh * h / (2.0 * k));

    // SUPG stabilization parameter
    double Tsupg = 0.0;
    if (mvh &gt; 0.0)
    {
        Tsupg = h / (2.0 * mvh);
        if (Re &gt; 0.0 &amp;&amp; Re &lt;= 3.0)
        {
            Tsupg *= Re / 3.0;
        }
    }

    for (uint m=0;m&lt;nen;m++)
    {
        for (uint n=0;n&lt;nen;n++)
        {
            // m matrix
            if (unsteady)
            {
                me[m][n] = ca * iNiN[m][n];
            }
            // c matrix
            ce[m][n] = ca * iN[m] * vdiv[n];
            // k matrix
            ke[m][n] = -k * wt * (B[m][0] * B[n][0] + B[m][1] * B[n][1] + B[m][2] * B[n][2]);
            // k~ matrix
            kte[m][n] = Tsupg * ca * vdiv[m] * vdiv[n] * wt;
            // y~ matrix
            yte[m][n] = Tsupg * vdiv[m] * wt;
        }
        // f vector
        fv[m] = this-&gt;nodeRate[element.getNodeId(m)] * iN[m];
    }

    // Assembly element level matrixes
    for (uint m=0;m&lt;nen;m++)
    {
        for (uint n=0;n&lt;nen;n++)
        {
            if (unsteady)
            {
                Ae[m][n] = me[m][n] + cte[m][n]
                         + alpha * dt * (  ce[m][n]  + ke[m][n]
                                         + kte[m][n] + yte[m][n] );
            }
            else
            {
                Ae[m][n] = ce[m][n] + ke[m][n]
                         + kte[m][n] + yte[m][n];
            }
        }
        if (unsteady)
        {
            be[m] = dt * fv[m];
            for (uint n=0;n&lt;nen;n++)
            {
                be[m] += (me[m][n] + cte[m][n] - (1.0 - alpha) * dt * (ce[m][n] + ke[m][n] + kte[m][n] + yte[m][n]))
                       * this-&gt;nodeConcentration[element.getNodeId(n)];
            }
        }
        else
        {
            be[m] = fv[m];
        }
    }

    double detJ = this-&gt;shapeDerivations[elementID]-&gt;getJacobian(0);
    Ae *= detJ;
    be *= detJ;
}

</t>
<t tx="leo.20201108101543.15">void RSolverFluidParticle::assemblyMatrix(unsigned int elementID, const RRMatrix &amp;Ae, const RRVector &amp;be)
{
    const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);
    RRVector fe(be);

    // Apply explicit boundary conditions.
    for (uint m=0;m&lt;rElement.size();m++)
    {
        uint mp = 0;
        if (!this-&gt;nodeBook.getValue(rElement.getNodeId(m),mp))
        {
            for (uint n=0;n&lt;rElement.size();n++)
            {
                fe[n] -= Ae[n][m] * this-&gt;nodeConcentration[rElement.getNodeId(m)];
            }
        }
    }

    // Assembly final matrix system
    for (uint m=0;m&lt;rElement.size();m++)
    {
        uint mp = 0;

        if (this-&gt;nodeBook.getValue(rElement.getNodeId(m),mp))
        {
            this-&gt;b[mp] += fe[m];

            for (uint n=0;n&lt;rElement.size();n++)
            {
                uint np = 0;

                if (this-&gt;nodeBook.getValue(rElement.getNodeId(n),np))
                {
                    this-&gt;A.addValue(mp,np,Ae[m][n]);
                }
            }
        }
    }
}
</t>
<t tx="leo.20201108101543.16">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolvergeneric.cpp                                       *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th December 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Generic solver class definition                     *
 *********************************************************************/

#include &lt;QFile&gt;
#include &lt;cstdio&gt;

#include "rsolvergeneric.h"


const double RSolverGeneric::sigma = 5.670367e-8; // Stefan-Boltzman constant [W/(m*m*K*K*K*K)]
const double RSolverGeneric::e0 = 8.854187817e-12; // Vacuum permittivity [F/m]

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101543.17">void RSolverGeneric::_init(const RSolverGeneric *pGenericSolver)
{
    if (pGenericSolver)
    {
        this-&gt;meshChanged = pGenericSolver-&gt;meshChanged;
        this-&gt;problemType = pGenericSolver-&gt;problemType;
        this-&gt;pModel = pGenericSolver-&gt;pModel;
        this-&gt;M = pGenericSolver-&gt;M;
        this-&gt;A = pGenericSolver-&gt;A;
        this-&gt;x = pGenericSolver-&gt;x;
        this-&gt;b = pGenericSolver-&gt;b;
        this-&gt;nodeBook = pGenericSolver-&gt;nodeBook;
        this-&gt;localRotations = pGenericSolver-&gt;localRotations;
        this-&gt;elementTemperature = pGenericSolver-&gt;elementTemperature;
        this-&gt;pSharedData = pGenericSolver-&gt;pSharedData;
        this-&gt;firstRun = pGenericSolver-&gt;firstRun;
        this-&gt;taskIteration = pGenericSolver-&gt;taskIteration;
        this-&gt;computableElements = pGenericSolver-&gt;computableElements;
    }
}

RSolverGeneric::RSolverGeneric(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : meshChanged(true)
    , problemType(R_PROBLEM_NONE)
    , pModel(pModel)
    , modelFileName(modelFileName)
    , convergenceFileName(convergenceFileName)
    , pSharedData(&amp;sharedData)
    , firstRun(false)
    , taskIteration(0)
    , computableElements(this-&gt;pModel-&gt;getNElements(),false)
{
    this-&gt;elementTemperature = this-&gt;pSharedData-&gt;findData("element-temperature");
    this-&gt;elementTemperature.resize(this-&gt;pModel-&gt;getNElements(),RVariable::getInitValue(R_VARIABLE_TEMPERATURE));
    this-&gt;localRotations.resize(this-&gt;pModel-&gt;getNNodes());
    this-&gt;_init();
}

RSolverGeneric::RSolverGeneric(const RSolverGeneric &amp;genericSolver)
{
    this-&gt;_init(&amp;genericSolver);
}

RSolverGeneric::~RSolverGeneric()
{

}

RSolverGeneric &amp;RSolverGeneric::operator =(const RSolverGeneric &amp;genericSolver)
{
    this-&gt;_init(&amp;genericSolver);
    return (*this);
}

</t>
<t tx="leo.20201108101543.18">void RSolverGeneric::run(bool firstRun, uint taskIteration)
{
    this-&gt;firstRun = firstRun;
    this-&gt;taskIteration = taskIteration;

    this-&gt;elementTemperature.resize(this-&gt;pModel-&gt;getNElements(),RVariable::getInitValue(R_VARIABLE_TEMPERATURE));

    if (this-&gt;taskIteration == 0)
    {
        this-&gt;findComputableElements(this-&gt;problemType);
        this-&gt;findIncludableElements();
        this-&gt;findInwardElements();
        this-&gt;updateLocalRotations();
    }

    if (this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
    {
        RModalSetup &amp;modalSetup = this-&gt;pModel-&gt;getProblemSetup().getModalSetup();

        this-&gt;updateScales();
        this-&gt;scales.downscale(*this-&gt;pModel);

        this-&gt;recoverSharedData();
        this-&gt;recover();
        this-&gt;prepare();
        this-&gt;solve();

        this-&gt;scales.upscale(*this-&gt;pModel);

        uint nModes = modalSetup.getNModesToExtract();
        if (modalSetup.getMethod() == R_MODAL_DOMINANT_MODE)
        {
            nModes = 1;
        }

        for (uint i=0;i&lt;nModes;i++)
        {
            uint mode = nModes - (i + 1);
            RLogger::info("Extracting mode %d\n",mode+1);
            modalSetup.setMode(mode);

            RLogger::indent();

            this-&gt;scales.downscale(*this-&gt;pModel);

            this-&gt;process();
            this-&gt;store();
            this-&gt;storeSharedData();

            this-&gt;scales.upscale(*this-&gt;pModel);

            this-&gt;writeResults();
            this-&gt;statistics();

            RLogger::unindent();

            if (RApplicationState::getInstance().getStateType() == R_APPLICATION_STATE_STOP)
            {
                break;
            }
        }
    }
    else
    {
        if (this-&gt;problemType != R_PROBLEM_STRESS &amp;&amp; this-&gt;problemType != R_PROBLEM_STRESS_MODAL &amp;&amp; this-&gt;problemType != R_PROBLEM_MESH)
        {
            this-&gt;applyDisplacement();
        }

        this-&gt;updateScales();
        if (this-&gt;problemType != R_PROBLEM_MESH)
        {
            this-&gt;scales.downscale(*this-&gt;pModel);
        }

        this-&gt;recoverSharedData();
        this-&gt;recover();
        this-&gt;prepare();
        this-&gt;solve();
        this-&gt;process();
        this-&gt;store();
        this-&gt;storeSharedData();

        if (this-&gt;problemType != R_PROBLEM_MESH)
        {
            this-&gt;scales.upscale(*this-&gt;pModel);
        }

        if (this-&gt;problemType != R_PROBLEM_STRESS &amp;&amp; this-&gt;problemType != R_PROBLEM_STRESS_MODAL)
        {
            this-&gt;removeDisplacement();
        }

        this-&gt;writeResults();
        this-&gt;statistics();
    }

    this-&gt;meshChanged = (this-&gt;problemType == R_PROBLEM_MESH);
}

</t>
<t tx="leo.20201108101543.19">bool RSolverGeneric::getMeshChanged() const
{
    return this-&gt;meshChanged;
}

</t>
<t tx="leo.20201108101543.2">void RSolverFluidParticle::generateNodeRateVector(void)
{
    RBVector rateSetValues;
    this-&gt;generateVariableVector(R_VARIABLE_PARTICLE_RATE,this-&gt;elementRate,rateSetValues,true,this-&gt;firstRun,this-&gt;firstRun);

    this-&gt;nodeRate.fill(0.0); // Particle rate on node is meant as an input - needs to be cleared
    this-&gt;pModel-&gt;convertElementToNodeVector(this-&gt;elementRate,rateSetValues,this-&gt;nodeRate,true);
}

</t>
<t tx="leo.20201108101543.20">void RSolverGeneric::setMeshChanged(bool meshChanged)
{
    this-&gt;meshChanged = meshChanged;
}

</t>
<t tx="leo.20201108101543.21">void RSolverGeneric::updateOldRecords(const RTimeSolver &amp;rTimeSolver, const QString &amp;modelFileName)
{
    if (rTimeSolver.getEnabled())
    {
        // Update previous records.
        for (unsigned int i=0;i&lt;=rTimeSolver.getCurrentTimeStep();i++)
        {
            QString fileName = RFileManager::getFileNameWithTimeStep(modelFileName,i);

            if (RFileManager::fileExists(fileName))
            {
                RLogger::info("Updating model file \'%s\'\n",fileName.toUtf8().constData());

                RModel model;
                model.read(fileName);
                model.getTimeSolver().setTimes(rTimeSolver.getTimes());
                model.getTimeSolver().setInputNTimeSteps(rTimeSolver.getInputNTimeSteps());
                model.getTimeSolver().setInputStartTime(rTimeSolver.getInputStartTime());
                model.getTimeSolver().setInputTimeStepSize(rTimeSolver.getInputTimeStepSize());
                model.write(fileName);
            }
        }
        // Delete records which will be computed again.
        for (unsigned int i=rTimeSolver.getCurrentTimeStep();i&lt;rTimeSolver.getNTimeSteps();i++)
        {
            QString fileName = RFileManager::getFileNameWithTimeStep(modelFileName,i+1);

            if (RFileManager::fileExists(fileName))
            {
                RLogger::info("Removing model file \'%s\'\n",fileName.toUtf8().constData());
                try
                {
                    RFileManager::remove(fileName);
                }
                catch (RError &amp;error)
                {
                    RLogger::warning("Failed to remove model file \'%s\'. ERROR: %s\n",fileName.toUtf8().constData(),error.getMessage().toUtf8().constData());
                }
            }
        }
    }
}

RRVector RSolverGeneric::findElementSizes(void) const
{
    uint ne = this-&gt;pModel-&gt;getNElements();
    RRVector elementSizes(ne,0.0);
    for (uint i=0;i&lt;ne;i++)
    {
        elementSizes[i] = this-&gt;pModel-&gt;getElement(i).findSize(this-&gt;pModel-&gt;getNodes());
    }
    return elementSizes;
}

double RSolverGeneric::findElementScale(bool onlyVolumes) const
{
    RRVector elementSizes = this-&gt;findElementSizes();

    if (onlyVolumes)
    {
        uint ne = this-&gt;pModel-&gt;getNElements();

        std::vector&lt;bool&gt; volumeElements;
        volumeElements.resize(ne,false);

        for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
        {
            const RLine &amp;rLine = this-&gt;pModel-&gt;getLine(i);
            if (rLine.getCrossArea() &gt; RConstants::eps)
            {
                for (uint j=0;j&lt;rLine.size();j++)
                {
                    volumeElements[rLine.get(j)] = true;
                }
            }
        }
        for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
        {
            const RSurface &amp;rSurface = this-&gt;pModel-&gt;getSurface(i);
            if (rSurface.getThickness() &gt; RConstants::eps)
            {
                for (uint j=0;j&lt;rSurface.size();j++)
                {
                    volumeElements[rSurface.get(j)] = true;
                }
            }
        }
        for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
        {
            const RVolume &amp;rVolume = this-&gt;pModel-&gt;getVolume(i);
            for (uint j=0;j&lt;rVolume.size();j++)
            {
                volumeElements[rVolume.get(j)] = true;
            }
        }

        uint nve = 0;
        for (uint i=0;i&lt;ne;i++)
        {
            if (volumeElements[i])
            {
                elementSizes[nve] = elementSizes[i];
                nve ++;
            }
        }
        elementSizes.resize(nve);
    }
    double elementSize = RStatistics::findMedianValue(elementSizes);

    if (elementSize &lt; RConstants::eps)
    {
        elementSize = 1.0;
    }
    return 1.0 / elementSize;
}

double RSolverGeneric::findMeshScale(void) const
{
    return this-&gt;pModel-&gt;findNodeScale();
}

</t>
<t tx="leo.20201108101543.22">void RSolverGeneric::updateLocalRotations(void)
{
    std::vector&lt;RR3Vector&gt; nodeNormals(this-&gt;pModel-&gt;getNNodes());
    RBVector nodeNormalsBook(this-&gt;pModel-&gt;getNNodes(),false);
    RR3Vector normal;
    RRMatrix R;

    // Calculate directions for surface elements
    for (unsigned int i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        const RSurface &amp;rSurface = this-&gt;pModel-&gt;getSurface(i);
        bool findLocalDirections = false;
        for (unsigned int j=0;j&lt;rSurface.getNBoundaryConditions();j++)
        {
            const RBoundaryCondition &amp;bc = rSurface.getBoundaryCondition(j);
            if (RBoundaryCondition::getProblemTypeMask(bc.getType()) &amp; problemType)
            {
                if (bc.getHasLocalDirection())
                {
                    findLocalDirections = true;
                    break;
                }
            }
        }
        for (unsigned int j=0;j&lt;rSurface.size();j++)
        {
            if (findLocalDirections)
            {
                const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(rSurface.get(j));

                if (!rElement.findNormal(this-&gt;pModel-&gt;getNodes(),normal[0],normal[1],normal[2]))
                {
                    throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Could not calculate element normal for element# = %u.",rSurface.get(j));
                }
                for (unsigned int k=0;k&lt;rElement.size();k++)
                {
                    uint nodeId = rElement.getNodeId(k);
                    nodeNormals[nodeId][0] += normal[0];
                    nodeNormals[nodeId][1] += normal[1];
                    nodeNormals[nodeId][2] += normal[2];
                    nodeNormalsBook[nodeId] = true;
                }
            }
        }
    }

    // Apply directions for point elements
    for (unsigned int i=0;i&lt;this-&gt;pModel-&gt;getNPoints();i++)
    {
        RR3Vector direction;
        bool hasLocalDirections = false;
        const RPoint &amp;rPoint = this-&gt;pModel-&gt;getPoint(i);
        for (unsigned int j=0;j&lt;rPoint.getNBoundaryConditions();j++)
        {
            const RBoundaryCondition &amp;bc = rPoint.getBoundaryCondition(j);
            if (RBoundaryCondition::getProblemTypeMask(bc.getType()) &amp; problemType)
            {
                if (bc.getHasLocalDirection())
                {
                    hasLocalDirections = true;
                    direction = bc.getLocalDirection();
                    break;
                }
            }
        }
        if (hasLocalDirections)
        {
            for (uint j=0;j&lt;rPoint.size();j++)
            {
                const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(rPoint.get(j));
                for (unsigned int k=0;k&lt;rElement.size();k++)
                {
                    uint nodeId = rElement.getNodeId(k);
                    nodeNormals[nodeId][0] = direction[0];
                    nodeNormals[nodeId][1] = direction[1];
                    nodeNormals[nodeId][2] = direction[2];
                    nodeNormalsBook[nodeId] = true;
                }
            }
        }
    }

    // Convert local directions to rotation matricies
    this-&gt;localRotations.resize(this-&gt;pModel-&gt;getNNodes());
    for (uint i=0;i&lt;nodeNormals.size();i++)
    {
        if (nodeNormalsBook[i])
        {
            nodeNormals[i].normalize();
            nodeNormals[i].findRotationMatrix(R);
            this-&gt;localRotations[i].activate(R);
        }
        else
        {
            this-&gt;localRotations[i].deactivate();
        }
    }

    // Apply local rotation for line elements
    for (unsigned int i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        RR3Vector direction;
        bool findLocalDirections = false;
        const RLine &amp;rLine = this-&gt;pModel-&gt;getLine(i);
        for (unsigned int j=0;j&lt;rLine.getNBoundaryConditions();j++)
        {
            const RBoundaryCondition &amp;bc = rLine.getBoundaryCondition(j);
            if (RBoundaryCondition::getProblemTypeMask(bc.getType()) &amp; problemType)
            {
                if (bc.getHasLocalDirection())
                {
                    findLocalDirections = true;
                    break;
                }
            }
        }
        if (findLocalDirections)
        {
            for (uint j=0;j&lt;rLine.size();j++)
            {
                const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(rLine.get(j));

                RR3Vector d1,d2,d3;
                RSegment s(this-&gt;pModel-&gt;getNode(rElement.getNodeId(0)),
                           this-&gt;pModel-&gt;getNode(rElement.getNodeId(1)));
                s.findPerpendicularVectors(d1,d2,d3);

                R.resize(3,3,0.0);
                R[0][0]=d1[0]; R[0][1]=d1[1]; R[0][2]=d1[2];
                R[1][0]=d2[0]; R[1][1]=d2[1]; R[1][2]=d2[2];
                R[2][0]=d3[0]; R[2][1]=d3[1]; R[2][2]=d3[2];
                R.invert();

                for (uint k=0;k&lt;rElement.size();k++)
                {
                    this-&gt;localRotations[rElement.getNodeId(k)].activate(R);
                }
            }
        }
    }
}

</t>
<t tx="leo.20201108101543.23">void RSolverGeneric::clearSharedData(void)
{
    this-&gt;pSharedData-&gt;clearData();
}

</t>
<t tx="leo.20201108101543.24">void RSolverGeneric::storeSharedData(void)
{
    this-&gt;pSharedData-&gt;addData("element-temperature",this-&gt;elementTemperature);
}

</t>
<t tx="leo.20201108101543.25">void RSolverGeneric::recoverSharedData(void)
{
    if (this-&gt;pSharedData-&gt;hasData("element-temperature",this-&gt;pModel-&gt;getNElements()))
    {
        this-&gt;elementTemperature = this-&gt;pSharedData-&gt;findData("element-temperature");
    }
}

</t>
<t tx="leo.20201108101543.26">void RSolverGeneric::writeResults(void)
{
    if (this-&gt;modelFileName.isEmpty())
    {
        return;
    }

    bool canWrite = true;
    if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
    {
        canWrite = false;
        if (/*(!this-&gt;pModel-&gt;getTimeSolver().getRestartSolver() &amp;&amp; this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStep() == 0) ||*/
            (this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStep()+1) == this-&gt;pModel-&gt;getTimeSolver().getNTimeSteps() ||
            ((this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStep()+1) % this-&gt;pModel-&gt;getTimeSolver().getOutputFrequency() == 0))
        {
            canWrite = true;
        }
    }

    if (canWrite)
    {
        this-&gt;modelFileName = this-&gt;pModel-&gt;write(this-&gt;modelFileName);
    }
}

</t>
<t tx="leo.20201108101543.27">void RSolverGeneric::applyDisplacement(void)
{
    uint variablePosition = this-&gt;pModel-&gt;findVariable(R_VARIABLE_DISPLACEMENT);
    if (variablePosition == RConstants::eod)
    {
        return;
    }

    const RVariable &amp;rVariable = this-&gt;pModel-&gt;getVariable(variablePosition);

    R_ERROR_ASSERT(rVariable.getNValues() == this-&gt;pModel-&gt;getNNodes());
    R_ERROR_ASSERT(rVariable.getNVectors() == 3);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        RRVector u = rVariable.getValueVector(i);
        this-&gt;pModel-&gt;getNode(i).move(RR3Vector(u[0],u[1],u[2]));
    }
}

</t>
<t tx="leo.20201108101543.28">void RSolverGeneric::removeDisplacement(void)
{
    uint variablePosition = this-&gt;pModel-&gt;findVariable(R_VARIABLE_DISPLACEMENT);
    if (variablePosition == RConstants::eod)
    {
        return;
    }

    const RVariable &amp;rVariable = this-&gt;pModel-&gt;getVariable(variablePosition);

    R_ERROR_ASSERT(rVariable.getNValues() == this-&gt;pModel-&gt;getNNodes());
    R_ERROR_ASSERT(rVariable.getNVectors() == 3);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        RRVector u = rVariable.getValueVector(i);
        u *= -1.0;
        this-&gt;pModel-&gt;getNode(i).move(RR3Vector(u[0],u[1],u[2]));
    }
}

</t>
<t tx="leo.20201108101543.29">void RSolverGeneric::generateNodeBook(RProblemType problemType)
{
    if (problemType == R_PROBLEM_FLUID)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Unsupported problem type \'%s\' for node book generation.",
                     RProblem::getName(problemType).toUtf8().constData());
    }

    this-&gt;nodeBook.resize(this-&gt;pModel-&gt;getNNodes());

    for (unsigned int i=0;i&lt;this-&gt;pModel-&gt;getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = this-&gt;pModel-&gt;getElementGroupPtr(i);
        if (!pElementGroup)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Element group could not be found (%u of %u).",i,this-&gt;pModel-&gt;getNElementGroups());
        }
        bool hasExplicitBc = false;
        for (unsigned int j=0;j&lt;pElementGroup-&gt;getNBoundaryConditions();j++)
        {
            const RBoundaryCondition &amp;bc = pElementGroup-&gt;getBoundaryCondition(j);
            if (RBoundaryCondition::getProblemTypeMask(bc.getType()) &amp; problemType)
            {
                if (bc.getExplicit())
                {
                    hasExplicitBc = true;
                    break;
                }
            }
        }
        for (unsigned int j=0;j&lt;pElementGroup-&gt;size();j++)
        {
            if (hasExplicitBc)
            {
                const RElement &amp;element = this-&gt;pModel-&gt;getElement(pElementGroup-&gt;get(j));
                for (unsigned int k=0;k&lt;element.size();k++)
                {
                    this-&gt;nodeBook.disable(element.getNodeId(k),true);
                }
            }
        }
    }
    RBVector computableNodes(this-&gt;pModel-&gt;getNNodes(),false);
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        if (this-&gt;computableElements[i])
        {
            const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(i);
            for (uint j=0;j&lt;rElement.size();j++)
            {
                computableNodes[rElement.getNodeId(j)] = true;
            }
        }
    }
    for (uint i=0;i&lt;computableNodes.size();i++)
    {
        if (!computableNodes[i])
        {
            this-&gt;nodeBook.disable(i,true);
        }
    }
}

</t>
<t tx="leo.20201108101543.3">void RSolverFluidParticle::updateScales(void)
{

}

</t>
<t tx="leo.20201108101543.30">void RSolverGeneric::generateMaterialVecor(RMaterialPropertyType materialPropertyType, RRVector &amp;materialPropertyValues) const
{
    unsigned int ne = this-&gt;pModel-&gt;getNElements();

    materialPropertyValues.resize(ne,0.0);

    for (unsigned int i=0;i&lt;this-&gt;pModel-&gt;getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = this-&gt;pModel-&gt;getElementGroupPtr(i);
        if (!pElementGroup)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Element group could not be found (%u of %u).",i,this-&gt;pModel-&gt;getNElementGroups());
        }

        const RMaterial &amp;material = pElementGroup-&gt;getMaterial();

        // Get material property
        unsigned int materialPropertyPosition = material.findPosition(materialPropertyType);
        if (materialPropertyPosition == material.size())
        {
//            RLogger::warning("Could not find material property \'%s\' in element group \'%s\'\n",
//                             RMaterialProperty::getName(materialPropertyType).toUtf8().constData(),
//                             pElementGroup-&gt;getName().toUtf8().constData());
            continue;
        }
        const RMaterialProperty &amp;materialProperty = material.get(materialPropertyPosition);

        // Apply values to element vectors.
        for (unsigned int j=0;j&lt;pElementGroup-&gt;size();j++)
        {
            unsigned int elementID = pElementGroup-&gt;get(j);
            double temperature = this-&gt;elementTemperature[elementID];
            materialPropertyValues[elementID] = materialProperty.get(temperature);
        }
    }
}

</t>
<t tx="leo.20201108101543.31">void RSolverGeneric::generateVariableVector(RVariableType variableType,
                                            RRVector &amp;variableValues,
                                            RBVector &amp;setValues,
                                            bool boundaryConditions,
                                            bool initialConditions,
                                            bool environmentConditions,
                                            bool onlyExplicitBcs) const
{
    unsigned int ne = this-&gt;pModel-&gt;getNElements();

    variableValues.resize(ne,0.0);
    setValues.resize(ne,false);

    for (unsigned int i=0;i&lt;this-&gt;pModel-&gt;getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = this-&gt;pModel-&gt;getElementGroupPtr(i);
        if (!pElementGroup)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Element group could not be found (%u of %u).",i,this-&gt;pModel-&gt;getNElementGroups());
        }

        if (environmentConditions)
        {
            // Apply environment conditions.
            for (unsigned int j=0;j&lt;pElementGroup-&gt;getNEnvironmentConditions();j++)
            {
                const REnvironmentCondition &amp;ec = pElementGroup-&gt;getEnvironmentCondition(j);
                unsigned int ecComponentPosition = ec.findComponentPosition(variableType);
                if (ecComponentPosition == RConstants::eod)
                {
                    continue;
                }
                const RConditionComponent &amp;conditionComponent = ec.getComponent(ecComponentPosition);
                double value = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

                for (unsigned int k=0;k&lt;pElementGroup-&gt;size();k++)
                {
                    variableValues[pElementGroup-&gt;get(k)] = value;
                    setValues[pElementGroup-&gt;get(k)] = true;
                }
            }
        }

        if (initialConditions)
        {
            // Apply initial conditions.
            for (unsigned int j=0;j&lt;pElementGroup-&gt;getNInitialConditions();j++)
            {
                const RInitialCondition &amp;ic = pElementGroup-&gt;getInitialCondition(j);
                unsigned int icComponentPosition = ic.findComponentPosition(variableType);
                if (icComponentPosition == RConstants::eod)
                {
                    continue;
                }
                const RConditionComponent &amp;conditionComponent = ic.getComponent(icComponentPosition);
                double value = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

                for (unsigned int k=0;k&lt;pElementGroup-&gt;size();k++)
                {
                    variableValues[pElementGroup-&gt;get(k)] = value;
                    setValues[pElementGroup-&gt;get(k)] = true;
                }
            }
        }

        if (boundaryConditions)
        {
            // Apply boundary conditions.
            for (unsigned int j=0;j&lt;pElementGroup-&gt;getNBoundaryConditions();j++)
            {
                const RBoundaryCondition &amp;bc = pElementGroup-&gt;getBoundaryCondition(j);
                if (onlyExplicitBcs &amp;&amp; !bc.getExplicit())
                {
                    continue;
                }
                unsigned int bcComponentPosition = bc.findComponentPosition(variableType);
                if (bcComponentPosition == RConstants::eod)
                {
                    continue;
                }
                const RConditionComponent &amp;conditionComponent = bc.getComponent(bcComponentPosition);
                double value = conditionComponent.get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

                for (unsigned int k=0;k&lt;pElementGroup-&gt;size();k++)
                {
                    variableValues[pElementGroup-&gt;get(k)] = value;
                    setValues[pElementGroup-&gt;get(k)] = true;
                }
            }
        }
    }
}

</t>
<t tx="leo.20201108101543.32">void RSolverGeneric::recoverVariable(RVariableType variableType,
                                     RVariableApplyType applyType,
                                     uint expectedSize,
                                     uint vectorPosition,
                                     RRVector &amp;variableValues,
                                     double defaultValue) const
{
    variableValues.resize(expectedSize);
    variableValues.fill(defaultValue);

    uint variablePosition = this-&gt;pModel-&gt;findVariable(variableType);

    if (variablePosition != RConstants::eod)
    {
        const RVariable &amp;rVariable = this-&gt;pModel-&gt;getVariable(variablePosition);
        if (rVariable.getApplyType() == applyType)
        {
            variableValues = rVariable.getValues(vectorPosition);
        }
    }

    R_ERROR_ASSERT(variableValues.size() == expectedSize);
}

</t>
<t tx="leo.20201108101543.33">void RSolverGeneric::syncShared(const QString &amp;keyName, RRVector &amp;values)
{
    if (this-&gt;taskIteration == 0)
    {
        this-&gt;pSharedData-&gt;addData(keyName, values);
    }
    else
    {
        if (this-&gt;pSharedData-&gt;hasData(keyName,uint(values.size())))
        {
            values = this-&gt;pSharedData-&gt;findData(keyName);
        }
    }
}

</t>
<t tx="leo.20201108101543.34">void RSolverGeneric::findComputableElements(RProblemType problemType)
{
    this-&gt;computableElements.resize(this-&gt;pModel-&gt;getNElements());
    this-&gt;computableElements.fill(false);

    std::vector&lt;RMaterialPropertyType&gt; propList;

    bool needsMaterial = (RMaterialProperty::getTypes(problemType).size() &gt; 0);

    if (needsMaterial)
    {
        for (uint i=0;i&lt;R_MATERIAL_PROPERTY_N_TYPES;i++)
        {
            if (problemType &amp; RMaterialProperty::getProblemTypeMask(RMaterialPropertyType(i)))
            {
                propList.push_back(RMaterialPropertyType(i));
            }
        }
    }
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElementGroups();i++)
    {
        const RElementGroup *pElementGroup = this-&gt;pModel-&gt;getElementGroupPtr(i);
        const RMaterial &amp;rMaterial = pElementGroup-&gt;getMaterial();
        if (!needsMaterial || rMaterial.hasProperties(propList))
        {
            for (uint j=0;j&lt;pElementGroup-&gt;size();j++)
            {
                this-&gt;computableElements[pElementGroup-&gt;get(j)] = true;
            }
            continue;
        }
        for (uint j=0;j&lt;pElementGroup-&gt;getNBoundaryConditions();j++)
        {
            const RBoundaryCondition &amp;rBoundaryCondition = pElementGroup-&gt;getBoundaryCondition(j);
            if (problemType &amp; RBoundaryCondition::getProblemTypeMask(rBoundaryCondition.getType()))
            {
                for (uint k=0;k&lt;pElementGroup-&gt;size();k++)
                {
                    this-&gt;computableElements[pElementGroup-&gt;get(k)] = true;
                }
            }
        }
    }
}

</t>
<t tx="leo.20201108101543.35">void RSolverGeneric::findIncludableElements(void)
{
    this-&gt;includableElements = this-&gt;computableElements;

    RBVector computableNodes(this-&gt;pModel-&gt;getNNodes(),false);

    for (uint i=0;i&lt;this-&gt;computableElements.size();i++)
    {
        if (this-&gt;computableElements[i])
        {
            const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(i);
            for (uint j=0;j&lt;rElement.size();j++)
            {
                computableNodes[rElement.getNodeId(j)] = true;
            }
        }
    }

    for (uint i=0;i&lt;this-&gt;includableElements.size();i++)
    {
        if (!this-&gt;includableElements[i])
        {
            const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(i);
            uint nComputable = 0;
            for (uint j=0;j&lt;rElement.size();j++)
            {
                if (computableNodes[rElement.getNodeId(j)])
                {
                    nComputable++;
                }
            }
            if (nComputable == rElement.size())
            {
                this-&gt;includableElements[i] = true;
            }
        }
    }

}

</t>
<t tx="leo.20201108101543.36">void RSolverGeneric::findInwardElements(void)
{
    this-&gt;inwardElements.resize(this-&gt;pModel-&gt;getNElements());
    this-&gt;inwardElements.fill(false);

    // Assuming that surface normals are synchronized.

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        const RSurface &amp;rSurface = this-&gt;pModel-&gt;getSurface(i);

        bool isInward = false;

        for (uint j=0;j&lt;rSurface.size();j++)
        {
            uint elementID = rSurface.get(j);
            uint volumeElementID = RConstants::eod;
            if (!this-&gt;includableElements[elementID])
            {
                continue;
            }
            const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);
            // Find related volume element.
            for (uint l=0;l&lt;this-&gt;pModel-&gt;getNElements();l++)
            {
                if (!this-&gt;computableElements[l])
                {
                    continue;
                }
                const RElement &amp;rVolumeElement = this-&gt;pModel-&gt;getElement(l);
                if (R_ELEMENT_TYPE_IS_VOLUME(rVolumeElement.getType()))
                {
                    uint nNodesFound = 0;
                    for (uint m=0;m&lt;rElement.size();m++)
                    {
                        if (rVolumeElement.hasNodeId(rElement.getNodeId(m)))
                        {
                            nNodesFound++;
                        }
                    }
                    if (nNodesFound == rElement.size())
                    {
                        volumeElementID = l;
                        break;
                    }
                }
            }
            if (volumeElementID != RConstants::eod)
            {
                const RElement &amp;rVolumeElement = this-&gt;pModel-&gt;getElement(volumeElementID);

                std::vector&lt;RElement&gt; edgeElements = rVolumeElement.generateEdgeElements();

                RR3Vector elementNormal;
                rElement.findNormal(this-&gt;pModel-&gt;getNodes(),elementNormal[0],elementNormal[1],elementNormal[2]);

                for (uint l=0;l&lt;edgeElements.size();l++)
                {
                    uint nNodesFound = 0;
                    for (uint m=0;m&lt;rElement.size();m++)
                    {
                        if (edgeElements[l].hasNodeId(rElement.getNodeId(m)))
                        {
                            nNodesFound++;
                        }
                    }
                    if (nNodesFound == rElement.size())
                    {
                        RR3Vector edgeElementNormal;
                        edgeElements[l].findNormal(this-&gt;pModel-&gt;getNodes(),edgeElementNormal[0],edgeElementNormal[1],edgeElementNormal[2]);

                        if (std::fabs(RR3Vector::angle(elementNormal,edgeElementNormal)) &lt; RConstants::pi/2.0)
                        {
                            isInward = true;
                        }
                    }
                }

                break;
            }
        }
        for (uint j=0;j&lt;rSurface.size();j++)
        {
            this-&gt;inwardElements[rSurface.get(j)] = isInward;
        }
    }
}

</t>
<t tx="leo.20201108101543.37">void RSolverGeneric::processMonitoringPoints(void) const
{
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getMonitoringPointManager().size();i++)
    {
        RMonitoringPoint &amp;rMonitorinPoint = this-&gt;pModel-&gt;getMonitoringPointManager()[i];

        unsigned int variableID = this-&gt;pModel-&gt;findVariable(rMonitorinPoint.getVariableType());
        if (variableID == RConstants::eod)
        {
            RLogger::warning("Monitoring point variable (%s) was not found among the results\n",
                             RVariable::getName(rMonitorinPoint.getVariableType()).toUtf8().constData());
            continue;
        }
        RVariable &amp;rVariable = this-&gt;pModel-&gt;getVariable(variableID);

        RNode iNode(rMonitorinPoint.getPosition());

        unsigned int elementID = RConstants::eod;
        for (unsigned int j=0;j&lt;this-&gt;pModel-&gt;getNElements();j++)
        {
            if (this-&gt;pModel-&gt;getElement(j).isInside(this-&gt;pModel-&gt;getNodes(),iNode))
            {
                elementID = j;
            }
        }
        if (elementID == RConstants::eod)
        {
            RLogger::warning("Monitoring point [%g %g %g] is outside of the model\n",
                             rMonitorinPoint.getPosition()[0],
                             rMonitorinPoint.getPosition()[1],
                             rMonitorinPoint.getPosition()[2]);
            continue;
        }

        RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);

        RValueVector valueVector;
        valueVector.resize(rVariable.getNVectors());

        if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            RRVector values(rVariable.getValueVector(elementID));
            for (unsigned int j=0;j&lt;values.size();j++)
            {
                valueVector[j] = values[j];
            }
        }
        else if (rVariable.getApplyType() == R_VARIABLE_APPLY_NODE)
        {
            std::vector&lt;RRVector&gt; values(rElement.size());
            for (unsigned int j=0;j&lt;rElement.size();j++)
            {
                values[j] = rVariable.getValueVector(rElement.getNodeId(j));
            }

            for (unsigned int j=0;j&lt;rVariable.getNVectors();j++)
            {
                RRVector nodeValues(rElement.size());
                for (unsigned int k=0;k&lt;rElement.size();k++)
                {
                    nodeValues[k] = values[k][j];
                }
                valueVector[j] = rElement.interpolate(this-&gt;pModel-&gt;getNodes(),iNode,nodeValues);
            }
        }

        try
        {
            rMonitorinPoint.writeValueVectorToFile(this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStep()+1,valueVector);
        }
        catch (const RError &amp;error)
        {
            RLogger::error("Failed to write monitoring point. %s\n",error.getMessage().toUtf8().constData());
        }
    }
}

</t>
<t tx="leo.20201108101543.38">void RSolverGeneric::printStats(RVariableType variableType) const
{
    unsigned int variablePosition = this-&gt;pModel-&gt;findVariable(variableType);
    if (variablePosition == RConstants::eod)
    {
        return;
    }
    const RVariable &amp;rVariable = this-&gt;pModel-&gt;getVariable(variablePosition);

    RStatistics stat(rVariable.getValues(),100,true);

    RLogger::info("%s [%s]\n",rVariable.getName().toUtf8().constData(),rVariable.getUnits().toUtf8().constData());
    RLogger::indent();
    stat.print();
    RLogger::unindent();
}
</t>
<t tx="leo.20201108101543.39">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolverheat.cpp                                          *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   12-th December 2012                                      *
 *                                                                   *
 *  DESCRIPTION: Heat-transfer solver class definition               *
 *********************************************************************/

#include &lt;rblib.h&gt;

#include "rsolverheat.h"
#include "rconvection.h"
#include "rmatrixsolver.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101543.4">void RSolverFluidParticle::recover(void)
{
    this-&gt;recoveryStopWatch.reset();
    this-&gt;recoveryStopWatch.resume();
    this-&gt;recoverVariable(R_VARIABLE_PARTICLE_CONCENTRATION,
                          R_VARIABLE_APPLY_NODE,
                          this-&gt;pModel-&gt;getNNodes(),
                          0,
                          this-&gt;nodeConcentration,
                          0.0);
    this-&gt;recoverVariable(R_VARIABLE_PARTICLE_RATE,
                          R_VARIABLE_APPLY_ELEMENT,
                          this-&gt;pModel-&gt;getNNodes(),
                          0,
                          this-&gt;elementRate,
                          0.0);
    this-&gt;recoverVariable(R_VARIABLE_VELOCITY,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),0,this-&gt;nodeVelocity.x,0.0);
    this-&gt;recoverVariable(R_VARIABLE_VELOCITY,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),1,this-&gt;nodeVelocity.y,0.0);
    this-&gt;recoverVariable(R_VARIABLE_VELOCITY,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),2,this-&gt;nodeVelocity.z,0.0);
    this-&gt;recoveryStopWatch.pause();
}

</t>
<t tx="leo.20201108101543.40">void RSolverHeat::_init(const RSolverHeat *pHeatSolver)
{
    if (pHeatSolver)
    {
        this-&gt;elementCapacity = pHeatSolver-&gt;elementCapacity;
        this-&gt;elementConduction = pHeatSolver-&gt;elementConduction;
        this-&gt;elementDensity = pHeatSolver-&gt;elementDensity;
        this-&gt;nodeTemperature = pHeatSolver-&gt;nodeTemperature;
        this-&gt;elementHeat = pHeatSolver-&gt;elementHeat;
        this-&gt;elementRadiativeHeat = pHeatSolver-&gt;elementRadiativeHeat;
        this-&gt;elementJouleHeat = pHeatSolver-&gt;elementJouleHeat;
        this-&gt;elementHeatFlux = pHeatSolver-&gt;elementHeatFlux;
    }
}

RSolverHeat::RSolverHeat(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
{
    this-&gt;problemType = R_PROBLEM_HEAT;
    this-&gt;_init();
}

RSolverHeat::RSolverHeat(const RSolverHeat &amp;heatSolver)
    : RSolverGeneric(heatSolver)
{
    this-&gt;_init(&amp;heatSolver);
}

RSolverHeat::~RSolverHeat()
{
}

RSolverHeat &amp;RSolverHeat::operator =(const RSolverHeat &amp;heatSolver)
{
    RSolverGeneric::operator =(heatSolver);
    this-&gt;_init(&amp;heatSolver);
    return (*this);
}

</t>
<t tx="leo.20201108101543.41">bool RSolverHeat::hasConverged(void) const
{
    return true;
}

double RSolverHeat::findTemperatureScale(void) const
{
    return 1.0;
}

</t>
<t tx="leo.20201108101543.42">void RSolverHeat::updateScales(void)
{
    this-&gt;scales.setMetre(this-&gt;findMeshScale());
    this-&gt;scales.setKelvin(this-&gt;findTemperatureScale());
}

</t>
<t tx="leo.20201108101543.43">void RSolverHeat::recover(void)
{
    this-&gt;recoverVariable(R_VARIABLE_TEMPERATURE,
                          R_VARIABLE_APPLY_NODE,
                          this-&gt;pModel-&gt;getNNodes(),
                          0,
                          this-&gt;nodeTemperature,
                          RVariable::getInitValue(R_VARIABLE_TEMPERATURE));
    this-&gt;recoverVariable(R_VARIABLE_HEAT,
                          R_VARIABLE_APPLY_ELEMENT,
                          this-&gt;pModel-&gt;getNElements(),
                          0,
                          this-&gt;elementHeat,
                          0.0);
    this-&gt;recoverVariable(R_VARIABLE_HEAT_RADIATION,
                          R_VARIABLE_APPLY_ELEMENT,
                          this-&gt;pModel-&gt;getNElements(),
                          0,
                          this-&gt;elementRadiativeHeat,
                          0.0);
    this-&gt;recoverVariable(R_VARIABLE_JOULE_HEAT,
                          R_VARIABLE_APPLY_ELEMENT,
                          this-&gt;pModel-&gt;getNElements(),
                          0,
                          this-&gt;elementJouleHeat,
                          0.0);
}

</t>
<t tx="leo.20201108101543.44">void RSolverHeat::prepare(void)
{
    RBVector temperatureSetValues;
    RBVector heatSetValues;

    this-&gt;generateNodeBook(R_PROBLEM_HEAT);

//    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeTemperature,this-&gt;elementTemperature);

    this-&gt;generateVariableVector(R_VARIABLE_TEMPERATURE,this-&gt;elementTemperature,temperatureSetValues,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_HEAT,this-&gt;elementHeat,heatSetValues,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_THERMAL_CONDUCTIVITY,this-&gt;elementConduction);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_HEAT_CAPACITY,this-&gt;elementCapacity);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_DENSITY,this-&gt;elementDensity);

    this-&gt;pModel-&gt;convertElementToNodeVector(this-&gt;elementTemperature,temperatureSetValues,this-&gt;nodeTemperature,true);

    this-&gt;b.resize(this-&gt;nodeBook.getNEnabled());
    this-&gt;x.resize(this-&gt;nodeBook.getNEnabled());

    this-&gt;A.clear();
    this-&gt;b.fill(0.0);
    this-&gt;x.fill(0.0);

    // Prepare point elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNPoints();i++)
    {
        RPoint &amp;point = this-&gt;pModel-&gt;getPoint(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(point.size());j++)
        {
            try
            {
                uint elementID = point.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_POINT(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size(),element.size());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());

                Me.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    for (unsigned m=0;m&lt;element.size();m++)
                    {
                        for (unsigned n=0;n&lt;element.size();n++)
                        {
                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
                            {
                                Me[m][n] += N[m] * N[n]
                                         * this-&gt;elementDensity[elementID]
                                         * this-&gt;elementCapacity[elementID]
                                         * detJ
                                         * shapeFunc.getW()
                                         * point.getVolume();
                            }
                        }
                        // Force
                        fe[m] += (this-&gt;elementHeat[elementID] + this-&gt;elementJouleHeat[elementID]) * N[m] * detJ * shapeFunc.getW();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare line elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        RLine &amp;line = this-&gt;pModel-&gt;getLine(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(line.size());j++)
        {
            try
            {
                uint elementID = line.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_LINE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size(),element.size());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());

                RRMatrix B(element.size(),1);

                Me.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += dN[m][0]*J[0][0];
                    }

                    for (unsigned m=0;m&lt;element.size();m++)
                    {
                        for (unsigned n=0;n&lt;element.size();n++)
                        {
                            // Conduction
                            double kcnd = (B[m][0]*B[n][0]) * line.getCrossArea() * this-&gt;elementConduction[elementID];

                            Ke[m][n] += kcnd * detJ * shapeFunc.getW();

                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
                            {
                                Me[m][n] += N[m] * N[n]
                                         * this-&gt;elementDensity[elementID]
                                         * this-&gt;elementCapacity[elementID]
                                         * detJ
                                         * shapeFunc.getW()
                                         * line.getCrossArea();
                            }
                        }
                        // Force
                        fe[m] += (this-&gt;elementHeat[elementID] + this-&gt;elementJouleHeat[elementID]) * N[m] * detJ * shapeFunc.getW();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare surface elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        RSurface &amp;surface = this-&gt;pModel-&gt;getSurface(i);

        double htc = 0.0;
        double htt = 0.0;

        this-&gt;getSimpleConvection(surface,htc,htt);
        this-&gt;getForcedConvection(surface,htc,htt);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(surface.size());j++)
        {
            try
            {
                uint elementID = surface.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_SURFACE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size(),element.size());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());
                RRMatrix B(element.size(),2);

                this-&gt;getNaturalConvection(surface,elementID,htc,htt);

                Me.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1]);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1]);
                    }

                    for (unsigned m=0;m&lt;element.size();m++)
                    {
                        for (unsigned n=0;n&lt;element.size();n++)
                        {
                            // Conduction
                            double kcnd = (B[m][0]*B[n][0]+B[m][1]*B[n][1]) * surface.getThickness() * this-&gt;elementConduction[elementID];
                            // Convection
                            double kcnv = N[m] * N[n] * htc;

                            Ke[m][n] += (kcnd + kcnv) * detJ * shapeFunc.getW();

                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
                            {
                                Me[m][n] += N[m] * N[n]
                                         * this-&gt;elementDensity[elementID]
                                         * this-&gt;elementCapacity[elementID]
                                         * detJ
                                         * shapeFunc.getW()
                                         * surface.getThickness();
                            }
                        }
                        // Force
                        fe[m] += (this-&gt;elementHeat[elementID] + this-&gt;elementRadiativeHeat[elementID] + this-&gt;elementJouleHeat[elementID]) * N[m] * detJ * shapeFunc.getW();
                    }
                }

                // Convection force
                double elementArea = 0.0;
                if (element.findArea(this-&gt;pModel-&gt;getNodes(),elementArea))
                {
                    for (unsigned m=0;m&lt;element.size();m++)
                    {
                        fe[m] += htc * htt * elementArea / element.size();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare volume elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        RVolume &amp;volume = this-&gt;pModel-&gt;getVolume(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(volume.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = volume.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_VOLUME(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size(),element.size());
                RRMatrix Ke(element.size(),element.size());
                RRVector fe(element.size());
                RRMatrix B(element.size(),3);

                Me.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                // Conduction
                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]);
                        B[m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]);
                    }

                    for (unsigned m=0;m&lt;element.size();m++)
                    {
                        for (unsigned n=0;n&lt;element.size();n++)
                        {
                            // Conduction
                            Ke[m][n] += (B[m][0]*B[n][0] + B[m][1]*B[n][1] + B[m][2]*B[n][2])
                                     * this-&gt;elementConduction[elementID]
                                     * detJ
                                     * shapeFunc.getW();

                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
                            {
                                Me[m][n] += N[m] * N[n]
                                         * this-&gt;elementDensity[elementID]
                                         * this-&gt;elementCapacity[elementID]
                                         * detJ
                                         * shapeFunc.getW();
                            }
                        }
                        // Force
                        fe[m] += (this-&gt;elementHeat[elementID] + this-&gt;elementJouleHeat[elementID]) * N[m] * detJ * shapeFunc.getW();
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }
}

</t>
<t tx="leo.20201108101543.45">void RSolverHeat::solve(void)
{
    try
    {
        RLogger::indent();
        RMatrixSolver matrixSolver(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));
        matrixSolver.solve(this-&gt;A,this-&gt;b,this-&gt;x,R_MATRIX_PRECONDITIONER_JACOBI,1);
        RLogger::unindent();
    }
    catch (RError error)
    {
        RLogger::unindent();
        throw error;
    }

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        uint position;
        if (this-&gt;nodeBook.getValue(i,position))
        {
            this-&gt;nodeTemperature[i] = this-&gt;x[position];
        }
    }

    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeTemperature,this-&gt;elementTemperature);
}

</t>
<t tx="leo.20201108101543.46">void RSolverHeat::process(void)
{
//    RLogger::info("Processing results\n");
    double Qx;
    double Qy;
    double Qz;

    // Initialize heat flux vector vector
    this-&gt;elementHeatFlux.resize(this-&gt;pModel-&gt;getNElements(),RR3Vector(0.0,0.0,0.0));

    // Process line elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        RLine &amp;line = this-&gt;pModel-&gt;getLine(i);

        for (uint j=0;j&lt;line.size();j++)
        {
            uint elementID = line.get(j);

            if (!this-&gt;computableElements[elementID])
            {
                continue;
            }

            const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
            uint nInp = RElement::getNIntegrationPoints(element.getType());
            RRVector B(element.size());

            Qx = Qy = Qz = 0.0;

            // Conduction
            if (line.getCrossArea() &gt; 0.0)
            {
                double Qi = 0.0;

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    if (line.getCrossArea() != 0.0)
                    {
                        for (uint m=0;m&lt;dN.getNRows();m++)
                        {
                            B[m] += dN[m][0] * J[0][0] * detJ / double(nInp);
                        }
                    }
                }

                for (uint k=0;k&lt;element.size();k++)
                {
                    uint nodeID = element.getNodeId(k);

                    Qi -= B[k] * this-&gt;elementConduction[elementID] * this-&gt;nodeTemperature[nodeID];
                }

                RRMatrix R;
                RRVector t;
                this-&gt;pModel-&gt;getElement(elementID).findTransformationMatrix(this-&gt;pModel-&gt;getNodes(),R,t);

                Qx += R[0][0]*Qi;
                Qy += R[1][0]*Qi;
                Qz += R[2][0]*Qi;
            }

            this-&gt;elementHeatFlux[elementID][0] = Qx;
            this-&gt;elementHeatFlux[elementID][1] = Qy;
            this-&gt;elementHeatFlux[elementID][2] = Qz;
        }
    }

    // Process surface elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        RSurface &amp;surface = this-&gt;pModel-&gt;getSurface(i);

        double htc = 0.0;
        double htt = 0.0;

        this-&gt;getSimpleConvection(surface,htc,htt);
        this-&gt;getForcedConvection(surface,htc,htt);

        for (uint j=0;j&lt;surface.size();j++)
        {
            uint elementID = surface.get(j);

            if (!this-&gt;computableElements[elementID])
            {
                continue;
            }

            const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
            uint nInp = RElement::getNIntegrationPoints(element.getType());
            RRMatrix B(element.size(),2);

            this-&gt;getNaturalConvection(surface,elementID,htc,htt);

            Qx = Qy = Qz = 0.0;

            // Conduction
            if (surface.getThickness() &gt; 0.0)
            {
                double Qi = 0.0;
                double Qj = 0.0;

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    if (surface.getThickness() != 0.0)
                    {
                        for (uint m=0;m&lt;dN.getNRows();m++)
                        {
                            B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1]) * detJ / double(nInp);
                            B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1]) * detJ / double(nInp);
                        }
                    }
                }

                for (uint k=0;k&lt;element.size();k++)
                {
                    uint nodeID = element.getNodeId(k);

                    Qi -= B[k][0] * this-&gt;elementConduction[elementID] * this-&gt;nodeTemperature[nodeID];
                    Qj -= B[k][1] * this-&gt;elementConduction[elementID] * this-&gt;nodeTemperature[nodeID];
                }

                RRMatrix R;
                RRVector t;
                this-&gt;pModel-&gt;getElement(elementID).findTransformationMatrix(this-&gt;pModel-&gt;getNodes(),R,t);

                Qx += R[0][0]*Qi + R[0][1]*Qj;
                Qy += R[1][0]*Qi + R[1][1]*Qj;
                Qz += R[2][0]*Qi + R[2][1]*Qj;
            }

            // Convection
            if (htc &gt; 0.0)
            {
                RR3Vector normal;
                double area;
                if (element.findNormal(this-&gt;pModel-&gt;getNodes(),normal[0],normal[1],normal[2]) &amp;&amp;
                    element.findArea(this-&gt;pModel-&gt;getNodes(),area))
                {
                    double Qhe = htc * area * (htt - this-&gt;elementTemperature[elementID]);
                    Qx += normal[0] * Qhe;
                    Qy += normal[1] * Qhe;
                    Qz += normal[2] * Qhe;
                }
            }


            this-&gt;elementHeatFlux[elementID][0] = Qx;
            this-&gt;elementHeatFlux[elementID][1] = Qy;
            this-&gt;elementHeatFlux[elementID][2] = Qz;
        }
    }

    // Process volume elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        RVolume &amp;volume = this-&gt;pModel-&gt;getVolume(i);

        for (uint j=0;j&lt;volume.size();j++)
        {
            uint elementID = volume.get(j);

            if (!this-&gt;computableElements[elementID])
            {
                continue;
            }

            const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
            uint nInp = RElement::getNIntegrationPoints(element.getType());
            RRMatrix B(element.size(),3);

            Qx = Qy = Qz = 0.0;

            B.fill(0.0);

            // Conduction
            for (uint k=0;k&lt;nInp;k++)
            {
                const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                const RRMatrix &amp;dN = shapeFunc.getDN();
                RRMatrix J, Rt;
                double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                for (uint m=0;m&lt;dN.getNRows();m++)
                {
                    B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]) * detJ / double(nInp);
                    B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]) * detJ / double(nInp);
                    B[m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]) * detJ / double(nInp);
                }
            }

            for (uint m=0;m&lt;element.size();m++)
            {
                uint nodeID = element.getNodeId(m);

                Qx -= B[m][0] * this-&gt;elementConduction[elementID] * this-&gt;nodeTemperature[nodeID];
                Qy -= B[m][1] * this-&gt;elementConduction[elementID] * this-&gt;nodeTemperature[nodeID];
                Qz -= B[m][2] * this-&gt;elementConduction[elementID] * this-&gt;nodeTemperature[nodeID];
            }

            this-&gt;elementHeatFlux[elementID][0] = Qx;
            this-&gt;elementHeatFlux[elementID][1] = Qy;
            this-&gt;elementHeatFlux[elementID][2] = Qz;
        }
    }
}

</t>
<t tx="leo.20201108101543.47">void RSolverHeat::store(void)
{
    RLogger::info("Storing results\n");
    RLogger::indent();

    // Temperature
    uint temperaturePos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_TEMPERATURE);
    if (temperaturePos == RConstants::eod)
    {
        temperaturePos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_TEMPERATURE);
        this-&gt;pModel-&gt;getVariable(temperaturePos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumValue(this-&gt;nodeTemperature),
                    RStatistics::findMaximumValue(this-&gt;nodeTemperature));
    }
    RVariable &amp;temperature =  this-&gt;pModel-&gt;getVariable(temperaturePos);

    temperature.setApplyType(R_VARIABLE_APPLY_NODE);
    temperature.resize(1,this-&gt;pModel-&gt;getNNodes());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        temperature.setValue(0,i,this-&gt;nodeTemperature[i]);
    }

    // Heat flux
    uint heatFluxPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_HEAT_FLUX);
    if (heatFluxPos == RConstants::eod)
    {
        heatFluxPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_HEAT_FLUX);
        this-&gt;pModel-&gt;getVariable(heatFluxPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumMagnitude(this-&gt;elementHeatFlux),
                    RStatistics::findMaximumMagnitude(this-&gt;elementHeatFlux));
    }
    RVariable &amp;heatFlux =  this-&gt;pModel-&gt;getVariable(heatFluxPos);

    heatFlux.setApplyType(R_VARIABLE_APPLY_ELEMENT);
    heatFlux.resize(3,this-&gt;pModel-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        heatFlux.setValue(0,i,this-&gt;elementHeatFlux[i][0]);
        heatFlux.setValue(1,i,this-&gt;elementHeatFlux[i][1]);
        heatFlux.setValue(2,i,this-&gt;elementHeatFlux[i][2]);
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101543.48">void RSolverHeat::statistics(void)
{
    this-&gt;printStats(R_VARIABLE_TEMPERATURE);
    this-&gt;printStats(R_VARIABLE_HEAT_FLUX);
    this-&gt;processMonitoringPoints();
}

</t>
<t tx="leo.20201108101543.49">void RSolverHeat::assemblyMatrix(uint elementID, const RRMatrix &amp;Me, const RRMatrix &amp;Ke, const RRVector &amp;fe)
{
    double alpha = this-&gt;pModel-&gt;getTimeSolver().getTimeMarchApproximationCoefficient();
    double dt = this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStepSize();

    const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);

    RRMatrix Ae(element.size(),element.size());
    RRVector be(element.size());

    Ae.fill(0.0);
    be.fill(0.0);

    if (this-&gt;pModel-&gt;getTimeSolver().getEnabled())
    {
        for (unsigned m=0;m&lt;element.size();m++)
        {
            be[m] = dt * fe[m];
            for (unsigned n=0;n&lt;element.size();n++)
            {
                Ae[m][n] = Me[m][n] + alpha * dt * Ke[m][n];
                be[m] += (Me[m][n] - (1.0 - alpha) * dt * Ke[m][n]) * this-&gt;nodeTemperature[element.getNodeId(n)];
            }
        }
    }
    else
    {
        Ae = Ke;
        be = fe;
    }

    // Apply explicit boundary conditions.
    for (uint m=0;m&lt;element.size();m++)
    {
        uint position;
        uint nodeID = element.getNodeId(m);
        if (!this-&gt;nodeBook.getValue(nodeID,position))
        {
            for (uint n=0;n&lt;element.size();n++)
            {
                be[n] -= Ae[n][m] * this-&gt;nodeTemperature[nodeID];
            }
        }
    }


    // Assembly final matrix system
    for (uint m=0;m&lt;element.size();m++)
    {
        uint mp;

        if (this-&gt;nodeBook.getValue(element.getNodeId(m),mp))
        {
            this-&gt;b[mp] += be[m];
            for (uint n=0;n&lt;element.size();n++)
            {
                uint np = 0;

                if (this-&gt;nodeBook.getValue(element.getNodeId(n),np))
                {
                    this-&gt;A.addValue(mp,np,Ae[m][n]);
                }
            }
        }
    }
}

</t>
<t tx="leo.20201108101543.5">void RSolverFluidParticle::prepare(void)
{
    RLogger::info("Building matrix system\n");
    RLogger::indent();

    this-&gt;buildStopWatch.reset();
    this-&gt;assemblyStopWatch.reset();

    RBVector concentrationSetValues;

    this-&gt;generateNodeBook(R_PROBLEM_FLUID_PARTICLE);

    this-&gt;generateVariableVector(R_VARIABLE_PARTICLE_CONCENTRATION,this-&gt;elementConcentration,concentrationSetValues,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_DENSITY,this-&gt;elementDensity);
    this-&gt;elementDiffusion.resize(this-&gt;pModel-&gt;getNElements());
    this-&gt;elementDiffusion.fill(0.0); // TODO: Diffusion not yet implemented

    this-&gt;generateNodeRateVector();

    this-&gt;pModel-&gt;convertElementToNodeVector(this-&gt;elementConcentration,concentrationSetValues,this-&gt;nodeConcentration,true);

    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeVelocity.x,this-&gt;elementVelocity.x);
    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeVelocity.y,this-&gt;elementVelocity.y);
    this-&gt;pModel-&gt;convertNodeToElementVector(this-&gt;nodeVelocity.z,this-&gt;elementVelocity.z);

    this-&gt;computeShapeDerivatives();
    this-&gt;streamVelocity = RSolverFluid::computeStreamVelocity(*this-&gt;pModel,this-&gt;nodeVelocity,false);

    this-&gt;b.resize(this-&gt;nodeBook.getNEnabled());
    this-&gt;x.resize(this-&gt;nodeBook.getNEnabled());

    this-&gt;A.clear();
    this-&gt;A.setNRows(this-&gt;nodeBook.getNEnabled());
    this-&gt;b.fill(0.0);
    this-&gt;x.fill(0.0);

    bool abort = false;

    RMatrixManager&lt;FluidParticleMatrixContainer&gt; matrixManager;

    // Compute element matrices
    #pragma omp parallel for default(shared) private(matrixManager)
    for (int64_t i=0;i&lt;int64_t(this-&gt;pModel-&gt;getNElements());i++)
    {
        uint elementID = i;

        const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);

        #pragma omp flush (abort)
        if (abort)
        {
            continue;
        }
        try
        {
            uint nen = element.size();

            RRMatrix Ae(nen,nen,0.0);
            RRVector be(nen,0.0);

            RStopWatch localStopWatch;
            localStopWatch.reset();

            if (R_ELEMENT_TYPE_IS_VOLUME(element.getType()))
            {
                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }
                localStopWatch.resume();
                this-&gt;computeElement(elementID,Ae,be,matrixManager);
                localStopWatch.pause();
            }
            #pragma omp critical
            {
                this-&gt;buildStopWatch.addElapsedTime(localStopWatch.getMiliSeconds());

                this-&gt;assemblyStopWatch.resume();
                this-&gt;assemblyMatrix(elementID,Ae,be);
                this-&gt;assemblyStopWatch.pause();
            }
        }
        catch (const RError &amp;rError)
        {
            #pragma omp critical
            {
                RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                abort = true;
            }
            #pragma omp flush (abort)
        }
    }

    if (abort)
    {
        RLogger::unindent();
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101543.50">bool RSolverHeat::getSimpleConvection(const RElementGroup &amp;elementGroup, double &amp;htc, double &amp;htt)
{
    if (!elementGroup.hasBoundaryCondition(R_BOUNDARY_CONDITION_CONVECTION_SIMPLE))
    {
        return false;
    }

    RBoundaryCondition bc = elementGroup.getBoundaryCondition(R_BOUNDARY_CONDITION_CONVECTION_SIMPLE);
    uint cPos = 0;

    cPos = bc.findComponentPosition(R_VARIABLE_CONVECTION_COEFFICIENT);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_CONVECTION_COEFFICIENT).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_SIMPLE).toUtf8().constData());
    }
    htc = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    cPos = bc.findComponentPosition(R_VARIABLE_FLUID_TEMPERATURE);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_FLUID_TEMPERATURE).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_SIMPLE).toUtf8().constData());
    }
    htt = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    return true;
}

</t>
<t tx="leo.20201108101543.51">bool RSolverHeat::getForcedConvection(const RElementGroup &amp;elementGroup, double &amp;htc, double &amp;htt)
{
    if (!elementGroup.hasBoundaryCondition(R_BOUNDARY_CONDITION_CONVECTION_FORCED))
    {
        return false;
    }

    RBoundaryCondition bc = elementGroup.getBoundaryCondition(R_BOUNDARY_CONDITION_CONVECTION_FORCED);
    uint cPos = 0;

    // Fluid temperature
    cPos = bc.findComponentPosition(R_VARIABLE_FLUID_TEMPERATURE);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_FLUID_TEMPERATURE).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_FORCED).toUtf8().constData());
    }
    htt = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Density
    cPos = bc.findComponentPosition(R_VARIABLE_DENSITY);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_DENSITY).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_FORCED).toUtf8().constData());
    }
    double ro = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Dynamic viscosity
    cPos = bc.findComponentPosition(R_VARIABLE_DYNAMIC_VISCOSITY);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_DYNAMIC_VISCOSITY).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_FORCED).toUtf8().constData());
    }
    double mu = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Heat capacity
    cPos = bc.findComponentPosition(R_VARIABLE_HEAT_CAPACITY);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_HEAT_CAPACITY).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_FORCED).toUtf8().constData());
    }
    double c = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Hydraulic diameter
    cPos = bc.findComponentPosition(R_VARIABLE_HYDRAULIC_DIAMETER);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_HYDRAULIC_DIAMETER).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_FORCED).toUtf8().constData());
    }
    double d = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Thermal conductivity
    cPos = bc.findComponentPosition(R_VARIABLE_THERMAL_CONDUCTIVITY);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_THERMAL_CONDUCTIVITY).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_FORCED).toUtf8().constData());
    }
    double k = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Mean velocity
    cPos = bc.findComponentPosition(R_VARIABLE_VELOCITY);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_VELOCITY).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_FORCED).toUtf8().constData());
    }
    double v = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    RConvection convection;

    convection.setType(R_CONVECTION_FORCED_EXTERNAL);
    convection.setMaterial("Custom material",mu,ro,k,c,0.0);
    convection.setDiameter(d);
    convection.setVelocity(v);
    convection.setFluidTemp(htt);

    htc = convection.calculateHtc();

    return true;
}

</t>
<t tx="leo.20201108101543.52">bool RSolverHeat::getNaturalConvection(const RElementGroup &amp;elementGroup, uint elementId, double &amp;htc, double &amp;htt)
{
    if (!elementGroup.hasBoundaryCondition(R_BOUNDARY_CONDITION_CONVECTION_NATURAL))
    {
        return false;
    }

    RBoundaryCondition bc = elementGroup.getBoundaryCondition(R_BOUNDARY_CONDITION_CONVECTION_NATURAL);
    uint cPos = 0;

    // Density
    cPos = bc.findComponentPosition(R_VARIABLE_DENSITY);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_DENSITY).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_NATURAL).toUtf8().constData());
    }
    double ro = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Dynamic viscosity
    cPos = bc.findComponentPosition(R_VARIABLE_DYNAMIC_VISCOSITY);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_DYNAMIC_VISCOSITY).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_NATURAL).toUtf8().constData());
    }
    double mu = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Fluid temperature
    cPos = bc.findComponentPosition(R_VARIABLE_FLUID_TEMPERATURE);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_FLUID_TEMPERATURE).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_NATURAL).toUtf8().constData());
    }
    htt = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Heat capacity
    cPos = bc.findComponentPosition(R_VARIABLE_HEAT_CAPACITY);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_HEAT_CAPACITY).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_NATURAL).toUtf8().constData());
    }
    double c = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Hydraulic diameter
    cPos = bc.findComponentPosition(R_VARIABLE_HYDRAULIC_DIAMETER);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_HYDRAULIC_DIAMETER).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_NATURAL).toUtf8().constData());
    }
    double d = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Thermal conductivity
    cPos = bc.findComponentPosition(R_VARIABLE_THERMAL_CONDUCTIVITY);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_THERMAL_CONDUCTIVITY).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_NATURAL).toUtf8().constData());
    }
    double k = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    // Thermal expansion coefficient
    cPos = bc.findComponentPosition(R_VARIABLE_THERMAL_EXPANSION_COEFFICIENT);
    if (cPos == RConstants::eod)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                     "Failed to find \'%s\' component in \'%s\' boundary condition.",
                     RVariable::getName(R_VARIABLE_THERMAL_EXPANSION_COEFFICIENT).toUtf8().constData(),
                     RBoundaryCondition::getName(R_BOUNDARY_CONDITION_CONVECTION_NATURAL).toUtf8().constData());
    }
    double b = bc.getComponent(cPos).get(this-&gt;pModel-&gt;getTimeSolver().getCurrentTime());

    RConvection convection;

    convection.setType(R_CONVECTION_NATURAL_EXTERNAL_HORIZONTAL_PLATES);
    convection.setMaterial("Custom material",mu,ro,k,c,b);
    convection.setDiameter(d);
    convection.setSurfTemp(this-&gt;elementTemperature[elementId]);
    convection.setFluidTemp(htt);

    htc = convection.calculateHtc();

    return true;
}
</t>
<t tx="leo.20201108101543.53">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolvermagnetostatics.cpp                                *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   20-th November 2015                                      *
 *                                                                   *
 *  DESCRIPTION: Magnetostatics solver class definition              *
 *********************************************************************/

#include "rsolvermagnetostatics.h"
#include "rmatrixsolver.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101543.54">void RSolverMagnetostatics::_init(const RSolverMagnetostatics *pSolver)
{
    if (pSolver)
    {
        this-&gt;nodeCurrentDensity = pSolver-&gt;nodeCurrentDensity;
        this-&gt;nodeMagneticField = pSolver-&gt;nodeMagneticField;
    }
}

RSolverMagnetostatics::RSolverMagnetostatics(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
{
    this-&gt;problemType = R_PROBLEM_MAGNETOSTATICS;
    this-&gt;_init();
}

RSolverMagnetostatics::RSolverMagnetostatics(const RSolverMagnetostatics &amp;solver)
    : RSolverGeneric(solver)
{
    this-&gt;_init(&amp;solver);
}

RSolverMagnetostatics::~RSolverMagnetostatics()
{

}

RSolverMagnetostatics &amp;RSolverMagnetostatics::operator =(const RSolverMagnetostatics &amp;solver)
{
    RSolverGeneric::operator =(solver);
    this-&gt;_init(&amp;solver);
    return (*this);
}

</t>
<t tx="leo.20201108101543.55">bool RSolverMagnetostatics::hasConverged(void) const
{
    return true;
}

</t>
<t tx="leo.20201108101543.56">void RSolverMagnetostatics::updateScales(void)
{

}

</t>
<t tx="leo.20201108101543.57">void RSolverMagnetostatics::recover(void)
{
    RRVector elementCurrentDensityX(this-&gt;pModel-&gt;getNElements(),0.0);
    RRVector elementCurrentDensityY(this-&gt;pModel-&gt;getNElements(),0.0);
    RRVector elementCurrentDensityZ(this-&gt;pModel-&gt;getNElements(),0.0);

    this-&gt;recoverVariable(R_VARIABLE_CURRENT_DENSITY,R_VARIABLE_APPLY_ELEMENT,this-&gt;pModel-&gt;getNElements(),0,elementCurrentDensityX,0.0);
    this-&gt;recoverVariable(R_VARIABLE_CURRENT_DENSITY,R_VARIABLE_APPLY_ELEMENT,this-&gt;pModel-&gt;getNElements(),1,elementCurrentDensityY,0.0);
    this-&gt;recoverVariable(R_VARIABLE_CURRENT_DENSITY,R_VARIABLE_APPLY_ELEMENT,this-&gt;pModel-&gt;getNElements(),2,elementCurrentDensityZ,0.0);

    this-&gt;pModel-&gt;convertElementToNodeVector(elementCurrentDensityX,RBVector(this-&gt;pModel-&gt;getNElements(),true),this-&gt;nodeCurrentDensity.x,false);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementCurrentDensityY,RBVector(this-&gt;pModel-&gt;getNElements(),true),this-&gt;nodeCurrentDensity.y,false);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementCurrentDensityZ,RBVector(this-&gt;pModel-&gt;getNElements(),true),this-&gt;nodeCurrentDensity.z,false);
}

</t>
<t tx="leo.20201108101543.58">void RSolverMagnetostatics::prepare(void)
{
    this-&gt;generateNodeBook(R_PROBLEM_MAGNETOSTATICS);

    this-&gt;b.resize(3*this-&gt;nodeBook.getNEnabled());
    this-&gt;x.resize(3*this-&gt;nodeBook.getNEnabled());

    this-&gt;A.clear();
    this-&gt;b.fill(0.0);
    this-&gt;x.fill(0.0);

    // Prepare volume elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        RVolume &amp;volume = this-&gt;pModel-&gt;getVolume(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(volume.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = volume.get(j);

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_VOLUME(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Ke(element.size()*3,element.size()*3);
                RRVector fe(element.size()*3);
                RRMatrix B(element.size(),3);

                Ke.fill(0.0);
                fe.fill(0.0);

                // Conduction
                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = this-&gt;pModel-&gt;getElement(elementID).findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]);
                        B[m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]);
                    }

                    for (unsigned m=0;m&lt;element.size();m++)
                    {
                        uint nodeID = element.getNodeId(m);
                        for (unsigned n=0;n&lt;element.size();n++)
                        {
                            double KeValue = (B[m][0]*B[n][0] + B[m][1]*B[n][1] + B[m][2]*B[n][2]) * detJ * shapeFunc.getW();
                            Ke[3*m+0][3*n+0] -= KeValue;
                            Ke[3*m+1][3*n+1] -= KeValue;
                            Ke[3*m+2][3*n+2] -= KeValue;
                        }
                        double feValue = N[m] * detJ * shapeFunc.getW() * RSolverGeneric::e0;

                        double jsx = - B[m][2] * this-&gt;nodeCurrentDensity.y[nodeID] + B[m][1] * this-&gt;nodeCurrentDensity.z[nodeID];
                        double jsy =   B[m][2] * this-&gt;nodeCurrentDensity.x[nodeID] - B[m][0] * this-&gt;nodeCurrentDensity.z[nodeID];
                        double jsz = - B[m][1] * this-&gt;nodeCurrentDensity.x[nodeID] + B[m][0] * this-&gt;nodeCurrentDensity.y[nodeID];

                        fe[3*m+0] += feValue * jsx;
                        fe[3*m+1] += feValue * jsy;
                        fe[3*m+2] += feValue * jsz;
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }
}

</t>
<t tx="leo.20201108101543.59">void RSolverMagnetostatics::solve(void)
{
    try
    {
        RLogger::indent();
        RMatrixSolver matrixSolver(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));
        matrixSolver.solve(this-&gt;A,this-&gt;b,this-&gt;x,R_MATRIX_PRECONDITIONER_JACOBI,1);
        RLogger::unindent();
    }
    catch (RError error)
    {
        RLogger::unindent();
        throw error;
    }

    this-&gt;nodeMagneticField.x.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeMagneticField.y.resize(this-&gt;pModel-&gt;getNNodes(),0.0);
    this-&gt;nodeMagneticField.z.resize(this-&gt;pModel-&gt;getNNodes(),0.0);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        uint position;
        if (this-&gt;nodeBook.getValue(i,position))
        {
            this-&gt;nodeMagneticField.x[i] = this-&gt;x[3*position+0];
            this-&gt;nodeMagneticField.y[i] = this-&gt;x[3*position+1];
            this-&gt;nodeMagneticField.z[i] = this-&gt;x[3*position+2];
        }
    }
}

</t>
<t tx="leo.20201108101543.6">void RSolverFluidParticle::solve(void)
{
    RLogger::info("Solving matrix system\n");
    RLogger::indent();

    this-&gt;solverStopWatch.reset();
    this-&gt;solverStopWatch.resume();

    try
    {
        RLogger::indent();
        RMatrixSolver matrixSolver(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::GMRES));
        matrixSolver.solve(this-&gt;A,this-&gt;b,this-&gt;x,R_MATRIX_PRECONDITIONER_JACOBI,1);
        RLogger::unindent();
    }
    catch (RError error)
    {
        RLogger::unindent();
        throw error;
    }

    this-&gt;solverStopWatch.pause();

    this-&gt;nodeConcentration.resize(this-&gt;pModel-&gt;getNNodes(),0.0);

    this-&gt;updateStopWatch.reset();
    this-&gt;updateStopWatch.resume();

    double cOld = RRVector::norm(this-&gt;nodeConcentration);

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        uint position = 0;
        if (this-&gt;nodeBook.getValue(i,position))
        {
            this-&gt;nodeConcentration[i] = std::max(this-&gt;x[position],0.0);
        }
    }

    double c = RRVector::norm(this-&gt;nodeConcentration);

    this-&gt;cvgC = (c - cOld) / this-&gt;scales.findScaleFactor(R_VARIABLE_PARTICLE_CONCENTRATION);

    this-&gt;updateStopWatch.pause();

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101543.60">void RSolverMagnetostatics::process(void)
{

}

</t>
<t tx="leo.20201108101543.61">void RSolverMagnetostatics::store(void)
{
    RLogger::info("Storing results\n");
    RLogger::indent();

    // Displacement
    uint magneticFieldPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_MAGNETIC_FIELD);
    if (magneticFieldPos == RConstants::eod)
    {
        magneticFieldPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_MAGNETIC_FIELD);

        double umin = 0.0;
        double umax = 0.0;
        for (uint i=0;i&lt;this-&gt;nodeMagneticField.x.size();i++)
        {
            @others
}

</t>
<t tx="leo.20201108101543.62">        double u = RR3Vector(this-&gt;nodeMagneticField.x[i],
                             this-&gt;nodeMagneticField.y[i],
                             this-&gt;nodeMagneticField.z[i]).length();
        if (i == 0)
        {
            umin = umax = u;
        }
        else
        {
            umin = std::min(umin,u);
            umax = std::max(umax,u);
        }
    }

    this-&gt;pModel-&gt;getVariable(magneticFieldPos).getVariableData().setMinMaxDisplayValue(umin,umax);
}
RVariable &amp;magneticField =  this-&gt;pModel-&gt;getVariable(magneticFieldPos);

magneticField.setApplyType(R_VARIABLE_APPLY_NODE);
magneticField.resize(3,this-&gt;pModel-&gt;getNNodes());
for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
{
    magneticField.setValue(0,i,this-&gt;nodeMagneticField.x[i]);
    magneticField.setValue(1,i,this-&gt;nodeMagneticField.y[i]);
    magneticField.setValue(2,i,this-&gt;nodeMagneticField.z[i]);
}

RLogger::unindent();
</t>
<t tx="leo.20201108101543.63">void RSolverMagnetostatics::statistics(void)
{
    this-&gt;printStats(R_VARIABLE_MAGNETIC_FIELD);
    this-&gt;processMonitoringPoints();
}

</t>
<t tx="leo.20201108101543.64">void RSolverMagnetostatics::assemblyMatrix(unsigned int elementID, const RRMatrix &amp;Ke, const RRVector &amp;fe)
{
    const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);

    RRVector be(fe);

    // Apply explicit boundary conditions.
    for (uint m=0;m&lt;element.size();m++)
    {
        uint position;
        uint nodeID = element.getNodeId(m);
        if (!this-&gt;nodeBook.getValue(nodeID,position))
        {
            for (uint n=0;n&lt;3*element.size();n++)
            {
                be[n] -= Ke[n][3*m+0] * this-&gt;nodeMagneticField.x[nodeID];
                be[n] -= Ke[n][3*m+1] * this-&gt;nodeMagneticField.y[nodeID];
                be[n] -= Ke[n][3*m+2] * this-&gt;nodeMagneticField.z[nodeID];
            }
        }
    }

    // Assembly final matrix system
    for (uint m=0;m&lt;element.size();m++)
    {
        uint mp;

        if (this-&gt;nodeBook.getValue(element.getNodeId(m),mp))
        {
            this-&gt;b[3*mp+0] += be[3*m+0];
            this-&gt;b[3*mp+1] += be[3*m+1];
            this-&gt;b[3*mp+2] += be[3*m+2];
            for (uint n=0;n&lt;element.size();n++)
            {
                uint np = 0;

                if (this-&gt;nodeBook.getValue(element.getNodeId(n),np))
                {
                    this-&gt;A.addValue(3*mp+0,3*np+0,Ke[3*m+0][3*n+0]);
                    this-&gt;A.addValue(3*mp+1,3*np+0,Ke[3*m+1][3*n+0]);
                    this-&gt;A.addValue(3*mp+2,3*np+0,Ke[3*m+2][3*n+0]);

                    this-&gt;A.addValue(3*mp+0,3*np+1,Ke[3*m+0][3*n+1]);
                    this-&gt;A.addValue(3*mp+1,3*np+1,Ke[3*m+1][3*n+1]);
                    this-&gt;A.addValue(3*mp+2,3*np+1,Ke[3*m+2][3*n+1]);

                    this-&gt;A.addValue(3*mp+0,3*np+2,Ke[3*m+0][3*n+2]);
                    this-&gt;A.addValue(3*mp+1,3*np+2,Ke[3*m+1][3*n+2]);
                    this-&gt;A.addValue(3*mp+2,3*np+2,Ke[3*m+2][3*n+2]);
                }
            }
        }
    }
}
</t>
<t tx="leo.20201108101543.65">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolvermesh.cpp                                          *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   11-th October 2018                                       *
 *                                                                   *
 *  DESCRIPTION: Mesh solver class definition                        *
 *********************************************************************/

#include &lt;omp.h&gt;

#include "rsolvermesh.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101543.66">void RSolverMesh::_init(const RSolverMesh *pSolver)
{
    if (pSolver)
    {

    }
}

RSolverMesh::RSolverMesh(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
{
    this-&gt;problemType = R_PROBLEM_MESH;
    this-&gt;_init();
}

RSolverMesh::RSolverMesh(const RSolverMesh &amp;solver)
    : RSolverGeneric(solver)
{
    this-&gt;_init(&amp;solver);
}

RSolverMesh::~RSolverMesh()
{

}

RSolverMesh &amp;RSolverMesh::operator =(const RSolverMesh &amp;solver)
{
    RSolverGeneric::operator =(solver);
    this-&gt;_init(&amp;solver);
    return (*this);
}

</t>
<t tx="leo.20201108101543.67">bool RSolverMesh::hasConverged() const
{
    return true;
}

</t>
<t tx="leo.20201108101543.68">void RSolverMesh::updateScales()
{

}

</t>
<t tx="leo.20201108101543.69">void RSolverMesh::recover()
{

}

</t>
<t tx="leo.20201108101543.7">void RSolverFluidParticle::process(void)
{

}

</t>
<t tx="leo.20201108101543.70">void RSolverMesh::prepare()
{
    RLogger::info("Calculating volume constraint.\n");
    RLogger::indent();
    double maxVolume = 0.0;

    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        const RVolume &amp;rVolume = this-&gt;pModel-&gt;getVolume(i);
#pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(rVolume.size());j++)
        {
            uint elementID = rVolume.get(uint(j));
            const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(elementID);

            double volume = 0.0;
            if (rElement.findVolume(this-&gt;pModel-&gt;getNodes(),volume))
            {
#pragma omp critical
                {
                    maxVolume = std::max(maxVolume,volume);
                }
            }
        }
    }
    RLogger::info("Maximum element volume = %g\n",maxVolume);
    RLogger::unindent();

    RLogger::info("Calculating mesh size function.\n");
    RLogger::indent();
    const RMeshSetup &amp;rMeshSetup = this-&gt;pModel-&gt;getProblemSetup().getMeshSetup();
    RRVector meshSizeFunction = this-&gt;pModel-&gt;generateMeshSizeFunction(rMeshSetup.getVariables(),
                                                                       rMeshSetup.getMinEdgeLength(),
                                                                       rMeshSetup.getMaxEdgeLength(),
                                                                       0.5);
    RLogger::unindent();

    this-&gt;meshInput.setQualityMesh(true);
    this-&gt;meshInput.setKeepResults(true);
    this-&gt;meshInput.setReconstruct(true);
    this-&gt;meshInput.setSizeFunctionValues(meshSizeFunction);
    this-&gt;meshInput.setUseSizeFunction(true);
    this-&gt;meshInput.setUseTetGenInputParams(false);
    this-&gt;meshInput.setVolumeConstraint(maxVolume);
    this-&gt;meshInput.setVolumeMesh(true);
}

</t>
<t tx="leo.20201108101543.71">void RSolverMesh::solve()
{
    RLogger::info("Generating 3D mesh for model \'%s\'\n",this-&gt;pModel-&gt;getName().toUtf8().constData());
    RLogger::indent();
    try
    {
        RMeshGenerator::generate(this-&gt;meshInput,(*this-&gt;pModel));
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        throw RError(error.getType(),R_ERROR_REF,"Failed to generate 3D mesh: %s\n",error.getMessage().toUtf8().constData());
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101543.72">void RSolverMesh::process()
{

}

</t>
<t tx="leo.20201108101543.73">void RSolverMesh::store()
{

}

</t>
<t tx="leo.20201108101543.74">void RSolverMesh::statistics()
{

}
</t>
<t tx="leo.20201108101543.75">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolverradiativeheat.cpp                                 *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   6-th November 2015                                       *
 *                                                                   *
 *  DESCRIPTION: Radiative Heat-transfer solver class definition     *
 *********************************************************************/

#include "rsolverradiativeheat.h"
#include "rmatrixsolver.h"
#include "rhemicube.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101543.76">void RSolverRadiativeHeat::_init(const RSolverRadiativeHeat *pRadiativeHeatSolver)
{
    if (pRadiativeHeatSolver)
    {
        this-&gt;elementTemperature = pRadiativeHeatSolver-&gt;elementTemperature;
        this-&gt;elementRadiativeHeat = pRadiativeHeatSolver-&gt;elementRadiativeHeat;
        this-&gt;patchHeat = pRadiativeHeatSolver-&gt;patchHeat;
        this-&gt;viewFactorMatrix = pRadiativeHeatSolver-&gt;viewFactorMatrix;
        this-&gt;patchHeatNorm = pRadiativeHeatSolver-&gt;patchHeatNorm;
        this-&gt;oldPatchHeatNorm = pRadiativeHeatSolver-&gt;oldPatchHeatNorm;
    }
}

RSolverRadiativeHeat::RSolverRadiativeHeat(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
    , patchHeatNorm(0.0)
    , oldPatchHeatNorm(0.0)
{
    this-&gt;problemType = R_PROBLEM_RADIATIVE_HEAT;
    this-&gt;_init();
}

RSolverRadiativeHeat::RSolverRadiativeHeat(const RSolverRadiativeHeat &amp;radiativeHeatSolver)
    : RSolverGeneric(radiativeHeatSolver)
{
    this-&gt;_init(&amp;radiativeHeatSolver);
}

RSolverRadiativeHeat::~RSolverRadiativeHeat()
{

}

RSolverRadiativeHeat &amp;RSolverRadiativeHeat::operator =(const RSolverRadiativeHeat &amp;radiativeHeatSolver)
{
    RSolverGeneric::operator =(radiativeHeatSolver);
    this-&gt;_init(&amp;radiativeHeatSolver);
    return (*this);
}

</t>
<t tx="leo.20201108101543.77">bool RSolverRadiativeHeat::hasConverged(void) const
{
    if (this-&gt;oldPatchHeatNorm &lt; RConstants::eps)
    {
        return (this-&gt;patchHeatNorm &lt; RConstants::eps);
    }
    double convergenceRate = std::abs(1.0 - this-&gt;patchHeatNorm/this-&gt;oldPatchHeatNorm);

    RLogger::info("Convergence rate = %g\n",convergenceRate);

    return (convergenceRate &lt; RConstants::eps);
}

double RSolverRadiativeHeat::findTemperatureScale(void) const
{
    return 1.0;
}

</t>
<t tx="leo.20201108101543.78">void RSolverRadiativeHeat::updateScales(void)
{
    this-&gt;scales.setMetre(this-&gt;findMeshScale());
    this-&gt;scales.setKelvin(this-&gt;findTemperatureScale());
}

</t>
<t tx="leo.20201108101543.79">void RSolverRadiativeHeat::recover(void)
{
    uint heatRadiationVariablePosition = this-&gt;pModel-&gt;findVariable(R_VARIABLE_HEAT_RADIATION);

    if (heatRadiationVariablePosition != RConstants::eod)
    {
        const RVariable &amp;rVariable = this-&gt;pModel-&gt;getVariable(heatRadiationVariablePosition);
        if (rVariable.getApplyType() == R_VARIABLE_APPLY_ELEMENT)
        {
            this-&gt;elementRadiativeHeat = rVariable.getValues();
        }
    }
}

</t>
<t tx="leo.20201108101543.8">void RSolverFluidParticle::store(void)
{
    RLogger::info("Storing results\n");
    RLogger::indent();

    // Concentration
    uint concentrationPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_PARTICLE_CONCENTRATION);
    if (concentrationPos == RConstants::eod)
    {
        concentrationPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_PARTICLE_CONCENTRATION);

        this-&gt;pModel-&gt;getVariable(concentrationPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumValue(this-&gt;nodeConcentration),
                    RStatistics::findMaximumValue(this-&gt;nodeConcentration));
    }
    RVariable &amp;concentration =  this-&gt;pModel-&gt;getVariable(concentrationPos);

    concentration.setApplyType(R_VARIABLE_APPLY_NODE);
    concentration.resize(1,this-&gt;pModel-&gt;getNNodes());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
    {
        concentration.setValue(0,i,this-&gt;nodeConcentration[i]);
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101543.80">void RSolverRadiativeHeat::prepareViewFactors(void)
{
    if (this-&gt;checkViewFactorHeader(this-&gt;viewFactorMatrix.getHeader()))
    {
        return;
    }

    bool reculateViewFactors = false;

    QString viewFactorMatrixFile = this-&gt;pModel-&gt;getProblemSetup().getRadiationSetup().getViewFactorMatrixFile();
    if (viewFactorMatrixFile.isEmpty())
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Missing view-factor matrix file name.");
    }

    QString recentViewFactorMatrixFile = RRadiationSetup::findRecentViewFactorMatrixFile(viewFactorMatrixFile,
                                                                                         this-&gt;pModel-&gt;getTimeSolver().getCurrentTimeStep());

    if (recentViewFactorMatrixFile.isEmpty())
    {
        reculateViewFactors = true;
    }
    else
    {
        RViewFactorMatrixHeader viewFactorMatrixHeader;
        try
        {
            RViewFactorMatrix::readHeader(recentViewFactorMatrixFile,viewFactorMatrixHeader);
        }
        catch (const RError &amp;error)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                         "Failed to read view factor matrix header from file \'%s\'. %s",
                         recentViewFactorMatrixFile.toUtf8().constData(),
                         error.getMessage().toUtf8().constData());
        }

        if (!this-&gt;checkViewFactorHeader(viewFactorMatrixHeader))
        {
            reculateViewFactors = true;
        }
        else
        {
            try
            {
                this-&gt;viewFactorMatrix.read(recentViewFactorMatrixFile);
                if (!this-&gt;checkViewFactorHeader(this-&gt;viewFactorMatrix.getHeader()))
                {
                    reculateViewFactors = true;
                }
            }
            catch (const RError &amp;error)
            {
                throw RError(R_ERROR_APPLICATION,R_ERROR_REF,
                             "Failed to read view factor matrix header from file \'%s\'. %s",
                             recentViewFactorMatrixFile.toUtf8().constData(),
                             error.getMessage().toUtf8().constData());
            }
        }
    }

    if (reculateViewFactors)
    {
        // Generate patch surface
        this-&gt;pModel-&gt;generatePatchInputVector(this-&gt;viewFactorMatrix.getHeader().getPatchInput());
        this-&gt;pModel-&gt;generatePatchSurface(this-&gt;viewFactorMatrix.getHeader().getPatchInput(),
                                           this-&gt;viewFactorMatrix.getPatchBook());

        // Calculate view-factors
        RHemiCube::calculateViewFactors(*this-&gt;pModel,this-&gt;viewFactorMatrix);

        // Write view-factor matrix to file
        viewFactorMatrixFile = this-&gt;pModel-&gt;writeViewFactorMatrix(this-&gt;viewFactorMatrix,viewFactorMatrixFile);

        this-&gt;pModel-&gt;getProblemSetup().getRadiationSetup().setViewFactorMatrixFile(viewFactorMatrixFile);
    }
}

</t>
<t tx="leo.20201108101543.81">void RSolverRadiativeHeat::prepare(void)
{
    RBVector temperatureExplicitFlags;
    RRVector elementAmbientTemperature;
    RRVector elementEmissivity;

    this-&gt;generateNodeBook(R_PROBLEM_HEAT);
    this-&gt;generateVariableVector(R_VARIABLE_TEMPERATURE,this-&gt;elementTemperature,temperatureExplicitFlags,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_TEMPERATURE,elementAmbientTemperature,temperatureExplicitFlags,false,false,true);

    // Initialize view-factor matrix.
    this-&gt;prepareViewFactors();
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_EMISSIVITY,elementEmissivity);

    const RPatchBook &amp;rPatchBook = this-&gt;viewFactorMatrix.getPatchBook();

    // Initialize radiation heat.
    this-&gt;elementRadiativeHeat.resize(this-&gt;pModel-&gt;getNElements(),0.0);
    this-&gt;patchHeat.resize(rPatchBook.getNPatches(),0.0);

    // Resize computatioal arrays.
    this-&gt;b.resize(rPatchBook.getNPatches());
    this-&gt;x.resize(rPatchBook.getNPatches());

    this-&gt;A.clear();
    this-&gt;b.fill(0.0);
    this-&gt;x.fill(0.0);

    RRVector patchEmissivity(rPatchBook.getNPatches(),0.0);
    RRVector patchTemperature(rPatchBook.getNPatches(),0.0);
    RRVector patchAmbientTemperature(rPatchBook.getNPatches(),0.0);

    // Find patch emissivity and temperature.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        const RSurface &amp;rSurface = this-&gt;pModel-&gt;getSurface(i);
        for (uint j=0;j&lt;rSurface.size();j++)
        {
            uint elementID = rSurface.get(j);
            uint patchID = rPatchBook.findPatchID(elementID);
            if (patchID != RConstants::eod)
            {
                patchEmissivity[patchID] += elementEmissivity[elementID];
                patchTemperature[patchID] += this-&gt;elementTemperature[elementID];
                patchAmbientTemperature[patchID] += elementAmbientTemperature[elementID];
            }
        }
    }
    for (uint i=0;i&lt;rPatchBook.getNPatches();i++)
    {
        uint nElements = uint(rPatchBook.getPatch(i).getElementIDs().size());
        if (nElements &gt; 0)
        {
            patchEmissivity[i] /= double(nElements);
            patchTemperature[i] /= double(nElements);
            patchAmbientTemperature[i] /= double(nElements);
        }
    }

    // Prepare patch elements.
    #pragma omp parallel for default(shared)
    for (int64_t i=0;i&lt;int64_t(rPatchBook.getNPatches());i++)
    {
        RRVector viewFactors = this-&gt;viewFactorMatrix.getRow(i).getViewFactors().getValues(rPatchBook.getNPatches());

        double Fsum = 0.0;
        for (uint j=0;j&lt;rPatchBook.getNPatches();j++)
        {
            double dij = (i == j ? 1.0 : 0.0);

            double Fij = viewFactors[j];
            double Ej = patchEmissivity[j];
            Fsum += Fij;

            double Aij = 0.0;
            if (Ej != 0.0)
            {
                Aij = dij/Ej - Fij*(1.0-Ej)/Ej;
            }
            double Bij = (dij-Fij)*RSolverGeneric::sigma;

            #pragma omp critical
            {
                this-&gt;A.addValue(i,j,Aij);
                this-&gt;b[j] -= Bij * std::pow(patchTemperature[j],4);
            }
        }

        // Ambient radiative heat flux
        this-&gt;b[i] += (1.0 - Fsum) * RSolverGeneric::sigma * std::pow(patchAmbientTemperature[i],4);
        // Subtract resulting heat from convection-conduction equation to ensure energy balance
//        this-&gt;b[i] -= this-&gt;patchHeat[i];
    }
}

</t>
<t tx="leo.20201108101543.82">void RSolverRadiativeHeat::solve(void)
{
    try
    {
        RLogger::indent();
        RMatrixSolver matrixSolver(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));
        matrixSolver.solve(this-&gt;A,this-&gt;b,this-&gt;x,R_MATRIX_PRECONDITIONER_JACOBI,1);
        RLogger::unindent();
    }
    catch (RError error)
    {
        RLogger::unindent();
        throw error;
    }

    const RPatchBook &amp;rPatchBook = this-&gt;viewFactorMatrix.getPatchBook();

    for (uint i=0;i&lt;rPatchBook.getNPatches();i++)
    {
        this-&gt;patchHeat[i] = this-&gt;x[i];
    }
    this-&gt;oldPatchHeatNorm = this-&gt;patchHeatNorm;
    this-&gt;patchHeatNorm = RRVector::norm(this-&gt;patchHeat);
}

</t>
<t tx="leo.20201108101543.83">void RSolverRadiativeHeat::process(void)
{
    const RPatchBook &amp;rPatchBook = this-&gt;viewFactorMatrix.getPatchBook();

    for (uint i=0;i&lt;rPatchBook.getNPatches();i++)
    {
        const RUVector &amp;elementIDs = rPatchBook.getPatch(i).getElementIDs();

        // Distribute heat to elements based on their size portion.
        double patchArea = 0.0;
        for (uint j=0;j&lt;elementIDs.size();j++)
        {
            double elementArea;
            if (this-&gt;pModel-&gt;getElement(elementIDs[j]).findArea(this-&gt;pModel-&gt;getNodes(),elementArea))
            {
                patchArea += elementArea;
            }
        }
        for (uint j=0;j&lt;elementIDs.size();j++)
        {
            double elementArea;
            double ratio = 0.0;
            if (this-&gt;pModel-&gt;getElement(elementIDs[j]).findArea(this-&gt;pModel-&gt;getNodes(),elementArea))
            {
                ratio = elementArea / patchArea;
            }
            this-&gt;elementRadiativeHeat[elementIDs[j]] = this-&gt;patchHeat[i] * ratio;
        }
    }
}

</t>
<t tx="leo.20201108101543.84">void RSolverRadiativeHeat::store(void)
{
    RLogger::info("Storing results\n");
    RLogger::indent();

    // Heat flux
    uint heatPos = this-&gt;pModel-&gt;findVariable(R_VARIABLE_HEAT_RADIATION);
    if (heatPos == RConstants::eod)
    {
        heatPos = this-&gt;pModel-&gt;addVariable(R_VARIABLE_HEAT_RADIATION);
        this-&gt;pModel-&gt;getVariable(heatPos).getVariableData().setMinMaxDisplayValue(
                    RStatistics::findMinimumValue(this-&gt;elementRadiativeHeat),
                    RStatistics::findMaximumValue(this-&gt;elementRadiativeHeat));
    }
    RVariable &amp;heat =  this-&gt;pModel-&gt;getVariable(heatPos);

    heat.setApplyType(R_VARIABLE_APPLY_ELEMENT);
    heat.resize(1,this-&gt;pModel-&gt;getNElements());
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNElements();i++)
    {
        heat.setValue(0,i,this-&gt;elementRadiativeHeat[i]);
    }

    RLogger::unindent();
}

</t>
<t tx="leo.20201108101543.85">void RSolverRadiativeHeat::statistics(void)
{
    this-&gt;printStats(R_VARIABLE_HEAT_RADIATION);
    this-&gt;processMonitoringPoints();
}

</t>
<t tx="leo.20201108101543.86">bool RSolverRadiativeHeat::checkViewFactorHeader(const RViewFactorMatrixHeader &amp;viewFactorMatrixHeader) const
{
    if (viewFactorMatrixHeader.getPatchInput().size() != this-&gt;pModel-&gt;getNSurfaces())
    {
        return false;
    }
    if (viewFactorMatrixHeader.getNElements() != this-&gt;pModel-&gt;getNElements())
    {
        return false;
    }
    if (viewFactorMatrixHeader.getHemicubeResolution() != this-&gt;pModel-&gt;getProblemSetup().getRadiationSetup().getResolution())
    {
        return false;
    }
    std::vector&lt;RPatchInput&gt; patchInput;
    this-&gt;pModel-&gt;generatePatchInputVector(patchInput);
    if (viewFactorMatrixHeader.getPatchInput() != patchInput)
    {
        return false;
    }
    return true;
}
</t>
<t tx="leo.20201108101543.87">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolvershareddata.cpp                                    *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   7-th November 2012                                       *
 *                                                                   *
 *  DESCRIPTION: Range solver shared data class definition           *
 *********************************************************************/

#include "rsolvershareddata.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101543.88">void RSolverSharedData::_init(const RSolverSharedData *pSolverSharedData)
{
    if (pSolverSharedData)
    {
        this-&gt;data = pSolverSharedData-&gt;data;
    }
}

RSolverSharedData::RSolverSharedData()
{
    this-&gt;_init();
}

RSolverSharedData::RSolverSharedData(const RSolverSharedData &amp;solverSharedData)
{
    this-&gt;_init(&amp;solverSharedData);
}

RSolverSharedData::~RSolverSharedData()
{

}

RSolverSharedData &amp;RSolverSharedData::operator =(const RSolverSharedData &amp;solverSharedData)
{
    this-&gt;_init(&amp;solverSharedData);
    return (*this);
}

</t>
<t tx="leo.20201108101543.89">bool RSolverSharedData::hasData(const QString &amp;name, uint dataSize) const
{
    if (this-&gt;data.contains(name))
    {
        return (this-&gt;data[name].size() == dataSize);
    }
    return false;
}

</t>
<t tx="leo.20201108101543.9">void RSolverFluidParticle::statistics(void)
{
    static uint counter = 0;
    static double oldResidual = 0.0;

    double scale = std::pow(this-&gt;scales.getSecond(),2) / this-&gt;scales.getKilogram();
    double residual = RRVector::norm(this-&gt;b)*scale;
    double convergence = residual - oldResidual;
    oldResidual = residual;

    std::vector&lt;RIterationInfoValue&gt; cvgValues;
    cvgValues.push_back(RIterationInfoValue("Solver residual",residual));
    cvgValues.push_back(RIterationInfoValue("Solver convergence",convergence));
    cvgValues.push_back(RIterationInfoValue("Concentration convergence",this-&gt;cvgC));

    RIterationInfo::writeToFile(this-&gt;convergenceFileName,counter,cvgValues);

    this-&gt;printStats(R_VARIABLE_PARTICLE_CONCENTRATION);
    this-&gt;processMonitoringPoints();

    RLogger::info("Convergence:   %-13g\n",residual);

    RLogger::info("Build time:    %9u [ms]\n",this-&gt;buildStopWatch.getMiliSeconds());
    RLogger::info("Assembly time: %9u [ms]\n",this-&gt;assemblyStopWatch.getMiliSeconds());
    RLogger::info("Solver time:   %9u [ms]\n",this-&gt;solverStopWatch.getMiliSeconds());
    RLogger::info("Update time:   %9u [ms]\n",this-&gt;updateStopWatch.getMiliSeconds());

    counter++;
}

</t>
<t tx="leo.20201108101543.90">void RSolverSharedData::addData(const QString &amp;name, const RRVector &amp;data)
{
    this-&gt;data[name] = data;
}

RRVector &amp;RSolverSharedData::findData(const QString &amp;name)
{
    return this-&gt;data[name];
}

</t>
<t tx="leo.20201108101543.91">void RSolverSharedData::clearData(void)
{
    this-&gt;data.clear();
}

</t>
<t tx="leo.20201108101543.92">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolverstress.cpp                                        *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   27-th May 2015                                           *
 *                                                                   *
 *  DESCRIPTION: Stress-strain solver class definition               *
 *********************************************************************/

#include &lt;cmath&gt;

#include "rsolverstress.h"
#include "rmatrixsolver.h"
#include "reigenvaluesolver.h"

@others
@language c
@tabwidth -4
@ignore
</t>
<t tx="leo.20201108101543.93">void RSolverStress::_init(const RSolverStress *pStressSolver)
{
    if (pStressSolver)
    {
        this-&gt;problemType = pStressSolver-&gt;problemType;
        this-&gt;elementElasticityModulus = pStressSolver-&gt;elementElasticityModulus;
        this-&gt;elementPoissonRatio = pStressSolver-&gt;elementPoissonRatio;
        this-&gt;elementDensity = pStressSolver-&gt;elementDensity;
        this-&gt;elementThermalExpansion = pStressSolver-&gt;elementThermalExpansion;
        this-&gt;elementEnvironmentTemperature = pStressSolver-&gt;elementEnvironmentTemperature;
        this-&gt;nodeDisplacement = pStressSolver-&gt;nodeDisplacement;
        this-&gt;nodeInitialDisplacement = pStressSolver-&gt;nodeInitialDisplacement;
        this-&gt;nodeForce = pStressSolver-&gt;nodeForce;
        this-&gt;nodeAcceleration = pStressSolver-&gt;nodeAcceleration;
        this-&gt;elementNormalStress = pStressSolver-&gt;elementNormalStress;
        this-&gt;elementShearStress = pStressSolver-&gt;elementShearStress;
        this-&gt;elementVonMisses = pStressSolver-&gt;elementVonMisses;
    }
}

RSolverStress::RSolverStress(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData, bool modalAnalysis)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
{
    this-&gt;problemType = modalAnalysis ? R_PROBLEM_STRESS_MODAL : R_PROBLEM_STRESS;
    this-&gt;_init();
}

RSolverStress::RSolverStress(const RSolverStress &amp;stressSolver)
    : RSolverGeneric(stressSolver)
{
    this-&gt;_init(&amp;stressSolver);
}

RSolverStress::~RSolverStress()
{

}

RSolverStress &amp;RSolverStress::operator =(const RSolverStress &amp;stressSolver)
{
    RSolverGeneric::operator =(stressSolver);
    this-&gt;_init(&amp;stressSolver);
    return (*this);
}

</t>
<t tx="leo.20201108101543.94">bool RSolverStress::hasConverged(void) const
{
    return true;
}

</t>
<t tx="leo.20201108101543.95">void RSolverStress::updateScales(void)
{
    this-&gt;scales.setMetre(this-&gt;findMeshScale());
}

</t>
<t tx="leo.20201108101543.96">void RSolverStress::recover(void)
{
    this-&gt;recoverVariable(R_VARIABLE_DISPLACEMENT,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),0,this-&gt;nodeDisplacement.x,0.0);
    this-&gt;recoverVariable(R_VARIABLE_DISPLACEMENT,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),1,this-&gt;nodeDisplacement.y,0.0);
    this-&gt;recoverVariable(R_VARIABLE_DISPLACEMENT,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),2,this-&gt;nodeDisplacement.z,0.0);
    this-&gt;recoverVariable(R_VARIABLE_FORCE,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),0,this-&gt;nodeForce.x,0.0);
    this-&gt;recoverVariable(R_VARIABLE_FORCE,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),1,this-&gt;nodeForce.y,0.0);
    this-&gt;recoverVariable(R_VARIABLE_FORCE,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),2,this-&gt;nodeForce.z,0.0);
    this-&gt;recoverVariable(R_VARIABLE_ACCELERATION,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),0,this-&gt;nodeAcceleration.x,0.0);
    this-&gt;recoverVariable(R_VARIABLE_ACCELERATION,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),1,this-&gt;nodeAcceleration.y,0.0);
    this-&gt;recoverVariable(R_VARIABLE_ACCELERATION,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),2,this-&gt;nodeAcceleration.z,0.0);
    this-&gt;recoverVariable(R_VARIABLE_PRESSURE,R_VARIABLE_APPLY_NODE,this-&gt;pModel-&gt;getNNodes(),0,this-&gt;nodePressure,0.0);

//    this-&gt;syncShared("node-displacement-x",this-&gt;nodeDisplacement.x);
//    this-&gt;syncShared("node-displacement-y",this-&gt;nodeDisplacement.y);
//    this-&gt;syncShared("node-displacement-z",this-&gt;nodeDisplacement.z);

//    this-&gt;syncShared("node-acceleration-x",this-&gt;nodeAcceleration.x);
//    this-&gt;syncShared("node-acceleration-y",this-&gt;nodeAcceleration.y);
//    this-&gt;syncShared("node-acceleration-z",this-&gt;nodeAcceleration.z);
}

</t>
<t tx="leo.20201108101543.97">void RSolverStress::prepare(void)
{
    //! Element displacement vector.
    struct { RRVector x, y, z, n; } elementDisplacement;
    struct { RBVector x, y, z, n; } displacementSetValues;

    //! Element force vector.
    RSolverCartesianVector&lt;RRVector&gt; elementForce;
    RSolverCartesianVector&lt;RBVector&gt; forceSetValues;

    //! Element acceleration vector.
    RSolverCartesianVector&lt;RRVector&gt; elementAcceleration;
    RSolverCartesianVector&lt;RBVector&gt; accelerationSetValues;

    //! Element gravity vector.
    RSolverCartesianVector&lt;RRVector&gt; elementGravity;
    RSolverCartesianVector&lt;RBVector&gt; gGravitySetValues;

    //! Element pressure.
    RRVector elementPressure;
    RBVector pressureSetValues;

    //! Element traction per unit area.
    RSolverCartesianVector&lt;RRVector&gt; elementForceUnitArea;
    RSolverCartesianVector&lt;RBVector&gt; forceUnitAreaSetValues;

    //! Element weight.
    RRVector elementWeight;
    RBVector weightSetValues;

    RBVector temperatureSetValues;

    this-&gt;generateNodeBook();
    this-&gt;generateVariableVector(R_VARIABLE_DISPLACEMENT_X,elementDisplacement.x,displacementSetValues.x,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_DISPLACEMENT_Y,elementDisplacement.y,displacementSetValues.y,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_DISPLACEMENT_Z,elementDisplacement.z,displacementSetValues.z,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_DISPLACEMENT,elementDisplacement.n,displacementSetValues.n,true,this-&gt;firstRun,this-&gt;firstRun);
    for (uint i=0;i&lt;displacementSetValues.n.size();i++)
    {
        if (displacementSetValues.n[i])
        {
            displacementSetValues.x[i] = true;
            elementDisplacement.x[i] = elementDisplacement.n[i];
        }
    }
    this-&gt;generateVariableVector(R_VARIABLE_FORCE_X,elementForce.x,forceSetValues.x,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_FORCE_Y,elementForce.y,forceSetValues.y,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_FORCE_Z,elementForce.z,forceSetValues.z,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_ACCELERATION_X,elementAcceleration.x,accelerationSetValues.x,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_ACCELERATION_Y,elementAcceleration.y,accelerationSetValues.y,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_ACCELERATION_Z,elementAcceleration.z,accelerationSetValues.z,true,this-&gt;firstRun,this-&gt;firstRun);
    this-&gt;generateVariableVector(R_VARIABLE_G_ACCELERATION_X,elementGravity.x,gGravitySetValues.x,true,true,true);
    this-&gt;generateVariableVector(R_VARIABLE_G_ACCELERATION_Y,elementGravity.y,gGravitySetValues.y,true,true,true);
    this-&gt;generateVariableVector(R_VARIABLE_G_ACCELERATION_Z,elementGravity.z,gGravitySetValues.z,true,true,true);
    this-&gt;generateVariableVector(R_VARIABLE_PRESSURE,elementPressure,pressureSetValues,true,true,true);
    this-&gt;generateVariableVector(R_VARIABLE_FORCE_UNIT_AREA_X,elementForceUnitArea.x,forceUnitAreaSetValues.x,true,true,true);
    this-&gt;generateVariableVector(R_VARIABLE_FORCE_UNIT_AREA_Y,elementForceUnitArea.y,forceUnitAreaSetValues.y,true,true,true);
    this-&gt;generateVariableVector(R_VARIABLE_FORCE_UNIT_AREA_Z,elementForceUnitArea.z,forceUnitAreaSetValues.z,true,true,true);
    this-&gt;generateVariableVector(R_VARIABLE_WEIGHT,elementWeight,weightSetValues,true,true,true);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_MODULUS_OF_ELASTICITY,this-&gt;elementElasticityModulus);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_POISSON_RATIO,this-&gt;elementPoissonRatio);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_DENSITY,this-&gt;elementDensity);
    this-&gt;generateMaterialVecor(R_MATERIAL_PROPERTY_THERMAL_EXPANSION_COEFFICIENT,this-&gt;elementThermalExpansion);
    this-&gt;generateVariableVector(R_VARIABLE_TEMPERATURE,this-&gt;elementEnvironmentTemperature,temperatureSetValues,false,false,true);

    this-&gt;b.resize(this-&gt;nodeBook.getNEnabled());
    this-&gt;x.resize(this-&gt;nodeBook.getNEnabled());

    this-&gt;M.clear();
    this-&gt;A.clear();
    this-&gt;b.fill(0.0);
    this-&gt;x.fill(0.0);

    this-&gt;pModel-&gt;convertElementToNodeVector(elementDisplacement.x,displacementSetValues.x,this-&gt;nodeDisplacement.x,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementDisplacement.y,displacementSetValues.y,this-&gt;nodeDisplacement.y,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementDisplacement.z,displacementSetValues.z,this-&gt;nodeDisplacement.z,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementForce.x,forceSetValues.x,this-&gt;nodeForce.x,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementForce.y,forceSetValues.y,this-&gt;nodeForce.y,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementForce.z,forceSetValues.z,this-&gt;nodeForce.z,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementAcceleration.x,accelerationSetValues.x,this-&gt;nodeAcceleration.x,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementAcceleration.y,accelerationSetValues.y,this-&gt;nodeAcceleration.y,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementAcceleration.z,accelerationSetValues.z,this-&gt;nodeAcceleration.z,true);
    this-&gt;pModel-&gt;convertElementToNodeVector(elementPressure,pressureSetValues,this-&gt;nodePressure,true);

    // Convert node pressure to element pressure
    for (uint i=0;i&lt;elementPressure.size();i++)
    {
        if (!pressureSetValues[i])
        {
            const RElement &amp;rElement = this-&gt;pModel-&gt;getElement(i);
            uint nne = rElement.size();
            if (nne &gt; 0)
            {
                elementPressure[i] = 0.0;
                for (uint j=0;j&lt;nne;j++)
                {
                    elementPressure[i] += this-&gt;nodePressure[rElement.getNodeId(j)];
                }
                elementPressure[i] /= double(nne);
            }
        }
    }

    std::vector&lt;RNode&gt; nodesBkp;
    if (this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
    {
        this-&gt;nodeInitialDisplacement.x = this-&gt;nodeDisplacement.x;
        this-&gt;nodeInitialDisplacement.y = this-&gt;nodeDisplacement.y;
        this-&gt;nodeInitialDisplacement.z = this-&gt;nodeDisplacement.z;
        RLogger::info("Moving prestressed nodes\n");
        nodesBkp = this-&gt;pModel-&gt;getNodes();
        for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
        {
            this-&gt;pModel-&gt;getNode(i).move(RR3Vector(this-&gt;nodeDisplacement.x[i],this-&gt;nodeDisplacement.y[i],this-&gt;nodeDisplacement.z[i]));
        }
    }

    // Prepare point elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNPoints();i++)
    {
        RPoint &amp;point = this-&gt;pModel-&gt;getPoint(i);
        double pointVolume = point.getVolume();

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(point.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = point.get(uint(j));

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_POINT(this-&gt;pModel-&gt;getElement(elementID).getType()));
                RRMatrix Me(3,3);
                RRMatrix Ke(3,3);
                RRVector fe(3);

                Me.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                // Force
                fe[0] += elementForce.x[elementID];
                fe[1] += elementForce.y[elementID];
                fe[2] += elementForce.z[elementID];
                // Weight
                fe[0] += elementWeight[elementID] * elementGravity.x[elementID];
                fe[1] += elementWeight[elementID] * elementGravity.y[elementID];
                fe[2] += elementWeight[elementID] * elementGravity.z[elementID];
                // Own weight
                if (pointVolume &gt; 0.0)
                {
                    fe[0] += elementGravity.x[elementID] * this-&gt;elementDensity[elementID] * pointVolume;
                    fe[1] += elementGravity.y[elementID] * this-&gt;elementDensity[elementID] * pointVolume;
                    fe[2] += elementGravity.z[elementID] * this-&gt;elementDensity[elementID] * pointVolume;
                }

                // Mass
                if (this-&gt;pModel-&gt;getTimeSolver().getEnabled() || this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
                {
                    Me.setIdentity(3);
                    Me *= this-&gt;elementDensity[elementID] * pointVolume;
                }

                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
                #pragma omp flush (abort)
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare line elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNLines();i++)
    {
        RLine &amp;line = this-&gt;pModel-&gt;getLine(i);
        double lineCrossArea = line.getCrossArea();

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(line.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = line.get(uint(j));

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_LINE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size()*3,element.size()*3,0.0);
                RRMatrix Ke(element.size()*3,element.size()*3,0.0);
                RRVector fe(element.size()*3,0.0);

                RRMatrix Be(3*element.size(),1);
                RRMatrix BeT(1,3*element.size());

                double lineLength = 0.0;
                element.findLength(this-&gt;pModel-&gt;getNodes(),lineLength);

                double E = this-&gt;elementElasticityModulus[elementID];
                double De = E * lineCrossArea;

                double dT = this-&gt;elementTemperature[elementID] - this-&gt;elementEnvironmentTemperature[elementID];

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = element.findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);
                    if (lineCrossArea &gt; 0.0)
                    {
                        Be.fill(0.0);
                        for (uint m=0;m&lt;dN.getNRows();m++)
                        {
                            Be[3*m+0][0] += Rt[3*m+0][0]*dN[m][0]*J[0][0];
                            Be[3*m+1][0] += Rt[3*m+1][0]*dN[m][0]*J[0][0];
                            Be[3*m+2][0] += Rt[3*m+2][0]*dN[m][0]*J[0][0];
                        }
                        BeT.transpose(Be);
                        Be *= De;
                        RRMatrix::mlt(Be,BeT,Ke);
                    }

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        if (lineCrossArea &gt; 0.0)
                        {
                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled() || this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
                            {
                                for (uint n=0;n&lt;element.size();n++)
                                {
                                    double value = N[m] * N[n]

                        double integValue = N[m] * detJ * shapeFunc.getW();

                        // Force
                        fe[3*m+0] += (elementForce.x[elementID] / lineLength) * integValue;
                        fe[3*m+1] += (elementForce.y[elementID] / lineLength) * integValue;
                        fe[3*m+2] += (elementForce.z[elementID] / lineLength) * integValue;
                        // Weight
                        fe[3*m+0] += (elementWeight[elementID] * elementGravity.x[elementID] / lineLength) * integValue;
                        fe[3*m+1] += (elementWeight[elementID] * elementGravity.y[elementID] / lineLength) * integValue;
                        fe[3*m+2] += (elementWeight[elementID] * elementGravity.z[elementID] / lineLength) * integValue;
                        // Own weight
                        if (lineCrossArea &gt; 0.0)
                        {
                            fe[3*m+0] += elementGravity.x[elementID] * this-&gt;elementDensity[elementID] * lineCrossArea * integValue;
                            fe[3*m+1] += elementGravity.y[elementID] * this-&gt;elementDensity[elementID] * lineCrossArea * integValue;
                            fe[3*m+2] += elementGravity.z[elementID] * this-&gt;elementDensity[elementID] * lineCrossArea * integValue;
                        }

                        // Thermal expansion
                        if (lineCrossArea &gt; 0.0)
                        {
                            double fet = this-&gt;elementThermalExpansion[elementID] * dT * De * Be[m][0] * lineCrossArea * detJ * shapeFunc.getW();

                            fe[3*m+0] += Rt[3*m+0][0]*fet;
                            fe[3*m+1] += Rt[3*m+1][0]*fet;
                            fe[3*m+2] += Rt[3*m+2][0]*fet;
                        }
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
                #pragma omp flush (abort)
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare surface elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNSurfaces();i++)
    {
        RSurface &amp;surface = this-&gt;pModel-&gt;getSurface(i);
        double surfaceArea = surface.findArea(this-&gt;pModel-&gt;getNodes(),this-&gt;pModel-&gt;getElements());
        double surfaceThickness = surface.getThickness();

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(surface.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = surface.get(uint(j));

                if (!this-&gt;computableElements[elementID] &amp;&amp; !this-&gt;includableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_SURFACE(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size()*3,element.size()*3);
                RRMatrix Ke(element.size()*3,element.size()*3);
                RRVector fe(element.size()*3);

                Me.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                RRMatrix B(element.size(),3);
                RRMatrix Be(element.size()*2,3);
                RRMatrix BeT(3,element.size()*2);
                RRMatrix BeD(element.size()*2,3);
                RRMatrix Met(element.size()*2,element.size()*2);
                RRMatrix MeRt(element.size()*3,element.size()*2);
                RRMatrix Ket(element.size()*2,element.size()*2);
                RRMatrix KeRt(element.size()*3,element.size()*2);
                RRVector fet(element.size()*2);

                RRMatrix De(3,3,0.0);

                double E = this-&gt;elementElasticityModulus[elementID];
                double v = this-&gt;elementPoissonRatio[elementID];

                De[0][0] = 1-v;   De[0][1] = v;
                De[1][0] = v;     De[1][1] = 1-v;
                De[2][2] = (1-2*v)/2;
                De *= E/((1+v)*(1-2*v));

                double dT = this-&gt;elementTemperature[elementID] - this-&gt;elementEnvironmentTemperature[elementID];

                RR3Vector normal;
                element.findNormal(this-&gt;pModel-&gt;getNodes(),normal[0],normal[1],normal[2]);

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt, RtT;
                    double detJ = element.findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);
                    RtT.transpose(Rt);

                    if (surfaceThickness &gt; 0.0)
                    {
                        B.fill(0.0);
                        for (uint m=0;m&lt;dN.getNRows();m++)
                        {
                            B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1]);
                            B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1]);
                        }

                        for (uint m=0;m&lt;element.size();m++)
                        {
                            Be[2*m][0] = B[m][0];   Be[2*m+1][0] = 0.0;
                            Be[2*m][1] = 0.0;       Be[2*m+1][1] = B[m][1];
                            Be[2*m][2] = B[m][1];   Be[2*m+1][2] = B[m][0];
                        }
                        BeT.transpose(Be);

                        RRMatrix::mlt(Be,De,BeD);
                        RRMatrix::mlt(BeD,BeT,Ket);
                        RRMatrix::mlt(Rt,Ket,KeRt);
                        RRMatrix::mlt(KeRt,RtT,Ke);
                        Ke *= detJ * shapeFunc.getW();
                    }

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        if (surfaceThickness &gt; 0.0)
                        {
                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled() || this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
                            {
                                for (uint n=0;n&lt;element.size();n++)
                                {
                                    double value = N[m] * N[n]
                        double integValue = N[m] * detJ * shapeFunc.getW();

                        // Pressure vector
                        fe[3*m+0] += elementPressure[elementID] * normal[0] * integValue * (this-&gt;inwardElements[elementID] ? 1.0 : -1.0);
                        fe[3*m+1] += elementPressure[elementID] * normal[1] * integValue * (this-&gt;inwardElements[elementID] ? 1.0 : -1.0);
                        fe[3*m+2] += elementPressure[elementID] * normal[2] * integValue * (this-&gt;inwardElements[elementID] ? 1.0 : -1.0);
                        // Force per unit area
                        fe[3*m+0] += elementForceUnitArea.x[elementID] * integValue;
                        fe[3*m+1] += elementForceUnitArea.y[elementID] * integValue;
                        fe[3*m+2] += elementForceUnitArea.z[elementID] * integValue;
                        // Force
                        fe[3*m+0] += (elementForce.x[elementID] / surfaceArea) * integValue;
                        fe[3*m+1] += (elementForce.y[elementID] / surfaceArea) * integValue;
                        fe[3*m+2] += (elementForce.z[elementID] / surfaceArea) * integValue;
                        // Weight
                        fe[3*m+0] += (elementWeight[elementID] * elementGravity.x[elementID] / surfaceArea) * integValue;
                        fe[3*m+1] += (elementWeight[elementID] * elementGravity.y[elementID] / surfaceArea) * integValue;
                        fe[3*m+2] += (elementWeight[elementID] * elementGravity.z[elementID] / surfaceArea) * integValue;
                        // Own weight
                        if (surfaceThickness &gt; 0.0)
                        {
                            fe[3*m+0] += elementGravity.x[elementID] * this-&gt;elementDensity[elementID] * surfaceThickness * integValue;
                            fe[3*m+1] += elementGravity.y[elementID] * this-&gt;elementDensity[elementID] * surfaceThickness * integValue;
                            fe[3*m+2] += elementGravity.z[elementID] * this-&gt;elementDensity[elementID] * surfaceThickness * integValue;
                        }

                        // Thermal expansion
                        if (surfaceThickness &gt; 0.0)
                        {
                            fet.fill(0.0);
                            for (uint n=0;n&lt;3;n++)
                            {
                                fet[2*m+0] += this-&gt;elementThermalExpansion[elementID] * dT * BeD[2*m+0][n] * surfaceThickness * detJ * shapeFunc.getW();
                                fet[2*m+1] += this-&gt;elementThermalExpansion[elementID] * dT * BeD[2*m+1][n] * surfaceThickness * detJ * shapeFunc.getW();
                            }

                            fe[3*m+0] += Rt[3*m+0][0]*fet[2*m+0] + Rt[3*m+0][1]*fet[2*m+1];
                            fe[3*m+1] += Rt[3*m+1][0]*fet[2*m+0] + Rt[3*m+1][1]*fet[2*m+1];
                            fe[3*m+2] += Rt[3*m+2][0]*fet[2*m+0] + Rt[3*m+2][1]*fet[2*m+1];
                        }
                    }

                    // Mass
                    if (surfaceThickness &gt; 0.0 &amp;&amp; (this-&gt;pModel-&gt;getTimeSolver().getEnabled() || this-&gt;problemType == R_PROBLEM_STRESS_MODAL))
                    {
                        RRMatrix::mlt(Rt,Met,MeRt);
                        RRMatrix::mlt(MeRt,RtT,Me,true);
                    }
                    if (!this-&gt;computableElements[elementID])
                    {
                        Me.fill(0.0);
                        Ke.fill(0.0);
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
                #pragma omp flush (abort)
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }

    // Prepare volume elements.
    for (uint i=0;i&lt;this-&gt;pModel-&gt;getNVolumes();i++)
    {
        RVolume &amp;volume = this-&gt;pModel-&gt;getVolume(i);

        bool abort = false;
        #pragma omp parallel for default(shared)
        for (int64_t j=0;j&lt;int64_t(volume.size());j++)
        {
            #pragma omp flush (abort)
            if (abort)
            {
                continue;
            }
            try
            {
                uint elementID = volume.get(uint(j));

                if (!this-&gt;computableElements[elementID])
                {
                    continue;
                }

                const RElement &amp;element = this-&gt;pModel-&gt;getElement(elementID);
                R_ERROR_ASSERT(R_ELEMENT_TYPE_IS_VOLUME(element.getType()));
                uint nInp = RElement::getNIntegrationPoints(element.getType());
                RRMatrix Me(element.size()*3,element.size()*3);
                RRMatrix Ke(element.size()*3,element.size()*3);
                RRVector fe(element.size()*3);

                Me.fill(0.0);
                Ke.fill(0.0);
                fe.fill(0.0);

                RRMatrix B(element.size(),3);
                RRMatrix Be(element.size()*3,6);
                RRMatrix BeT(6,element.size()*3);
                RRMatrix BeD(element.size()*3,6);
                RRMatrix Ket(element.size()*3,element.size()*3);

                RRMatrix De(6,6);
                De.fill(0.0);

                double E = this-&gt;elementElasticityModulus[elementID];
                double v = this-&gt;elementPoissonRatio[elementID];

                De[0][0] = 1.0-v; De[0][1] = v;     De[0][2] = v;
                De[1][0] = v;     De[1][1] = 1.0-v; De[1][2] = v;
                De[2][0] = v;     De[2][1] = v;     De[2][2] = 1.0-v;
                De[3][3] = De[4][4] = De[5][5] = (1.0-2.0*v)/2.0;
                De *= E/((1.0+v)*(1.0-2.0*v));

                double dT = this-&gt;elementTemperature[elementID] - this-&gt;elementEnvironmentTemperature[elementID];

                for (uint k=0;k&lt;nInp;k++)
                {
                    const RElementShapeFunction &amp;shapeFunc = RElement::getShapeFunction(element.getType(),k);
                    const RRVector &amp;N = shapeFunc.getN();
                    const RRMatrix &amp;dN = shapeFunc.getDN();
                    RRMatrix J, Rt;
                    double detJ = element.findJacobian(this-&gt;pModel-&gt;getNodes(),k,J,Rt);

                    B.fill(0.0);
                    for (uint m=0;m&lt;dN.getNRows();m++)
                    {
                        B[m][0] += (dN[m][0]*J[0][0] + dN[m][1]*J[0][1] + dN[m][2]*J[0][2]);
                        B[m][1] += (dN[m][0]*J[1][0] + dN[m][1]*J[1][1] + dN[m][2]*J[1][2]);
                        B[m][2] += (dN[m][0]*J[2][0] + dN[m][1]*J[2][1] + dN[m][2]*J[2][2]);
                    }

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        Be[3*m+0][0] = B[m][0];   Be[3*m+1][0] = 0.0;       Be[3*m+2][0] = 0.0;
                        Be[3*m+0][1] = 0.0;       Be[3*m+1][1] = B[m][1];   Be[3*m+2][1] = 0.0;
                        Be[3*m+0][2] = 0.0;       Be[3*m+1][2] = 0.0;       Be[3*m+2][2] = B[m][2];
                        Be[3*m+0][3] = 0.0;       Be[3*m+1][3] = B[m][2];   Be[3*m+2][3] = B[m][1];
                        Be[3*m+0][4] = B[m][2];   Be[3*m+1][4] = 0.0;       Be[3*m+2][4] = B[m][0];
                        Be[3*m+0][5] = B[m][1];   Be[3*m+1][5] = B[m][0];   Be[3*m+2][5] = 0.0;
                    }
                    BeT.transpose(Be);

                    RRMatrix::mlt(Be,De,BeD);
                    RRMatrix::mlt(BeD,BeT,Ket);
                    for (uint m=0;m&lt;3*element.size();m++)
                    {
                        for (uint n=0;n&lt;3*element.size();n++)
                        {
                            // Stiffness matrix
                            Ke[m][n] += Ket[m][n] * detJ * shapeFunc.getW();
                        }
                    }

                    for (uint m=0;m&lt;element.size();m++)
                    {
                        for (uint n=0;n&lt;element.size();n++)
                        {
                            // Mass
                            if (this-&gt;pModel-&gt;getTimeSolver().getEnabled() || this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
                            {
                                double value = N[m] * N[n]
                        fe[3*m+0] += elementGravity.x[elementID] * this-&gt;elementDensity[elementID] * N[m] * detJ * shapeFunc.getW();
                        fe[3*m+1] += elementGravity.y[elementID] * this-&gt;elementDensity[elementID] * N[m] * detJ * shapeFunc.getW();
                        fe[3*m+2] += elementGravity.z[elementID] * this-&gt;elementDensity[elementID] * N[m] * detJ * shapeFunc.getW();

                        // Thermal expansion
                        for (uint n=0;n&lt;3;n++)
                        {
                            fe[3*m+0] += this-&gt;elementThermalExpansion[elementID] * dT * BeD[3*m+0][n] * detJ * shapeFunc.getW();
                            fe[3*m+1] += this-&gt;elementThermalExpansion[elementID] * dT * BeD[3*m+1][n] * detJ * shapeFunc.getW();
                            fe[3*m+2] += this-&gt;elementThermalExpansion[elementID] * dT * BeD[3*m+2][n] * detJ * shapeFunc.getW();
                        }
                    }
                }
                #pragma omp critical
                {
                    this-&gt;assemblyMatrix(elementID,Me,Ke,fe);
                }
            }
            catch (const RError &amp;rError)
            {
                #pragma omp critical
                {
                    RLogger::error("%s\n",rError.getMessage().toUtf8().constData());
                    abort = true;
                }
                #pragma omp flush (abort)
            }
        }
        if (abort)
        {
            throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to prepare matrix system.");
        }
    }
    if (this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
    {
        RLogger::info("Restoring prestressed nodes\n");
        for (uint i=0;i&lt;this-&gt;pModel-&gt;getNNodes();i++)
        {
            this-&gt;pModel-&gt;setNode(i,nodesBkp[i]);
        }
    }
}

</t>
<t tx="leo.20201108101543.98">void RSolverStress::solve(void)
{
    try
    {
        if (this-&gt;problemType == R_PROBLEM_STRESS_MODAL)
        {
            this-&gt;solveEigenValue();
        }
        else
        {
            this-&gt;solveStressStrain();
        }
    }
    catch (const RError &amp;error)
    {
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to solve problem. %s", error.getMessage().toUtf8().constData());
    }
}

</t>
<t tx="leo.20201108101543.99">void RSolverStress::solveStressStrain(void)
{
    RLogger::info("Solving stress-strain problem.\n");

    try
    {
        RLogger::indent();
        RMatrixSolver matrixSolver(this-&gt;pModel-&gt;getMatrixSolverConf(RMatrixSolverConf::CG));
        matrixSolver.solve(this-&gt;A,this-&gt;b,this-&gt;x,R_MATRIX_PRECONDITIONER_JACOBI,3);
        RLogger::unindent();
    }
    catch (const RError &amp;error)
    {
        RLogger::unindent();
        throw RError(R_ERROR_APPLICATION,R_ERROR_REF,"Failed to solve stress-strain problem. %s", error.getMessage().toUtf8().constData());
    }

    this-&gt;setDisplacement(this-&gt;x);
}

</t>
<t tx="leo.20201108101544.1">@path ./RangeSolverLib/src/
/*********************************************************************
 *  AUTHOR: Tomas Soltys                                             *
 *  FILE:   rsolverwave.cpp                                          *
 *  GROUP:  RSolverLib                                               *
 *  TYPE:   source file (*.cpp)                                      *
 *  DATE:   18-th August 2015                                        *
 *                                                                   *
 *  DESCRIPTION: Wave solver class definition                        *
 *********************************************************************/

#include "rsolverwave.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101544.10">void RSolverWave::statistics(void)
{

}
</t>
<t tx="leo.20201108101544.11"></t>
<t tx="leo.20201108101544.12">@path ./RangeTests/
#include &lt;QTest&gt;

#include "TestRangeBase/tst_rbl_rvector.h"
#include "TestRangeBase/tst_rbl_r3vector.h"
#include "TestRangeBase/tst_rbl_rmatrix.h"
#include "TestRangeModel/tst_rml_sparse_vector.h"
#include "TestRangeModel/tst_rml_sparse_matrix.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101544.13">int main(int argc, char *argv[])
{
   int status = 0;

   {
       tst_RRVector tc;
       status |= QTest::qExec(&amp;tc, argc, argv);
   }

   {
       tst_RR3Vector tc;
       status |= QTest::qExec(&amp;tc, argc, argv);
   }

   {
       tst_RRMatrix tc;
       status |= QTest::qExec(&amp;tc, argc, argv);
   }

   {
       tst_RSparseVector tc;
       status |= QTest::qExec(&amp;tc, argc, argv);
   }

   {
       tst_RSparseMatrix tc;
       status |= QTest::qExec(&amp;tc, argc, argv);
   }

   return status;
}
</t>
<t tx="leo.20201108101544.14"></t>
<t tx="leo.20201108101544.15">@path ./RangeTests/TestRangeBase/
#include &lt;rblib.h&gt;

#include "tst_rbl_r3vector.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101544.16">void tst_RR3Vector::getOpposite()
{
    RR3Vector r(1.0,1.0,1.0);
    QVERIFY(r.getOpposite() == RR3Vector(-1.0,-1.0,-1.0));
}

</t>
<t tx="leo.20201108101544.17">void tst_RR3Vector::findDistance()
{
    QVERIFY(RR3Vector::findDistance(RR3Vector(2.0,0.0,0.0),RR3Vector(2.0,0.0,0.0)) == 0.0);
    QVERIFY(RR3Vector::findDistance(RR3Vector(2.0,0.0,0.0),RR3Vector(-2.0,0.0,0.0)) == 4.0);
    QVERIFY(RR3Vector::findDistance(RR3Vector(0.0,2.0,0.0),RR3Vector(0.0,-2.0,0.0)) == 4.0);
    QVERIFY(RR3Vector::findDistance(RR3Vector(0.0,0.0,2.0),RR3Vector(0.0,0.0,-2.0)) == 4.0);
}

</t>
<t tx="leo.20201108101544.18">void tst_RR3Vector::findOrthogonal()
{
    RR3Vector r(1.0,1.0,1.0);
    QVERIFY(RRVector::dot(r,r.findOrthogonal()) == 0.0);
}

</t>
<t tx="leo.20201108101544.19">void tst_RR3Vector::cross()
{
    RR3Vector v1(1.0,0.0,0.0);
    RR3Vector v2(0.0,1.0,0.0);
    RR3Vector vx;
    RR3Vector::cross(v1,v2,vx);
    QVERIFY(vx == RR3Vector(0.0,0.0,1.0));
}

</t>
<t tx="leo.20201108101544.2">void RSolverWave::_init(const RSolverWave *pWaveSolver)
{
    if (pWaveSolver)
    {
        this-&gt;elementWaveSpeed = pWaveSolver-&gt;elementWaveSpeed;
        this-&gt;elementWaveDisplacement = pWaveSolver-&gt;elementWaveDisplacement;
        this-&gt;nodeWaveDisplacement = pWaveSolver-&gt;nodeWaveDisplacement;
    }
}

RSolverWave::RSolverWave(RModel *pModel, const QString &amp;modelFileName, const QString &amp;convergenceFileName, RSolverSharedData &amp;sharedData)
    : RSolverGeneric(pModel,modelFileName,convergenceFileName,sharedData)
{
    this-&gt;problemType = R_PROBLEM_WAVE;
    this-&gt;_init();
}

RSolverWave::RSolverWave(const RSolverWave &amp;waveSolver)
    : RSolverGeneric(waveSolver)
{
    this-&gt;_init(&amp;waveSolver);
}

RSolverWave::~RSolverWave()
{

}

RSolverWave &amp;RSolverWave::operator =(const RSolverWave &amp;waveSolver)
{
    RSolverGeneric::operator =(waveSolver);
    this-&gt;_init(&amp;waveSolver);
    return (*this);
}

</t>
<t tx="leo.20201108101544.20">void tst_RR3Vector::angle()
{
    RR3Vector v1(1.0,0.0,0.0);
    RR3Vector v2(0.0,1.0,0.0);
    QVERIFY(R_D_ARE_SAME(RR3Vector::angle(v1,v2),RConstants::pi/2.0));
}
</t>
<t tx="leo.20201108101544.21">@path ./RangeTests/TestRangeBase/
#include &lt;rblib.h&gt;

#include "tst_rbl_rmatrix.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101544.22">void tst_RRMatrix::transpose() const
{
    RRMatrix A(2,3);
    A[0][0] = 1.0; A[0][1] = 2.0; A[0][2] = 3.0;
    A[1][0] = 4.0; A[1][1] = 5.0; A[1][2] = 6.0;
    RRMatrix B(A);

    A.transpose();

    for (uint i=0;i&lt;A.getNRows();i++)
    {
        for (uint j=0;j&lt;A.getNColumns();j++)
        {
            QVERIFY(R_D_ARE_SAME(A[i][j],B[j][i]));
        }
    }
}

</t>
<t tx="leo.20201108101544.23">void tst_RRMatrix::invert() const
{
    // 2x2 marix
    RRMatrix A2(2,2);
    RRMatrix X2(2,2);
    RRMatrix E2;
    E2.setIdentity(2);
    A2[0][0] =  3.0; A2[0][1] = 2.0;
    A2[1][0] = -2.0; A2[1][1] = 3.0;
    RRMatrix iA2(A2);
    iA2.invert();

    RRMatrix::mlt(A2,iA2,X2);

    QVERIFY(X2 == E2);

    // 3x3 marix
    RRMatrix A3(3,3);
    RRMatrix X3(3,3);
    RRMatrix E3;
    E3.setIdentity(3);
    A3[0][0] =  3.0; A3[0][1] =  2.0; A3[0][2] = 1.0;
    A3[1][0] = -2.0; A3[1][1] =  3.0; A3[1][2] = 2.0;
    A3[2][0] = -1.0; A3[2][1] = -2.0; A3[2][2] = 3.0;
    RRMatrix iA3(A3);
    iA3.invert();

    RRMatrix::mlt(A3,iA3,X3);

    QVERIFY(X3 == E3);

    // 4x4 marix
    RRMatrix A4(4,4);
    RRMatrix X4(4,4);
    RRMatrix E4;
    E4.setIdentity(4);
    A4[0][0] =  3.0; A4[0][1] =  2.0; A4[0][2] =  1.0; A4[0][3] = 0.0;
    A4[1][0] = -2.0; A4[1][1] =  3.0; A4[1][2] =  2.0; A4[1][3] = 1.0;
    A4[2][0] = -1.0; A4[2][1] = -2.0; A4[2][2] =  3.0; A4[2][3] = 2.0;
    A4[3][0] =  0.0; A4[3][1] = -1.0; A4[3][2] = -2.0; A4[3][3] = 3.0;
    RRMatrix iA4(A4);
    iA4.invert();

    RRMatrix::mlt(A4,iA4,X4);

    QVERIFY(X4 == E4);
}

</t>
<t tx="leo.20201108101544.24">void tst_RRMatrix::decomposeToLU() const
{
    RRMatrix A(3,3);
    A[0][0] = 3.0; A[0][1] = 2.0; A[0][2] = 1.0;
    A[1][0] = 2.0; A[1][1] = 3.0; A[1][2] = 2.0;
    A[2][0] = 1.0; A[2][1] = 2.0; A[2][2] = 3.0;

    RRMatrix LU(3,3);
    LU[0][0] = 3.0;     LU[0][1] = 2.0;     LU[0][2] = 1.0;
    LU[1][0] = 2.0/3.0; LU[1][1] = 5.0/3.0; LU[1][2] = 4.0/3.0;
    LU[2][0] = 1.0/3.0; LU[2][1] = 0.8;     LU[2][2] = 1.6;

    A.decomposeToLU();

    QVERIFY(A == LU);
}

</t>
<t tx="leo.20201108101544.25">void tst_RRMatrix::getDeterminant() const
{
    RRMatrix A4(4,4);
    A4[0][0] =  3.0; A4[0][1] =  2.0; A4[0][2] =  1.0; A4[0][3] = 0.0;
    A4[1][0] = -2.0; A4[1][1] =  3.0; A4[1][2] =  2.0; A4[1][3] = 1.0;
    A4[2][0] = -1.0; A4[2][1] = -2.0; A4[2][2] =  3.0; A4[2][3] = 2.0;
    A4[3][0] =  0.0; A4[3][1] = -1.0; A4[3][2] = -2.0; A4[3][3] = 3.0;

    QVERIFY(R_D_ARE_SAME(A4.getDeterminant(),216.0));
}

</t>
<t tx="leo.20201108101544.26">void tst_RRMatrix::getSummedRows() const
{
    RRMatrix A4(4,4);
    A4[0][0] =  3.0; A4[0][1] =  2.0; A4[0][2] =  1.0; A4[0][3] = 0.0;
    A4[1][0] = -2.0; A4[1][1] =  3.0; A4[1][2] =  2.0; A4[1][3] = 1.0;
    A4[2][0] = -1.0; A4[2][1] = -2.0; A4[2][2] =  3.0; A4[2][3] = 2.0;
    A4[3][0] =  0.0; A4[3][1] = -1.0; A4[3][2] = -2.0; A4[3][3] = 3.0;

    RRVector sv = A4.getSummedRows();
    QVERIFY(sv.getNRows() == 4);
    QVERIFY(R_D_ARE_SAME(sv[0],6.0));
    QVERIFY(R_D_ARE_SAME(sv[1],4.0));
    QVERIFY(R_D_ARE_SAME(sv[2],2.0));
    QVERIFY(R_D_ARE_SAME(sv[3],0.0));
}

</t>
<t tx="leo.20201108101544.27">void tst_RRMatrix::getBlock() const
{
    RRMatrix A4(4,4);
    A4[0][0] =  3.0; A4[0][1] =  2.0; A4[0][2] =  1.0; A4[0][3] = 0.0;
    A4[1][0] = -2.0; A4[1][1] =  3.0; A4[1][2] =  2.0; A4[1][3] = 1.0;
    A4[2][0] = -1.0; A4[2][1] = -2.0; A4[2][2] =  3.0; A4[2][3] = 2.0;
    A4[3][0] =  0.0; A4[3][1] = -1.0; A4[3][2] = -2.0; A4[3][3] = 3.0;

    RRMatrix A2(2,2);

    RRMatrix B2(2,2);
    B2[0][0] =  3.0; B2[0][1] = 2.0;
    B2[1][0] = -2.0; B2[1][1] = 3.0;

    A2 = A4.getBlock(1,2,1,2);

    QVERIFY(A2 == B2);
}

</t>
<t tx="leo.20201108101544.28">void tst_RRMatrix::setBlock() const
{
    RRMatrix A4(4,4);
    A4[0][0] =  3.0; A4[0][1] =  2.0; A4[0][2] =  1.0; A4[0][3] = 0.0;
    A4[1][0] = -2.0; A4[1][1] =  3.0; A4[1][2] =  2.0; A4[1][3] = 1.0;
    A4[2][0] = -1.0; A4[2][1] = -2.0; A4[2][2] =  3.0; A4[2][3] = 2.0;
    A4[3][0] =  0.0; A4[3][1] = -1.0; A4[3][2] = -2.0; A4[3][3] = 3.0;

    RRMatrix B4(4,4);
    B4[0][0] =  3.0; B4[0][1] =  2.0; B4[0][2] =  1.0; B4[0][3] = 0.0;
    B4[1][0] = -2.0; B4[1][1] = -9.0; B4[1][2] = -7.0; B4[1][3] = 1.0;
    B4[2][0] = -1.0; B4[2][1] =  7.0; B4[2][2] = -9.0; B4[2][3] = 2.0;
    B4[3][0] =  0.0; B4[3][1] = -1.0; B4[3][2] = -2.0; B4[3][3] = 3.0;

    RRMatrix A2(2,2);
    A2[0][0] = -9.0; A2[0][1] = -7.0;
    A2[1][0] =  7.0; A2[1][1] = -9.0;

    A4.setBlock(A2,1,1);

    QVERIFY(A4 == B4);
}

</t>
<t tx="leo.20201108101544.29">void tst_RRMatrix::trace() const
{
    RRMatrix A4(4,4);
    A4[0][0] =  3.0; A4[0][1] =  2.0; A4[0][2] =  1.0; A4[0][3] = 0.0;
    A4[1][0] = -2.0; A4[1][1] =  3.0; A4[1][2] =  2.0; A4[1][3] = 1.0;
    A4[2][0] = -1.0; A4[2][1] = -2.0; A4[2][2] =  3.0; A4[2][3] = 2.0;
    A4[3][0] =  0.0; A4[3][1] = -1.0; A4[3][2] = -2.0; A4[3][3] = 3.0;

    QVERIFY(R_D_ARE_SAME(RRMatrix::trace(A4),12.0));
}

</t>
<t tx="leo.20201108101544.3">bool RSolverWave::hasConverged(void) const
{
    return true;
}

</t>
<t tx="leo.20201108101544.30">void tst_RRMatrix::mlt() const
{
    RRMatrix A4(4,4);
    A4[0][0] =  3.0; A4[0][1] =  2.0; A4[0][2] =  1.0; A4[0][3] = 0.0;
    A4[1][0] = -2.0; A4[1][1] =  3.0; A4[1][2] =  2.0; A4[1][3] = 1.0;
    A4[2][0] = -1.0; A4[2][1] = -2.0; A4[2][2] =  3.0; A4[2][3] = 2.0;
    A4[3][0] =  0.0; A4[3][1] = -1.0; A4[3][2] = -2.0; A4[3][3] = 3.0;

    RRVector v4(4);
    v4[0] = -1.0;
    v4[1] =  2.0;
    v4[2] = -3.0;
    v4[3] =  4.0;

    RRVector b4(4);
    b4[0] =  -2.0;
    b4[1] =   6.0;
    b4[2] =  -4.0;
    b4[3] =  16.0;

    RRVector x4(4);

    RRMatrix::mlt(A4,v4,x4);

    QVERIFY(x4 == b4);

    b4[0] =  -4.0;
    b4[1] =  12.0;
    b4[2] =  -8.0;
    b4[3] =  32.0;

    RRMatrix::mlt(A4,v4,x4,true);

    QVERIFY(x4 == b4);

    RRMatrix B4(4,4);
    B4[0][0] =   4.0; B4[0][1] =  10.0; B4[0][2] =  10.0; B4[0][3] =  4.0;
    B4[1][0] = -14.0; B4[1][1] =   0.0; B4[1][2] =   8.0; B4[1][3] = 10.0;
    B4[2][0] =  -2.0; B4[2][1] = -16.0; B4[2][2] =   0.0; B4[2][3] = 10.0;
    B4[3][0] =   4.0; B4[3][1] =  -2.0; B4[3][2] = -14.0; B4[3][3] =  4.0;

    RRMatrix X4(4,4);

    RRMatrix::mlt(A4,A4,X4);

    QVERIFY(X4 == B4);

    B4[0][0] =   8.0; B4[0][1] =  20.0; B4[0][2] =  20.0; B4[0][3] =  8.0;
    B4[1][0] = -28.0; B4[1][1] =   0.0; B4[1][2] =  16.0; B4[1][3] = 20.0;
    B4[2][0] =  -4.0; B4[2][1] = -32.0; B4[2][2] =   0.0; B4[2][3] = 20.0;
    B4[3][0] =   8.0; B4[3][1] =  -4.0; B4[3][2] = -28.0; B4[3][3] =  8.0;

    RRMatrix::mlt(A4,A4,X4,true);

    QVERIFY(X4 == B4);
}
</t>
<t tx="leo.20201108101544.31">@path ./RangeTests/TestRangeBase/
#include &lt;rblib.h&gt;

#include "tst_rbl_rvector.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101544.32">void tst_RRVector::dot()
{
    RRVector r1(5);
    r1[0] =  1.0;
    r1[1] = -2.0;
    r1[2] =  3.0;
    r1[3] = -4.0;
    r1[4] =  5.0;
    RRVector r2(5);
    r2[0] = -1.0;
    r2[1] =  2.0;
    r2[2] = -3.0;
    r2[3] =  4.0;
    r2[4] = -5.0;
    QVERIFY(R_D_ARE_SAME(RRVector::dot(r1,r2),-55.0));
}

</t>
<t tx="leo.20201108101544.33">void tst_RRVector::norm()
{
    RRVector r(10);
    r[0] =  1.0;
    r[1] = -2.0;
    r[2] =  3.0;
    r[3] = -4.0;
    r[4] =  5.0;
    r[5] = -6.0;
    r[6] =  7.0;
    r[7] = -8.0;
    r[8] =  9.0;
    r[9] = -10.0;
    QVERIFY(R_D_ARE_SAME(RRVector::norm(r),std::sqrt(385.0)));
}
</t>
<t tx="leo.20201108101544.34"></t>
<t tx="leo.20201108101544.35">@path ./RangeTests/TestRangeModel/
#include &lt;rmlib.h&gt;

#include "tst_rml_sparse_matrix.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101544.36">void tst_RSparseMatrix::addMatrix() const
{
    RSparseMatrix A1;

    A1.addValue(0,0,1.0);
    A1.addValue(1,1,1.0);

    RSparseMatrix A2;
    A2.addValue(0,1,-1.0);
    A2.addValue(1,0,-1.0);

    RSparseMatrix A3;
    A3.addValue(0,1,3.0);
    A3.addValue(1,1,3.0);

    A2.addMatrix(A3);
    A1.addMatrix(A2);

    QVERIFY(R_D_ARE_SAME(A1.findValue(0,0),1.0));
    QVERIFY(R_D_ARE_SAME(A1.findValue(0,1),2.0));
    QVERIFY(R_D_ARE_SAME(A1.findValue(1,0),-1.0));
    QVERIFY(R_D_ARE_SAME(A1.findValue(1,1),4.0));
}
</t>
<t tx="leo.20201108101544.37">@path ./RangeTests/TestRangeModel/
#include &lt;rmlib.h&gt;

#include "tst_rml_sparse_vector.h"

@others
@language c
@tabwidth -4
</t>
<t tx="leo.20201108101544.38">void tst_RSparseVector::addValue() const
{
    RSparseVector&lt;double&gt; v;
    v.addValue(3,-3.0);
    v.addValue(2,-2.0);

    QVERIFY(v.getIndex(0) == 2);
    QVERIFY(v.getIndex(1) == 3);

    std::vector&lt;double&gt; values = v.getValues(2);

    QVERIFY(R_D_ARE_SAME(values[2],-2.0));
    QVERIFY(R_D_ARE_SAME(values[3],-3.0));
}

</t>
<t tx="leo.20201108101544.39">void tst_RSparseVector::addVector() const
{
    RSparseVector&lt;double&gt; v1;
    v1.addValue(3,-3.0);
    v1.addValue(2,-2.0);

    RSparseVector&lt;double&gt; v2;
    v2.addValue(1,1.0);
    v2.addValue(2,3.0);

    v1.addVector(v2);

    std::vector&lt;double&gt; values = v1.getValues(3);

    QVERIFY(R_D_ARE_SAME(values[1],1.0));
    QVERIFY(R_D_ARE_SAME(values[2],1.0));
    QVERIFY(R_D_ARE_SAME(values[3],-3.0));
}
</t>
<t tx="leo.20201108101544.4">void RSolverWave::updateScales(void)
{

}

</t>
<t tx="leo.20201108101544.5">void RSolverWave::recover(void)
{

}

</t>
<t tx="leo.20201108101544.6">void RSolverWave::prepare(void)
{
    static bool firstTime = true;

    RBVector waveDisplacementExplicitFlags;

    this-&gt;generateNodeBook(R_PROBLEM_WAVE);
    this-&gt;generateVariableVector(R_VARIABLE_WAVE_DISPLACEMENT,this-&gt;elementWaveDisplacement,waveDisplacementExplicitFlags,true,firstTime,firstTime);
//    this-&gt;generateVariableVector(R_VARIABLE_W,this-&gt;elementWaveDisplacement,waveDisplacementExplicitFlags,true,firstTime,firstTime);

    this-&gt;b.resize(this-&gt;nodeBook.getNEnabled());
    this-&gt;x.resize(this-&gt;nodeBook.getNEnabled());

    this-&gt;A.clear();
    this-&gt;b.fill(0.0);
    this-&gt;x.fill(0.0);
}

</t>
<t tx="leo.20201108101544.7">void RSolverWave::solve(void)
{

}

</t>
<t tx="leo.20201108101544.8">void RSolverWave::process(void)
{

}

</t>
<t tx="leo.20201108101544.9">void RSolverWave::store(void)
{

}

</t>
<t tx="leo.20201108102637.1"></t>
</tnodes>
</leo_file>
